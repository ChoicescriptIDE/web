if (!function(a, b) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
        if (a.document) return b(a);
        throw new Error("jQuery requires a window with a document");
    } : b(a);
}("undefined" != typeof window ? window : this, function(a, b) {
    function q(a, b) {
        return b.toUpperCase();
    }
    var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = {}, l = "1.11.3", m = function(a, b) {
        return new m.fn.init(a, b);
    }, n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /^-ms-/, p = /-([\da-z])/gi;
    function r(a) {
        var b = "length" in a && a.length, c = m.type(a);
        return "function" !== c && !m.isWindow(a) && (!(1 !== a.nodeType || !b) || ("array" === c || 0 === b || "number" == typeof b && 0 < b && b - 1 in a));
    }
    m.fn = m.prototype = {
        jquery: l,
        constructor: m,
        selector: "",
        length: 0,
        toArray: function() {
            return d.call(this);
        },
        get: function(a) {
            return null != a ? a < 0 ? this[a + this.length] : this[a] : d.call(this);
        },
        pushStack: function(a) {
            a = m.merge(this.constructor(), a);
            return a.prevObject = this, a.context = this.context, a;
        },
        each: function(a, b) {
            return m.each(this, a, b);
        },
        map: function(a) {
            return this.pushStack(m.map(this, function(b, c) {
                return a.call(b, c, b);
            }));
        },
        slice: function() {
            return this.pushStack(d.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(a) {
            var b = this.length, a = +a + (a < 0 ? b : 0);
            return this.pushStack(0 <= a && a < b ? [ this[a] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: f,
        sort: c.sort,
        splice: c.splice
    }, m.extend = m.fn.extend = function() {
        var b, c, d, e, a, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
        for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || m.isFunction(g) || (g = {}), 
        h === i && (g = this, h--); h < i; h++) if (null != (e = arguments[h])) for (d in e) a = g[d], 
        c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (a = b ? (b = !1, 
        a && m.isArray(a) ? a : []) : a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, a, c)) : void 0 !== c && (g[d] = c));
        return g;
    }, m.extend({
        expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(a) {
            throw new Error(a);
        },
        noop: function() {},
        isFunction: function(a) {
            return "function" === m.type(a);
        },
        isArray: Array.isArray || function(a) {
            return "array" === m.type(a);
        },
        isWindow: function(a) {
            return null != a && a == a.window;
        },
        isNumeric: function(a) {
            return !m.isArray(a) && 0 <= a - parseFloat(a) + 1;
        },
        isEmptyObject: function(a) {
            for (var b in a) return !1;
            return !0;
        },
        isPlainObject: function(a) {
            if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a)) return !1;
            try {
                if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (c) {
                return !1;
            }
            if (k.ownLast) for (var b in a) return j.call(a, b);
            for (b in a);
            return void 0 === b || j.call(a, b);
        },
        type: function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a;
        },
        globalEval: function(b) {
            b && m.trim(b) && (a.execScript || function(b) {
                a.eval.call(a, b);
            })(b);
        },
        camelCase: function(a) {
            return a.replace(o, "ms-").replace(p, q);
        },
        nodeName: function(a, b) {
            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
        },
        each: function(a, b, c) {
            var d, e = 0, f = a.length, g = r(a);
            if (c) {
                if (g) for (;e < f && !1 !== (d = b.apply(a[e], c)); e++); else for (e in a) if (d = b.apply(a[e], c), 
                !1 === d) break;
            } else if (g) for (;e < f && !1 !== (d = b.call(a[e], e, a[e])); e++); else for (e in a) if (d = b.call(a[e], e, a[e]), 
            !1 === d) break;
            return a;
        },
        trim: function(a) {
            return null == a ? "" : (a + "").replace(n, "");
        },
        makeArray: function(a, b) {
            b = b || [];
            return null != a && (r(Object(a)) ? m.merge(b, "string" == typeof a ? [ a ] : a) : f.call(b, a)), 
            b;
        },
        inArray: function(a, b, c) {
            var d;
            if (b) {
                if (g) return g.call(b, a, c);
                for (d = b.length, c = c ? c < 0 ? Math.max(0, d + c) : c : 0; c < d; c++) if (c in b && b[c] === a) return c;
            }
            return -1;
        },
        merge: function(a, b) {
            for (var c = +b.length, d = 0, e = a.length; d < c; ) a[e++] = b[d++];
            if (c != c) for (;void 0 !== b[d]; ) a[e++] = b[d++];
            return a.length = e, a;
        },
        grep: function(a, b, c) {
            for (var e = [], f = 0, g = a.length, h = !c; f < g; f++) !b(a[f], f) != h && e.push(a[f]);
            return e;
        },
        map: function(a, b, c) {
            var d, f = 0, g = a.length, i = [];
            if (r(a)) for (;f < g; f++) null != (d = b(a[f], f, c)) && i.push(d); else for (f in a) d = b(a[f], f, c), 
            null != d && i.push(d);
            return e.apply([], i);
        },
        guid: 1,
        proxy: function(a, b) {
            var c, f;
            return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2), 
            (f = function() {
                return a.apply(b || this, c.concat(d.call(arguments)));
            }).guid = a.guid = a.guid || m.guid++, f) : void 0;
        },
        now: function() {
            return +new Date();
        },
        support: k
    }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
        h["[object " + b + "]"] = b.toLowerCase();
    });
    var l = function(a) {
        function da(a, b, c) {
            var d = "0x" + b - 65536;
            return d != d || c ? b : d < 0 ? String.fromCharCode(65536 + d) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
        }
        function ea() {
            m();
        }
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + +new Date(), v = a.document, w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function(a, b) {
            return a === b && (l = !0), 0;
        }, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = function(a, b) {
            for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return c;
            return -1;
        }, K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = M.replace("w", "w#"), O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]", P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)", Q = new RegExp(L + "+", "g"), R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"), S = new RegExp("^" + L + "*," + L + "*"), T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), V = new RegExp(P), W = new RegExp("^" + N + "$"), X = {
            ID: new RegExp("^#(" + M + ")"),
            CLASS: new RegExp("^\\.(" + M + ")"),
            TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + O),
            PSEUDO: new RegExp("^" + P),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + K + ")$", "i"),
            needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
        }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/, _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, aa = /[+~]/, ba = /'|\\/g, ca = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig");
        try {
            H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;
        } catch (fa) {
            H = {
                apply: E.length ? function(a, b) {
                    G.apply(a, I.call(b));
                } : function(a, b) {
                    for (var c = a.length, d = 0; a[c++] = b[d++]; );
                    a.length = c - 1;
                }
            };
        }
        function ga(a, b, d, e) {
            var k, l, o, h, s, f, j;
            if ((b ? b.ownerDocument || b : v) !== n && m(b), d = d || [], k = (b = b || n).nodeType, 
            "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k) return d;
            if (!e && p) {
                if (11 !== k && (f = _.exec(a))) if (j = f[1]) {
                    if (9 === k) {
                        if (!(h = b.getElementById(j)) || !h.parentNode) return d;
                        if (h.id === j) return d.push(h), d;
                    } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), 
                    d;
                } else {
                    if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
                    if ((j = f[3]) && c.getElementsByClassName) return H.apply(d, b.getElementsByClassName(j)), 
                    d;
                }
                if (c.qsa && (!q || !q.test(a))) {
                    if (s = h = u, f = b, j = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
                        for (o = g(a), (h = b.getAttribute("id")) ? s = h.replace(ba, "\\$&") : b.setAttribute("id", s), 
                        s = "[id='" + s + "'] ", l = o.length; l--; ) o[l] = s + ra(o[l]);
                        f = aa.test(a) && pa(b.parentNode) || b, j = o.join(",");
                    }
                    if (j) try {
                        return H.apply(d, f.querySelectorAll(j)), d;
                    } catch (y) {} finally {
                        h || b.removeAttribute("id");
                    }
                }
            }
            return i(a.replace(R, "$1"), b, d, e);
        }
        function ha() {
            var a = [];
            function b(c, e) {
                return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e;
            }
            return b;
        }
        function ia(a) {
            return a[u] = !0, a;
        }
        function ja(a) {
            var b = n.createElement("div");
            try {
                return !!a(b);
            } catch (c) {
                return !1;
            } finally {
                b.parentNode && b.parentNode.removeChild(b);
            }
        }
        function ka(a, b) {
            for (var c = a.split("|"), e = a.length; e--; ) d.attrHandle[c[e]] = b;
        }
        function la(a, b) {
            var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || 1 << 31) - (~a.sourceIndex || 1 << 31);
            if (d) return d;
            if (c) for (;c = c.nextSibling; ) if (c === b) return -1;
            return a ? 1 : -1;
        }
        function oa(a) {
            return ia(function(b) {
                return b = +b, ia(function(c, d) {
                    for (var e, f = a([], c.length, b), g = f.length; g--; ) c[e = f[g]] && (c[e] = !(d[e] = c[e]));
                });
            });
        }
        function pa(a) {
            return a && void 0 !== a.getElementsByTagName && a;
        }
        for (b in c = ga.support = {}, f = ga.isXML = function(a) {
            a = a && (a.ownerDocument || a).documentElement;
            return !!a && "HTML" !== a.nodeName;
        }, m = ga.setDocument = function(a) {
            var g = a ? a.ownerDocument || a : v;
            return g !== n && 9 === g.nodeType && g.documentElement ? (o = (n = g).documentElement, 
            (a = g.defaultView) && a !== a.top && (a.addEventListener ? a.addEventListener("unload", ea, !1) : a.attachEvent && a.attachEvent("onunload", ea)), 
            p = !f(g), c.attributes = ja(function(a) {
                return a.className = "i", !a.getAttribute("className");
            }), c.getElementsByTagName = ja(function(a) {
                return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length;
            }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = ja(function(a) {
                return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length;
            }), c.getById ? (d.find.ID = function(a, b) {
                if (void 0 !== b.getElementById && p) return (b = b.getElementById(a)) && b.parentNode ? [ b ] : [];
            }, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    return a.getAttribute("id") === b;
                };
            }) : (delete d.find.ID, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    a = void 0 !== a.getAttributeNode && a.getAttributeNode("id");
                    return a && a.value === b;
                };
            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
                return void 0 !== b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;
            } : function(a, b) {
                var c, d = [], e = 0, f = b.getElementsByTagName(a);
                if ("*" !== a) return f;
                for (;c = f[e++]; ) 1 === c.nodeType && d.push(c);
                return d;
            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
                return p ? b.getElementsByClassName(a) : void 0;
            }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (ja(function(a) {
                o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>", 
                a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), 
                a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), 
                a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), 
                a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]");
            }), ja(function(a) {
                var b = g.createElement("input");
                b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), 
                a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), 
                a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), 
                a.querySelectorAll("*,:x"), q.push(",.*:");
            })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function(a) {
                c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), 
                r.push("!=", P);
            }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), 
            a = $.test(o.compareDocumentPosition), t = a || $.test(o.contains) ? function(a, b) {
                var c = 9 === a.nodeType ? a.documentElement : a, b = b && b.parentNode;
                return a === b || !(!b || 1 !== b.nodeType || !(c.contains ? c.contains(b) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(b)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, B = a ? function(a, b) {
                var d;
                return a === b ? (l = !0, 0) : (d = !a.compareDocumentPosition - !b.compareDocumentPosition) || (1 & (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1) || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);
            } : function(a, b) {
                if (a === b) return l = !0, 0;
                var c, d = 0, e = a.parentNode, f = b.parentNode, h = [ a ], i = [ b ];
                if (!e || !f) return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
                if (e === f) return la(a, b);
                for (c = a; c = c.parentNode; ) h.unshift(c);
                for (c = b; c = c.parentNode; ) i.unshift(c);
                for (;h[d] === i[d]; ) d++;
                return d ? la(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0;
            }, g) : n;
        }, ga.matches = function(a, b) {
            return ga(a, null, null, b);
        }, ga.matchesSelector = function(a, b) {
            if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), 
            !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
                var d = s.call(a, b);
                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
            } catch (e) {}
            return 0 < ga(b, n, null, [ a ]).length;
        }, ga.contains = function(a, b) {
            return (a.ownerDocument || a) !== n && m(a), t(a, b);
        }, ga.attr = function(a, b) {
            (a.ownerDocument || a) !== n && m(a);
            var e = d.attrHandle[b.toLowerCase()], e = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
            return void 0 !== e ? e : c.attributes || !p ? a.getAttribute(b) : (e = a.getAttributeNode(b)) && e.specified ? e.value : null;
        }, ga.error = function(a) {
            throw new Error("Syntax error, unrecognized expression: " + a);
        }, ga.uniqueSort = function(a) {
            var b, d = [], e = 0, f = 0;
            if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), 
            l) {
                for (;b = a[f++]; ) b === a[f] && (e = d.push(f));
                for (;e--; ) a.splice(d[e], 1);
            }
            return k = null, a;
        }, e = ga.getText = function(a) {
            var b, c = "", d = 0, f = a.nodeType;
            if (f) {
                if (1 === f || 9 === f || 11 === f) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a);
                } else if (3 === f || 4 === f) return a.nodeValue;
            } else for (;b = a[d++]; ) c += e(b);
            return c;
        }, (d = ga.selectors = {
            cacheLength: 50,
            createPseudo: ia,
            match: X,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(a) {
                    return a[1] = a[1].replace(ca, da), a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da), 
                    "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
                },
                CHILD: function(a) {
                    return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), 
                    a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), 
                    a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), 
                    a;
                },
                PSEUDO: function(a) {
                    var b, c = !a[6] && a[2];
                    return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), 
                    a[2] = c.slice(0, b)), a.slice(0, 3));
                }
            },
            filter: {
                TAG: function(a) {
                    var b = a.replace(ca, da).toLowerCase();
                    return "*" === a ? function() {
                        return !0;
                    } : function(a) {
                        return a.nodeName && a.nodeName.toLowerCase() === b;
                    };
                },
                CLASS: function(a) {
                    var b = y[a + " "];
                    return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function(a) {
                        return b.test("string" == typeof a.className && a.className || void 0 !== a.getAttribute && a.getAttribute("class") || "");
                    });
                },
                ATTR: function(a, b, c) {
                    return function(d) {
                        d = ga.attr(d, a);
                        return null == d ? "!=" === b : !b || (d += "", "=" === b ? d === c : "!=" === b ? d !== c : "^=" === b ? c && 0 === d.indexOf(c) : "*=" === b ? c && -1 < d.indexOf(c) : "$=" === b ? c && d.slice(-c.length) === c : "~=" === b ? -1 < (" " + d.replace(Q, " ") + " ").indexOf(c) : "|=" === b && (d === c || d.slice(0, c.length + 1) === c + "-"));
                    };
                },
                CHILD: function(a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                    return 1 === d && 0 === e ? function(a) {
                        return !!a.parentNode;
                    } : function(b, c, i) {
                        var j, k, l, m, n, o, p = f != g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h;
                        if (q) {
                            if (f) {
                                for (;p; ) {
                                    for (l = b; l = l[p]; ) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                                    o = p = "only" === a && !o && "nextSibling";
                                }
                                return !0;
                            }
                            if (o = [ g ? q.firstChild : q.lastChild ], g && s) {
                                for (n = (j = (k = q[u] || (q[u] = {}))[a] || [])[0] === w && j[1], 
                                m = j[0] === w && j[2], l = n && q.childNodes[n]; l = ++n && l && l[p] || (m = n = 0) || o.pop(); ) if (1 === l.nodeType && ++m && l === b) {
                                    k[a] = [ w, n, m ];
                                    break;
                                }
                            } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1]; else for (;(l = ++n && l && l[p] || (m = n = 0) || o.pop()) && ((h ? l.nodeName.toLowerCase() !== r : 1 !== l.nodeType) || !++m || (s && ((l[u] || (l[u] = {}))[a] = [ w, m ]), 
                            l !== b)); );
                            return (m -= e) === d || m % d == 0 && 0 <= m / d;
                        }
                    };
                },
                PSEUDO: function(a, b) {
                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
                    return e[u] ? e(b) : 1 < e.length ? (c = [ a, a, "", b ], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function(a, c) {
                        for (var d, f = e(a, b), g = f.length; g--; ) a[d = J(a, f[g])] = !(c[d] = f[g]);
                    }) : function(a) {
                        return e(a, 0, c);
                    }) : e;
                }
            },
            pseudos: {
                not: ia(function(a) {
                    var b = [], c = [], d = h(a.replace(R, "$1"));
                    return d[u] ? ia(function(a, b, c, e) {
                        for (var f, g = d(a, null, e, []), h = a.length; h--; ) (f = g[h]) && (a[h] = !(b[h] = f));
                    }) : function(a, e, f) {
                        return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();
                    };
                }),
                has: ia(function(a) {
                    return function(b) {
                        return 0 < ga(a, b).length;
                    };
                }),
                contains: ia(function(a) {
                    return a = a.replace(ca, da), function(b) {
                        return -1 < (b.textContent || b.innerText || e(b)).indexOf(a);
                    };
                }),
                lang: ia(function(a) {
                    return W.test(a || "") || ga.error("unsupported lang: " + a), 
                    a = a.replace(ca, da).toLowerCase(), function(b) {
                        var c;
                        do {
                            if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return (c = c.toLowerCase()) === a || 0 === c.indexOf(a + "-");
                        } while ((b = b.parentNode) && 1 === b.nodeType);
                        return !1;
                    };
                }),
                target: function(b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id;
                },
                root: function(a) {
                    return a === o;
                },
                focus: function(a) {
                    return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
                },
                enabled: function(a) {
                    return !1 === a.disabled;
                },
                disabled: function(a) {
                    return !0 === a.disabled;
                },
                checked: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && !!a.checked || "option" === b && !!a.selected;
                },
                selected: function(a) {
                    return a.parentNode && a.parentNode.selectedIndex, !0 === a.selected;
                },
                empty: function(a) {
                    for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(a) {
                    return !d.pseudos.empty(a);
                },
                header: function(a) {
                    return Z.test(a.nodeName);
                },
                input: function(a) {
                    return Y.test(a.nodeName);
                },
                button: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b;
                },
                text: function(a) {
                    return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (a = a.getAttribute("type")) || "text" === a.toLowerCase());
                },
                first: oa(function() {
                    return [ 0 ];
                }),
                last: oa(function(a, b) {
                    return [ b - 1 ];
                }),
                eq: oa(function(a, b, c) {
                    return [ c < 0 ? c + b : c ];
                }),
                even: oa(function(a, b) {
                    for (var c = 0; c < b; c += 2) a.push(c);
                    return a;
                }),
                odd: oa(function(a, b) {
                    for (var c = 1; c < b; c += 2) a.push(c);
                    return a;
                }),
                lt: oa(function(a, b, c) {
                    for (var d = c < 0 ? c + b : c; 0 <= --d; ) a.push(d);
                    return a;
                }),
                gt: oa(function(a, b, c) {
                    for (var d = c < 0 ? c + b : c; ++d < b; ) a.push(d);
                    return a;
                })
            }
        }).pseudos.nth = d.pseudos.eq, {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) d.pseudos[b] = function(a) {
            return function(b) {
                return "input" === b.nodeName.toLowerCase() && b.type === a;
            };
        }(b);
        for (b in {
            submit: !0,
            reset: !0
        }) d.pseudos[b] = function(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a;
            };
        }(b);
        function qa() {}
        function ra(a) {
            for (var b = 0, c = a.length, d = ""; b < c; b++) d += a[b].value;
            return d;
        }
        function sa(a, b, c) {
            var d = b.dir, e = c && "parentNode" === d, f = x++;
            return b.first ? function(b, c, f) {
                for (;b = b[d]; ) if (1 === b.nodeType || e) return a(b, c, f);
            } : function(b, c, g) {
                var h, i, j = [ w, f ];
                if (g) {
                    for (;b = b[d]; ) if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
                } else for (;b = b[d]; ) if (1 === b.nodeType || e) {
                    if ((h = (i = b[u] || (b[u] = {}))[d]) && h[0] === w && h[1] === f) return j[2] = h[2];
                    if ((i[d] = j)[2] = a(b, c, g)) return !0;
                }
            };
        }
        function ta(a) {
            return 1 < a.length ? function(b, c, d) {
                for (var e = a.length; e--; ) if (!a[e](b, c, d)) return !1;
                return !0;
            } : a[0];
        }
        function va(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; h < i; h++) !(f = a[h]) || c && !c(f, d, e) || (g.push(f), 
            j && b.push(h));
            return g;
        }
        function wa(a, b, c, d, e, f) {
            return d && !d[u] && (d = wa(d)), e && !e[u] && (e = wa(e, f)), ia(function(f, g, h, i) {
                var j, k, l, m = [], n = [], o = g.length, p = f || function(a, b, c) {
                    for (var d = 0, e = b.length; d < e; d++) ga(a, b[d], c);
                    return c;
                }(b || "*", h.nodeType ? [ h ] : h, []), q = !a || !f && b ? p : va(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
                if (c && c(q, r, h, i), d) for (j = va(r, n), d(j, [], h, i), k = j.length; k--; ) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
                if (f) {
                    if (e || a) {
                        if (e) {
                            for (j = [], k = r.length; k--; ) (l = r[k]) && j.push(q[k] = l);
                            e(null, r = [], j, i);
                        }
                        for (k = r.length; k--; ) (l = r[k]) && -1 < (j = e ? J(f, l) : m[k]) && (f[j] = !(g[j] = l));
                    }
                } else r = va(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);
            });
        }
        function xa(a) {
            for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sa(function(a) {
                return a === b;
            }, h, !0), l = sa(function(a) {
                return -1 < J(b, a);
            }, h, !0), m = [ function(a, c, d) {
                a = !g && (d || c !== j) || ((b = c).nodeType ? k : l)(a, c, d);
                return b = null, a;
            } ]; i < f; i++) if (c = d.relative[a[i].type]) m = [ sa(ta(m), c) ]; else {
                if ((c = d.filter[a[i].type].apply(null, a[i].matches))[u]) {
                    for (e = ++i; e < f && !d.relative[a[e].type]; e++);
                    return wa(1 < i && ta(m), 1 < i && ra(a.slice(0, i - 1).concat({
                        value: " " === a[i - 2].type ? "*" : ""
                    })).replace(R, "$1"), c, i < e && xa(a.slice(i, e)), e < f && xa(a = a.slice(e)), e < f && ra(a));
                }
                m.push(c);
            }
            return ta(m);
        }
        function ya(a, b) {
            function f(f, g, h, i, k) {
                var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k), v = w += null == t ? 1 : Math.random() || .1, x = u.length;
                for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
                    if (e && l) {
                        for (m = 0; o = a[m++]; ) if (o(l, g, h)) {
                            i.push(l);
                            break;
                        }
                        k && (w = v);
                    }
                    c && ((l = !o && l) && p--, f && r.push(l));
                }
                if (p += q, c && q !== p) {
                    for (m = 0; o = b[m++]; ) o(r, s, g, h);
                    if (f) {
                        if (0 < p) for (;q--; ) r[q] || s[q] || (s[q] = F.call(i));
                        s = va(s);
                    }
                    H.apply(i, s), k && !f && 0 < s.length && 1 < p + b.length && ga.uniqueSort(i);
                }
                return k && (w = v, j = t), r;
            }
            var c = 0 < b.length, e = 0 < a.length;
            return c ? ia(f) : f;
        }
        return qa.prototype = d.filters = d.pseudos, d.setFilters = new qa(), g = ga.tokenize = function(a, b) {
            var c, e, f, g, h, i, j, k = z[a + " "];
            if (k) return b ? 0 : k.slice(0);
            for (h = a, i = [], j = d.preFilter; h; ) {
                for (g in c && !(e = S.exec(h)) || (e && (h = h.slice(e[0].length) || h), 
                i.push(f = [])), c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
                    value: c,
                    type: e[0].replace(R, " ")
                }), h = h.slice(c.length)), d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), 
                f.push({
                    value: c,
                    type: g,
                    matches: e
                }), h = h.slice(c.length));
                if (!c) break;
            }
            return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);
        }, h = ga.compile = function(a, b) {
            var c, d = [], e = [], f = A[a + " "];
            if (!f) {
                for (c = (b = b || g(a)).length; c--; ) ((f = xa(b[c]))[u] ? d : e).push(f);
                (f = A(a, ya(e, d))).selector = a;
            }
            return f;
        }, i = ga.select = function(a, b, e, f) {
            var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a);
            if (e = e || [], 1 === o.length) {
                if (2 < (j = o[0] = o[0].slice(0)).length && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
                    if (!(b = (d.find.ID(k.matches[0].replace(ca, da), b) || [])[0])) return e;
                    n && (b = b.parentNode), a = a.slice(j.shift().value.length);
                }
                for (i = X.needsContext.test(a) ? 0 : j.length; i-- && (k = j[i], 
                !d.relative[l = k.type]); ) if ((m = d.find[l]) && (f = m(k.matches[0].replace(ca, da), aa.test(j[0].type) && pa(b.parentNode) || b))) {
                    if (j.splice(i, 1), a = f.length && ra(j)) break;
                    return H.apply(e, f), e;
                }
            }
            return (n || h(a, o))(f, b, !p, e, aa.test(a) && pa(b.parentNode) || b), 
            e;
        }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, 
        m(), c.sortDetached = ja(function(a) {
            return 1 & a.compareDocumentPosition(n.createElement("div"));
        }), ja(function(a) {
            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
        }) || ka("type|href|height|width", function(a, b, c) {
            return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
        }), c.attributes && ja(function(a) {
            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), 
            "" === a.firstChild.getAttribute("value");
        }) || ka("value", function(a, b, c) {
            return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
        }), ja(function(a) {
            return null == a.getAttribute("disabled");
        }) || ka(K, function(a, b, c) {
            return c ? void 0 : !0 === a[b] ? b.toLowerCase() : (c = a.getAttributeNode(b)) && c.specified ? c.value : null;
        }), ga;
    }(a), t = (m.find = l, m.expr = l.selectors, m.expr[":"] = m.expr.pseudos, m.unique = l.uniqueSort, 
    m.text = l.getText, m.isXMLDoc = l.isXML, m.contains = l.contains, m.expr.match.needsContext), u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v = /^.[^:#\[\.,]*$/;
    function w(a, b, c) {
        if (m.isFunction(b)) return m.grep(a, function(a, d) {
            return !!b.call(a, d, a) !== c;
        });
        if (b.nodeType) return m.grep(a, function(a) {
            return a === b !== c;
        });
        if ("string" == typeof b) {
            if (v.test(b)) return m.filter(b, a, c);
            b = m.filter(b, a);
        }
        return m.grep(a, function(a) {
            return 0 <= m.inArray(a, b) !== c;
        });
    }
    m.filter = function(a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [ d ] : [] : m.find.matches(a, m.grep(b, function(a) {
            return 1 === a.nodeType;
        }));
    }, m.fn.extend({
        find: function(a) {
            var b, c = [], d = this, e = d.length;
            if ("string" != typeof a) return this.pushStack(m(a).filter(function() {
                for (b = 0; b < e; b++) if (m.contains(d[b], this)) return !0;
            }));
            for (b = 0; b < e; b++) m.find(a, d[b], c);
            return (c = this.pushStack(1 < e ? m.unique(c) : c)).selector = this.selector ? this.selector + " " + a : a, 
            c;
        },
        filter: function(a) {
            return this.pushStack(w(this, a || [], !1));
        },
        not: function(a) {
            return this.pushStack(w(this, a || [], !0));
        },
        is: function(a) {
            return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length;
        }
    });
    var x, y = a.document, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, B = ((m.fn.init = function(a, b) {
        var c, d;
        if (a) {
            if ("string" != typeof a) return a.nodeType ? (this.context = this[0] = a, 
            this.length = 1, this) : m.isFunction(a) ? void 0 !== x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector, 
            this.context = a.context), m.makeArray(a, this));
            if (!(c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && 3 <= a.length ? [ null, a, null ] : z.exec(a)) || !c[1] && b) return (!b || b.jquery ? b || x : this.constructor(b)).find(a);
            if (c[1]) {
                if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)), 
                u.test(c[1]) && m.isPlainObject(b)) for (c in b) m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
            } else {
                if ((d = y.getElementById(c[2])) && d.parentNode) {
                    if (d.id !== c[2]) return x.find(a);
                    this.length = 1, this[0] = d;
                }
                this.context = y, this.selector = a;
            }
        }
        return this;
    }).prototype = m.fn, x = m(y), /^(?:parents|prev(?:Until|All))/), C = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    function D(a, b) {
        for (;(a = a[b]) && 1 !== a.nodeType; );
        return a;
    }
    m.extend({
        dir: function(a, b, c) {
            for (var d = [], e = a[b]; e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c)); ) 1 === e.nodeType && d.push(e), 
            e = e[b];
            return d;
        },
        sibling: function(a, b) {
            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
            return c;
        }
    }), m.fn.extend({
        has: function(a) {
            var b, c = m(a, this), d = c.length;
            return this.filter(function() {
                for (b = 0; b < d; b++) if (m.contains(this, c[b])) return !0;
            });
        },
        closest: function(a, b) {
            for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; d < e; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? -1 < g.index(c) : 1 === c.nodeType && m.find.matchesSelector(c, a))) {
                f.push(c);
                break;
            }
            return this.pushStack(1 < f.length ? m.unique(f) : f);
        },
        index: function(a) {
            return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(a, b) {
            return this.pushStack(m.unique(m.merge(this.get(), m(a, b))));
        },
        addBack: function(a) {
            return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
        }
    }), m.each({
        parent: function(a) {
            a = a.parentNode;
            return a && 11 !== a.nodeType ? a : null;
        },
        parents: function(a) {
            return m.dir(a, "parentNode");
        },
        parentsUntil: function(a, b, c) {
            return m.dir(a, "parentNode", c);
        },
        next: function(a) {
            return D(a, "nextSibling");
        },
        prev: function(a) {
            return D(a, "previousSibling");
        },
        nextAll: function(a) {
            return m.dir(a, "nextSibling");
        },
        prevAll: function(a) {
            return m.dir(a, "previousSibling");
        },
        nextUntil: function(a, b, c) {
            return m.dir(a, "nextSibling", c);
        },
        prevUntil: function(a, b, c) {
            return m.dir(a, "previousSibling", c);
        },
        siblings: function(a) {
            return m.sibling((a.parentNode || {}).firstChild, a);
        },
        children: function(a) {
            return m.sibling(a.firstChild);
        },
        contents: function(a) {
            return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes);
        }
    }, function(a, b) {
        m.fn[a] = function(c, d) {
            var e = m.map(this, b, c);
            return (d = "Until" !== a.slice(-5) ? c : d) && "string" == typeof d && (e = m.filter(d, e)), 
            1 < this.length && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())), 
            this.pushStack(e);
        };
    });
    var H, E = /\S+/g, F = {};
    function I() {
        y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), 
        a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J), 
        a.detachEvent("onload", J));
    }
    function J() {
        !y.addEventListener && "load" !== event.type && "complete" !== y.readyState || (I(), 
        m.ready());
    }
    m.Callbacks = function(a) {
        a = "string" == typeof a ? F[a] || function(a) {
            var b = F[a] = {};
            return m.each(a.match(E) || [], function(a, c) {
                b[c] = !0;
            }), b;
        }(a) : m.extend({}, a);
        function j(l) {
            for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && f < e; f++) if (!1 === h[f].apply(l[0], l[1]) && a.stopOnFalse) {
                c = !1;
                break;
            }
            b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable());
        }
        var b, c, d, e, f, g, h = [], i = !a.once && [], k = {
            add: function() {
                var d;
                return h && (d = h.length, function f(b) {
                    m.each(b, function(b, c) {
                        var d = m.type(c);
                        "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c);
                    });
                }(arguments), b ? e = h.length : c && (g = d, j(c))), this;
            },
            remove: function() {
                return h && m.each(arguments, function(a, c) {
                    for (var d; -1 < (d = m.inArray(c, h, d)); ) h.splice(d, 1), 
                    b && (d <= e && e--, d <= f && f--);
                }), this;
            },
            has: function(a) {
                return a ? -1 < m.inArray(a, h) : !(!h || !h.length);
            },
            empty: function() {
                return h = [], e = 0, this;
            },
            disable: function() {
                return h = i = c = void 0, this;
            },
            disabled: function() {
                return !h;
            },
            lock: function() {
                return i = void 0, c || k.disable(), this;
            },
            locked: function() {
                return !i;
            },
            fireWith: function(a, c) {
                return !h || d && !i || (c = [ a, (c = c || []).slice ? c.slice() : c ], 
                b ? i.push(c) : j(c)), this;
            },
            fire: function() {
                return k.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!d;
            }
        };
        return k;
    }, m.extend({
        Deferred: function(a) {
            var b = [ [ "resolve", "done", m.Callbacks("once memory"), "resolved" ], [ "reject", "fail", m.Callbacks("once memory"), "rejected" ], [ "notify", "progress", m.Callbacks("memory") ] ], c = "pending", d = {
                state: function() {
                    return c;
                },
                always: function() {
                    return e.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var a = arguments;
                    return m.Deferred(function(c) {
                        m.each(b, function(b, f) {
                            var g = m.isFunction(a[b]) && a[b];
                            e[f[1]](function() {
                                var a = g && g.apply(this, arguments);
                                a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [ a ] : arguments);
                            });
                        }), a = null;
                    }).promise();
                },
                promise: function(a) {
                    return null != a ? m.extend(a, d) : d;
                }
            }, e = {};
            return d.pipe = d.then, m.each(b, function(a, f) {
                var g = f[2], h = f[3];
                d[f[1]] = g.add, h && g.add(function() {
                    c = h;
                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
                    return e[f[0] + "With"](this === e ? d : this, arguments), this;
                }, e[f[0] + "With"] = g.fireWith;
            }), d.promise(e), a && a.call(e, e), e;
        },
        when: function(a) {
            function h(a, b, c) {
                return function(e) {
                    b[a] = this, c[a] = 1 < arguments.length ? d.call(arguments) : e, 
                    c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
                };
            }
            var i, j, k, b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && m.isFunction(a.promise) ? e : 0, g = 1 === f ? a : m.Deferred();
            if (1 < e) for (i = new Array(e), j = new Array(e), k = new Array(e); b < e; b++) c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
            return f || g.resolveWith(k, c), g.promise();
        }
    }), m.fn.ready = function(a) {
        return m.ready.promise().done(a), this;
    }, m.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(a) {
            a ? m.readyWait++ : m.ready(!0);
        },
        ready: function(a) {
            if (!0 === a ? !--m.readyWait : !m.isReady) {
                if (!y.body) return setTimeout(m.ready);
                (m.isReady = !0) !== a && 0 < --m.readyWait || (H.resolveWith(y, [ m ]), 
                m.fn.triggerHandler && (m(y).triggerHandler("ready"), m(y).off("ready")));
            }
        }
    }), m.ready.promise = function(b) {
        if (!H) if (H = m.Deferred(), "complete" === y.readyState) setTimeout(m.ready); else if (y.addEventListener) y.addEventListener("DOMContentLoaded", J, !1), 
        a.addEventListener("load", J, !1); else {
            y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J);
            var c = !1;
            try {
                c = null == a.frameElement && y.documentElement;
            } catch (d) {}
            c && c.doScroll && !function e() {
                if (!m.isReady) {
                    try {
                        c.doScroll("left");
                    } catch (a) {
                        return setTimeout(e, 50);
                    }
                    I(), m.ready();
                }
            }();
        }
        return H.promise(b);
    };
    var L, K = "undefined";
    for (L in m(k)) break;
    k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function() {
        var b, d, c = y.getElementsByTagName("body")[0];
        c && c.style && (b = y.createElement("div"), (d = y.createElement("div")).style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
        c.appendChild(d).appendChild(b), typeof b.style.zoom != K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", 
        k.inlineBlockNeedsLayout = b = 3 === b.offsetWidth, b && (c.style.zoom = 1)), 
        c.removeChild(d));
    }), function() {
        var a = y.createElement("div");
        if (null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete a.test;
            } catch (b) {
                k.deleteExpando = !1;
            }
        }
    }(), m.acceptData = function(a) {
        var b = m.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1;
        return (1 === c || 9 === c) && (!b || !0 !== b && a.getAttribute("classid") === b);
    };
    var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, N = /([A-Z])/g;
    function O(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(N, "-$1").toLowerCase();
            if ("string" == typeof (c = a.getAttribute(d))) {
                try {
                    c = "true" === c || "false" !== c && ("null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c);
                } catch (e) {}
                m.data(a, b, c);
            } else c = void 0;
        }
        return c;
    }
    function P(a) {
        for (var b in a) if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b) return;
        return 1;
    }
    function Q(a, b, d, e) {
        if (m.acceptData(a)) {
            var f, h = m.expando, i = a.nodeType, j = i ? m.cache : a, k = i ? a[h] : a[h] && h;
            if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return j[k = k || (i ? a[h] = c.pop() || m.guid++ : h)] || (j[k] = i ? {} : {
                toJSON: m.noop
            }), "object" != typeof b && "function" != typeof b || (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)), 
            a = j[k], e || (a.data || (a.data = {}), a = a.data), void 0 !== d && (a[m.camelCase(b)] = d), 
            "string" == typeof b ? null == (f = a[b]) && (f = a[m.camelCase(b)]) : f = a, 
            f;
        }
    }
    function R(a, b, c) {
        if (m.acceptData(a)) {
            var d, e, f = a.nodeType, g = f ? m.cache : a, h = f ? a[m.expando] : m.expando;
            if (g[h]) {
                if (b && (d = c ? g[h] : g[h].data)) {
                    e = (b = m.isArray(b) ? b.concat(m.map(b, m.camelCase)) : b in d || (b = m.camelCase(b)) in d ? [ b ] : b.split(" ")).length;
                    for (;e--; ) delete d[b[e]];
                    if (c ? !P(d) : !m.isEmptyObject(d)) return;
                }
                (c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([ a ], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
            }
        }
    }
    m.extend({
        cache: {},
        noData: {
            "applet ": !0,
            "embed ": !0,
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(a) {
            return !!(a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando]) && !P(a);
        },
        data: function(a, b, c) {
            return Q(a, b, c);
        },
        removeData: function(a, b) {
            return R(a, b);
        },
        _data: function(a, b, c) {
            return Q(a, b, c, !0);
        },
        _removeData: function(a, b) {
            return R(a, b, !0);
        }
    }), m.fn.extend({
        data: function(a, b) {
            var c, d, e, f = this[0], g = f && f.attributes;
            if (void 0 !== a) return "object" == typeof a ? this.each(function() {
                m.data(this, a);
            }) : 1 < arguments.length ? this.each(function() {
                m.data(this, a, b);
            }) : f ? O(f, a, m.data(f, a)) : void 0;
            if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) {
                for (c = g.length; c--; ) g[c] && (0 === (d = g[c].name).indexOf("data-") && O(f, d = m.camelCase(d.slice(5)), e[d]));
                m._data(f, "parsedAttrs", !0);
            }
            return e;
        },
        removeData: function(a) {
            return this.each(function() {
                m.removeData(this, a);
            });
        }
    }), m.extend({
        queue: function(a, b, c) {
            var d;
            return a ? (d = m._data(a, b = (b || "fx") + "queue"), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)), 
            d || []) : void 0;
        },
        dequeue: function(a, b) {
            b = b || "fx";
            var c = m.queue(a, b), d = c.length, e = c.shift(), f = m._queueHooks(a, b);
            "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), 
            delete f.stop, e.call(a, function() {
                m.dequeue(a, b);
            }, f)), !d && f && f.empty.fire();
        },
        _queueHooks: function(a, b) {
            var c = b + "queueHooks";
            return m._data(a, c) || m._data(a, c, {
                empty: m.Callbacks("once memory").add(function() {
                    m._removeData(a, b + "queue"), m._removeData(a, c);
                })
            });
        }
    }), m.fn.extend({
        queue: function(a, b) {
            var c = 2;
            return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                var c = m.queue(this, a, b);
                m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a);
            });
        },
        dequeue: function(a) {
            return this.each(function() {
                m.dequeue(this, a);
            });
        },
        clearQueue: function(a) {
            return this.queue(a || "fx", []);
        },
        promise: function(a, b) {
            function h() {
                --d || e.resolveWith(f, [ f ]);
            }
            var c, d = 1, e = m.Deferred(), f = this, g = this.length;
            for ("string" != typeof a && (b = a, a = void 0), a = a || "fx"; g--; ) (c = m._data(f[g], a + "queueHooks")) && c.empty && (d++, 
            c.empty.add(h));
            return h(), e.promise(b);
        }
    });
    function U(a, b) {
        return "none" === m.css(a = b || a, "display") || !m.contains(a.ownerDocument, a);
    }
    var l = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = [ "Top", "Right", "Bottom", "Left" ], V = m.access = function(a, b, c, d, e, f, g) {
        var h = 0, i = a.length, j = null == c;
        if ("object" === m.type(c)) for (h in e = !0, c) m.access(a, b, h, c[h], !0, f, g); else if (void 0 !== d && (e = !0, 
        m.isFunction(d) || (g = !0), b = j ? g ? (b.call(a, d), null) : (j = b, 
        function(a, b, c) {
            return j.call(m(a), c);
        }) : b)) for (;h < i; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
    }, W = /^(?:checkbox|radio)$/i, X = (!function() {
        var a = y.createElement("input"), b = y.createElement("div"), c = y.createDocumentFragment();
        if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length, 
        k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML, 
        a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked, 
        b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, 
        c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", 
        k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0, 
        b.attachEvent && (b.attachEvent("onclick", function() {
            k.noCloneEvent = !1;
        }), b.cloneNode(!0).click()), null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete b.test;
            } catch (d) {
                k.deleteExpando = !1;
            }
        }
    }(), function() {
        var b, c, d = y.createElement("div");
        for (b in {
            submit: !0,
            change: !0,
            focusin: !0
        }) c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), 
        k[b + "Bubbles"] = !1 === d.attributes[c].expando);
    }(), /^(?:input|select|textarea)$/i), Y = /^key/, Z = /^(?:mouse|pointer|contextmenu)|click/, $ = /^(?:focusinfocus|focusoutblur)$/, _ = /^([^.]*)(?:\.(.+)|)$/;
    function aa() {
        return !0;
    }
    function ba() {
        return !1;
    }
    function ca() {
        try {
            return y.activeElement;
        } catch (a) {}
    }
    function da(a) {
        var b = ea.split("|"), c = a.createDocumentFragment();
        if (c.createElement) for (;b.length; ) c.createElement(b.pop());
        return c;
    }
    m.event = {
        global: {},
        add: function(a, b, c, d, e) {
            var g, h, i, j, k, n, o, f, q, r = m._data(a);
            if (r) for (c.handler && (c = (i = c).handler, e = i.selector), c.guid || (c.guid = m.guid++), 
            (g = r.events) || (g = r.events = {}), (k = r.handle) || ((k = r.handle = function(a) {
                return typeof m == K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments);
            }).elem = a), h = (b = (b || "").match(E) || [ "" ]).length; h--; ) o = q = (f = _.exec(b[h]) || [])[1], 
            f = (f[2] || "").split(".").sort(), o && (j = m.event.special[o] || {}, 
            o = (e ? j.delegateType : j.bindType) || o, j = m.event.special[o] || {}, 
            q = m.extend({
                type: o,
                origType: q,
                data: d,
                handler: c,
                guid: c.guid,
                selector: e,
                needsContext: e && m.expr.match.needsContext.test(e),
                namespace: f.join(".")
            }, i), (n = g[o]) || ((n = g[o] = []).delegateCount = 0, j.setup && !1 !== j.setup.call(a, d, f, k) || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), 
            j.add && (j.add.call(a, q), q.handler.guid || (q.handler.guid = c.guid)), 
            e ? n.splice(n.delegateCount++, 0, q) : n.push(q), m.event.global[o] = !0);
        },
        remove: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m.hasData(a) && m._data(a);
            if (r && (k = r.events)) {
                for (j = (b = (b || "").match(E) || [ "" ]).length; j--; ) if (o = q = (h = _.exec(b[j]) || [])[1], 
                p = (h[2] || "").split(".").sort(), o) {
                    for (l = m.event.special[o] || {}, n = k[o = (d ? l.delegateType : l.bindType) || o] || [], 
                    h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
                    i = f = n.length; f--; ) g = n[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1), 
                    g.selector && n.delegateCount--, l.remove && l.remove.call(a, g));
                    i && !n.length && (l.teardown && !1 !== l.teardown.call(a, p, r.handle) || m.removeEvent(a, o, r.handle), 
                    delete k[o]);
                } else for (o in k) m.event.remove(a, o + b[j], c, d, !0);
                m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events"));
            }
        },
        trigger: function(b, c, d, e) {
            var f, g, i, k, l, n, o = [ d || y ], p = j.call(b, "type") ? b.type : b, q = j.call(b, "namespace") ? b.namespace.split(".") : [], h = l = d = d || y;
            if (3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (0 <= p.indexOf(".") && (p = (q = p.split(".")).shift(), 
            q.sort()), g = p.indexOf(":") < 0 && "on" + p, (b = b[m.expando] ? b : new m.Event(p, "object" == typeof b && b)).isTrigger = e ? 2 : 3, 
            b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            b.result = void 0, b.target || (b.target = d), c = null == c ? [ b ] : m.makeArray(c, [ b ]), 
            k = m.event.special[p] || {}, e || !k.trigger || !1 !== k.trigger.apply(d, c))) {
                if (!e && !k.noBubble && !m.isWindow(d)) {
                    for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), 
                    l = h;
                    l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a);
                }
                for (n = 0; (h = o[n++]) && !b.isPropagationStopped(); ) b.type = 1 < n ? i : k.bindType || p, 
                (f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle")) && f.apply(h, c), 
                (f = g && h[g]) && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), 
                !1 === b.result && b.preventDefault());
                if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || !1 === k._default.apply(o.pop(), c)) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) {
                    (l = d[g]) && (d[g] = null), m.event.triggered = p;
                    try {
                        d[p]();
                    } catch (r) {}
                    m.event.triggered = void 0, l && (d[g] = l);
                }
                return b.result;
            }
        },
        dispatch: function(a) {
            a = m.event.fix(a);
            var b, e, f, g, h, i = d.call(arguments), j = (m._data(this, "events") || {})[a.type] || [], k = m.event.special[a.type] || {};
            if ((i[0] = a).delegateTarget = this, !k.preDispatch || !1 !== k.preDispatch.call(this, a)) {
                for (h = m.event.handlers.call(this, a, j), b = 0; (f = h[b++]) && !a.isPropagationStopped(); ) for (a.currentTarget = f.elem, 
                g = 0; (e = f.handlers[g++]) && !a.isImmediatePropagationStopped(); ) a.namespace_re && !a.namespace_re.test(e.namespace) || (a.handleObj = e, 
                a.data = e.data, void 0 !== (e = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i)) && !1 === (a.result = e) && (a.preventDefault(), 
                a.stopPropagation()));
                return k.postDispatch && k.postDispatch.call(this, a), a.result;
            }
        },
        handlers: function(a, b) {
            var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type)) for (;i != this; i = i.parentNode || this) if (1 === i.nodeType && (!0 !== i.disabled || "click" !== a.type)) {
                for (e = [], f = 0; f < h; f++) void 0 === e[c = (d = b[f]).selector + " "] && (e[c] = d.needsContext ? 0 <= m(c, this).index(i) : m.find(c, this, null, [ i ]).length), 
                e[c] && e.push(d);
                e.length && g.push({
                    elem: i,
                    handlers: e
                });
            }
            return h < b.length && g.push({
                elem: this,
                handlers: b.slice(h)
            }), g;
        },
        fix: function(a) {
            if (a[m.expando]) return a;
            var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
            for (g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), 
            d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), 
            b = d.length; b--; ) a[c = d[b]] = f[c];
            return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), 
            a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(a, b) {
                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), 
                a;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(a, b) {
                var d, e, f = b.button, g = b.fromElement;
                return null == a.pageX && null != b.clientX && (e = (d = a.target.ownerDocument || y).documentElement, 
                d = d.body, a.pageX = b.clientX + (e && e.scrollLeft || d && d.scrollLeft || 0) - (e && e.clientLeft || d && d.clientLeft || 0), 
                a.pageY = b.clientY + (e && e.scrollTop || d && d.scrollTop || 0) - (e && e.clientTop || d && d.clientTop || 0)), 
                !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), 
                a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), 
                a;
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== ca() && this.focus) try {
                        return this.focus(), !1;
                    } catch (a) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === ca() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), 
                    !1) : void 0;
                },
                _default: function(a) {
                    return m.nodeName(a.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(a) {
                    void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
                }
            }
        },
        simulate: function(a, b, c, d) {
            a = m.extend(new m.Event(), c, {
                type: a,
                isSimulated: !0,
                originalEvent: {}
            });
            d ? m.event.trigger(a, null, b) : m.event.dispatch.call(b, a), a.isDefaultPrevented() && c.preventDefault();
        }
    }, m.removeEvent = y.removeEventListener ? function(a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c, !1);
    } : function(a, b, c) {
        b = "on" + b;
        a.detachEvent && (typeof a[b] == K && (a[b] = null), a.detachEvent(b, c));
    }, m.Event = function(a, b) {
        return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, 
        this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && !1 === a.returnValue ? aa : ba) : this.type = a, 
        b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void (this[m.expando] = !0)) : new m.Event(a, b);
    }, m.Event.prototype = {
        isDefaultPrevented: ba,
        isPropagationStopped: ba,
        isImmediatePropagationStopped: ba,
        preventDefault: function() {
            var a = this.originalEvent;
            this.isDefaultPrevented = aa, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
        },
        stopPropagation: function() {
            var a = this.originalEvent;
            this.isPropagationStopped = aa, a && (a.stopPropagation && a.stopPropagation(), 
            a.cancelBubble = !0);
        },
        stopImmediatePropagation: function() {
            var a = this.originalEvent;
            this.isImmediatePropagationStopped = aa, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, m.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(a, b) {
        m.event.special[a] = {
            delegateType: b,
            bindType: b,
            handle: function(a) {
                var c, e = a.relatedTarget, f = a.handleObj;
                return e && (e === this || m.contains(this, e)) || (a.type = f.origType, 
                c = f.handler.apply(this, arguments), a.type = b), c;
            }
        };
    }), k.submitBubbles || (m.event.special.submit = {
        setup: function() {
            return !m.nodeName(this, "form") && void m.event.add(this, "click._submit keypress._submit", function(a) {
                a = a.target, a = m.nodeName(a, "input") || m.nodeName(a, "button") ? a.form : void 0;
                a && !m._data(a, "submitBubbles") && (m.event.add(a, "submit._submit", function(a) {
                    a._submit_bubble = !0;
                }), m._data(a, "submitBubbles", !0));
            });
        },
        postDispatch: function(a) {
            a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0));
        },
        teardown: function() {
            return !m.nodeName(this, "form") && void m.event.remove(this, "._submit");
        }
    }), k.changeBubbles || (m.event.special.change = {
        setup: function() {
            return X.test(this.nodeName) ? ("checkbox" !== this.type && "radio" !== this.type || (m.event.add(this, "propertychange._change", function(a) {
                "checked" === a.originalEvent.propertyName && (this._just_changed = !0);
            }), m.event.add(this, "click._change", function(a) {
                this._just_changed && !a.isTrigger && (this._just_changed = !1), 
                m.event.simulate("change", this, a, !0);
            })), !1) : void m.event.add(this, "beforeactivate._change", function(a) {
                a = a.target;
                X.test(a.nodeName) && !m._data(a, "changeBubbles") && (m.event.add(a, "change._change", function(a) {
                    !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0);
                }), m._data(a, "changeBubbles", !0));
            });
        },
        handle: function(a) {
            var b = a.target;
            return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0;
        },
        teardown: function() {
            return m.event.remove(this, "._change"), !X.test(this.nodeName);
        }
    }), k.focusinBubbles || m.each({
        focus: "focusin",
        blur: "focusout"
    }, function(a, b) {
        function c(a) {
            m.event.simulate(b, a.target, m.event.fix(a), !0);
        }
        m.event.special[b] = {
            setup: function() {
                var d = this.ownerDocument || this, e = m._data(d, b);
                e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1);
            },
            teardown: function() {
                var d = this.ownerDocument || this, e = m._data(d, b) - 1;
                e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b));
            }
        };
    }), m.fn.extend({
        on: function(a, b, c, d, e) {
            var f, g;
            if ("object" == typeof a) {
                for (f in "string" != typeof b && (c = c || b, b = void 0), a) this.on(f, b, c, a[f], e);
                return this;
            }
            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, 
            c = void 0) : (d = c, c = b, b = void 0)), !1 === d) d = ba; else if (!d) return this;
            return 1 === e && (g = d, (d = function(a) {
                return m().off(a), g.apply(this, arguments);
            }).guid = g.guid || (g.guid = m.guid++)), this.each(function() {
                m.event.add(this, a, d, c, b);
            });
        },
        one: function(a, b, c, d) {
            return this.on(a, b, c, d, 1);
        },
        off: function(a, b, c) {
            var d, e;
            if (a && a.preventDefault && a.handleObj) d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler); else {
                if ("object" != typeof a) return !1 !== b && "function" != typeof b || (c = b, 
                b = void 0), !1 === c && (c = ba), this.each(function() {
                    m.event.remove(this, a, c, b);
                });
                for (e in a) this.off(e, b, a[e]);
            }
            return this;
        },
        trigger: function(a, b) {
            return this.each(function() {
                m.event.trigger(a, b, this);
            });
        },
        triggerHandler: function(a, b) {
            var c = this[0];
            return c ? m.event.trigger(a, b, c, !0) : void 0;
        }
    });
    var ea = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", fa = / jQuery\d+="(?:null|\d+)"/g, ga = new RegExp("<(?:" + ea + ")[\\s/>]", "i"), ha = /^\s+/, ia = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, ja = /<([\w:]+)/, ka = /<tbody/i, la = /<|&#?\w+;/, ma = /<(?:script|style|link)/i, na = /checked\s*(?:[^=]|=\s*.checked.)/i, oa = /^$|\/(?:java|ecma)script/i, pa = /^true\/(.*)/, qa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, ra = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: k.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, ta = da(y).appendChild(y.createElement("div"));
    function ua(a, b) {
        var c, d, e = 0, f = typeof a.getElementsByTagName != K ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll != K ? a.querySelectorAll(b || "*") : void 0;
        if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ua(d, b));
        return void 0 === b || b && m.nodeName(a, b) ? m.merge([ a ], f) : f;
    }
    function va(a) {
        W.test(a.type) && (a.defaultChecked = a.checked);
    }
    function wa(a, b) {
        return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
    }
    function xa(a) {
        return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a;
    }
    function ya(a) {
        var b = pa.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"), a;
    }
    function za(a, b) {
        for (var c, d = 0; null != (c = a[d]); d++) m._data(c, "globalEval", !b || m._data(b[d], "globalEval"));
    }
    function Aa(a, b) {
        if (1 === b.nodeType && m.hasData(a)) {
            var c, d, e, a = m._data(a), g = m._data(b, a), h = a.events;
            if (h) for (c in delete g.handle, g.events = {}, h) for (d = 0, e = h[c].length; d < e; d++) m.event.add(b, c, h[c][d]);
            g.data && (g.data = m.extend({}, g.data));
        }
    }
    ra.optgroup = ra.option, ra.tbody = ra.tfoot = ra.colgroup = ra.caption = ra.thead, 
    ra.th = ra.td, m.extend({
        clone: function(a, b, c) {
            var d, e, f, g, h, i = m.contains(a.ownerDocument, a);
            if (k.html5Clone || m.isXMLDoc(a) || !ga.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (ta.innerHTML = a.outerHTML, 
            ta.removeChild(f = ta.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a))) for (d = ua(f), 
            h = ua(a), g = 0; null != (e = h[g]); ++g) d[g] && function(a, b) {
                var c, d, e;
                if (1 === b.nodeType) {
                    if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) {
                        for (d in (e = m._data(b)).events) m.removeEvent(b, d, e.handle);
                        b.removeAttribute(m.expando);
                    }
                    "script" === c && b.text !== a.text ? (xa(b).text = a.text, 
                    ya(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), 
                    k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked, 
                    b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue);
                }
            }(e, d[g]);
            if (b) if (c) for (h = h || ua(a), d = d || ua(f), g = 0; null != (e = h[g]); g++) Aa(e, d[g]); else Aa(a, f);
            return 0 < (d = ua(f, "script")).length && za(d, !i && ua(a, "script")), 
            d = h = e = null, f;
        },
        buildFragment: function(a, b, c, d) {
            for (var e, f, g, h, i, j, l, n = a.length, o = da(b), p = [], q = 0; q < n; q++) if ((f = a[q]) || 0 === f) if ("object" === m.type(f)) m.merge(p, f.nodeType ? [ f ] : f); else if (la.test(f)) {
                for (h = h || o.appendChild(b.createElement("div")), i = (ja.exec(f) || [ "", "" ])[1].toLowerCase(), 
                l = ra[i] || ra._default, h.innerHTML = l[1] + f.replace(ia, "<$1></$2>") + l[2], 
                e = l[0]; e--; ) h = h.lastChild;
                if (!k.leadingWhitespace && ha.test(f) && p.push(b.createTextNode(ha.exec(f)[0])), 
                !k.tbody) for (e = (f = "table" !== i || ka.test(f) ? "<table>" !== l[1] || ka.test(f) ? 0 : h : h.firstChild) && f.childNodes.length; e--; ) m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
                for (m.merge(p, h.childNodes), h.textContent = ""; h.firstChild; ) h.removeChild(h.firstChild);
                h = o.lastChild;
            } else p.push(b.createTextNode(f));
            for (h && o.removeChild(h), k.appendChecked || m.grep(ua(p, "input"), va), 
            q = 0; f = p[q++]; ) if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f), 
            h = ua(o.appendChild(f), "script"), g && za(h), c)) for (e = 0; f = h[e++]; ) oa.test(f.type || "") && c.push(f);
            return h = null, o;
        },
        cleanData: function(a, b) {
            for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++) if ((b || m.acceptData(d)) && (g = (f = d[i]) && j[f])) {
                if (g.events) for (e in g.events) n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle);
                j[f] && (delete j[f], l ? delete d[i] : typeof d.removeAttribute != K ? d.removeAttribute(i) : d[i] = null, 
                c.push(f));
            }
        }
    }), m.fn.extend({
        text: function(a) {
            return V(this, function(a) {
                return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a));
            }, null, a, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(a) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || wa(this, a).appendChild(a);
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(a) {
                var b;
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (b = wa(this, a)).insertBefore(a, b.firstChild);
            });
        },
        before: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
            });
        },
        remove: function(a, b) {
            for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || m.cleanData(ua(c)), 
            c.parentNode && (b && m.contains(c.ownerDocument, c) && za(ua(c, "script")), 
            c.parentNode.removeChild(c));
            return this;
        },
        empty: function() {
            for (var a, b = 0; null != (a = this[b]); b++) {
                for (1 === a.nodeType && m.cleanData(ua(a, !1)); a.firstChild; ) a.removeChild(a.firstChild);
                a.options && m.nodeName(a, "select") && (a.options.length = 0);
            }
            return this;
        },
        clone: function(a, b) {
            return a = null != a && a, b = null == b ? a : b, this.map(function() {
                return m.clone(this, a, b);
            });
        },
        html: function(a) {
            return V(this, function(a) {
                var b = this[0] || {}, c = 0, d = this.length;
                if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(fa, "") : void 0;
                if (!("string" != typeof a || ma.test(a) || !k.htmlSerialize && ga.test(a) || !k.leadingWhitespace && ha.test(a) || ra[(ja.exec(a) || [ "", "" ])[1].toLowerCase()])) {
                    a = a.replace(ia, "<$1></$2>");
                    try {
                        for (;c < d; c++) 1 === (b = this[c] || {}).nodeType && (m.cleanData(ua(b, !1)), 
                        b.innerHTML = a);
                        b = 0;
                    } catch (e) {}
                }
                b && this.empty().append(a);
            }, null, a, arguments.length);
        },
        replaceWith: function() {
            var a = arguments[0];
            return this.domManip(arguments, function(b) {
                a = this.parentNode, m.cleanData(ua(this)), a && a.replaceChild(b, this);
            }), a && (a.length || a.nodeType) ? this : this.remove();
        },
        detach: function(a) {
            return this.remove(a, !0);
        },
        domManip: function(a, b) {
            a = e.apply([], a);
            var c, d, f, g, h, i, j = 0, l = this.length, n = this, o = l - 1, p = a[0], q = m.isFunction(p);
            if (q || 1 < l && "string" == typeof p && !k.checkClone && na.test(p)) return this.each(function(c) {
                var d = n.eq(c);
                q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
            });
            if (l && (c = (i = m.buildFragment(a, this[0].ownerDocument, !1, this)).firstChild, 
            1 === i.childNodes.length && (i = c), c)) {
                for (f = (g = m.map(ua(i, "script"), xa)).length; j < l; j++) d = i, 
                j !== o && (d = m.clone(d, !0, !0), f && m.merge(g, ua(d, "script"))), 
                b.call(this[j], d, j);
                if (f) for (h = g[g.length - 1].ownerDocument, m.map(g, ya), j = 0; j < f; j++) d = g[j], 
                oa.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qa, "")));
                i = c = null;
            }
            return this;
        }
    }), m.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(a, b) {
        m.fn[a] = function(a) {
            for (var c, d = 0, e = [], g = m(a), h = g.length - 1; d <= h; d++) c = d === h ? this : this.clone(!0), 
            m(g[d])[b](c), f.apply(e, c.get());
            return this.pushStack(e);
        };
    });
    var Ca, Da = {};
    function Ea(b, c) {
        b = m(c.createElement(b)).appendTo(c.body), c = a.getDefaultComputedStyle && (c = a.getDefaultComputedStyle(b[0])) ? c.display : m.css(b[0], "display");
        return b.detach(), c;
    }
    function Fa(a) {
        var b = y, c = Da[a];
        return c || ("none" !== (c = Ea(a, b)) && c || ((b = ((Ca = (Ca || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement))[0].contentWindow || Ca[0].contentDocument).document).write(), 
        b.close(), c = Ea(a, b), Ca.detach()), Da[a] = c), c;
    }
    !function() {
        var a;
        k.shrinkWrapBlocks = function() {
            var b, c, d;
            return null != a ? a : (a = !1, (c = y.getElementsByTagName("body")[0]) && c.style ? (b = y.createElement("div"), 
            (d = y.createElement("div")).style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            c.appendChild(d).appendChild(b), typeof b.style.zoom != K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", 
            b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), 
            c.removeChild(d), a) : void 0);
        };
    }();
    var Ia, Ja, Ga = /^margin/, Ha = new RegExp("^(" + l + ")(?!px)[a-z%]+$", "i"), Ka = /^(top|right|bottom|left)$/;
    function La(a, b) {
        return {
            get: function() {
                var c = a();
                if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments);
            }
        };
    }
    a.getComputedStyle ? (Ia = function(b) {
        return (b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView : a).getComputedStyle(b, null);
    }, Ja = function(a, b, c) {
        var f, h = a.style, g = (c = c || Ia(a)) ? c.getPropertyValue(b) || c[b] : void 0;
        return c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)), 
        Ha.test(g) && Ga.test(b) && (a = h.width, b = h.minWidth, f = h.maxWidth, 
        h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = a, h.minWidth = b, 
        h.maxWidth = f)), void 0 === g ? g : g + "";
    }) : y.documentElement.currentStyle && (Ia = function(a) {
        return a.currentStyle;
    }, Ja = function(a, b, c) {
        var d, e, f, h = a.style;
        return null == (c = (c = c || Ia(a)) ? c[b] : void 0) && h && h[b] && (c = h[b]), 
        Ha.test(c) && !Ka.test(b) && (d = h.left, (f = (e = a.runtimeStyle) && e.left) && (e.left = a.currentStyle.left), 
        h.left = "fontSize" === b ? "1em" : c, c = h.pixelLeft + "px", h.left = d, 
        f && (e.left = f)), void 0 === c ? c : c + "" || "auto";
    }), function() {
        var b, d, e, f, g, h;
        function i() {
            var b, d, i, c = y.getElementsByTagName("body")[0];
            c && c.style && (b = y.createElement("div"), (d = y.createElement("div")).style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", 
            e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top, 
            f = "4px" === (a.getComputedStyle(b, null) || {
                width: "4px"
            }).width, (i = b.appendChild(y.createElement("div"))).style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", 
            i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight), 
            b.removeChild(i)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", 
            (i = b.getElementsByTagName("td"))[0].style.cssText = "margin:0;border:0;padding:0;display:none", 
            (g = 0 === i[0].offsetHeight) && (i[0].style.display = "", i[1].style.display = "none", 
            g = 0 === i[0].offsetHeight), c.removeChild(d));
        }
        (b = y.createElement("div")).innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        (d = (d = b.getElementsByTagName("a")[0]) && d.style) && (d.cssText = "float:left;opacity:.5", 
        k.opacity = "0.5" === d.opacity, k.cssFloat = !!d.cssFloat, b.style.backgroundClip = "content-box", 
        b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip, 
        k.boxSizing = "" === d.boxSizing || "" === d.MozBoxSizing || "" === d.WebkitBoxSizing, 
        m.extend(k, {
            reliableHiddenOffsets: function() {
                return null == g && i(), g;
            },
            boxSizingReliable: function() {
                return null == f && i(), f;
            },
            pixelPosition: function() {
                return null == e && i(), e;
            },
            reliableMarginRight: function() {
                return null == h && i(), h;
            }
        }));
    }(), m.swap = function(a, b, c, d) {
        var f, g = {};
        for (f in b) g[f] = a.style[f], a.style[f] = b[f];
        for (f in c = c.apply(a, d || []), b) a.style[f] = g[f];
        return c;
    };
    var Ma = /alpha\([^)]*\)/i, Na = /opacity\s*=\s*([^)]*)/, Oa = /^(none|table(?!-c[ea]).+)/, Pa = new RegExp("^(" + l + ")(.*)$", "i"), Qa = new RegExp("^([+-])=(" + l + ")", "i"), Ra = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Sa = {
        letterSpacing: "0",
        fontWeight: "400"
    }, Ta = [ "Webkit", "O", "Moz", "ms" ];
    function Ua(a, b) {
        if (b in a) return b;
        for (var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = Ta.length; e--; ) if ((b = Ta[e] + c) in a) return b;
        return d;
    }
    function Va(a, b) {
        for (var c, d, e, f = [], g = 0, h = a.length; g < h; g++) (d = a[g]).style && (f[g] = m._data(d, "olddisplay"), 
        c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), 
        "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fa(d.nodeName)))) : (e = U(d), 
        (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display"))));
        for (g = 0; g < h; g++) !(d = a[g]).style || b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none");
        return a;
    }
    function Wa(a, b, c) {
        var d = Pa.exec(b);
        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
    }
    function Xa(a, b, c, d, e) {
        for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; f < 4; f += 2) "margin" === c && (g += m.css(a, c + T[f], !0, e)), 
        d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e), 
        "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e)));
        return g;
    }
    function Ya(a, b, c) {
        var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ia(a), g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f);
        if (e <= 0 || null == e) {
            if (((e = Ja(a, b, f)) < 0 || null == e) && (e = a.style[b]), Ha.test(e)) return e;
            d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
        }
        return e + Xa(a, b, c || (g ? "border" : "content"), d, f) + "px";
    }
    function Za(a, b, c, d, e) {
        return new Za.prototype.init(a, b, c, d, e);
    }
    m.extend({
        cssHooks: {
            opacity: {
                get: function(a, b) {
                    if (b) return "" === (b = Ja(a, "opacity")) ? "1" : b;
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: k.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = m.camelCase(b), i = a.style;
                if (b = m.cssProps[h] || (m.cssProps[h] = Ua(i, h)), g = m.cssHooks[b] || m.cssHooks[h], 
                void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                if ("string" === (f = typeof c) && (e = Qa.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)), 
                f = "number"), null != c && c == c && ("number" !== f || m.cssNumber[h] || (c += "px"), 
                k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), 
                !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
                    i[b] = c;
                } catch (j) {}
            }
        },
        css: function(a, b, c, d) {
            var f, h = m.camelCase(b);
            return b = m.cssProps[h] || (m.cssProps[h] = Ua(a.style, h)), "normal" === (f = void 0 === (f = (h = m.cssHooks[b] || m.cssHooks[h]) && "get" in h ? h.get(a, !0, c) : f) ? Ja(a, b, d) : f) && b in Sa && (f = Sa[b]), 
            ("" === c || c) && (h = parseFloat(f), !0 === c || m.isNumeric(h)) ? h || 0 : f;
        }
    }), m.each([ "height", "width" ], function(a, b) {
        m.cssHooks[b] = {
            get: function(a, c, d) {
                return c ? Oa.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Ra, function() {
                    return Ya(a, b, d);
                }) : Ya(a, b, d) : void 0;
            },
            set: function(a, c, d) {
                var e = d && Ia(a);
                return Wa(0, c, d ? Xa(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0);
            }
        };
    }), k.opacity || (m.cssHooks.opacity = {
        get: function(a, b) {
            return Na.test((b && a.currentStyle ? a.currentStyle : a.style).filter || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "";
        },
        set: function(a, b) {
            var c = a.style, a = a.currentStyle, e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = a && a.filter || c.filter || "";
            ((c.zoom = 1) <= b || "" === b) && "" === m.trim(f.replace(Ma, "")) && c.removeAttribute && (c.removeAttribute("filter"), 
            "" === b || a && !a.filter) || (c.filter = Ma.test(f) ? f.replace(Ma, e) : f + " " + e);
        }
    }), m.cssHooks.marginRight = La(k.reliableMarginRight, function(a, b) {
        return b ? m.swap(a, {
            display: "inline-block"
        }, Ja, [ a, "marginRight" ]) : void 0;
    }), m.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(a, b) {
        m.cssHooks[a + b] = {
            expand: function(c) {
                for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [ c ]; d < 4; d++) e[a + T[d] + b] = f[d] || f[d - 2] || f[0];
                return e;
            }
        }, Ga.test(a) || (m.cssHooks[a + b].set = Wa);
    }), m.fn.extend({
        css: function(a, b) {
            return V(this, function(a, b, c) {
                var d, e, f = {}, g = 0;
                if (m.isArray(b)) {
                    for (d = Ia(a), e = b.length; g < e; g++) f[b[g]] = m.css(a, b[g], !1, d);
                    return f;
                }
                return void 0 !== c ? m.style(a, b, c) : m.css(a, b);
            }, a, b, 1 < arguments.length);
        },
        show: function() {
            return Va(this, !0);
        },
        hide: function() {
            return Va(this);
        },
        toggle: function(a) {
            return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                U(this) ? m(this).show() : m(this).hide();
            });
        }
    }), ((m.Tween = Za).prototype = {
        constructor: Za,
        init: function(a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, 
            this.start = this.now = this.cur(), this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px");
        },
        cur: function() {
            var a = Za.propHooks[this.prop];
            return (a && a.get ? a : Za.propHooks._default).get(this);
        },
        run: function(a) {
            var b, c = Za.propHooks[this.prop];
            return this.options.duration ? this.pos = b = m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, 
            this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            (c && c.set ? c : Za.propHooks._default).set(this), this;
        }
    }).init.prototype = Za.prototype, (Za.propHooks = {
        _default: {
            get: function(a) {
                var b;
                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, "")) && "auto" !== b ? b : 0 : a.elem[a.prop];
            },
            set: function(a) {
                m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
            }
        }
    }).scrollTop = Za.propHooks.scrollLeft = {
        set: function(a) {
            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
        }
    }, m.easing = {
        linear: function(a) {
            return a;
        },
        swing: function(a) {
            return .5 - Math.cos(a * Math.PI) / 2;
        }
    }, m.fx = Za.prototype.init, m.fx.step = {};
    var $a, _a, ab = /^(?:toggle|show|hide)$/, bb = new RegExp("^(?:([+-])=|)(" + l + ")([a-z%]*)$", "i"), cb = /queueHooks$/, db = [ function(a, b, c) {
        var d, e, f, g, h, i, j, n = this, o = {}, p = a.style, q = a.nodeType && U(a), r = m._data(a, "fxshow");
        for (d in c.queue || (null == (h = m._queueHooks(a, "fx")).unqueued && (h.unqueued = 0, 
        i = h.empty.fire, h.empty.fire = function() {
            h.unqueued || i();
        }), h.unqueued++, n.always(function() {
            n.always(function() {
                h.unqueued--, m.queue(a, "fx").length || h.empty.fire();
            });
        })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [ p.overflow, p.overflowX, p.overflowY ], 
        j = m.css(a, "display"), "inline" === ("none" === j ? m._data(a, "olddisplay") || Fa(a.nodeName) : j) && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fa(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), 
        c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function() {
            p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2];
        })), b) if (e = b[d], ab.exec(e)) {
            if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
                if ("show" !== e || !r || void 0 === r[d]) continue;
                q = !0;
            }
            o[d] = r && r[d] || m.style(a, d);
        } else j = void 0;
        if (m.isEmptyObject(o)) "inline" === ("none" === j ? Fa(a.nodeName) : j) && (p.display = j); else for (d in r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), 
        f && (r.hidden = !q), q ? m(a).show() : n.done(function() {
            m(a).hide();
        }), n.done(function() {
            for (var b in m._removeData(a, "fxshow"), o) m.style(a, b, o[b]);
        }), o) g = hb(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start, 
        g.start = "width" === d || "height" === d ? 1 : 0));
    } ], eb = {
        "*": [ function(a, b) {
            var c = this.createTween(a, b), d = c.cur(), b = bb.exec(b), f = b && b[3] || (m.cssNumber[a] ? "" : "px"), g = (m.cssNumber[a] || "px" !== f && +d) && bb.exec(m.css(c.elem, a)), h = 1, i = 20;
            if (g && g[3] !== f) for (f = f || g[3], b = b || [], g = +d || 1; m.style(c.elem, a, (g /= h = h || ".5") + f), 
            h !== (h = c.cur() / d) && 1 !== h && --i; );
            return b && (g = c.start = +g || +d || 0, c.unit = f, c.end = b[1] ? g + (b[1] + 1) * b[2] : +b[2]), 
            c;
        } ]
    };
    function fb() {
        return setTimeout(function() {
            $a = void 0;
        }), $a = m.now();
    }
    function gb(a, b) {
        var c, d = {
            height: a
        }, e = 0;
        for (b = b ? 1 : 0; e < 4; e += 2 - b) d["margin" + (c = T[e])] = d["padding" + c] = a;
        return b && (d.opacity = d.width = a), d;
    }
    function hb(a, b, c) {
        for (var d, e = (eb[b] || []).concat(eb["*"]), f = 0, g = e.length; f < g; f++) if (d = e[f].call(c, b, a)) return d;
    }
    function kb(a, b, c) {
        var d, e, f = 0, g = db.length, h = m.Deferred().always(function() {
            delete i.elem;
        }), i = function() {
            if (e) return !1;
            for (var b = $a || fb(), b = Math.max(0, j.startTime + j.duration - b), f = 1 - (b / j.duration || 0), g = 0, i = j.tweens.length; g < i; g++) j.tweens[g].run(f);
            return h.notifyWith(a, [ j, f, b ]), f < 1 && i ? b : (h.resolveWith(a, [ j ]), 
            !1);
        }, j = h.promise({
            elem: a,
            props: m.extend({}, b),
            opts: m.extend(!0, {
                specialEasing: {}
            }, c),
            originalProperties: b,
            originalOptions: c,
            startTime: $a || fb(),
            duration: c.duration,
            tweens: [],
            createTween: function(b, c) {
                c = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                return j.tweens.push(c), c;
            },
            stop: function(b) {
                var c = 0, d = b ? j.tweens.length : 0;
                if (!e) {
                    for (e = !0; c < d; c++) j.tweens[c].run(1);
                    b ? h.resolveWith(a, [ j, b ]) : h.rejectWith(a, [ j, b ]);
                }
                return this;
            }
        }), k = j.props;
        for (function(a, b) {
            var c, d, e, f, g;
            for (c in a) if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1], 
            f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = m.cssHooks[d], 
            g && "expand" in g) for (c in f = g.expand(f), delete a[d], f) c in a || (a[c] = f[c], 
            b[c] = e); else b[d] = e;
        }(k, j.opts.specialEasing); f < g; f++) if (d = db[f].call(j, a, k, j.opts)) return d;
        return m.map(k, hb, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), 
        m.fx.timer(m.extend(i, {
            elem: a,
            anim: j,
            queue: j.opts.queue
        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
    }
    m.Animation = m.extend(kb, {
        tweener: function(a, b) {
            for (var c, d = 0, e = (a = m.isFunction(a) ? (b = a, [ "*" ]) : a.split(" ")).length; d < e; d++) c = a[d], 
            eb[c] = eb[c] || [], eb[c].unshift(b);
        },
        prefilter: function(a, b) {
            b ? db.unshift(a) : db.push(a);
        }
    }), m.speed = function(a, b, c) {
        var d = a && "object" == typeof a ? m.extend({}, a) : {
            complete: c || !c && b || m.isFunction(a) && a,
            duration: a,
            easing: c && b || b && !m.isFunction(b) && b
        };
        return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default, 
        null != d.queue && !0 !== d.queue || (d.queue = "fx"), d.old = d.complete, 
        d.complete = function() {
            m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue);
        }, d;
    }, m.fn.extend({
        fadeTo: function(a, b, c, d) {
            return this.filter(U).css("opacity", 0).show().end().animate({
                opacity: b
            }, a, c, d);
        },
        animate: function(a, b, c, d) {
            function g() {
                var b = kb(this, m.extend({}, a), f);
                (e || m._data(this, "finish")) && b.stop(!0);
            }
            var e = m.isEmptyObject(a), f = m.speed(b, c, d);
            return g.finish = g, e || !1 === f.queue ? this.each(g) : this.queue(f.queue, g);
        },
        stop: function(a, b, c) {
            function d(a) {
                var b = a.stop;
                delete a.stop, b(c);
            }
            return "string" != typeof a && (c = b, b = a, a = void 0), b && !1 !== a && this.queue(a || "fx", []), 
            this.each(function() {
                var b = !0, e = null != a && a + "queueHooks", f = m.timers, g = m._data(this);
                if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && cb.test(e) && d(g[e]);
                for (e = f.length; e--; ) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), 
                b = !1, f.splice(e, 1));
                !b && c || m.dequeue(this, a);
            });
        },
        finish: function(a) {
            return !1 !== a && (a = a || "fx"), this.each(function() {
                var b, c = m._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = m.timers, g = d ? d.length : 0;
                for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0), 
                b = f.length; b--; ) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), 
                f.splice(b, 1));
                for (b = 0; b < g; b++) d[b] && d[b].finish && d[b].finish.call(this);
                delete c.finish;
            });
        }
    }), m.each([ "toggle", "show", "hide" ], function(a, b) {
        var c = m.fn[b];
        m.fn[b] = function(a, d, e) {
            return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e);
        };
    }), m.each({
        slideDown: gb("show"),
        slideUp: gb("hide"),
        slideToggle: gb("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(a, b) {
        m.fn[a] = function(a, c, d) {
            return this.animate(b, a, c, d);
        };
    }), m.timers = [], m.fx.tick = function() {
        var a, b = m.timers, c = 0;
        for ($a = m.now(); c < b.length; c++) (a = b[c])() || b[c] !== a || b.splice(c--, 1);
        b.length || m.fx.stop(), $a = void 0;
    }, m.fx.timer = function(a) {
        m.timers.push(a), a() ? m.fx.start() : m.timers.pop();
    }, m.fx.interval = 13, m.fx.start = function() {
        _a = _a || setInterval(m.fx.tick, m.fx.interval);
    }, m.fx.stop = function() {
        clearInterval(_a), _a = null;
    }, m.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, m.fn.delay = function(a, b) {
        return a = m.fx && m.fx.speeds[a] || a, this.queue(b = b || "fx", function(b, c) {
            var d = setTimeout(b, a);
            c.stop = function() {
                clearTimeout(d);
            };
        });
    }, function() {
        var a, c, d, e, b = y.createElement("div");
        b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        d = b.getElementsByTagName("a")[0], e = (c = y.createElement("select")).appendChild(y.createElement("option")), 
        a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className, 
        k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"), 
        k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype, 
        c.disabled = !0, k.optDisabled = !e.disabled, (a = y.createElement("input")).setAttribute("value", ""), 
        k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), 
        k.radioValue = "t" === a.value;
    }();
    var lb = /\r/g;
    m.fn.extend({
        val: function(a) {
            var b, c, d, e = this[0];
            return arguments.length ? (d = m.isFunction(a), this.each(function(c) {
                1 === this.nodeType && (null == (c = d ? a.call(this, c, m(this).val()) : a) ? c = "" : "number" == typeof c ? c += "" : m.isArray(c) && (c = m.map(c, function(a) {
                    return null == a ? "" : a + "";
                })), (b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()]) && "set" in b && void 0 !== b.set(this, c, "value") || (this.value = c));
            })) : e ? (b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()]) && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : "string" == typeof (c = e.value) ? c.replace(lb, "") : null == c ? "" : c : void 0;
        }
    }), m.extend({
        valHooks: {
            option: {
                get: function(a) {
                    var b = m.find.attr(a, "value");
                    return null != b ? b : m.trim(m.text(a));
                }
            },
            select: {
                get: function(a) {
                    for (var c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || e < 0, g = f ? null : [], h = f ? e + 1 : d.length, i = e < 0 ? h : f ? e : 0; i < h; i++) if (!(!(c = d[i]).selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) {
                        if (c = m(c).val(), f) return c;
                        g.push(c);
                    }
                    return g;
                },
                set: function(a, b) {
                    for (var c, d, e = a.options, f = m.makeArray(b), g = e.length; g--; ) if (d = e[g], 
                    0 <= m.inArray(m.valHooks.option.get(d), f)) try {
                        d.selected = c = !0;
                    } catch (h) {
                        d.scrollHeight;
                    } else d.selected = !1;
                    return c || (a.selectedIndex = -1), e;
                }
            }
        }
    }), m.each([ "radio", "checkbox" ], function() {
        m.valHooks[this] = {
            set: function(a, b) {
                return m.isArray(b) ? a.checked = 0 <= m.inArray(m(a).val(), b) : void 0;
            }
        }, k.checkOn || (m.valHooks[this].get = function(a) {
            return null === a.getAttribute("value") ? "on" : a.value;
        });
    });
    var mb, nb, ob = m.expr.attrHandle, pb = /^(?:checked|selected)$/i, qb = k.getSetAttribute, rb = k.input, sb = (m.fn.extend({
        attr: function(a, b) {
            return V(this, m.attr, a, b, 1 < arguments.length);
        },
        removeAttr: function(a) {
            return this.each(function() {
                m.removeAttr(this, a);
            });
        }
    }), m.extend({
        attr: function(a, b, c) {
            var d, e, f = a.nodeType;
            if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute == K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(), 
            d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nb : mb)), void 0 === c ? !(d && "get" in d && null !== (e = d.get(a, b))) && null == (e = m.find.attr(a, b)) ? void 0 : e : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), 
            c) : void m.removeAttr(a, b));
        },
        removeAttr: function(a, b) {
            var c, d, e = 0, f = b && b.match(E);
            if (f && 1 === a.nodeType) for (;c = f[e++]; ) d = m.propFix[c] || c, 
            m.expr.match.bool.test(c) ? rb && qb || !pb.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""), 
            a.removeAttribute(qb ? c : d);
        },
        attrHooks: {
            type: {
                set: function(a, b) {
                    var c;
                    if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) return c = a.value, 
                    a.setAttribute("type", b), c && (a.value = c), b;
                }
            }
        }
    }), nb = {
        set: function(a, b, c) {
            return !1 === b ? m.removeAttr(a, c) : rb && qb || !pb.test(c) ? a.setAttribute(!qb && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0, 
            c;
        }
    }, m.each(m.expr.match.bool.source.match(/\w+/g), function(a, b) {
        var c = ob[b] || m.find.attr;
        ob[b] = rb && qb || !pb.test(b) ? function(a, b, d) {
            var e, f;
            return d || (f = ob[b], ob[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, 
            ob[b] = f), e;
        } : function(a, b, c) {
            return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null;
        };
    }), rb && qb || (m.attrHooks.value = {
        set: function(a, b, c) {
            return m.nodeName(a, "input") ? void (a.defaultValue = b) : mb && mb.set(a, b, c);
        }
    }), qb || (mb = {
        set: function(a, b, c) {
            var d = a.getAttributeNode(c);
            return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), 
            d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0;
        }
    }, ob.id = ob.name = ob.coords = function(a, b, c) {
        return c ? void 0 : (c = a.getAttributeNode(b)) && "" !== c.value ? c.value : null;
    }, m.valHooks.button = {
        get: function(a, b) {
            a = a.getAttributeNode(b);
            return a && a.specified ? a.value : void 0;
        },
        set: mb.set
    }, m.attrHooks.contenteditable = {
        set: function(a, b, c) {
            mb.set(a, "" !== b && b, c);
        }
    }, m.each([ "width", "height" ], function(a, b) {
        m.attrHooks[b] = {
            set: function(a, c) {
                return "" === c ? (a.setAttribute(b, "auto"), c) : void 0;
            }
        };
    })), k.style || (m.attrHooks.style = {
        get: function(a) {
            return a.style.cssText || void 0;
        },
        set: function(a, b) {
            return a.style.cssText = b + "";
        }
    }), /^(?:input|select|textarea|button|object)$/i), tb = /^(?:a|area)$/i, ub = (m.fn.extend({
        prop: function(a, b) {
            return V(this, m.prop, a, b, 1 < arguments.length);
        },
        removeProp: function(a) {
            return a = m.propFix[a] || a, this.each(function() {
                try {
                    this[a] = void 0, delete this[a];
                } catch (b) {}
            });
        }
    }), m.extend({
        propFix: {
            for: "htmlFor",
            class: "className"
        },
        prop: function(a, b, c) {
            var d, e, g = a.nodeType;
            if (a && 3 !== g && 8 !== g && 2 !== g) return (1 !== g || !m.isXMLDoc(a)) && (b = m.propFix[b] || b, 
            e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];
        },
        propHooks: {
            tabIndex: {
                get: function(a) {
                    var b = m.find.attr(a, "tabindex");
                    return b ? parseInt(b, 10) : sb.test(a.nodeName) || tb.test(a.nodeName) && a.href ? 0 : -1;
                }
            }
        }
    }), k.hrefNormalized || m.each([ "href", "src" ], function(a, b) {
        m.propHooks[b] = {
            get: function(a) {
                return a.getAttribute(b, 4);
            }
        };
    }), k.optSelected || (m.propHooks.selected = {
        get: function(a) {
            a = a.parentNode;
            return a && (a.selectedIndex, a.parentNode && a.parentNode.selectedIndex), 
            null;
        }
    }), m.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        m.propFix[this.toLowerCase()] = this;
    }), k.enctype || (m.propFix.enctype = "encoding"), /[\t\r\n\f]/g), vb = (m.fn.extend({
        addClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).addClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; h < i; h++) if (d = 1 === (c = this[h]).nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : " ")) {
                for (f = 0; e = b[f++]; ) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                g = m.trim(d), c.className !== g && (c.className = g);
            }
            return this;
        },
        removeClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).removeClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; h < i; h++) if (d = 1 === (c = this[h]).nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : "")) {
                for (f = 0; e = b[f++]; ) for (;0 <= d.indexOf(" " + e + " "); ) d = d.replace(" " + e + " ", " ");
                g = a ? m.trim(d) : "", c.className !== g && (c.className = g);
            }
            return this;
        },
        toggleClass: function(a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" == c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function(c) {
                m(this).toggleClass(a.call(this, c, this.className, b), b);
            } : function() {
                if ("string" == c) for (var b, d = 0, e = m(this), f = a.match(E) || []; b = f[d++]; ) e.hasClass(b) ? e.removeClass(b) : e.addClass(b); else c != K && "boolean" != c || (this.className && m._data(this, "__className__", this.className), 
                this.className = !this.className && !1 !== a && m._data(this, "__className__") || "");
            });
        },
        hasClass: function(a) {
            for (var b = " " + a + " ", c = 0, d = this.length; c < d; c++) if (1 === this[c].nodeType && 0 <= (" " + this[c].className + " ").replace(ub, " ").indexOf(b)) return !0;
            return !1;
        }
    }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
        m.fn[b] = function(a, c) {
            return 0 < arguments.length ? this.on(b, null, a, c) : this.trigger(b);
        };
    }), m.fn.extend({
        hover: function(a, b) {
            return this.mouseenter(a).mouseleave(b || a);
        },
        bind: function(a, b, c) {
            return this.on(a, null, b, c);
        },
        unbind: function(a, b) {
            return this.off(a, null, b);
        },
        delegate: function(a, b, c, d) {
            return this.on(b, a, c, d);
        },
        undelegate: function(a, b, c) {
            return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
        }
    }), m.now()), wb = /\?/, xb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    m.parseJSON = function(b) {
        var c, d, e;
        return a.JSON && a.JSON.parse ? a.JSON.parse(b + "") : (d = null, (e = m.trim(b + "")) && !m.trim(e.replace(xb, function(a, b, e, f) {
            return 0 === (d = c && b ? 0 : d) ? a : (c = e || b, d += !f - !e, "");
        })) ? Function("return " + e)() : m.error("Invalid JSON: " + b));
    }, m.parseXML = function(b) {
        var c;
        if (!b || "string" != typeof b) return null;
        try {
            a.DOMParser ? c = new DOMParser().parseFromString(b, "text/xml") : ((c = new ActiveXObject("Microsoft.XMLDOM")).async = "false", 
            c.loadXML(b));
        } catch (e) {
            c = void 0;
        }
        return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b), 
        c;
    };
    var yb, zb, Ab = /#.*$/, Bb = /([?&])_=[^&]*/, Cb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Eb = /^(?:GET|HEAD)$/, Fb = /^\/\//, Gb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Hb = {}, Ib = {}, Jb = "*/".concat("*");
    try {
        zb = location.href;
    } catch (Kb) {
        (zb = y.createElement("a")).href = "", zb = zb.href;
    }
    function Lb(a) {
        return function(b, c) {
            "string" != typeof b && (c = b, b = "*");
            var d, e = 0, f = b.toLowerCase().match(E) || [];
            if (m.isFunction(c)) for (;d = f[e++]; ) "+" === d.charAt(0) ? (d = d.slice(1) || "*", 
            (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
        };
    }
    function Mb(a, b, c, d) {
        var e = {}, f = a === Ib;
        function g(h) {
            var i;
            return e[h] = !0, m.each(a[h] || [], function(a, h) {
                h = h(b, c, d);
                return "string" != typeof h || f || e[h] ? f ? !(i = h) : void 0 : (b.dataTypes.unshift(h), 
                g(h), !1);
            }), i;
        }
        return g(b.dataTypes[0]) || !e["*"] && g("*");
    }
    function Nb(a, b) {
        var c, d, e = m.ajaxSettings.flatOptions || {};
        for (d in b) void 0 !== b[d] && ((e[d] ? a : c = c || {})[d] = b[d]);
        return c && m.extend(!0, a, c), a;
    }
    yb = Gb.exec(zb.toLowerCase()) || [], m.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: zb,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(yb[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Jb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": m.parseJSON,
                "text xml": m.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(a, b) {
            return b ? Nb(Nb(a, m.ajaxSettings), b) : Nb(m.ajaxSettings, a);
        },
        ajaxPrefilter: Lb(Hb),
        ajaxTransport: Lb(Ib),
        ajax: function(a, b) {
            "object" == typeof a && (b = a, a = void 0);
            var d, e, f, g, h, i, j, k = m.ajaxSetup({}, b = b || {}), l = k.context || k, n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event, o = m.Deferred(), p = m.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                readyState: 0,
                getResponseHeader: function(a) {
                    var b;
                    if (2 === t) {
                        if (!j) for (j = {}; b = Cb.exec(f); ) j[b[1].toLowerCase()] = b[2];
                        b = j[a.toLowerCase()];
                    }
                    return null == b ? null : b;
                },
                getAllResponseHeaders: function() {
                    return 2 === t ? f : null;
                },
                setRequestHeader: function(a, b) {
                    var c = a.toLowerCase();
                    return t || (a = s[c] = s[c] || a, r[a] = b), this;
                },
                overrideMimeType: function(a) {
                    return t || (k.mimeType = a), this;
                },
                statusCode: function(a) {
                    if (a) if (t < 2) for (var b in a) q[b] = [ q[b], a[b] ]; else v.always(a[v.status]);
                    return this;
                },
                abort: function(a) {
                    a = a || u;
                    return i && i.abort(a), x(0, a), this;
                }
            };
            if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, 
            k.url = ((a || k.url || zb) + "").replace(Ab, "").replace(Fb, yb[1] + "//"), 
            k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [ "" ], 
            null == k.crossDomain && (a = Gb.exec(k.url.toLowerCase()), k.crossDomain = !(!a || a[1] === yb[1] && a[2] === yb[2] && (a[3] || ("http:" === a[1] ? "80" : "443")) === (yb[3] || ("http:" === yb[1] ? "80" : "443")))), 
            k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)), 
            Mb(Hb, k, b, v), 2 !== t) {
                for (d in (h = m.event && k.global) && 0 == m.active++ && m.event.trigger("ajaxStart"), 
                k.type = k.type.toUpperCase(), k.hasContent = !Eb.test(k.type), 
                e = k.url, k.hasContent || (k.data && (e = k.url += (wb.test(e) ? "&" : "?") + k.data, 
                delete k.data), !1 === k.cache && (k.url = Bb.test(e) ? e.replace(Bb, "$1_=" + vb++) : e + (wb.test(e) ? "&" : "?") + "_=" + vb++)), 
                k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]), 
                m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && !1 !== k.contentType || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), 
                v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jb + "; q=0.01" : "") : k.accepts["*"]), 
                k.headers) v.setRequestHeader(d, k.headers[d]);
                if (k.beforeSend && (!1 === k.beforeSend.call(l, v, k) || 2 === t)) return v.abort();
                for (d in u = "abort", {
                    success: 1,
                    error: 1,
                    complete: 1
                }) v[d](k[d]);
                if (i = Mb(Ib, k, b, v)) {
                    v.readyState = 1, h && n.trigger("ajaxSend", [ v, k ]), k.async && 0 < k.timeout && (g = setTimeout(function() {
                        v.abort("timeout");
                    }, k.timeout));
                    try {
                        t = 1, i.send(r, x);
                    } catch (w) {
                        if (!(t < 2)) throw w;
                        x(-1, w);
                    }
                } else x(-1, "No Transport");
            }
            return v;
            function x(a, b, c, d) {
                var r, s, u, x = b;
                2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", 
                v.readyState = 0 < a ? 4 : 0, d = 200 <= a && a < 300 || 304 === a, 
                c && (u = function(a, b, c) {
                    for (var d, e, f, g, h = a.contents, i = a.dataTypes; "*" === i[0]; ) i.shift(), 
                    void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
                    if (e) for (g in h) if (h[g] && h[g].test(e)) {
                        i.unshift(g);
                        break;
                    }
                    if (i[0] in c) f = i[0]; else {
                        for (g in c) {
                            if (!i[0] || a.converters[g + " " + i[0]]) {
                                f = g;
                                break;
                            }
                            d = d || g;
                        }
                        f = f || d;
                    }
                    return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
                }(k, v, c)), u = function(a, b, c, d) {
                    var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
                    if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
                    for (f = k.shift(); f; ) if (a.responseFields[f] && (c[a.responseFields[f]] = b), 
                    !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), 
                    i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) {
                        if (!(g = j[i + " " + f] || j["* " + f])) for (e in j) if (h = e.split(" "), 
                        h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                            !0 === g ? g = j[e] : !0 !== j[e] && (f = h[0], k.unshift(h[1]));
                            break;
                        }
                        if (!0 !== g) if (g && a.throws) b = g(b); else try {
                            b = g(b);
                        } catch (l) {
                            return {
                                state: "parsererror",
                                error: g ? l : "No conversion from " + i + " to " + f
                            };
                        }
                    }
                    return {
                        state: "success",
                        data: b
                    };
                }(k, u, v, d), d ? (k.ifModified && ((c = v.getResponseHeader("Last-Modified")) && (m.lastModified[e] = c), 
                (c = v.getResponseHeader("etag")) && (m.etag[e] = c)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, 
                r = u.data, d = !(s = u.error))) : (s = x, !a && x || (x = "error", 
                a < 0 && (a = 0))), v.status = a, v.statusText = (b || x) + "", 
                d ? o.resolveWith(l, [ r, x, v ]) : o.rejectWith(l, [ v, x, s ]), 
                v.statusCode(q), q = void 0, h && n.trigger(d ? "ajaxSuccess" : "ajaxError", [ v, k, d ? r : s ]), 
                p.fireWith(l, [ v, x ]), h && (n.trigger("ajaxComplete", [ v, k ]), 
                --m.active || m.event.trigger("ajaxStop")));
            }
        },
        getJSON: function(a, b, c) {
            return m.get(a, b, c, "json");
        },
        getScript: function(a, b) {
            return m.get(a, void 0, b, "script");
        }
    }), m.each([ "get", "post" ], function(a, b) {
        m[b] = function(a, c, d, e) {
            return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({
                url: a,
                type: b,
                dataType: e,
                data: c,
                success: d
            });
        };
    }), m._evalUrl = function(a) {
        return m.ajax({
            url: a,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            throws: !0
        });
    }, m.fn.extend({
        wrapAll: function(a) {
            var b;
            return m.isFunction(a) ? this.each(function(b) {
                m(this).wrapAll(a.call(this, b));
            }) : (this[0] && (b = m(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), 
            b.map(function() {
                for (var a = this; a.firstChild && 1 === a.firstChild.nodeType; ) a = a.firstChild;
                return a;
            }).append(this)), this);
        },
        wrapInner: function(a) {
            return this.each(m.isFunction(a) ? function(b) {
                m(this).wrapInner(a.call(this, b));
            } : function() {
                var b = m(this), c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a);
            });
        },
        wrap: function(a) {
            var b = m.isFunction(a);
            return this.each(function(c) {
                m(this).wrapAll(b ? a.call(this, c) : a);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                m.nodeName(this, "body") || m(this).replaceWith(this.childNodes);
            }).end();
        }
    }), m.expr.filters.hidden = function(a) {
        return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display"));
    }, m.expr.filters.visible = function(a) {
        return !m.expr.filters.hidden(a);
    };
    var Qb = /%20/g, Rb = /\[\]$/, Sb = /\r?\n/g, Tb = /^(?:submit|button|image|reset|file)$/i, Ub = /^(?:input|select|textarea|keygen)/i;
    m.param = function(a, b) {
        function e(a, b) {
            b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
        }
        var c, d = [];
        if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), 
        m.isArray(a) || a.jquery && !m.isPlainObject(a)) m.each(a, function() {
            e(this.name, this.value);
        }); else for (c in a) !function Vb(a, b, c, d) {
            if (m.isArray(b)) m.each(b, function(b, e) {
                c || Rb.test(a) ? d(a, e) : Vb(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
            }); else if (c || "object" !== m.type(b)) d(a, b); else for (var e in b) Vb(a + "[" + e + "]", b[e], c, d);
        }(c, a[c], b, e);
        return d.join("&").replace(Qb, "+");
    }, m.fn.extend({
        serialize: function() {
            return m.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var a = m.prop(this, "elements");
                return a ? m.makeArray(a) : this;
            }).filter(function() {
                var a = this.type;
                return this.name && !m(this).is(":disabled") && Ub.test(this.nodeName) && !Tb.test(a) && (this.checked || !W.test(a));
            }).map(function(a, b) {
                var c = m(this).val();
                return null == c ? null : m.isArray(c) ? m.map(c, function(a) {
                    return {
                        name: b.name,
                        value: a.replace(Sb, "\r\n")
                    };
                }) : {
                    name: b.name,
                    value: c.replace(Sb, "\r\n")
                };
            }).get();
        }
    }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zb() || function() {
            try {
                return new a.ActiveXObject("Microsoft.XMLHTTP");
            } catch (b) {}
        }();
    } : Zb;
    var Wb = 0, Xb = {}, l = m.ajaxSettings.xhr();
    function Zb() {
        try {
            return new a.XMLHttpRequest();
        } catch (b) {}
    }
    a.attachEvent && a.attachEvent("onunload", function() {
        for (var a in Xb) Xb[a](void 0, !0);
    }), k.cors = !!l && "withCredentials" in l, (l = k.ajax = !!l) && m.ajaxTransport(function(a) {
        var b;
        if (!a.crossDomain || k.cors) return {
            send: function(c, d) {
                var e, f = a.xhr(), g = ++Wb;
                if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
                for (e in a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), 
                a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest"), 
                c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                f.send(a.hasContent && a.data || null), b = function(c, e) {
                    var h, i, j;
                    if (b && (e || 4 === f.readyState)) if (delete Xb[g], b = void 0, 
                    f.onreadystatechange = m.noop, e) 4 !== f.readyState && f.abort(); else {
                        j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                        try {
                            i = f.statusText;
                        } catch (k) {
                            i = "";
                        }
                        h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
                    }
                    j && d(h, i, j, f.getAllResponseHeaders());
                }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Xb[g] = b : b();
            },
            abort: function() {
                b && b(void 0, !0);
            }
        };
    }), m.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(a) {
                return m.globalEval(a), a;
            }
        }
    }), m.ajaxPrefilter("script", function(a) {
        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", 
        a.global = !1);
    }), m.ajaxTransport("script", function(a) {
        var b, c;
        if (a.crossDomain) return c = y.head || m("head")[0] || y.documentElement, 
        {
            send: function(d, e) {
                (b = y.createElement("script")).async = !0, a.scriptCharset && (b.charset = a.scriptCharset), 
                b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
                    !c && b.readyState && !/loaded|complete/.test(b.readyState) || (b.onload = b.onreadystatechange = null, 
                    b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"));
                }, c.insertBefore(b, c.firstChild);
            },
            abort: function() {
                b && b.onload(void 0, !0);
            }
        };
    });
    var _b = [], ac = /(=)\?(?=&|$)|\?\?/, bc = (m.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var a = _b.pop() || m.expando + "_" + vb++;
            return this[a] = !0, a;
        }
    }), m.ajaxPrefilter("json jsonp", function(b, c, d) {
        var e, f, g, h = !1 !== b.jsonp && (ac.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ac.test(b.data) && "data");
        return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, 
        h ? b[h] = b[h].replace(ac, "$1" + e) : !1 !== b.jsonp && (b.url += (wb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), 
        b.converters["script json"] = function() {
            return g || m.error(e + " was not called"), g[0];
        }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
            g = arguments;
        }, d.always(function() {
            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _b.push(e)), g && m.isFunction(f) && f(g[0]), 
            g = f = void 0;
        }), "script") : void 0;
    }), m.parseHTML = function(a, b, c) {
        if (!a || "string" != typeof a) return null;
        "boolean" == typeof b && (c = b, b = !1), b = b || y;
        var d = u.exec(a), c = !c && [];
        return d ? [ b.createElement(d[1]) ] : (d = m.buildFragment([ a ], b, c), 
        c && c.length && m(c).remove(), m.merge([], d.childNodes));
    }, m.fn.load), cc = (m.fn.load = function(a, b, c) {
        var d, e, f, g, h;
        return "string" != typeof a && bc ? bc.apply(this, arguments) : (g = this, 
        0 <= (h = a.indexOf(" ")) && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), 
        m.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (f = "POST"), 
        0 < g.length && m.ajax({
            url: a,
            type: f,
            dataType: "html",
            data: b
        }).done(function(a) {
            e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a);
        }).complete(c && function(a, b) {
            g.each(c, e || [ a.responseText, b, a ]);
        }), this);
    }, m.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(a, b) {
        m.fn[b] = function(a) {
            return this.on(b, a);
        };
    }), m.expr.filters.animated = function(a) {
        return m.grep(m.timers, function(b) {
            return a === b.elem;
        }).length;
    }, a.document.documentElement);
    function dc(a) {
        return m.isWindow(a) ? a : 9 === a.nodeType && (a.defaultView || a.parentWindow);
    }
    m.offset = {
        setOffset: function(a, b, c) {
            var f, g, h, i, k = m.css(a, "position"), l = m(a), n = {};
            "static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"), 
            i = m.css(a, "left"), k = ("absolute" === k || "fixed" === k) && -1 < m.inArray("auto", [ f, i ]) ? (g = (k = l.position()).top, 
            k.left) : (g = parseFloat(f) || 0, parseFloat(i) || 0), null != (b = m.isFunction(b) ? b.call(a, c, h) : b).top && (n.top = b.top - h.top + g), 
            null != b.left && (n.left = b.left - h.left + k), "using" in b ? b.using.call(a, n) : l.css(n);
        }
    }, m.fn.extend({
        offset: function(a) {
            var b, d, e, f;
            return arguments.length ? void 0 === a ? this : this.each(function(b) {
                m.offset.setOffset(this, a, b);
            }) : (d = {
                top: 0,
                left: 0
            }, (f = (e = this[0]) && e.ownerDocument) ? (b = f.documentElement, 
            m.contains(b, e) ? (typeof e.getBoundingClientRect != K && (d = e.getBoundingClientRect()), 
            e = dc(f), {
                top: d.top + (e.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                left: d.left + (e.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
            }) : d) : void 0);
        },
        position: function() {
            var a, b, c, d;
            if (this[0]) return c = {
                top: 0,
                left: 0
            }, d = this[0], "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), 
            b = this.offset(), (c = m.nodeName(a[0], "html") ? c : a.offset()).top += m.css(a[0], "borderTopWidth", !0), 
            c.left += m.css(a[0], "borderLeftWidth", !0)), {
                top: b.top - c.top - m.css(d, "marginTop", !0),
                left: b.left - c.left - m.css(d, "marginLeft", !0)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                for (var a = this.offsetParent || cc; a && !m.nodeName(a, "html") && "static" === m.css(a, "position"); ) a = a.offsetParent;
                return a || cc;
            });
        }
    }), m.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(a, b) {
        var c = /Y/.test(b);
        m.fn[a] = function(d) {
            return V(this, function(a, d, e) {
                var f = dc(a);
                return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e);
            }, a, d, arguments.length, null);
        };
    }), m.each([ "top", "left" ], function(a, b) {
        m.cssHooks[b] = La(k.pixelPosition, function(a, c) {
            return c ? (c = Ja(a, b), Ha.test(c) ? m(a).position()[b] + "px" : c) : void 0;
        });
    }), m.each({
        Height: "height",
        Width: "width"
    }, function(a, b) {
        m.each({
            padding: "inner" + a,
            content: b,
            "": "outer" + a
        }, function(c, d) {
            m.fn[d] = function(d, e) {
                var f = arguments.length && (c || "boolean" != typeof d), g = c || (!0 === d || !0 === e ? "margin" : "border");
                return V(this, function(b, c, d) {
                    var e;
                    return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, 
                    Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g);
                }, b, f ? d : void 0, f, null);
            };
        });
    }), m.fn.size = function() {
        return this.length;
    }, m.fn.andSelf = m.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return m;
    });
    var ec = a.jQuery, fc = a.$;
    return m.noConflict = function(b) {
        return a.$ === m && (a.$ = fc), b && a.jQuery === m && (a.jQuery = ec), 
        m;
    }, typeof b == K && (a.jQuery = a.$ = m), m;
}), !function(e) {
    "function" == typeof define && define.amd ? define([ "jquery" ], e) : e(jQuery);
}(function(e) {
    function t(t, s) {
        var a, n, r = t.nodeName.toLowerCase();
        return "area" === r ? (a = (n = t.parentNode).name, !(!t.href || !a || "map" !== n.nodeName.toLowerCase()) && (!!(n = e("img[usemap='#" + a + "']")[0]) && i(n))) : (/^(input|select|textarea|button|object)$/.test(r) ? !t.disabled : "a" === r && t.href || s) && i(t);
    }
    function i(t) {
        return e.expr.filters.visible(t) && !e(t).parents().addBack().filter(function() {
            return "hidden" === e.css(this, "visibility");
        }).length;
    }
    e.ui = e.ui || {}, e.extend(e.ui, {
        version: "1.11.4",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), e.fn.extend({
        scrollParent: function(t) {
            var i = this.css("position"), s = "absolute" === i, n = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/, t = this.parents().filter(function() {
                var t = e(this);
                return (!s || "static" !== t.css("position")) && n.test(t.css("overflow") + t.css("overflow-y") + t.css("overflow-x"));
            }).eq(0);
            return "fixed" !== i && t.length ? t : e(this[0].ownerDocument || document);
        },
        uniqueId: function() {
            var e = 0;
            return function() {
                return this.each(function() {
                    this.id || (this.id = "ui-id-" + ++e);
                });
            };
        }(),
        removeUniqueId: function() {
            return this.each(function() {
                /^ui-id-\d+$/.test(this.id) && e(this).removeAttr("id");
            });
        }
    }), e.extend(e.expr[":"], {
        data: e.expr.createPseudo ? e.expr.createPseudo(function(t) {
            return function(i) {
                return !!e.data(i, t);
            };
        }) : function(t, i, s) {
            return !!e.data(t, s[3]);
        },
        focusable: function(i) {
            return t(i, !isNaN(e.attr(i, "tabindex")));
        },
        tabbable: function(i) {
            var s = e.attr(i, "tabindex"), n = isNaN(s);
            return (n || 0 <= s) && t(i, !n);
        }
    }), e("<a>").outerWidth(1).jquery || e.each([ "Width", "Height" ], function(t, i) {
        function s(t, i, s, a) {
            return e.each(n, function() {
                i -= parseFloat(e.css(t, "padding" + this)) || 0, s && (i -= parseFloat(e.css(t, "border" + this + "Width")) || 0), 
                a && (i -= parseFloat(e.css(t, "margin" + this)) || 0);
            }), i;
        }
        var n = "Width" === i ? [ "Left", "Right" ] : [ "Top", "Bottom" ], a = i.toLowerCase(), o = {
            innerWidth: e.fn.innerWidth,
            innerHeight: e.fn.innerHeight,
            outerWidth: e.fn.outerWidth,
            outerHeight: e.fn.outerHeight
        };
        e.fn["inner" + i] = function(t) {
            return void 0 === t ? o["inner" + i].call(this) : this.each(function() {
                e(this).css(a, s(this, t) + "px");
            });
        }, e.fn["outer" + i] = function(t, n) {
            return "number" != typeof t ? o["outer" + i].call(this, t) : this.each(function() {
                e(this).css(a, s(this, t, !0, n) + "px");
            });
        };
    }), e.fn.addBack || (e.fn.addBack = function(e) {
        return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
    }), e("<a>").data("a-b", "a").removeData("a-b").data("a-b") && (e.fn.removeData = function(t) {
        return function(i) {
            return arguments.length ? t.call(this, e.camelCase(i)) : t.call(this);
        };
    }(e.fn.removeData)), e.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), 
    e.fn.extend({
        focus: function(t) {
            return function(i, s) {
                return "number" == typeof i ? this.each(function() {
                    var t = this;
                    setTimeout(function() {
                        e(t).focus(), s && s.call(t);
                    }, i);
                }) : t.apply(this, arguments);
            };
        }(e.fn.focus),
        disableSelection: function() {
            var e = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
            return function() {
                return this.bind(e + ".ui-disableSelection", function(e) {
                    e.preventDefault();
                });
            };
        }(),
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        },
        zIndex: function(t) {
            if (void 0 !== t) return this.css("zIndex", t);
            if (this.length) for (var i, n = e(this[0]); n.length && n[0] !== document; ) {
                if (("absolute" === (i = n.css("position")) || "relative" === i || "fixed" === i) && (i = parseInt(n.css("zIndex"), 10), 
                !isNaN(i) && 0 !== i)) return i;
                n = n.parent();
            }
            return 0;
        }
    }), e.ui.plugin = {
        add: function(t, i, s) {
            var n, a = e.ui[t].prototype;
            for (n in s) a.plugins[n] = a.plugins[n] || [], a.plugins[n].push([ i, s[n] ]);
        },
        call: function(e, t, i, s) {
            var n, a = e.plugins[t];
            if (a && (s || e.element[0].parentNode && 11 !== e.element[0].parentNode.nodeType)) for (n = 0; a.length > n; n++) e.options[a[n][0]] && a[n][1].apply(e.element, i);
        }
    };
    var s = 0, n = Array.prototype.slice, a = (e.cleanData = function(t) {
        return function(i) {
            for (var s, n, a = 0; null != (n = i[a]); a++) try {
                (s = e._data(n, "events")) && s.remove && e(n).triggerHandler("remove");
            } catch (o) {}
            t(i);
        };
    }(e.cleanData), e.widget = function(t, i, s) {
        var n, a, o, r, h = {}, l = t.split(".")[0];
        return t = t.split(".")[1], n = l + "-" + t, s || (s = i, i = e.Widget), 
        e.expr[":"][n.toLowerCase()] = function(t) {
            return !!e.data(t, n);
        }, e[l] = e[l] || {}, a = e[l][t], o = e[l][t] = function(e, t) {
            return this._createWidget ? void (arguments.length && this._createWidget(e, t)) : new o(e, t);
        }, e.extend(o, a, {
            version: s.version,
            _proto: e.extend({}, s),
            _childConstructors: []
        }), (r = new i()).options = e.widget.extend({}, r.options), e.each(s, function(t, s) {
            return e.isFunction(s) ? void (h[t] = function() {
                function e() {
                    return i.prototype[t].apply(this, arguments);
                }
                function n(e) {
                    return i.prototype[t].apply(this, e);
                }
                return function() {
                    var t, i = this._super, a = this._superApply;
                    return this._super = e, this._superApply = n, t = s.apply(this, arguments), 
                    this._super = i, this._superApply = a, t;
                };
            }()) : void (h[t] = s);
        }), o.prototype = e.widget.extend(r, {
            widgetEventPrefix: a && r.widgetEventPrefix || t
        }, h, {
            constructor: o,
            namespace: l,
            widgetName: t,
            widgetFullName: n
        }), a ? (e.each(a._childConstructors, function(t, i) {
            var s = i.prototype;
            e.widget(s.namespace + "." + s.widgetName, o, i._proto);
        }), delete a._childConstructors) : i._childConstructors.push(o), e.widget.bridge(t, o), 
        o;
    }, e.widget.extend = function(t) {
        for (var i, s, a = n.call(arguments, 1), o = 0, r = a.length; o < r; o++) for (i in a[o]) s = a[o][i], 
        a[o].hasOwnProperty(i) && void 0 !== s && (t[i] = e.isPlainObject(s) ? e.isPlainObject(t[i]) ? e.widget.extend({}, t[i], s) : e.widget.extend({}, s) : s);
        return t;
    }, e.widget.bridge = function(t, i) {
        var s = i.prototype.widgetFullName || t;
        e.fn[t] = function(a) {
            var o = "string" == typeof a, r = n.call(arguments, 1), h = this;
            return o ? this.each(function() {
                var i, n = e.data(this, s);
                return "instance" === a ? (h = n, !1) : n ? e.isFunction(n[a]) && "_" !== a.charAt(0) ? (i = n[a].apply(n, r)) !== n && void 0 !== i ? (h = i && i.jquery ? h.pushStack(i.get()) : i, 
                !1) : void 0 : e.error("no such method '" + a + "' for " + t + " widget instance") : e.error("cannot call methods on " + t + " prior to initialization; attempted to call method '" + a + "'");
            }) : (r.length && (a = e.widget.extend.apply(null, [ a ].concat(r))), 
            this.each(function() {
                var t = e.data(this, s);
                t ? (t.option(a || {}), t._init && t._init()) : e.data(this, s, new i(a, this));
            })), h;
        };
    }, e.Widget = function() {}, e.Widget._childConstructors = [], e.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: !1,
            create: null
        },
        _createWidget: function(t, i) {
            i = e(i || this.defaultElement || this)[0], this.element = e(i), this.uuid = s++, 
            this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = e(), 
            this.hoverable = e(), this.focusable = e(), i !== this && (e.data(i, this.widgetFullName, this), 
            this._on(!0, this.element, {
                remove: function(e) {
                    e.target === i && this.destroy();
                }
            }), this.document = e(i.style ? i.ownerDocument : i.document || i), 
            this.window = e(this.document[0].defaultView || this.document[0].parentWindow)), 
            this.options = e.widget.extend({}, this.options, this._getCreateOptions(), t), 
            this._create(), this._trigger("create", null, this._getCreateEventData()), 
            this._init();
        },
        _getCreateOptions: e.noop,
        _getCreateEventData: e.noop,
        _create: e.noop,
        _init: e.noop,
        destroy: function() {
            this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)), 
            this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"), 
            this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), 
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: e.noop,
        widget: function() {
            return this.element;
        },
        option: function(t, i) {
            var s, n, a, o = t;
            if (0 === arguments.length) return e.widget.extend({}, this.options);
            if ("string" == typeof t) if (o = {}, t = (s = t.split(".")).shift(), 
            s.length) {
                for (n = o[t] = e.widget.extend({}, this.options[t]), a = 0; s.length - 1 > a; a++) n[s[a]] = n[s[a]] || {}, 
                n = n[s[a]];
                if (t = s.pop(), 1 === arguments.length) return void 0 === n[t] ? null : n[t];
                n[t] = i;
            } else {
                if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
                o[t] = i;
            }
            return this._setOptions(o), this;
        },
        _setOptions: function(e) {
            for (var t in e) this._setOption(t, e[t]);
            return this;
        },
        _setOption: function(e, t) {
            return this.options[e] = t, "disabled" === e && (this.widget().toggleClass(this.widgetFullName + "-disabled", !!t), 
            t && (this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus"))), 
            this;
        },
        enable: function() {
            return this._setOptions({
                disabled: !1
            });
        },
        disable: function() {
            return this._setOptions({
                disabled: !0
            });
        },
        _on: function(t, i, s) {
            var n, a = this;
            "boolean" != typeof t && (s = i, i = t, t = !1), s ? (i = n = e(i), 
            this.bindings = this.bindings.add(i)) : (s = i, i = this.element, n = this.widget()), 
            e.each(s, function(s, o) {
                function r() {
                    return t || !0 !== a.options.disabled && !e(this).hasClass("ui-state-disabled") ? ("string" == typeof o ? a[o] : o).apply(a, arguments) : void 0;
                }
                "string" != typeof o && (r.guid = o.guid = o.guid || r.guid || e.guid++);
                var s = s.match(/^([\w:-]*)\s*(.*)$/), l = s[1] + a.eventNamespace, s = s[2];
                s ? n.delegate(s, l, r) : i.bind(l, r);
            });
        },
        _off: function(t, i) {
            i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, 
            t.unbind(i).undelegate(i), this.bindings = e(this.bindings.not(t).get()), 
            this.focusable = e(this.focusable.not(t).get()), this.hoverable = e(this.hoverable.not(t).get());
        },
        _delay: function(e, t) {
            var s = this;
            return setTimeout(function() {
                return ("string" == typeof e ? s[e] : e).apply(s, arguments);
            }, t || 0);
        },
        _hoverable: function(t) {
            this.hoverable = this.hoverable.add(t), this._on(t, {
                mouseenter: function(t) {
                    e(t.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(t) {
                    e(t.currentTarget).removeClass("ui-state-hover");
                }
            });
        },
        _focusable: function(t) {
            this.focusable = this.focusable.add(t), this._on(t, {
                focusin: function(t) {
                    e(t.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(t) {
                    e(t.currentTarget).removeClass("ui-state-focus");
                }
            });
        },
        _trigger: function(t, i, s) {
            var n, a, o = this.options[t];
            if (s = s || {}, (i = e.Event(i)).type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), 
            i.target = this.element[0], a = i.originalEvent) for (n in a) n in i || (i[n] = a[n]);
            return this.element.trigger(i, s), !(e.isFunction(o) && !1 === o.apply(this.element[0], [ i ].concat(s)) || i.isDefaultPrevented());
        }
    }, e.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(t, i) {
        e.Widget.prototype["_" + t] = function(s, n, a) {
            var r = (n = "string" == typeof n ? {
                effect: n
            } : n) ? !0 !== n && "number" != typeof n && n.effect || i : t, o = !e.isEmptyObject(n = "number" == typeof (n = n || {}) ? {
                duration: n
            } : n);
            n.complete = a, n.delay && s.delay(n.delay), o && e.effects && e.effects.effect[r] ? s[t](n) : r !== t && s[r] ? s[r](n.duration, n.easing, a) : s.queue(function(i) {
                e(this)[t](), a && a.call(s[0]), i();
            });
        };
    }), e.widget, !1);
    e(document).mouseup(function() {
        a = !1;
    }), e.widget("ui.mouse", {
        version: "1.11.4",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var t = this;
            this.element.bind("mousedown." + this.widgetName, function(e) {
                return t._mouseDown(e);
            }).bind("click." + this.widgetName, function(i) {
                return !0 === e.data(i.target, t.widgetName + ".preventClickEvent") ? (e.removeData(i.target, t.widgetName + ".preventClickEvent"), 
                i.stopImmediatePropagation(), !1) : void 0;
            }), this.started = !1;
        },
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
        },
        _mouseDown: function(t) {
            var i, s, n;
            if (!a) return this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), 
            s = 1 === (this._mouseDownEvent = t).which, n = !("string" != typeof (i = this).options.cancel || !t.target.nodeName) && e(t.target).closest(this.options.cancel).length, 
            s && !n && this._mouseCapture(t) && (this.mouseDelayMet = !this.options.delay, 
            this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function() {
                i.mouseDelayMet = !0;
            }, this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(t), 
            !this._mouseStarted) ? t.preventDefault() : (!0 === e.data(t.target, this.widgetName + ".preventClickEvent") && e.removeData(t.target, this.widgetName + ".preventClickEvent"), 
            this._mouseMoveDelegate = function(e) {
                return i._mouseMove(e);
            }, this._mouseUpDelegate = function(e) {
                return i._mouseUp(e);
            }, this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), 
            t.preventDefault(), a = !0)), !0;
        },
        _mouseMove: function(t) {
            if (this._mouseMoved) {
                if (e.ui.ie && (!document.documentMode || document.documentMode < 9) && !t.button) return this._mouseUp(t);
                if (!t.which) return this._mouseUp(t);
            }
            return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t), 
            t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, t), 
            this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted);
        },
        _mouseUp: function(t) {
            return this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), 
            this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && e.data(t.target, this.widgetName + ".preventClickEvent", !0), 
            this._mouseStop(t)), a = !1;
        },
        _mouseDistanceMet: function(e) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return !0;
        }
    }), e.widget("ui.draggable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "drag",
        options: {
            addClasses: !0,
            appendTo: "parent",
            axis: !1,
            connectToSortable: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            iframeFix: !1,
            opacity: !1,
            refreshPositions: !1,
            revert: !1,
            revertDuration: 500,
            scope: "default",
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: !1,
            snapMode: "both",
            snapTolerance: 20,
            stack: !1,
            zIndex: !1,
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
            "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this.element.addClass("ui-draggable"), 
            this.options.disabled && this.element.addClass("ui-draggable-disabled"), 
            this._setHandleClassName(), this._mouseInit();
        },
        _setOption: function(e, t) {
            this._super(e, t), "handle" === e && (this._removeHandleClassName(), 
            this._setHandleClassName());
        },
        _destroy: function() {
            return (this.helper || this.element).is(".ui-draggable-dragging") ? void (this.destroyOnClear = !0) : (this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"), 
            this._removeHandleClassName(), void this._mouseDestroy());
        },
        _mouseCapture: function(t) {
            var i = this.options;
            return this._blurActiveElement(t), !(this.helper || i.disabled || 0 < e(t.target).closest(".ui-resizable-handle").length) && (this.handle = this._getHandle(t), 
            !!this.handle && (this._blockFrames(!0 === i.iframeFix ? "iframe" : i.iframeFix), 
            !0));
        },
        _blockFrames: function(t) {
            this.iframeBlocks = this.document.find(t).map(function() {
                var t = e(this);
                return e("<div>").css("position", "absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0];
            });
        },
        _unblockFrames: function() {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
        },
        _blurActiveElement: function(t) {
            var i = this.document[0];
            if (this.handleElement.is(t.target)) try {
                i.activeElement && "body" !== i.activeElement.nodeName.toLowerCase() && e(i.activeElement).blur();
            } catch (s) {}
        },
        _mouseStart: function(t) {
            var i = this.options;
            return this.helper = this._createHelper(t), this.helper.addClass("ui-draggable-dragging"), 
            this._cacheHelperProportions(), e.ui.ddmanager && (e.ui.ddmanager.current = this), 
            this._cacheMargins(), this.cssPosition = this.helper.css("position"), 
            this.scrollParent = this.helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(), 
            this.hasFixedAncestor = 0 < this.helper.parents().filter(function() {
                return "fixed" === e(this).css("position");
            }).length, this.positionAbs = this.element.offset(), this._refreshOffsets(t), 
            this.originalPosition = this.position = this._generatePosition(t, !1), 
            this.originalPageX = t.pageX, this.originalPageY = t.pageY, i.cursorAt && this._adjustOffsetFromHelper(i.cursorAt), 
            this._setContainment(), !1 === this._trigger("start", t) ? (this._clear(), 
            !1) : (this._cacheHelperProportions(), e.ui.ddmanager && !i.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), 
            this._normalizeRightBottom(), this._mouseDrag(t, !0), e.ui.ddmanager && e.ui.ddmanager.dragStart(this, t), 
            !0);
        },
        _refreshOffsets: function(e) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: !1,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }, this.offset.click = {
                left: e.pageX - this.offset.left,
                top: e.pageY - this.offset.top
            };
        },
        _mouseDrag: function(t, i) {
            if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), 
            this.position = this._generatePosition(t, !0), this.positionAbs = this._convertPositionTo("absolute"), 
            !i) {
                i = this._uiHash();
                if (!1 === this._trigger("drag", t, i)) return this._mouseUp({}), 
                !1;
                this.position = i.position;
            }
            return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", 
            e.ui.ddmanager && e.ui.ddmanager.drag(this, t), !1;
        },
        _mouseStop: function(t) {
            var i = this, s = !1;
            return e.ui.ddmanager && !this.options.dropBehaviour && (s = e.ui.ddmanager.drop(this, t)), 
            this.dropped && (s = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !s || "valid" === this.options.revert && s || !0 === this.options.revert || e.isFunction(this.options.revert) && this.options.revert.call(this.element, s) ? e(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                !1 !== i._trigger("stop", t) && i._clear();
            }) : !1 !== this._trigger("stop", t) && this._clear(), !1;
        },
        _mouseUp: function(t) {
            return this._unblockFrames(), e.ui.ddmanager && e.ui.ddmanager.dragStop(this, t), 
            this.handleElement.is(t.target) && this.element.focus(), e.ui.mouse.prototype._mouseUp.call(this, t);
        },
        cancel: function() {
            return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(), 
            this;
        },
        _getHandle: function(t) {
            return !this.options.handle || !!e(t.target).closest(this.element.find(this.options.handle)).length;
        },
        _setHandleClassName: function() {
            this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, 
            this.handleElement.addClass("ui-draggable-handle");
        },
        _removeHandleClassName: function() {
            this.handleElement.removeClass("ui-draggable-handle");
        },
        _createHelper: function(t) {
            var i = this.options, s = e.isFunction(i.helper), t = s ? e(i.helper.apply(this.element[0], [ t ])) : "clone" === i.helper ? this.element.clone().removeAttr("id") : this.element;
            return t.parents("body").length || t.appendTo("parent" === i.appendTo ? this.element[0].parentNode : i.appendTo), 
            s && t[0] === this.element[0] && this._setPositionRelative(), t[0] === this.element[0] || /(fixed|absolute)/.test(t.css("position")) || t.css("position", "absolute"), 
            t;
        },
        _setPositionRelative: function() {
            /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative");
        },
        _adjustOffsetFromHelper: function(t) {
            "string" == typeof t && (t = t.split(" ")), "left" in (t = e.isArray(t) ? {
                left: +t[0],
                top: +t[1] || 0
            } : t) && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), 
            "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top);
        },
        _isRootNode: function(e) {
            return /(html|body)/i.test(e.tagName) || e === this.document[0];
        },
        _getParentOffset: function() {
            var t = this.offsetParent.offset(), i = this.document[0];
            return "absolute" === this.cssPosition && this.scrollParent[0] !== i && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), 
            t.top += this.scrollParent.scrollTop()), {
                top: (t = this._isRootNode(this.offsetParent[0]) ? {
                    top: 0,
                    left: 0
                } : t).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            var e, t;
            return "relative" !== this.cssPosition ? {
                top: 0,
                left: 0
            } : (e = this.element.position(), t = this._isRootNode(this.scrollParent[0]), 
            {
                top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + (t ? 0 : this.scrollParent.scrollTop()),
                left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + (t ? 0 : this.scrollParent.scrollLeft())
            });
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var t, n = this.options, a = this.document[0];
            return this.relativeContainer = null, n.containment ? "window" === n.containment ? void (this.containment = [ e(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, e(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, e(window).scrollLeft() + e(window).width() - this.helperProportions.width - this.margins.left, e(window).scrollTop() + (e(window).height() || a.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]) : "document" === n.containment ? void (this.containment = [ 0, 0, e(a).width() - this.helperProportions.width - this.margins.left, (e(a).height() || a.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]) : n.containment.constructor === Array ? void (this.containment = n.containment) : ("parent" === n.containment && (n.containment = this.helper[0].parentNode), 
            void ((n = (a = e(n.containment))[0]) && (t = /(scroll|auto)/.test(a.css("overflow")), 
            this.containment = [ (parseInt(a.css("borderLeftWidth"), 10) || 0) + (parseInt(a.css("paddingLeft"), 10) || 0), (parseInt(a.css("borderTopWidth"), 10) || 0) + (parseInt(a.css("paddingTop"), 10) || 0), (t ? Math.max(n.scrollWidth, n.offsetWidth) : n.offsetWidth) - (parseInt(a.css("borderRightWidth"), 10) || 0) - (parseInt(a.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (t ? Math.max(n.scrollHeight, n.offsetHeight) : n.offsetHeight) - (parseInt(a.css("borderBottomWidth"), 10) || 0) - (parseInt(a.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ], 
            this.relativeContainer = a))) : void (this.containment = null);
        },
        _convertPositionTo: function(e, t) {
            t = t || this.position;
            var e = "absolute" === e ? 1 : -1, s = this._isRootNode(this.scrollParent[0]);
            return {
                top: t.top + this.offset.relative.top * e + this.offset.parent.top * e - ("fixed" === this.cssPosition ? -this.offset.scroll.top : s ? 0 : this.offset.scroll.top) * e,
                left: t.left + this.offset.relative.left * e + this.offset.parent.left * e - ("fixed" === this.cssPosition ? -this.offset.scroll.left : s ? 0 : this.offset.scroll.left) * e
            };
        },
        _generatePosition: function(e, t) {
            var i, o = this.options, r = this._isRootNode(this.scrollParent[0]), h = e.pageX, l = e.pageY;
            return r && this.offset.scroll || (this.offset.scroll = {
                top: this.scrollParent.scrollTop(),
                left: this.scrollParent.scrollLeft()
            }), t && (this.containment && (i = this.relativeContainer ? (t = this.relativeContainer.offset(), 
            [ this.containment[0] + t.left, this.containment[1] + t.top, this.containment[2] + t.left, this.containment[3] + t.top ]) : this.containment, 
            e.pageX - this.offset.click.left < i[0] && (h = i[0] + this.offset.click.left), 
            e.pageY - this.offset.click.top < i[1] && (l = i[1] + this.offset.click.top), 
            e.pageX - this.offset.click.left > i[2] && (h = i[2] + this.offset.click.left), 
            e.pageY - this.offset.click.top > i[3] && (l = i[3] + this.offset.click.top)), 
            o.grid && (t = o.grid[1] ? this.originalPageY + Math.round((l - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY, 
            l = !i || t - this.offset.click.top >= i[1] || t - this.offset.click.top > i[3] ? t : t - this.offset.click.top >= i[1] ? t - o.grid[1] : t + o.grid[1], 
            e = o.grid[0] ? this.originalPageX + Math.round((h - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX, 
            h = !i || e - this.offset.click.left >= i[0] || e - this.offset.click.left > i[2] ? e : e - this.offset.click.left >= i[0] ? e - o.grid[0] : e + o.grid[0]), 
            "y" === o.axis && (h = this.originalPageX), "x" === o.axis && (l = this.originalPageY)), 
            {
                top: l - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : r ? 0 : this.offset.scroll.top),
                left: h - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : r ? 0 : this.offset.scroll.left)
            };
        },
        _clear: function() {
            this.helper.removeClass("ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), 
            this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy();
        },
        _normalizeRightBottom: function() {
            "y" !== this.options.axis && "auto" !== this.helper.css("right") && (this.helper.width(this.helper.width()), 
            this.helper.css("right", "auto")), "x" !== this.options.axis && "auto" !== this.helper.css("bottom") && (this.helper.height(this.helper.height()), 
            this.helper.css("bottom", "auto"));
        },
        _trigger: function(t, i, s) {
            return s = s || this._uiHash(), e.ui.plugin.call(this, t, [ i, s, this ], !0), 
            /^(drag|start|stop)/.test(t) && (this.positionAbs = this._convertPositionTo("absolute"), 
            s.offset = this.positionAbs), e.Widget.prototype._trigger.call(this, t, i, s);
        },
        plugins: {},
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }
    }), e.ui.plugin.add("draggable", "connectToSortable", {
        start: function(t, i, s) {
            var n = e.extend({}, i, {
                item: s.element
            });
            s.sortables = [], e(s.options.connectToSortable).each(function() {
                var i = e(this).sortable("instance");
                i && !i.options.disabled && (s.sortables.push(i), i.refreshPositions(), 
                i._trigger("activate", t, n));
            });
        },
        stop: function(t, i, s) {
            var n = e.extend({}, i, {
                item: s.element
            });
            s.cancelHelperRemoval = !1, e.each(s.sortables, function() {
                var e = this;
                e.isOver ? (e.isOver = 0, s.cancelHelperRemoval = !0, e.cancelHelperRemoval = !1, 
                e._storedCSS = {
                    position: e.placeholder.css("position"),
                    top: e.placeholder.css("top"),
                    left: e.placeholder.css("left")
                }, e._mouseStop(t), e.options.helper = e.options._helper) : (e.cancelHelperRemoval = !0, 
                e._trigger("deactivate", t, n));
            });
        },
        drag: function(t, i, s) {
            e.each(s.sortables, function() {
                var n = !1, a = this;
                a.positionAbs = s.positionAbs, a.helperProportions = s.helperProportions, 
                a.offset.click = s.offset.click, a._intersectsWith(a.containerCache) && (n = !0, 
                e.each(s.sortables, function() {
                    return this.positionAbs = s.positionAbs, this.helperProportions = s.helperProportions, 
                    this.offset.click = s.offset.click, n = this !== a && this._intersectsWith(this.containerCache) && e.contains(a.element[0], this.element[0]) ? !1 : n;
                })), n ? (a.isOver || (a.isOver = 1, s._parent = i.helper.parent(), 
                a.currentItem = i.helper.appendTo(a.element).data("ui-sortable-item", !0), 
                a.options._helper = a.options.helper, a.options.helper = function() {
                    return i.helper[0];
                }, t.target = a.currentItem[0], a._mouseCapture(t, !0), a._mouseStart(t, !0, !0), 
                a.offset.click.top = s.offset.click.top, a.offset.click.left = s.offset.click.left, 
                a.offset.parent.left -= s.offset.parent.left - a.offset.parent.left, 
                a.offset.parent.top -= s.offset.parent.top - a.offset.parent.top, 
                s._trigger("toSortable", t), s.dropped = a.element, e.each(s.sortables, function() {
                    this.refreshPositions();
                }), s.currentItem = s.element, a.fromOutside = s), a.currentItem && (a._mouseDrag(t), 
                i.position = a.position)) : a.isOver && (a.isOver = 0, a.cancelHelperRemoval = !0, 
                a.options._revert = a.options.revert, a.options.revert = !1, a._trigger("out", t, a._uiHash(a)), 
                a._mouseStop(t, !0), a.options.revert = a.options._revert, a.options.helper = a.options._helper, 
                a.placeholder && a.placeholder.remove(), i.helper.appendTo(s._parent), 
                s._refreshOffsets(t), i.position = s._generatePosition(t, !0), s._trigger("fromSortable", t), 
                s.dropped = !1, e.each(s.sortables, function() {
                    this.refreshPositions();
                }));
            });
        }
    }), e.ui.plugin.add("draggable", "cursor", {
        start: function(t, i, s) {
            var n = e("body"), s = s.options;
            n.css("cursor") && (s._cursor = n.css("cursor")), n.css("cursor", s.cursor);
        },
        stop: function(t, i, s) {
            s = s.options;
            s._cursor && e("body").css("cursor", s._cursor);
        }
    }), e.ui.plugin.add("draggable", "opacity", {
        start: function(t, i, s) {
            i = e(i.helper), s = s.options;
            i.css("opacity") && (s._opacity = i.css("opacity")), i.css("opacity", s.opacity);
        },
        stop: function(t, i, s) {
            s = s.options;
            s._opacity && e(i.helper).css("opacity", s._opacity);
        }
    }), e.ui.plugin.add("draggable", "scroll", {
        start: function(e, t, i) {
            i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), 
            i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset());
        },
        drag: function(t, i, s) {
            var n = s.options, a = !1, o = s.scrollParentNotHidden[0], r = s.document[0];
            o !== r && "HTML" !== o.tagName ? (n.axis && "x" === n.axis || (s.overflowOffset.top + o.offsetHeight - t.pageY < n.scrollSensitivity ? o.scrollTop = a = o.scrollTop + n.scrollSpeed : t.pageY - s.overflowOffset.top < n.scrollSensitivity && (o.scrollTop = a = o.scrollTop - n.scrollSpeed)), 
            n.axis && "y" === n.axis || (s.overflowOffset.left + o.offsetWidth - t.pageX < n.scrollSensitivity ? o.scrollLeft = a = o.scrollLeft + n.scrollSpeed : t.pageX - s.overflowOffset.left < n.scrollSensitivity && (o.scrollLeft = a = o.scrollLeft - n.scrollSpeed))) : (n.axis && "x" === n.axis || (t.pageY - e(r).scrollTop() < n.scrollSensitivity ? a = e(r).scrollTop(e(r).scrollTop() - n.scrollSpeed) : e(window).height() - (t.pageY - e(r).scrollTop()) < n.scrollSensitivity && (a = e(r).scrollTop(e(r).scrollTop() + n.scrollSpeed))), 
            n.axis && "y" === n.axis || (t.pageX - e(r).scrollLeft() < n.scrollSensitivity ? a = e(r).scrollLeft(e(r).scrollLeft() - n.scrollSpeed) : e(window).width() - (t.pageX - e(r).scrollLeft()) < n.scrollSensitivity && (a = e(r).scrollLeft(e(r).scrollLeft() + n.scrollSpeed)))), 
            !1 !== a && e.ui.ddmanager && !n.dropBehaviour && e.ui.ddmanager.prepareOffsets(s, t);
        }
    }), e.ui.plugin.add("draggable", "snap", {
        start: function(t, i, s) {
            var n = s.options;
            s.snapElements = [], e(n.snap.constructor !== String ? n.snap.items || ":data(ui-draggable)" : n.snap).each(function() {
                var t = e(this), i = t.offset();
                this !== s.element[0] && s.snapElements.push({
                    item: this,
                    width: t.outerWidth(),
                    height: t.outerHeight(),
                    top: i.top,
                    left: i.left
                });
            });
        },
        drag: function(t, i, s) {
            for (var n, a, o, r, h, l, u, d, p, f = s.options, m = f.snapTolerance, g = i.offset.left, v = g + s.helperProportions.width, y = i.offset.top, b = y + s.helperProportions.height, c = s.snapElements.length - 1; 0 <= c; c--) l = (h = s.snapElements[c].left - s.margins.left) + s.snapElements[c].width, 
            d = (u = s.snapElements[c].top - s.margins.top) + s.snapElements[c].height, 
            v < h - m || l + m < g || b < u - m || d + m < y || !e.contains(s.snapElements[c].item.ownerDocument, s.snapElements[c].item) ? (s.snapElements[c].snapping && s.options.snap.release && s.options.snap.release.call(s.element, t, e.extend(s._uiHash(), {
                snapItem: s.snapElements[c].item
            })), s.snapElements[c].snapping = !1) : ("inner" !== f.snapMode && (n = m >= Math.abs(u - b), 
            a = m >= Math.abs(d - y), o = m >= Math.abs(h - v), r = m >= Math.abs(l - g), 
            n && (i.position.top = s._convertPositionTo("relative", {
                top: u - s.helperProportions.height,
                left: 0
            }).top), a && (i.position.top = s._convertPositionTo("relative", {
                top: d,
                left: 0
            }).top), o && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: h - s.helperProportions.width
            }).left), r && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: l
            }).left)), p = n || a || o || r, "outer" !== f.snapMode && (n = m >= Math.abs(u - y), 
            a = m >= Math.abs(d - b), o = m >= Math.abs(h - g), r = m >= Math.abs(l - v), 
            n && (i.position.top = s._convertPositionTo("relative", {
                top: u,
                left: 0
            }).top), a && (i.position.top = s._convertPositionTo("relative", {
                top: d - s.helperProportions.height,
                left: 0
            }).top), o && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: h
            }).left), r && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: l - s.helperProportions.width
            }).left)), !s.snapElements[c].snapping && (n || a || o || r || p) && s.options.snap.snap && s.options.snap.snap.call(s.element, t, e.extend(s._uiHash(), {
                snapItem: s.snapElements[c].item
            })), s.snapElements[c].snapping = n || a || o || r || p);
        }
    }), e.ui.plugin.add("draggable", "stack", {
        start: function(t, i, s) {
            var n, s = s.options, s = e.makeArray(e(s.stack)).sort(function(t, i) {
                return (parseInt(e(t).css("zIndex"), 10) || 0) - (parseInt(e(i).css("zIndex"), 10) || 0);
            });
            s.length && (n = parseInt(e(s[0]).css("zIndex"), 10) || 0, e(s).each(function(t) {
                e(this).css("zIndex", n + t);
            }), this.css("zIndex", n + s.length));
        }
    }), e.ui.plugin.add("draggable", "zIndex", {
        start: function(t, i, s) {
            i = e(i.helper), s = s.options;
            i.css("zIndex") && (s._zIndex = i.css("zIndex")), i.css("zIndex", s.zIndex);
        },
        stop: function(t, i, s) {
            s = s.options;
            s._zIndex && e(i.helper).css("zIndex", s._zIndex);
        }
    }), e.ui.draggable, e.widget("ui.droppable", {
        version: "1.11.4",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: !1,
            addClasses: !0,
            greedy: !1,
            hoverClass: !1,
            scope: "default",
            tolerance: "intersect",
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
            var t, i = this.options, s = i.accept;
            this.isover = !1, this.isout = !0, this.accept = e.isFunction(s) ? s : function(e) {
                return e.is(s);
            }, this.proportions = function() {
                return arguments.length ? void (t = arguments[0]) : t = t || {
                    width: this.element[0].offsetWidth,
                    height: this.element[0].offsetHeight
                };
            }, this._addToManager(i.scope), i.addClasses && this.element.addClass("ui-droppable");
        },
        _addToManager: function(t) {
            e.ui.ddmanager.droppables[t] = e.ui.ddmanager.droppables[t] || [], e.ui.ddmanager.droppables[t].push(this);
        },
        _splice: function(e) {
            for (var t = 0; e.length > t; t++) e[t] === this && e.splice(t, 1);
        },
        _destroy: function() {
            var t = e.ui.ddmanager.droppables[this.options.scope];
            this._splice(t), this.element.removeClass("ui-droppable ui-droppable-disabled");
        },
        _setOption: function(t, i) {
            var s;
            "accept" === t ? this.accept = e.isFunction(i) ? i : function(e) {
                return e.is(i);
            } : "scope" === t && (s = e.ui.ddmanager.droppables[this.options.scope], 
            this._splice(s), this._addToManager(i)), this._super(t, i);
        },
        _activate: function(t) {
            var i = e.ui.ddmanager.current;
            this.options.activeClass && this.element.addClass(this.options.activeClass), 
            i && this._trigger("activate", t, this.ui(i));
        },
        _deactivate: function(t) {
            var i = e.ui.ddmanager.current;
            this.options.activeClass && this.element.removeClass(this.options.activeClass), 
            i && this._trigger("deactivate", t, this.ui(i));
        },
        _over: function(t) {
            var i = e.ui.ddmanager.current;
            i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(this.element[0], i.currentItem || i.element) && (this.options.hoverClass && this.element.addClass(this.options.hoverClass), 
            this._trigger("over", t, this.ui(i)));
        },
        _out: function(t) {
            var i = e.ui.ddmanager.current;
            i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(this.element[0], i.currentItem || i.element) && (this.options.hoverClass && this.element.removeClass(this.options.hoverClass), 
            this._trigger("out", t, this.ui(i)));
        },
        _drop: function(t, i) {
            var s = i || e.ui.ddmanager.current, n = !1;
            return !(!s || (s.currentItem || s.element)[0] === this.element[0]) && (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                var i = e(this).droppable("instance");
                return i.options.greedy && !i.options.disabled && i.options.scope === s.options.scope && i.accept.call(i.element[0], s.currentItem || s.element) && e.ui.intersect(s, e.extend(i, {
                    offset: i.element.offset()
                }), i.options.tolerance, t) ? !(n = !0) : void 0;
            }), !n && (!!this.accept.call(this.element[0], s.currentItem || s.element) && (this.options.activeClass && this.element.removeClass(this.options.activeClass), 
            this.options.hoverClass && this.element.removeClass(this.options.hoverClass), 
            this._trigger("drop", t, this.ui(s)), this.element)));
        },
        ui: function(e) {
            return {
                draggable: e.currentItem || e.element,
                helper: e.helper,
                position: e.position,
                offset: e.positionAbs
            };
        }
    }), e.ui.intersect = function() {
        function e(e, t, i) {
            return t <= e && e < t + i;
        }
        return function(t, i, s, n) {
            if (!i.offset) return !1;
            var a = (t.positionAbs || t.position.absolute).left + t.margins.left, o = (t.positionAbs || t.position.absolute).top + t.margins.top, r = a + t.helperProportions.width, h = o + t.helperProportions.height, l = i.offset.left, u = i.offset.top, d = l + i.proportions().width, c = u + i.proportions().height;
            switch (s) {
              case "fit":
                return l <= a && r <= d && u <= o && h <= c;

              case "intersect":
                return a + t.helperProportions.width / 2 > l && d > r - t.helperProportions.width / 2 && o + t.helperProportions.height / 2 > u && c > h - t.helperProportions.height / 2;

              case "pointer":
                return e(n.pageY, u, i.proportions().height) && e(n.pageX, l, i.proportions().width);

              case "touch":
                return (u <= o && o <= c || u <= h && h <= c || o < u && c < h) && (l <= a && a <= d || l <= r && r <= d || a < l && d < r);

              default:
                return !1;
            }
        };
    }(), e.ui.ddmanager = {
        current: null,
        droppables: {
            default: []
        },
        prepareOffsets: function(t, i) {
            var s, n, a = e.ui.ddmanager.droppables[t.options.scope] || [], o = i ? i.type : null, r = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            e: for (s = 0; a.length > s; s++) if (!(a[s].options.disabled || t && !a[s].accept.call(a[s].element[0], t.currentItem || t.element))) {
                for (n = 0; r.length > n; n++) if (r[n] === a[s].element[0]) {
                    a[s].proportions().height = 0;
                    continue e;
                }
                a[s].visible = "none" !== a[s].element.css("display"), a[s].visible && ("mousedown" === o && a[s]._activate.call(a[s], i), 
                a[s].offset = a[s].element.offset(), a[s].proportions({
                    width: a[s].element[0].offsetWidth,
                    height: a[s].element[0].offsetHeight
                }));
            }
        },
        drop: function(t, i) {
            var s = !1;
            return e.each((e.ui.ddmanager.droppables[t.options.scope] || []).slice(), function() {
                this.options && (!this.options.disabled && this.visible && e.ui.intersect(t, this, this.options.tolerance, i) && (s = this._drop.call(this, i) || s), 
                !this.options.disabled && this.visible && this.accept.call(this.element[0], t.currentItem || t.element) && (this.isout = !0, 
                this.isover = !1, this._deactivate.call(this, i)));
            }), s;
        },
        dragStart: function(t, i) {
            t.element.parentsUntil("body").bind("scroll.droppable", function() {
                t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, i);
            });
        },
        drag: function(t, i) {
            t.options.refreshPositions && e.ui.ddmanager.prepareOffsets(t, i), e.each(e.ui.ddmanager.droppables[t.options.scope] || [], function() {
                var s, n, a, o;
                this.options.disabled || this.greedyChild || !this.visible || (o = !(o = e.ui.intersect(t, this, this.options.tolerance, i)) && this.isover ? "isout" : o && !this.isover ? "isover" : null) && (this.options.greedy && (n = this.options.scope, 
                (a = this.element.parents(":data(ui-droppable)").filter(function() {
                    return e(this).droppable("instance").options.scope === n;
                })).length && ((s = e(a[0]).droppable("instance")).greedyChild = "isover" === o)), 
                s && "isover" === o && (s.isover = !1, s.isout = !0, s._out.call(s, i)), 
                this[o] = !0, this["isout" === o ? "isover" : "isout"] = !1, this["isover" === o ? "_over" : "_out"].call(this, i), 
                s && "isout" === o && (s.isout = !1, s.isover = !0, s._over.call(s, i)));
            });
        },
        dragStop: function(t, i) {
            t.element.parentsUntil("body").unbind("scroll.droppable"), t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, i);
        }
    }, e.ui.droppable, e.widget("ui.resizable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: !1,
            animate: !1,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: !1,
            autoHide: !1,
            containment: !1,
            ghost: !1,
            grid: !1,
            handles: "e,s,se",
            helper: !1,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 90,
            resize: null,
            start: null,
            stop: null
        },
        _num: function(e) {
            return parseInt(e, 10) || 0;
        },
        _isNumber: function(e) {
            return !isNaN(parseInt(e, 10));
        },
        _hasScroll: function(t, i) {
            var n;
            return "hidden" !== e(t).css("overflow") && (n = !1, 0 < t[i = i && "left" === i ? "scrollLeft" : "scrollTop"] || (t[i] = 1, 
            n = 0 < t[i], t[i] = 0, n));
        },
        _create: function() {
            var t, i, s, n, o = this, r = this.options;
            if (this.element.addClass("ui-resizable"), e.extend(this, {
                _aspectRatio: !!r.aspectRatio,
                aspectRatio: r.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: r.helper || r.ghost || r.animate ? r.helper || "ui-resizable-helper" : null
            }), this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(e("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                position: this.element.css("position"),
                width: this.element.outerWidth(),
                height: this.element.outerHeight(),
                top: this.element.css("top"),
                left: this.element.css("left")
            })), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")), 
            this.elementIsWrapper = !0, this.element.css({
                marginLeft: this.originalElement.css("marginLeft"),
                marginTop: this.originalElement.css("marginTop"),
                marginRight: this.originalElement.css("marginRight"),
                marginBottom: this.originalElement.css("marginBottom")
            }), this.originalElement.css({
                marginLeft: 0,
                marginTop: 0,
                marginRight: 0,
                marginBottom: 0
            }), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), 
            this._proportionallyResizeElements.push(this.originalElement.css({
                position: "static",
                zoom: 1,
                display: "block"
            })), this.originalElement.css({
                margin: this.originalElement.css("margin")
            }), this._proportionallyResize()), this.handles = r.handles || (e(".ui-resizable-handle", this.element).length ? {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            } : "e,s,se"), this._handles = e(), this.handles.constructor === String) for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), 
            t = this.handles.split(","), this.handles = {}, i = 0; t.length > i; i++) s = e.trim(t[i]), 
            (n = e("<div class='ui-resizable-handle " + ("ui-resizable-" + s) + "'></div>")).css({
                zIndex: r.zIndex
            }), "se" === s && n.addClass("ui-icon ui-icon-gripsmall-diagonal-se"), 
            this.handles[s] = ".ui-resizable-" + s, this.element.append(n);
            this._renderAxis = function(t) {
                var i, n, s;
                for (i in t = t || this.element, this.handles) this.handles[i].constructor === String ? this.handles[i] = this.element.children(this.handles[i]).first().show() : (this.handles[i].jquery || this.handles[i].nodeType) && (this.handles[i] = e(this.handles[i]), 
                this._on(this.handles[i], {
                    mousedown: o._mouseDown
                })), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (s = e(this.handles[i], this.element), 
                s = /sw|ne|nw|se|n|s/.test(i) ? s.outerHeight() : s.outerWidth(), 
                n = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join(""), 
                t.css(n, s), this._proportionallyResize()), this._handles = this._handles.add(this.handles[i]);
            }, this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")), 
            this._handles.disableSelection(), this._handles.mouseover(function() {
                o.resizing || (this.className && (n = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), 
                o.axis = n && n[1] ? n[1] : "se");
            }), r.autoHide && (this._handles.hide(), e(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
                r.disabled || (e(this).removeClass("ui-resizable-autohide"), o._handles.show());
            }).mouseleave(function() {
                r.disabled || o.resizing || (e(this).addClass("ui-resizable-autohide"), 
                o._handles.hide());
            })), this._mouseInit();
        },
        _destroy: function() {
            this._mouseDestroy();
            function i(t) {
                e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
            }
            var t;
            return this.elementIsWrapper && (i(this.element), t = this.element, 
            this.originalElement.css({
                position: t.css("position"),
                width: t.outerWidth(),
                height: t.outerHeight(),
                top: t.css("top"),
                left: t.css("left")
            }).insertAfter(t), t.remove()), this.originalElement.css("resize", this.originalResizeStyle), 
            i(this.originalElement), this;
        },
        _mouseCapture: function(t) {
            var i, s, n = !1;
            for (i in this.handles) s = e(this.handles[i])[0], s !== t.target && !e.contains(s, t.target) || (n = !0);
            return !this.options.disabled && n;
        },
        _mouseStart: function(t) {
            var s, i, a = this.options, o = this.element;
            return this.resizing = !0, this._renderProxy(), i = this._num(this.helper.css("left")), 
            s = this._num(this.helper.css("top")), a.containment && (i += e(a.containment).scrollLeft() || 0, 
            s += e(a.containment).scrollTop() || 0), this.offset = this.helper.offset(), 
            this.position = {
                left: i,
                top: s
            }, this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                width: o.width(),
                height: o.height()
            }, this.originalSize = this._helper ? {
                width: o.outerWidth(),
                height: o.outerHeight()
            } : {
                width: o.width(),
                height: o.height()
            }, this.sizeDiff = {
                width: o.outerWidth() - o.width(),
                height: o.outerHeight() - o.height()
            }, this.originalPosition = {
                left: i,
                top: s
            }, this.originalMousePosition = {
                left: t.pageX,
                top: t.pageY
            }, this.aspectRatio = "number" == typeof a.aspectRatio ? a.aspectRatio : this.originalSize.width / this.originalSize.height || 1, 
            i = e(".ui-resizable-" + this.axis).css("cursor"), e("body").css("cursor", "auto" === i ? this.axis + "-resize" : i), 
            o.addClass("ui-resizable-resizing"), this._propagate("start", t), !0;
        },
        _mouseDrag: function(t) {
            var n = this.originalMousePosition, a = this.axis, o = t.pageX - n.left || 0, n = t.pageY - n.top || 0, a = this._change[a];
            return this._updatePrevProperties(), a && (a = a.apply(this, [ t, o, n ]), 
            this._updateVirtualBoundaries(t.shiftKey), (this._aspectRatio || t.shiftKey) && (a = this._updateRatio(a, t)), 
            a = this._respectSize(a, t), this._updateCache(a), this._propagate("resize", t), 
            o = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), 
            e.isEmptyObject(o) || (this._updatePrevProperties(), this._trigger("resize", t, this.ui()), 
            this._applyChanges())), !1;
        },
        _mouseStop: function(t) {
            this.resizing = !1;
            var s, i, h, l = this.options, u = this;
            return this._helper && (i = (s = (i = this._proportionallyResizeElements).length && /textarea/i.test(i[0].nodeName)) && this._hasScroll(i[0], "left") ? 0 : u.sizeDiff.height, 
            s = s ? 0 : u.sizeDiff.width, s = {
                width: u.helper.width() - s,
                height: u.helper.height() - i
            }, i = parseInt(u.element.css("left"), 10) + (u.position.left - u.originalPosition.left) || null, 
            h = parseInt(u.element.css("top"), 10) + (u.position.top - u.originalPosition.top) || null, 
            l.animate || this.element.css(e.extend(s, {
                top: h,
                left: i
            })), u.helper.height(u.size.height), u.helper.width(u.size.width), this._helper && !l.animate && this._proportionallyResize()), 
            e("body").css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"), 
            this._propagate("stop", t), this._helper && this.helper.remove(), !1;
        },
        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            }, this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },
        _applyChanges: function() {
            var e = {};
            return this.position.top !== this.prevPosition.top && (e.top = this.position.top + "px"), 
            this.position.left !== this.prevPosition.left && (e.left = this.position.left + "px"), 
            this.size.width !== this.prevSize.width && (e.width = this.size.width + "px"), 
            this.size.height !== this.prevSize.height && (e.height = this.size.height + "px"), 
            this.helper.css(e), e;
        },
        _updateVirtualBoundaries: function(e) {
            var i, s, n, o = this.options, o = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : 1 / 0,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : 1 / 0
            };
            (this._aspectRatio || e) && (e = o.minHeight * this.aspectRatio, s = o.minWidth / this.aspectRatio, 
            i = o.maxHeight * this.aspectRatio, n = o.maxWidth / this.aspectRatio, 
            e > o.minWidth && (o.minWidth = e), s > o.minHeight && (o.minHeight = s), 
            o.maxWidth > i && (o.maxWidth = i), o.maxHeight > n && (o.maxHeight = n)), 
            this._vBoundaries = o;
        },
        _updateCache: function(e) {
            this.offset = this.helper.offset(), this._isNumber(e.left) && (this.position.left = e.left), 
            this._isNumber(e.top) && (this.position.top = e.top), this._isNumber(e.height) && (this.size.height = e.height), 
            this._isNumber(e.width) && (this.size.width = e.width);
        },
        _updateRatio: function(e) {
            var t = this.position, i = this.size, s = this.axis;
            return this._isNumber(e.height) ? e.width = e.height * this.aspectRatio : this._isNumber(e.width) && (e.height = e.width / this.aspectRatio), 
            "sw" === s && (e.left = t.left + (i.width - e.width), e.top = null), 
            "nw" === s && (e.top = t.top + (i.height - e.height), e.left = t.left + (i.width - e.width)), 
            e;
        },
        _respectSize: function(e) {
            var t = this._vBoundaries, i = this.axis, s = this._isNumber(e.width) && t.maxWidth && t.maxWidth < e.width, n = this._isNumber(e.height) && t.maxHeight && t.maxHeight < e.height, a = this._isNumber(e.width) && t.minWidth && t.minWidth > e.width, o = this._isNumber(e.height) && t.minHeight && t.minHeight > e.height, r = this.originalPosition.left + this.originalSize.width, h = this.position.top + this.size.height, l = /sw|nw|w/.test(i), i = /nw|ne|n/.test(i);
            return a && (e.width = t.minWidth), o && (e.height = t.minHeight), s && (e.width = t.maxWidth), 
            n && (e.height = t.maxHeight), a && l && (e.left = r - t.minWidth), 
            s && l && (e.left = r - t.maxWidth), o && i && (e.top = h - t.minHeight), 
            n && i && (e.top = h - t.maxHeight), e.width || e.height || e.left || !e.top ? e.width || e.height || e.top || !e.left || (e.left = null) : e.top = null, 
            e;
        },
        _getPaddingPlusBorderDimensions: function(e) {
            for (var t = 0, i = [], s = [ e.css("borderTopWidth"), e.css("borderRightWidth"), e.css("borderBottomWidth"), e.css("borderLeftWidth") ], n = [ e.css("paddingTop"), e.css("paddingRight"), e.css("paddingBottom"), e.css("paddingLeft") ]; t < 4; t++) i[t] = parseInt(s[t], 10) || 0, 
            i[t] += parseInt(n[t], 10) || 0;
            return {
                height: i[0] + i[2],
                width: i[1] + i[3]
            };
        },
        _proportionallyResize: function() {
            if (this._proportionallyResizeElements.length) for (var e, t = 0, i = this.helper || this.element; this._proportionallyResizeElements.length > t; t++) e = this._proportionallyResizeElements[t], 
            this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(e)), 
            e.css({
                height: i.height() - this.outerDimensions.height || 0,
                width: i.width() - this.outerDimensions.width || 0
            });
        },
        _renderProxy: function() {
            var t = this.element, i = this.options;
            this.elementOffset = t.offset(), this._helper ? (this.helper = this.helper || e("<div style='overflow:hidden;'></div>"), 
            this.helper.addClass(this._helper).css({
                width: this.element.outerWidth() - 1,
                height: this.element.outerHeight() - 1,
                position: "absolute",
                left: this.elementOffset.left + "px",
                top: this.elementOffset.top + "px",
                zIndex: ++i.zIndex
            }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element;
        },
        _change: {
            e: function(e, t) {
                return {
                    width: this.originalSize.width + t
                };
            },
            w: function(e, t) {
                var i = this.originalSize;
                return {
                    left: this.originalPosition.left + t,
                    width: i.width - t
                };
            },
            n: function(e, t, i) {
                var s = this.originalSize;
                return {
                    top: this.originalPosition.top + i,
                    height: s.height - i
                };
            },
            s: function(e, t, i) {
                return {
                    height: this.originalSize.height + i
                };
            },
            se: function(t, i, s) {
                return e.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ t, i, s ]));
            },
            sw: function(t, i, s) {
                return e.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ t, i, s ]));
            },
            ne: function(t, i, s) {
                return e.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ t, i, s ]));
            },
            nw: function(t, i, s) {
                return e.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ t, i, s ]));
            }
        },
        _propagate: function(t, i) {
            e.ui.plugin.call(this, t, [ i, this.ui() ]), "resize" !== t && this._trigger(t, i, this.ui());
        },
        plugins: {},
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }
    }), e.ui.plugin.add("resizable", "animate", {
        stop: function(t) {
            var i = e(this).resizable("instance"), s = i.options, n = i._proportionallyResizeElements, a = n.length && /textarea/i.test(n[0].nodeName), o = a && i._hasScroll(n[0], "left") ? 0 : i.sizeDiff.height, a = a ? 0 : i.sizeDiff.width, a = {
                width: i.size.width - a,
                height: i.size.height - o
            }, o = parseInt(i.element.css("left"), 10) + (i.position.left - i.originalPosition.left) || null, u = parseInt(i.element.css("top"), 10) + (i.position.top - i.originalPosition.top) || null;
            i.element.animate(e.extend(a, u && o ? {
                top: u,
                left: o
            } : {}), {
                duration: s.animateDuration,
                easing: s.animateEasing,
                step: function() {
                    var s = {
                        width: parseInt(i.element.css("width"), 10),
                        height: parseInt(i.element.css("height"), 10),
                        top: parseInt(i.element.css("top"), 10),
                        left: parseInt(i.element.css("left"), 10)
                    };
                    n && n.length && e(n[0]).css({
                        width: s.width,
                        height: s.height
                    }), i._updateCache(s), i._propagate("resize", t);
                }
            });
        }
    }), e.ui.plugin.add("resizable", "containment", {
        start: function() {
            var t, i, a, n, h = e(this).resizable("instance"), l = h.options, u = h.element, l = l.containment, u = l instanceof e ? l.get(0) : /parent/.test(l) ? u.parent().get(0) : l;
            u && (h.containerElement = e(u), /document/.test(l) || l === document ? (h.containerOffset = {
                left: 0,
                top: 0
            }, h.containerPosition = {
                left: 0,
                top: 0
            }, h.parentData = {
                element: e(document),
                left: 0,
                top: 0,
                width: e(document).width(),
                height: e(document).height() || document.body.parentNode.scrollHeight
            }) : (t = e(u), i = [], e([ "Top", "Right", "Left", "Bottom" ]).each(function(e, s) {
                i[e] = h._num(t.css("padding" + s));
            }), h.containerOffset = t.offset(), h.containerPosition = t.position(), 
            h.containerSize = {
                height: t.innerHeight() - i[3],
                width: t.innerWidth() - i[1]
            }, l = h.containerOffset, n = h.containerSize.height, a = h.containerSize.width, 
            a = h._hasScroll(u, "left") ? u.scrollWidth : a, n = h._hasScroll(u) ? u.scrollHeight : n, 
            h.parentData = {
                element: u,
                left: l.left,
                top: l.top,
                width: a,
                height: n
            }));
        },
        resize: function(t) {
            var o = e(this).resizable("instance"), r = o.options, h = o.containerOffset, l = o.position, t = o._aspectRatio || t.shiftKey, d = {
                top: 0,
                left: 0
            }, c = o.containerElement, p = !0;
            c[0] !== document && /static/.test(c.css("position")) && (d = h), l.left < (o._helper ? h.left : 0) && (o.size.width = o.size.width + (o._helper ? o.position.left - h.left : o.position.left - d.left), 
            t && (o.size.height = o.size.width / o.aspectRatio, p = !1), o.position.left = r.helper ? h.left : 0), 
            l.top < (o._helper ? h.top : 0) && (o.size.height = o.size.height + (o._helper ? o.position.top - h.top : o.position.top), 
            t && (o.size.width = o.size.height * o.aspectRatio, p = !1), o.position.top = o._helper ? h.top : 0), 
            c = o.containerElement.get(0) === o.element.parent().get(0), r = /relative|absolute/.test(o.containerElement.css("position")), 
            c && r ? (o.offset.left = o.parentData.left + o.position.left, o.offset.top = o.parentData.top + o.position.top) : (o.offset.left = o.element.offset().left, 
            o.offset.top = o.element.offset().top), l = Math.abs(o.sizeDiff.width + (o._helper ? o.offset.left - d.left : o.offset.left - h.left)), 
            c = Math.abs(o.sizeDiff.height + (o._helper ? o.offset.top - d.top : o.offset.top - h.top)), 
            l + o.size.width >= o.parentData.width && (o.size.width = o.parentData.width - l, 
            t && (o.size.height = o.size.width / o.aspectRatio, p = !1)), c + o.size.height >= o.parentData.height && (o.size.height = o.parentData.height - c, 
            t && (o.size.width = o.size.height * o.aspectRatio, p = !1)), p || (o.position.left = o.prevPosition.left, 
            o.position.top = o.prevPosition.top, o.size.width = o.prevSize.width, 
            o.size.height = o.prevSize.height);
        },
        stop: function() {
            var t = e(this).resizable("instance"), i = t.options, s = t.containerOffset, n = t.containerPosition, a = t.containerElement, o = e(t.helper), r = o.offset(), h = o.outerWidth() - t.sizeDiff.width, o = o.outerHeight() - t.sizeDiff.height;
            t._helper && !i.animate && /relative/.test(a.css("position")) && e(this).css({
                left: r.left - n.left - s.left,
                width: h,
                height: o
            }), t._helper && !i.animate && /static/.test(a.css("position")) && e(this).css({
                left: r.left - n.left - s.left,
                width: h,
                height: o
            });
        }
    }), e.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
            var i = e(this).resizable("instance").options;
            e(i.alsoResize).each(function() {
                var t = e(this);
                t.data("ui-resizable-alsoresize", {
                    width: parseInt(t.width(), 10),
                    height: parseInt(t.height(), 10),
                    left: parseInt(t.css("left"), 10),
                    top: parseInt(t.css("top"), 10)
                });
            });
        },
        resize: function(t, i) {
            var s = e(this).resizable("instance"), n = s.options, a = s.originalSize, o = s.originalPosition, r = {
                height: s.size.height - a.height || 0,
                width: s.size.width - a.width || 0,
                top: s.position.top - o.top || 0,
                left: s.position.left - o.left || 0
            };
            e(n.alsoResize).each(function() {
                var t = e(this), s = e(this).data("ui-resizable-alsoresize"), n = {}, a = t.parents(i.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                e.each(a, function(e, t) {
                    var i = (s[t] || 0) + (r[t] || 0);
                    i && 0 <= i && (n[t] = i || null);
                }), t.css(n);
            });
        },
        stop: function() {
            e(this).removeData("resizable-alsoresize");
        }
    }), e.ui.plugin.add("resizable", "ghost", {
        start: function() {
            var t = e(this).resizable("instance"), i = t.options, s = t.size;
            t.ghost = t.originalElement.clone(), t.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: s.height,
                width: s.width,
                margin: 0,
                left: 0,
                top: 0
            }).addClass("ui-resizable-ghost").addClass("string" == typeof i.ghost ? i.ghost : ""), 
            t.ghost.appendTo(t.helper);
        },
        resize: function() {
            var t = e(this).resizable("instance");
            t.ghost && t.ghost.css({
                position: "relative",
                height: t.size.height,
                width: t.size.width
            });
        },
        stop: function() {
            var t = e(this).resizable("instance");
            t.ghost && t.helper && t.helper.get(0).removeChild(t.ghost.get(0));
        }
    }), e.ui.plugin.add("resizable", "grid", {
        resize: function() {
            var t, i = e(this).resizable("instance"), s = i.options, n = i.size, a = i.originalSize, o = i.originalPosition, r = i.axis, h = "number" == typeof s.grid ? [ s.grid, s.grid ] : s.grid, l = h[0] || 1, u = h[1] || 1, d = Math.round((n.width - a.width) / l) * l, n = Math.round((n.height - a.height) / u) * u, p = a.width + d, f = a.height + n, m = s.maxWidth && p > s.maxWidth, g = s.maxHeight && f > s.maxHeight, v = s.minWidth && s.minWidth > p, y = s.minHeight && s.minHeight > f;
            s.grid = h, v && (p += l), y && (f += u), m && (p -= l), g && (f -= u), 
            /^(se|s|e)$/.test(r) ? (i.size.width = p, i.size.height = f) : /^(ne)$/.test(r) ? (i.size.width = p, 
            i.size.height = f, i.position.top = o.top - n) : /^(sw)$/.test(r) ? (i.size.width = p, 
            i.size.height = f, i.position.left = o.left - d) : ((f - u <= 0 || p - l <= 0) && (t = i._getPaddingPlusBorderDimensions(this)), 
            0 < f - u ? (i.size.height = f, i.position.top = o.top - n) : (f = u - t.height, 
            i.size.height = f, i.position.top = o.top + a.height - f), 0 < p - l ? (i.size.width = p, 
            i.position.left = o.left - d) : (p = l - t.width, i.size.width = p, 
            i.position.left = o.left + a.width - p));
        }
    }), e.ui.resizable, e.widget("ui.selectable", e.ui.mouse, {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoRefresh: !0,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var t, i = this;
            this.element.addClass("ui-selectable"), this.dragged = !1, this.refresh = function() {
                (t = e(i.options.filter, i.element[0])).addClass("ui-selectee"), 
                t.each(function() {
                    var t = e(this), i = t.offset();
                    e.data(this, "selectable-item", {
                        element: this,
                        $element: t,
                        left: i.left,
                        top: i.top,
                        right: i.left + t.outerWidth(),
                        bottom: i.top + t.outerHeight(),
                        startselected: !1,
                        selected: t.hasClass("ui-selected"),
                        selecting: t.hasClass("ui-selecting"),
                        unselecting: t.hasClass("ui-unselecting")
                    });
                });
            }, this.refresh(), this.selectees = t.addClass("ui-selectee"), this._mouseInit(), 
            this.helper = e("<div class='ui-selectable-helper'></div>");
        },
        _destroy: function() {
            this.selectees.removeClass("ui-selectee").removeData("selectable-item"), 
            this.element.removeClass("ui-selectable ui-selectable-disabled"), this._mouseDestroy();
        },
        _mouseStart: function(t) {
            var i = this, s = this.options;
            this.opos = [ t.pageX, t.pageY ], this.options.disabled || (this.selectees = e(s.filter, this.element[0]), 
            this._trigger("start", t), e(s.appendTo).append(this.helper), this.helper.css({
                left: t.pageX,
                top: t.pageY,
                width: 0,
                height: 0
            }), s.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function() {
                var s = e.data(this, "selectable-item");
                s.startselected = !0, t.metaKey || t.ctrlKey || (s.$element.removeClass("ui-selected"), 
                s.selected = !1, s.$element.addClass("ui-unselecting"), s.unselecting = !0, 
                i._trigger("unselecting", t, {
                    unselecting: s.element
                }));
            }), e(t.target).parents().addBack().each(function() {
                var s, n = e.data(this, "selectable-item");
                return n ? (s = !t.metaKey && !t.ctrlKey || !n.$element.hasClass("ui-selected"), 
                n.$element.removeClass(s ? "ui-unselecting" : "ui-selected").addClass(s ? "ui-selecting" : "ui-unselecting"), 
                n.unselecting = !s, n.selecting = s, (n.selected = s) ? i._trigger("selecting", t, {
                    selecting: n.element
                }) : i._trigger("unselecting", t, {
                    unselecting: n.element
                }), !1) : void 0;
            }));
        },
        _mouseDrag: function(t) {
            var i, s, n, a, o, r, h;
            if (this.dragged = !0, !this.options.disabled) return n = (s = this).options, 
            a = this.opos[0], o = this.opos[1], r = t.pageX, h = t.pageY, r < a && (i = r, 
            r = a, a = i), h < o && (i = h, h = o, o = i), this.helper.css({
                left: a,
                top: o,
                width: r - a,
                height: h - o
            }), this.selectees.each(function() {
                var i = e.data(this, "selectable-item"), l = !1;
                i && i.element !== s.element[0] && ("touch" === n.tolerance ? l = !(i.left > r || a > i.right || i.top > h || o > i.bottom) : "fit" === n.tolerance && (l = i.left > a && r > i.right && i.top > o && h > i.bottom), 
                l ? (i.selected && (i.$element.removeClass("ui-selected"), i.selected = !1), 
                i.unselecting && (i.$element.removeClass("ui-unselecting"), i.unselecting = !1), 
                i.selecting || (i.$element.addClass("ui-selecting"), i.selecting = !0, 
                s._trigger("selecting", t, {
                    selecting: i.element
                }))) : (i.selecting && ((t.metaKey || t.ctrlKey) && i.startselected ? (i.$element.removeClass("ui-selecting"), 
                i.selecting = !1, i.$element.addClass("ui-selected"), i.selected = !0) : (i.$element.removeClass("ui-selecting"), 
                i.selecting = !1, i.startselected && (i.$element.addClass("ui-unselecting"), 
                i.unselecting = !0), s._trigger("unselecting", t, {
                    unselecting: i.element
                }))), !i.selected || t.metaKey || t.ctrlKey || i.startselected || (i.$element.removeClass("ui-selected"), 
                i.selected = !1, i.$element.addClass("ui-unselecting"), i.unselecting = !0, 
                s._trigger("unselecting", t, {
                    unselecting: i.element
                }))));
            }), !1;
        },
        _mouseStop: function(t) {
            var i = this;
            return this.dragged = !1, e(".ui-unselecting", this.element[0]).each(function() {
                var s = e.data(this, "selectable-item");
                s.$element.removeClass("ui-unselecting"), s.unselecting = !1, s.startselected = !1, 
                i._trigger("unselected", t, {
                    unselected: s.element
                });
            }), e(".ui-selecting", this.element[0]).each(function() {
                var s = e.data(this, "selectable-item");
                s.$element.removeClass("ui-selecting").addClass("ui-selected"), 
                s.selecting = !1, s.selected = !0, s.startselected = !0, i._trigger("selected", t, {
                    selected: s.element
                });
            }), this._trigger("stop", t), this.helper.remove(), !1;
        }
    }), e.widget("ui.sortable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "sort",
        ready: !1,
        options: {
            appendTo: "parent",
            axis: !1,
            connectWith: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            dropOnEmpty: !0,
            forcePlaceholderSize: !1,
            forceHelperSize: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            items: "> *",
            opacity: !1,
            placeholder: !1,
            revert: !1,
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _isOverAxis: function(e, t, i) {
            return t <= e && e < t + i;
        },
        _isFloating: function(e) {
            return /left|right/.test(e.css("float")) || /inline|table-cell/.test(e.css("display"));
        },
        _create: function() {
            this.containerCache = {}, this.element.addClass("ui-sortable"), this.refresh(), 
            this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(), 
            this.ready = !0;
        },
        _setOption: function(e, t) {
            this._super(e, t), "handle" === e && this._setHandleClassName();
        },
        _setHandleClassName: function() {
            this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"), 
            e.each(this.items, function() {
                (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle");
            });
        },
        _destroy: function() {
            this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"), 
            this._mouseDestroy();
            for (var e = this.items.length - 1; 0 <= e; e--) this.items[e].item.removeData(this.widgetName + "-item");
            return this;
        },
        _mouseCapture: function(t, i) {
            var s = null, n = !1, a = this;
            return !this.reverting && (!this.options.disabled && "static" !== this.options.type && (this._refreshItems(t), 
            e(t.target).parents().each(function() {
                return e.data(this, a.widgetName + "-item") === a ? (s = e(this), 
                !1) : void 0;
            }), !!(s = e.data(t.target, a.widgetName + "-item") === a ? e(t.target) : s) && (!(this.options.handle && !i && (e(this.options.handle, s).find("*").addBack().each(function() {
                this === t.target && (n = !0);
            }), !n)) && (this.currentItem = s, this._removeCurrentsFromItems(), 
            !0))));
        },
        _mouseStart: function(t, i, s) {
            var n, a, o = this.options;
            if ((this.currentContainer = this).refreshPositions(), this.helper = this._createHelper(t), 
            this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), 
            this.offset = this.currentItem.offset(), this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            }, e.extend(this.offset, {
                click: {
                    left: t.pageX - this.offset.left,
                    top: t.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), 
            this.originalPosition = this._generatePosition(t), this.originalPageX = t.pageX, 
            this.originalPageY = t.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), 
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), 
            this._createPlaceholder(), o.containment && this._setContainment(), 
            o.cursor && "auto" !== o.cursor && (a = this.document.find("body"), 
            this.storedCursor = a.css("cursor"), a.css("cursor", o.cursor), this.storedStylesheet = e("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(a)), 
            o.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), 
            this.helper.css("opacity", o.opacity)), o.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), 
            this.helper.css("zIndex", o.zIndex)), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), 
            this._trigger("start", t, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), 
            !s) for (n = this.containers.length - 1; 0 <= n; n--) this.containers[n]._trigger("activate", t, this._uiHash(this));
            return e.ui.ddmanager && (e.ui.ddmanager.current = this), e.ui.ddmanager && !o.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), 
            this.dragging = !0, this.helper.addClass("ui-sortable-helper"), this._mouseDrag(t), 
            !0;
        },
        _mouseDrag: function(t) {
            var i, s, n, a, o = this.options, r = !1;
            for (this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute"), 
            this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), this.options.scroll && (this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t.pageY < o.scrollSensitivity ? this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop + o.scrollSpeed : t.pageY - this.overflowOffset.top < o.scrollSensitivity && (this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop - o.scrollSpeed), 
            this.overflowOffset.left + this.scrollParent[0].offsetWidth - t.pageX < o.scrollSensitivity ? this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft + o.scrollSpeed : t.pageX - this.overflowOffset.left < o.scrollSensitivity && (this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft - o.scrollSpeed)) : (t.pageY - this.document.scrollTop() < o.scrollSensitivity ? r = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed) : this.window.height() - (t.pageY - this.document.scrollTop()) < o.scrollSensitivity && (r = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed)), 
            t.pageX - this.document.scrollLeft() < o.scrollSensitivity ? r = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed) : this.window.width() - (t.pageX - this.document.scrollLeft()) < o.scrollSensitivity && (r = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed))), 
            !1 !== r && e.ui.ddmanager && !o.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t)), 
            this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), 
            this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), 
            i = this.items.length - 1; 0 <= i; i--) if (n = (s = this.items[i]).item[0], 
            (a = this._intersectsWithPointer(s)) && s.instance === this.currentContainer && n !== this.currentItem[0] && this.placeholder[1 === a ? "next" : "prev"]()[0] !== n && !e.contains(this.placeholder[0], n) && ("semi-dynamic" !== this.options.type || !e.contains(this.element[0], n))) {
                if (this.direction = 1 === a ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(s)) break;
                this._rearrange(t, s), this._trigger("change", t, this._uiHash());
                break;
            }
            return this._contactContainers(t), e.ui.ddmanager && e.ui.ddmanager.drag(this, t), 
            this._trigger("sort", t, this._uiHash()), this.lastPositionAbs = this.positionAbs, 
            !1;
        },
        _mouseStop: function(t, i) {
            var s, n, a, o;
            if (t) return e.ui.ddmanager && !this.options.dropBehaviour && e.ui.ddmanager.drop(this, t), 
            this.options.revert ? (n = (s = this).placeholder.offset(), o = {}, 
            (a = this.options.axis) && "x" !== a || (o.left = n.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)), 
            a && "y" !== a || (o.top = n.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)), 
            this.reverting = !0, e(this.helper).animate(o, parseInt(this.options.revert, 10) || 500, function() {
                s._clear(t);
            })) : this._clear(t, i), !1;
        },
        cancel: function() {
            if (this.dragging) {
                this._mouseUp({
                    target: null
                }), "original" === this.options.helper ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();
                for (var t = this.containers.length - 1; 0 <= t; t--) this.containers[t]._trigger("deactivate", null, this._uiHash(this)), 
                this.containers[t].containerCache.over && (this.containers[t]._trigger("out", null, this._uiHash(this)), 
                this.containers[t].containerCache.over = 0);
            }
            return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), 
            "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), 
            e.extend(this, {
                helper: null,
                dragging: !1,
                reverting: !1,
                _noFinalSort: null
            }), this.domPosition.prev ? e(this.domPosition.prev).after(this.currentItem) : e(this.domPosition.parent).prepend(this.currentItem)), 
            this;
        },
        serialize: function(t) {
            var i = this._getItemsAsjQuery(t && t.connected), s = [];
            return t = t || {}, e(i).each(function() {
                var i = (e(t.item || this).attr(t.attribute || "id") || "").match(t.expression || /(.+)[\-=_](.+)/);
                i && s.push((t.key || i[1] + "[]") + "=" + (t.key && t.expression ? i[1] : i[2]));
            }), !s.length && t.key && s.push(t.key + "="), s.join("&");
        },
        toArray: function(t) {
            var i = this._getItemsAsjQuery(t && t.connected), s = [];
            return t = t || {}, i.each(function() {
                s.push(e(t.item || this).attr(t.attribute || "id") || "");
            }), s;
        },
        _intersectsWith: function(e) {
            var t = this.positionAbs.left, i = t + this.helperProportions.width, s = this.positionAbs.top, n = s + this.helperProportions.height, a = e.left, o = a + e.width, r = e.top, h = r + e.height, l = this.offset.click.top, u = this.offset.click.left, l = "x" === this.options.axis || r < s + l && s + l < h, u = "y" === this.options.axis || a < t + u && t + u < o;
            return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > e[this.floating ? "width" : "height"] ? l && u : t + this.helperProportions.width / 2 > a && o > i - this.helperProportions.width / 2 && s + this.helperProportions.height / 2 > r && h > n - this.helperProportions.height / 2;
        },
        _intersectsWithPointer: function(e) {
            var t = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, e.top, e.height), e = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, e.left, e.width), t = t && e, e = this._getDragVerticalDirection(), a = this._getDragHorizontalDirection();
            return !!t && (this.floating ? a && "right" === a || "down" === e ? 2 : 1 : e && ("down" === e ? 2 : 1));
        },
        _intersectsWithSides: function(e) {
            var t = this._isOverAxis(this.positionAbs.top + this.offset.click.top, e.top + e.height / 2, e.height), e = this._isOverAxis(this.positionAbs.left + this.offset.click.left, e.left + e.width / 2, e.width), s = this._getDragVerticalDirection(), n = this._getDragHorizontalDirection();
            return this.floating && n ? "right" === n && e || "left" === n && !e : s && ("down" === s && t || "up" === s && !t);
        },
        _getDragVerticalDirection: function() {
            var e = this.positionAbs.top - this.lastPositionAbs.top;
            return 0 != e && (0 < e ? "down" : "up");
        },
        _getDragHorizontalDirection: function() {
            var e = this.positionAbs.left - this.lastPositionAbs.left;
            return 0 != e && (0 < e ? "right" : "left");
        },
        refresh: function(e) {
            return this._refreshItems(e), this._setHandleClassName(), this.refreshPositions(), 
            this;
        },
        _connectWith: function() {
            var e = this.options;
            return e.connectWith.constructor === String ? [ e.connectWith ] : e.connectWith;
        },
        _getItemsAsjQuery: function(t) {
            function i() {
                r.push(this);
            }
            var s, n, a, o, r = [], h = [], l = this._connectWith();
            if (l && t) for (s = l.length - 1; 0 <= s; s--) for (n = (a = e(l[s], this.document[0])).length - 1; 0 <= n; n--) (o = e.data(a[n], this.widgetFullName)) && o !== this && !o.options.disabled && h.push([ e.isFunction(o.options.items) ? o.options.items.call(o.element) : e(o.options.items, o.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), o ]);
            for (h.push([ e.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : e(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this ]), 
            s = h.length - 1; 0 <= s; s--) h[s][0].each(i);
            return e(r);
        },
        _removeCurrentsFromItems: function() {
            var t = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = e.grep(this.items, function(e) {
                for (var i = 0; t.length > i; i++) if (t[i] === e.item[0]) return !1;
                return !0;
            });
        },
        _refreshItems: function(t) {
            this.items = [], this.containers = [ this ];
            var i, s, n, a, o, r, h, l, u = this.items, d = [ [ e.isFunction(this.options.items) ? this.options.items.call(this.element[0], t, {
                item: this.currentItem
            }) : e(this.options.items, this.element), this ] ], c = this._connectWith();
            if (c && this.ready) for (i = c.length - 1; 0 <= i; i--) for (s = (n = e(c[i], this.document[0])).length - 1; 0 <= s; s--) (a = e.data(n[s], this.widgetFullName)) && a !== this && !a.options.disabled && (d.push([ e.isFunction(a.options.items) ? a.options.items.call(a.element[0], t, {
                item: this.currentItem
            }) : e(a.options.items, a.element), a ]), this.containers.push(a));
            for (i = d.length - 1; 0 <= i; i--) for (o = d[i][1], l = (r = d[i][s = 0]).length; s < l; s++) (h = e(r[s])).data(this.widgetName + "-item", o), 
            u.push({
                item: h,
                instance: o,
                width: 0,
                height: 0,
                left: 0,
                top: 0
            });
        },
        refreshPositions: function(t) {
            var i, s, n, a;
            for (this.floating = !!this.items.length && ("x" === this.options.axis || this._isFloating(this.items[0].item)), 
            this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset()), 
            i = this.items.length - 1; 0 <= i; i--) (s = this.items[i]).instance !== this.currentContainer && this.currentContainer && s.item[0] !== this.currentItem[0] || (n = this.options.toleranceElement ? e(this.options.toleranceElement, s.item) : s.item, 
            t || (s.width = n.outerWidth(), s.height = n.outerHeight()), a = n.offset(), 
            s.left = a.left, s.top = a.top);
            if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this); else for (i = this.containers.length - 1; 0 <= i; i--) a = this.containers[i].element.offset(), 
            this.containers[i].containerCache.left = a.left, this.containers[i].containerCache.top = a.top, 
            this.containers[i].containerCache.width = this.containers[i].element.outerWidth(), 
            this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
            return this;
        },
        _createPlaceholder: function(t) {
            var i, s = (t = t || this).options;
            s.placeholder && s.placeholder.constructor !== String || (i = s.placeholder, 
            s.placeholder = {
                element: function() {
                    var s = t.currentItem[0].nodeName.toLowerCase(), n = e("<" + s + ">", t.document[0]).addClass(i || t.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                    return "tbody" === s ? t._createTrPlaceholder(t.currentItem.find("tr").eq(0), e("<tr>", t.document[0]).appendTo(n)) : "tr" === s ? t._createTrPlaceholder(t.currentItem, n) : "img" === s && n.attr("src", t.currentItem.attr("src")), 
                    i || n.css("visibility", "hidden"), n;
                },
                update: function(e, n) {
                    i && !s.forcePlaceholderSize || (n.height() || n.height(t.currentItem.innerHeight() - parseInt(t.currentItem.css("paddingTop") || 0, 10) - parseInt(t.currentItem.css("paddingBottom") || 0, 10)), 
                    n.width() || n.width(t.currentItem.innerWidth() - parseInt(t.currentItem.css("paddingLeft") || 0, 10) - parseInt(t.currentItem.css("paddingRight") || 0, 10)));
                }
            }), t.placeholder = e(s.placeholder.element.call(t.element, t.currentItem)), 
            t.currentItem.after(t.placeholder), s.placeholder.update(t, t.placeholder);
        },
        _createTrPlaceholder: function(t, i) {
            var s = this;
            t.children().each(function() {
                e("<td>&#160;</td>", s.document[0]).attr("colspan", e(this).attr("colspan") || 1).appendTo(i);
            });
        },
        _contactContainers: function(t) {
            for (var s, n, a, o, r, h, l, u, d, c = null, p = null, i = this.containers.length - 1; 0 <= i; i--) if (!e.contains(this.currentItem[0], this.containers[i].element[0])) if (this._intersectsWith(this.containers[i].containerCache)) {
                if (c && e.contains(this.containers[i].element[0], c.element[0])) continue;
                c = this.containers[i], p = i;
            } else this.containers[i].containerCache.over && (this.containers[i]._trigger("out", t, this._uiHash(this)), 
            this.containers[i].containerCache.over = 0);
            if (c) if (1 === this.containers.length) this.containers[p].containerCache.over || (this.containers[p]._trigger("over", t, this._uiHash(this)), 
            this.containers[p].containerCache.over = 1); else {
                for (n = 1e4, a = null, o = (u = c.floating || this._isFloating(this.currentItem)) ? "left" : "top", 
                r = u ? "width" : "height", d = u ? "clientX" : "clientY", s = this.items.length - 1; 0 <= s; s--) e.contains(this.containers[p].element[0], this.items[s].item[0]) && this.items[s].item[0] !== this.currentItem[0] && (h = this.items[s].item.offset()[o], 
                l = !1, t[d] - h > this.items[s][r] / 2 && (l = !0), n > Math.abs(t[d] - h) && (n = Math.abs(t[d] - h), 
                a = this.items[s], this.direction = l ? "up" : "down"));
                (a || this.options.dropOnEmpty) && (this.currentContainer === this.containers[p] ? this.currentContainer.containerCache.over || (this.containers[p]._trigger("over", t, this._uiHash()), 
                this.currentContainer.containerCache.over = 1) : (a ? this._rearrange(t, a, null, !0) : this._rearrange(t, null, this.containers[p].element, !0), 
                this._trigger("change", t, this._uiHash()), this.containers[p]._trigger("change", t, this._uiHash(this)), 
                this.currentContainer = this.containers[p], this.options.placeholder.update(this.currentContainer, this.placeholder), 
                this.containers[p]._trigger("over", t, this._uiHash(this)), this.containers[p].containerCache.over = 1));
            }
        },
        _createHelper: function(t) {
            var i = this.options, t = e.isFunction(i.helper) ? e(i.helper.apply(this.element[0], [ t, this.currentItem ])) : "clone" === i.helper ? this.currentItem.clone() : this.currentItem;
            return t.parents("body").length || e("parent" !== i.appendTo ? i.appendTo : this.currentItem[0].parentNode)[0].appendChild(t[0]), 
            t[0] === this.currentItem[0] && (this._storedCSS = {
                width: this.currentItem[0].style.width,
                height: this.currentItem[0].style.height,
                position: this.currentItem.css("position"),
                top: this.currentItem.css("top"),
                left: this.currentItem.css("left")
            }), t[0].style.width && !i.forceHelperSize || t.width(this.currentItem.width()), 
            t[0].style.height && !i.forceHelperSize || t.height(this.currentItem.height()), 
            t;
        },
        _adjustOffsetFromHelper: function(t) {
            "string" == typeof t && (t = t.split(" ")), "left" in (t = e.isArray(t) ? {
                left: +t[0],
                top: +t[1] || 0
            } : t) && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), 
            "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top);
        },
        _getParentOffset: function() {
            this.offsetParent = this.helper.offsetParent();
            var t = this.offsetParent.offset();
            return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), 
            t.top += this.scrollParent.scrollTop()), {
                top: (t = this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && e.ui.ie ? {
                    top: 0,
                    left: 0
                } : t).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            var e;
            return "relative" === this.cssPosition ? {
                top: (e = this.currentItem.position()).top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
            } : {
                top: 0,
                left: 0
            };
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var t, s, n = this.options;
            "parent" === n.containment && (n.containment = this.helper[0].parentNode), 
            "document" !== n.containment && "window" !== n.containment || (this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === n.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === n.containment ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]), 
            /^(document|window|parent)$/.test(n.containment) || (t = e(n.containment)[0], 
            n = e(n.containment).offset(), s = "hidden" !== e(t).css("overflow"), 
            this.containment = [ n.left + (parseInt(e(t).css("borderLeftWidth"), 10) || 0) + (parseInt(e(t).css("paddingLeft"), 10) || 0) - this.margins.left, n.top + (parseInt(e(t).css("borderTopWidth"), 10) || 0) + (parseInt(e(t).css("paddingTop"), 10) || 0) - this.margins.top, n.left + (s ? Math.max(t.scrollWidth, t.offsetWidth) : t.offsetWidth) - (parseInt(e(t).css("borderLeftWidth"), 10) || 0) - (parseInt(e(t).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, n.top + (s ? Math.max(t.scrollHeight, t.offsetHeight) : t.offsetHeight) - (parseInt(e(t).css("borderTopWidth"), 10) || 0) - (parseInt(e(t).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top ]);
        },
        _convertPositionTo: function(t, i) {
            i = i || this.position;
            var t = "absolute" === t ? 1 : -1, n = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, a = /(html|body)/i.test(n[0].tagName);
            return {
                top: i.top + this.offset.relative.top * t + this.offset.parent.top * t - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : a ? 0 : n.scrollTop()) * t,
                left: i.left + this.offset.relative.left * t + this.offset.parent.left * t - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : a ? 0 : n.scrollLeft()) * t
            };
        },
        _generatePosition: function(t) {
            var n = this.options, a = t.pageX, o = t.pageY, r = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, h = /(html|body)/i.test(r[0].tagName);
            return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), 
            this.originalPosition && (this.containment && (t.pageX - this.offset.click.left < this.containment[0] && (a = this.containment[0] + this.offset.click.left), 
            t.pageY - this.offset.click.top < this.containment[1] && (o = this.containment[1] + this.offset.click.top), 
            t.pageX - this.offset.click.left > this.containment[2] && (a = this.containment[2] + this.offset.click.left), 
            t.pageY - this.offset.click.top > this.containment[3] && (o = this.containment[3] + this.offset.click.top)), 
            n.grid && (t = this.originalPageY + Math.round((o - this.originalPageY) / n.grid[1]) * n.grid[1], 
            o = !this.containment || t - this.offset.click.top >= this.containment[1] && t - this.offset.click.top <= this.containment[3] ? t : t - this.offset.click.top >= this.containment[1] ? t - n.grid[1] : t + n.grid[1], 
            t = this.originalPageX + Math.round((a - this.originalPageX) / n.grid[0]) * n.grid[0], 
            a = !this.containment || t - this.offset.click.left >= this.containment[0] && t - this.offset.click.left <= this.containment[2] ? t : t - this.offset.click.left >= this.containment[0] ? t - n.grid[0] : t + n.grid[0])), 
            {
                top: o - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : h ? 0 : r.scrollTop()),
                left: a - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : h ? 0 : r.scrollLeft())
            };
        },
        _rearrange: function(e, t, i, s) {
            i ? i[0].appendChild(this.placeholder[0]) : t.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? t.item[0] : t.item[0].nextSibling), 
            this.counter = this.counter ? ++this.counter : 1;
            var n = this.counter;
            this._delay(function() {
                n === this.counter && this.refreshPositions(!s);
            });
        },
        _clear: function(e, t) {
            function i(e, t, i) {
                return function(s) {
                    i._trigger(e, s, t._uiHash(t));
                };
            }
            this.reverting = !1;
            var s, n = [];
            if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), 
            this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
                for (s in this._storedCSS) "auto" !== this._storedCSS[s] && "static" !== this._storedCSS[s] || (this._storedCSS[s] = "");
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else this.currentItem.show();
            for (this.fromOutside && !t && n.push(function(e) {
                this._trigger("receive", e, this._uiHash(this.fromOutside));
            }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || t || n.push(function(e) {
                this._trigger("update", e, this._uiHash());
            }), this === this.currentContainer || t || (n.push(function(e) {
                this._trigger("remove", e, this._uiHash());
            }), n.push(function(e) {
                return function(t) {
                    e._trigger("receive", t, this._uiHash(this));
                };
            }.call(this, this.currentContainer)), n.push(function(e) {
                return function(t) {
                    e._trigger("update", t, this._uiHash(this));
                };
            }.call(this, this.currentContainer))), s = this.containers.length - 1; 0 <= s; s--) t || n.push(i("deactivate", this, this.containers[s])), 
            this.containers[s].containerCache.over && (n.push(i("out", this, this.containers[s])), 
            this.containers[s].containerCache.over = 0);
            if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), 
            this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), 
            this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), 
            this.dragging = !1, t || this._trigger("beforeStop", e, this._uiHash()), 
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), 
            this.helper = null), !t) {
                for (s = 0; n.length > s; s++) n[s].call(this, e);
                this._trigger("stop", e, this._uiHash());
            }
            return this.fromOutside = !1, !this.cancelHelperRemoval;
        },
        _trigger: function() {
            !1 === e.Widget.prototype._trigger.apply(this, arguments) && this.cancel();
        },
        _uiHash: function(t) {
            var i = t || this;
            return {
                helper: i.helper,
                placeholder: i.placeholder || e([]),
                position: i.position,
                originalPosition: i.originalPosition,
                offset: i.positionAbs,
                item: i.currentItem,
                sender: t ? t.element : null
            };
        }
    }), e.widget("ui.tabs", {
        version: "1.11.4",
        delay: 300,
        options: {
            active: null,
            collapsible: !1,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _isLocal: function() {
            var e = /#.*$/;
            return function(t) {
                var i = (t = t.cloneNode(!1)).href.replace(e, ""), s = location.href.replace(e, "");
                try {
                    i = decodeURIComponent(i);
                } catch (n) {}
                try {
                    s = decodeURIComponent(s);
                } catch (n) {}
                return 1 < t.hash.length && i === s;
            };
        }(),
        _create: function() {
            var t = this, i = this.options;
            this.running = !1, this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", i.collapsible), 
            this._processTabs(), i.active = this._initialActive(), e.isArray(i.disabled) && (i.disabled = e.unique(i.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"), function(e) {
                return t.tabs.index(e);
            }))).sort()), this.active = !1 !== this.options.active && this.anchors.length ? this._findActive(i.active) : e(), 
            this._refresh(), this.active.length && this.load(i.active);
        },
        _initialActive: function() {
            var t = this.options.active, i = this.options.collapsible, s = location.hash.substring(1);
            return null === t && (s && this.tabs.each(function(i, n) {
                return e(n).attr("aria-controls") === s ? (t = i, !1) : void 0;
            }), null !== (t = null === t ? this.tabs.index(this.tabs.filter(".ui-tabs-active")) : t) && -1 !== t || (t = !!this.tabs.length && 0)), 
            !1 !== t && (-1 === (t = this.tabs.index(this.tabs.eq(t))) && (t = !i && 0)), 
            t = !i && !1 === t && this.anchors.length ? 0 : t;
        },
        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: this.active.length ? this._getPanelForTab(this.active) : e()
            };
        },
        _tabKeydown: function(t) {
            var i = e(this.document[0].activeElement).closest("li"), s = this.tabs.index(i), n = !0;
            if (!this._handlePageNav(t)) {
                switch (t.keyCode) {
                  case e.ui.keyCode.RIGHT:
                  case e.ui.keyCode.DOWN:
                    s++;
                    break;

                  case e.ui.keyCode.UP:
                  case e.ui.keyCode.LEFT:
                    n = !1, s--;
                    break;

                  case e.ui.keyCode.END:
                    s = this.anchors.length - 1;
                    break;

                  case e.ui.keyCode.HOME:
                    s = 0;
                    break;

                  case e.ui.keyCode.SPACE:
                    return t.preventDefault(), clearTimeout(this.activating), void this._activate(s);

                  case e.ui.keyCode.ENTER:
                    return t.preventDefault(), clearTimeout(this.activating), void this._activate(s !== this.options.active && s);

                  default:
                    return;
                }
                t.preventDefault(), clearTimeout(this.activating), s = this._focusNextTab(s, n), 
                t.ctrlKey || t.metaKey || (i.attr("aria-selected", "false"), this.tabs.eq(s).attr("aria-selected", "true"), 
                this.activating = this._delay(function() {
                    this.option("active", s);
                }, this.delay));
            }
        },
        _panelKeydown: function(t) {
            this._handlePageNav(t) || t.ctrlKey && t.keyCode === e.ui.keyCode.UP && (t.preventDefault(), 
            this.active.focus());
        },
        _handlePageNav: function(t) {
            return t.altKey && t.keyCode === e.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), 
            !0) : t.altKey && t.keyCode === e.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), 
            !0) : void 0;
        },
        _findNextTab: function(t, i) {
            for (var n = this.tabs.length - 1; -1 !== e.inArray(t = (t = n < t ? 0 : t) < 0 ? n : t, this.options.disabled); ) t = i ? t + 1 : t - 1;
            return t;
        },
        _focusNextTab: function(e, t) {
            return e = this._findNextTab(e, t), this.tabs.eq(e).focus(), e;
        },
        _setOption: function(e, t) {
            return "active" === e ? void this._activate(t) : "disabled" === e ? void this._setupDisabled(t) : (this._super(e, t), 
            "collapsible" === e && (this.element.toggleClass("ui-tabs-collapsible", t), 
            t || !1 !== this.options.active || this._activate(0)), "event" === e && this._setupEvents(t), 
            void ("heightStyle" === e && this._setupHeightStyle(t)));
        },
        _sanitizeSelector: function(e) {
            return e ? e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },
        refresh: function() {
            var t = this.options, i = this.tablist.children(":has(a[href])");
            t.disabled = e.map(i.filter(".ui-state-disabled"), function(e) {
                return i.index(e);
            }), this._processTabs(), !1 !== t.active && this.anchors.length ? this.active.length && !e.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t.disabled.length ? (t.active = !1, 
            this.active = e()) : this._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active = this.tabs.index(this.active) : (t.active = !1, 
            this.active = e()), this._refresh();
        },
        _refresh: function() {
            this._setupDisabled(this.options.disabled), this._setupEvents(this.options.event), 
            this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                "aria-hidden": "true"
            }), this.active.length ? (this.active.addClass("ui-tabs-active ui-state-active").attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            }), this._getPanelForTab(this.active).show().attr({
                "aria-hidden": "false"
            })) : this.tabs.eq(0).attr("tabIndex", 0);
        },
        _processTabs: function() {
            var t = this, i = this.tabs, s = this.anchors, n = this.panels;
            this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist").delegate("> li", "mousedown" + this.eventNamespace, function(t) {
                e(this).is(".ui-state-disabled") && t.preventDefault();
            }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                e(this).closest("li").is(".ui-state-disabled") && this.blur();
            }), this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                role: "tab",
                tabIndex: -1
            }), this.anchors = this.tabs.map(function() {
                return e("a", this)[0];
            }).addClass("ui-tabs-anchor").attr({
                role: "presentation",
                tabIndex: -1
            }), this.panels = e(), this.anchors.each(function(i, s) {
                var n, a, o, r = e(s).uniqueId().attr("id"), h = e(s).closest("li"), l = h.attr("aria-controls");
                t._isLocal(s) ? (o = (n = s.hash).substring(1), a = t.element.find(t._sanitizeSelector(n))) : (o = h.attr("aria-controls") || e({}).uniqueId()[0].id, 
                (a = t.element.find(n = "#" + o)).length || (a = t._createPanel(o)).insertAfter(t.panels[i - 1] || t.tablist), 
                a.attr("aria-live", "polite")), a.length && (t.panels = t.panels.add(a)), 
                l && h.data("ui-tabs-aria-controls", l), h.attr({
                    "aria-controls": o,
                    "aria-labelledby": r
                }), a.attr("aria-labelledby", r);
            }), this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel"), 
            i && (this._off(i.not(this.tabs)), this._off(s.not(this.anchors)), this._off(n.not(this.panels)));
        },
        _getList: function() {
            return this.tablist || this.element.find("ol,ul").eq(0);
        },
        _createPanel: function(t) {
            return e("<div>").attr("id", t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0);
        },
        _setupDisabled: function(t) {
            e.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) : t = !1);
            for (var i, s = 0; i = this.tabs[s]; s++) !0 === t || -1 !== e.inArray(s, t) ? e(i).addClass("ui-state-disabled").attr("aria-disabled", "true") : e(i).removeClass("ui-state-disabled").removeAttr("aria-disabled");
            this.options.disabled = t;
        },
        _setupEvents: function(t) {
            var i = {};
            t && e.each(t.split(" "), function(e, t) {
                i[t] = "_eventHandler";
            }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(!0, this.anchors, {
                click: function(e) {
                    e.preventDefault();
                }
            }), this._on(this.anchors, i), this._on(this.tabs, {
                keydown: "_tabKeydown"
            }), this._on(this.panels, {
                keydown: "_panelKeydown"
            }), this._focusable(this.tabs), this._hoverable(this.tabs);
        },
        _setupHeightStyle: function(t) {
            var i, s = this.element.parent();
            "fill" === t ? (i = s.height(), i -= this.element.outerHeight() - this.element.height(), 
            this.element.siblings(":visible").each(function() {
                var t = e(this), s = t.css("position");
                "absolute" !== s && "fixed" !== s && (i -= t.outerHeight(!0));
            }), this.element.children().not(this.panels).each(function() {
                i -= e(this).outerHeight(!0);
            }), this.panels.each(function() {
                e(this).height(Math.max(0, i - e(this).innerHeight() + e(this).height()));
            }).css("overflow", "auto")) : "auto" === t && (i = 0, this.panels.each(function() {
                i = Math.max(i, e(this).height("").height());
            }).height(i));
        },
        _eventHandler: function(t) {
            var i = this.options, s = this.active, a = e(t.currentTarget).closest("li"), o = a[0] === s[0], r = o && i.collapsible, h = r ? e() : this._getPanelForTab(a), l = s.length ? this._getPanelForTab(s) : e(), s = {
                oldTab: s,
                oldPanel: l,
                newTab: r ? e() : a,
                newPanel: h
            };
            t.preventDefault(), a.hasClass("ui-state-disabled") || a.hasClass("ui-tabs-loading") || this.running || o && !i.collapsible || !1 === this._trigger("beforeActivate", t, s) || (i.active = !r && this.tabs.index(a), 
            this.active = o ? e() : a, this.xhr && this.xhr.abort(), l.length || h.length || e.error("jQuery UI Tabs: Mismatching fragment identifier."), 
            h.length && this.load(this.tabs.index(a), t), this._toggle(t, s));
        },
        _toggle: function(t, i) {
            function s() {
                a.running = !1, a._trigger("activate", t, i);
            }
            function n() {
                i.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), 
                o.length && a.options.show ? a._show(o, a.options.show, s) : (o.show(), 
                s());
            }
            var a = this, o = i.newPanel, r = i.oldPanel;
            this.running = !0, r.length && this.options.hide ? this._hide(r, this.options.hide, function() {
                i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), 
                n();
            }) : (i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), 
            r.hide(), n()), r.attr("aria-hidden", "true"), i.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            }), o.length && r.length ? i.oldTab.attr("tabIndex", -1) : o.length && this.tabs.filter(function() {
                return 0 === e(this).attr("tabIndex");
            }).attr("tabIndex", -1), o.attr("aria-hidden", "false"), i.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },
        _activate: function(t) {
            var t = this._findActive(t);
            t[0] !== this.active[0] && (t = (t = t.length ? t : this.active).find(".ui-tabs-anchor")[0], 
            this._eventHandler({
                target: t,
                currentTarget: t,
                preventDefault: e.noop
            }));
        },
        _findActive: function(t) {
            return !1 === t ? e() : this.tabs.eq(t);
        },
        _getIndex: function(e) {
            return e = "string" == typeof e ? this.anchors.index(this.anchors.filter("[href$='" + e + "']")) : e;
        },
        _destroy: function() {
            this.xhr && this.xhr.abort(), this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"), 
            this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"), 
            this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(), 
            this.tablist.unbind(this.eventNamespace), this.tabs.add(this.panels).each(function() {
                e.data(this, "ui-tabs-destroy") ? e(this).remove() : e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
            }), this.tabs.each(function() {
                var t = e(this), i = t.data("ui-tabs-aria-controls");
                i ? t.attr("aria-controls", i).removeData("ui-tabs-aria-controls") : t.removeAttr("aria-controls");
            }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "");
        },
        enable: function(t) {
            var i = this.options.disabled;
            !1 !== i && (i = void 0 !== t && (t = this._getIndex(t), e.isArray(i) ? e.map(i, function(e) {
                return e !== t ? e : null;
            }) : e.map(this.tabs, function(e, i) {
                return i !== t ? i : null;
            })), this._setupDisabled(i));
        },
        disable: function(t) {
            var i = this.options.disabled;
            if (!0 !== i) {
                if (void 0 === t) i = !0; else {
                    if (t = this._getIndex(t), -1 !== e.inArray(t, i)) return;
                    i = e.isArray(i) ? e.merge([ t ], i).sort() : [ t ];
                }
                this._setupDisabled(i);
            }
        },
        load: function(t, i) {
            t = this._getIndex(t);
            function h(e, t) {
                "abort" === t && s.panels.stop(!1, !0), n.removeClass("ui-tabs-loading"), 
                o.removeAttr("aria-busy"), e === s.xhr && delete s.xhr;
            }
            var s = this, n = this.tabs.eq(t), t = n.find(".ui-tabs-anchor"), o = this._getPanelForTab(n), r = {
                tab: n,
                panel: o
            };
            this._isLocal(t[0]) || (this.xhr = e.ajax(this._ajaxSettings(t, i, r)), 
            this.xhr && "canceled" !== this.xhr.statusText && (n.addClass("ui-tabs-loading"), 
            o.attr("aria-busy", "true"), this.xhr.done(function(e, t, n) {
                setTimeout(function() {
                    o.html(e), s._trigger("load", i, r), h(n, t);
                }, 1);
            }).fail(function(e, t) {
                setTimeout(function() {
                    h(e, t);
                }, 1);
            })));
        },
        _ajaxSettings: function(t, i, s) {
            var n = this;
            return {
                url: t.attr("href"),
                beforeSend: function(t, a) {
                    return n._trigger("beforeLoad", i, e.extend({
                        jqXHR: t,
                        ajaxSettings: a
                    }, s));
                }
            };
        },
        _getPanelForTab: function(t) {
            t = e(t).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + t));
        }
    });
}), !function(t, e) {
    "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("Noty", [], e) : "object" == typeof exports ? exports.Noty = e() : t.Noty = e();
}(this, function() {
    return t = [ function(t, e, n) {
        "use strict";
        function u(t, e, n) {
            var o = 3 < arguments.length && void 0 !== arguments[3] && arguments[3];
            e = e.split(" ");
            for (var i = 0; i < e.length; i++) document.addEventListener ? t.addEventListener(e[i], n, o) : document.attachEvent && t.attachEvent("on" + e[i], n);
        }
        function a(t, e) {
            return 0 <= ("string" == typeof t ? t : f(t)).indexOf(" " + e + " ");
        }
        function d(t) {
            t.parentNode && t.parentNode.removeChild(t);
        }
        function f(t) {
            return (" " + (t && t.className || "") + " ").replace(/\s+/gi, " ");
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.css = e.deepExtend = e.animationEndEvents = void 0;
        var v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t;
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        };
        e.inArray = function(t, e, n) {
            var o = void 0;
            for (o in e) if (e.hasOwnProperty(o) && e[o] === t) return !0;
            return !1;
        }, e.stopPropagation = function(t) {
            void 0 !== (t = t || window.event).stopPropagation ? t.stopPropagation() : t.cancelBubble = !0;
        }, e.generateID = function() {
            return "noty_" + (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "") + "_" + "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
                var e = 16 * Math.random() | 0;
                return ("x" === t ? e : 3 & e | 8).toString(16);
            });
        }, e.outerHeight = function(t) {
            var e = t.offsetHeight, t = window.getComputedStyle(t);
            return e + (parseInt(t.marginTop) + parseInt(t.marginBottom));
        }, e.addListener = u, e.hasClass = a, e.addClass = function(t, e) {
            var n = f(t), o = n + e;
            a(n, e) || (t.className = o.substring(1));
        }, e.removeClass = function(t, e) {
            var n = f(t), o = void 0;
            a(t, e) && (o = n.replace(" " + e + " ", " "), t.className = o.substring(1, o.length - 1));
        }, e.remove = d, e.classList = f, e.visibilityChangeFlow = function() {
            function o() {
                b.PageHidden ? setTimeout(function() {
                    Object.keys(b.Store).forEach(function(t) {
                        b.Store.hasOwnProperty(t) && b.Store[t].options.visibilityControl && b.Store[t].stop();
                    });
                }, 100) : setTimeout(function() {
                    Object.keys(b.Store).forEach(function(t) {
                        b.Store.hasOwnProperty(t) && b.Store[t].options.visibilityControl && b.Store[t].resume();
                    }), b.queueRenderAll();
                }, 100);
            }
            var s = void 0, a = void 0;
            void 0 !== document.hidden ? (s = "hidden", a = "visibilitychange") : void 0 !== document.msHidden ? (s = "msHidden", 
            a = "msvisibilitychange") : void 0 !== document.webkitHidden && (s = "webkitHidden", 
            a = "webkitvisibilitychange"), a && u(document, a, function() {
                b.PageHidden = document[s], o();
            }), u(window, "blur", function() {
                b.PageHidden = !0, o();
            }), u(window, "focus", function() {
                b.PageHidden = !1, o();
            });
        }, e.createAudioElements = function(t) {
            var e;
            t.hasSound && (e = document.createElement("audio"), t.options.sounds.sources.forEach(function(t) {
                var n = document.createElement("source");
                n.src = t, n.type = "audio/" + t.match(/\.([^.]+)$/)[1], e.appendChild(n);
            }), (t.barDom || document.querySelector("body")).appendChild(e), e.volume = t.options.sounds.volume, 
            t.soundPlayed || (e.play(), t.soundPlayed = !0), e.onended = function() {
                d(e);
            });
        };
        var b = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t) for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e.default = t, e;
        }(n(1));
        e.animationEndEvents = "webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", 
        e.deepExtend = function t(e) {
            e = e || {};
            for (var n = 1; n < arguments.length; n++) {
                var o = arguments[n];
                if (o) for (var i in o) o.hasOwnProperty(i) && (!Array.isArray(o[i]) && "object" === v(o[i]) && null !== o[i] ? e[i] = t(e[i], o[i]) : e[i] = o[i]);
            }
            return e;
        }, e.css = function() {
            function n(n) {
                return n = function(t) {
                    return t.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(t, e) {
                        return e.toUpperCase();
                    });
                }(n), r[n] || (r[n] = function(t) {
                    var e = document.body.style;
                    if (!(t in e)) for (var r, n = i.length, o = t.charAt(0).toUpperCase() + t.slice(1); n--; ) if ((r = i[n] + o) in e) return r;
                    return t;
                }(n));
            }
            function o(t, e, o) {
                e = n(e), t.style[e] = o;
            }
            var i = [ "Webkit", "O", "Moz", "ms" ], r = {};
            return function(t, e) {
                var n = arguments, i = void 0, r = void 0;
                if (2 === n.length) for (i in e) e.hasOwnProperty(i) && void 0 !== (r = e[i]) && e.hasOwnProperty(i) && o(t, i, r); else o(t, n[1], n[2]);
            };
        }();
    }, function(t, e, n) {
        "use strict";
        function s() {
            var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "global";
            E.hasOwnProperty(t) && (t = E[t].queue.shift()) && t.show();
        }
        function l(t) {
            return !(!t.options.buttons || !Object.keys(t.options.buttons).length);
        }
        function v(t) {
            t.options.timeout && (t.options.progressBar && t.progressDom && k.css(t.progressDom, {
                transition: "width " + t.options.timeout + "ms linear",
                width: "0%"
            }), clearTimeout(t.closeTimer), t.closeTimer = setTimeout(function() {
                t.close();
            }, t.options.timeout));
        }
        function y(t) {
            t.options.timeout && t.closeTimer && (clearTimeout(t.closeTimer), t.closeTimer = -1, 
            t.options.progressBar && t.progressDom && k.css(t.progressDom, {
                transition: "width 0ms linear",
                width: "100%"
            }));
        }
        function b(t, e) {
            t.listeners.hasOwnProperty(e) && t.listeners[e].forEach(function(e) {
                "function" == typeof e && e.apply(t);
            });
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.Defaults = e.Store = e.Queues = e.DefaultMaxVisible = e.docTitle = e.DocModalCount = e.PageHidden = void 0, 
        e.getQueueCounts = function() {
            var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "global", e = 0, n = x;
            return E.hasOwnProperty(t) && (n = E[t].maxVisible, Object.keys(P).forEach(function(n) {
                P[n].options.queue !== t || P[n].closed || e++;
            })), {
                current: e,
                maxVisible: n
            };
        }, e.addToQueue = function(t) {
            E.hasOwnProperty(t.options.queue) || (E[t.options.queue] = {
                maxVisible: x,
                queue: []
            }), E[t.options.queue].queue.push(t);
        }, e.removeFromQueue = function(t) {
            var e;
            E.hasOwnProperty(t.options.queue) && (e = [], Object.keys(E[t.options.queue].queue).forEach(function(n) {
                E[t.options.queue].queue[n].id !== t.id && e.push(E[t.options.queue].queue[n]);
            }), E[t.options.queue].queue = e);
        }, e.queueRender = s, e.queueRenderAll = function() {
            Object.keys(E).forEach(function(t) {
                s(t);
            });
        }, e.ghostFix = function(t) {
            var e = k.generateID("ghost"), n = document.createElement("div");
            n.setAttribute("id", e), k.css(n, {
                height: k.outerHeight(t.barDom) + "px"
            }), t.barDom.insertAdjacentHTML("afterend", n.outerHTML), k.remove(t.barDom), 
            n = document.getElementById(e), k.addClass(n, "noty_fix_effects_height"), 
            k.addListener(n, k.animationEndEvents, function() {
                k.remove(n);
            });
        }, e.build = function(t) {
            !function(t) {
                var e;
                t.options.container ? t.layoutDom = document.querySelector(t.options.container) : (e = "noty_layout__" + t.options.layout, 
                t.layoutDom = document.querySelector("div#" + e), t.layoutDom || (t.layoutDom = document.createElement("div"), 
                t.layoutDom.setAttribute("id", e), t.layoutDom.setAttribute("role", "alert"), 
                t.layoutDom.setAttribute("aria-live", "polite"), k.addClass(t.layoutDom, "noty_layout"), 
                document.querySelector("body").appendChild(t.layoutDom)));
            }(t);
            var e = '<div class="noty_body">' + t.options.text + "</div>" + function(t) {
                {
                    var e;
                    if (l(t)) return e = document.createElement("div"), k.addClass(e, "noty_buttons"), 
                    Object.keys(t.options.buttons).forEach(function(n) {
                        e.appendChild(t.options.buttons[n].dom);
                    }), t.options.buttons.forEach(function(t) {
                        e.appendChild(t.dom);
                    }), e.outerHTML;
                }
                return "";
            }(t) + '<div class="noty_progressbar"></div>';
            t.barDom = document.createElement("div"), t.barDom.setAttribute("id", t.id), 
            k.addClass(t.barDom, "noty_bar noty_type__" + t.options.type + " noty_theme__" + t.options.theme), 
            t.barDom.innerHTML = e, b(t, "onTemplate");
        }, e.hasButtons = l, e.handleModal = function(t) {
            t.options.modal && (0 === C && function() {
                var t = document.querySelector("body"), e = document.createElement("div");
                k.addClass(e, "noty_modal"), t.insertBefore(e, t.firstChild), k.addClass(e, "noty_modal_open"), 
                k.addListener(e, k.animationEndEvents, function() {
                    k.removeClass(e, "noty_modal_open");
                });
            }(), e.DocModalCount = C += 1);
        }, e.handleModalClose = function(t) {
            var n;
            t.options.modal && 0 < C && (e.DocModalCount = --C, C <= 0) && ((n = document.querySelector(".noty_modal")) && (k.removeClass(n, "noty_modal_open"), 
            k.addClass(n, "noty_modal_close"), k.addListener(n, k.animationEndEvents, function() {
                k.remove(n);
            })));
        }, e.queueClose = v, e.dequeueClose = y, e.fire = b, e.openFlow = function(t) {
            b(t, "afterShow"), v(t), k.addListener(t.barDom, "mouseenter", function() {
                y(t);
            }), k.addListener(t.barDom, "mouseleave", function() {
                v(t);
            });
        }, e.closeFlow = function(t) {
            delete P[t.id], t.closing = !1, b(t, "afterClose"), k.remove(t.barDom), 
            0 !== t.layoutDom.querySelectorAll(".noty_bar").length || t.options.container || k.remove(t.layoutDom), 
            (k.inArray("docVisible", t.options.titleCount.conditions) || k.inArray("docHidden", t.options.titleCount.conditions)) && D.decrement(), 
            s(t.options.queue);
        };
        var k = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t) for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e.default = t, e;
        }(n(0)), C = (e.PageHidden = !1, e.DocModalCount = 0), S = {
            originalTitle: null,
            count: 0,
            changed: !1,
            timer: -1
        }, D = e.docTitle = {
            increment: function() {
                S.count++, D._update();
            },
            decrement: function() {
                --S.count <= 0 ? D._clear() : D._update();
            },
            _update: function() {
                var t = document.title;
                S.changed ? document.title = "(" + S.count + ") " + S.originalTitle : (S.originalTitle = t, 
                document.title = "(" + S.count + ") " + t, S.changed = !0);
            },
            _clear: function() {
                S.changed && (S.count = 0, document.title = S.originalTitle, S.changed = !1);
            }
        }, x = e.DefaultMaxVisible = 5, E = e.Queues = {
            global: {
                maxVisible: x,
                queue: []
            }
        }, P = e.Store = {};
        e.Defaults = {
            type: "alert",
            layout: "topRight",
            theme: "mint",
            text: "",
            timeout: !1,
            progressBar: !0,
            closeWith: [ "click" ],
            animation: {
                open: "noty_effects_open",
                close: "noty_effects_close"
            },
            id: !1,
            force: !1,
            killer: !1,
            queue: "global",
            container: !1,
            buttons: [],
            callbacks: {
                beforeShow: null,
                onShow: null,
                afterShow: null,
                onClose: null,
                afterClose: null,
                onClick: null,
                onHover: null,
                onTemplate: null
            },
            sounds: {
                sources: [],
                volume: 1,
                conditions: []
            },
            titleCount: {
                conditions: []
            },
            modal: !1,
            visibilityControl: !1
        };
    }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.NotyButton = void 0;
        var r = function(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t) for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e.default = t, e;
        }(n(0));
        e.NotyButton = function t(e, n, i) {
            var s = this, u = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};
            return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
            }(this, t), this.dom = document.createElement("button"), this.dom.innerHTML = e, 
            this.id = u.id = u.id || r.generateID("button"), this.cb = i, Object.keys(u).forEach(function(t) {
                s.dom.setAttribute(t, u[t]);
            }), r.addClass(this.dom, n || "noty_btn"), this;
        };
    }, function(t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var i = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), 
                    Object.defineProperty(t, o.key, o);
                }
            }
            return function(e, n, o) {
                return n && t(e.prototype, n), o && t(e, o), e;
            };
        }();
        e.Push = function() {
            function t() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "/service-worker.js";
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, t), this.subData = {}, this.workerPath = e, this.listeners = {
                    onPermissionGranted: [],
                    onPermissionDenied: [],
                    onSubscriptionSuccess: [],
                    onSubscriptionCancel: [],
                    onWorkerError: [],
                    onWorkerSuccess: [],
                    onWorkerNotSupported: []
                }, this;
            }
            return i(t, [ {
                key: "on",
                value: function(t) {
                    var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : function() {};
                    return "function" == typeof e && this.listeners.hasOwnProperty(t) && this.listeners[t].push(e), 
                    this;
                }
            }, {
                key: "fire",
                value: function(t) {
                    var e = this, n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : [];
                    this.listeners.hasOwnProperty(t) && this.listeners[t].forEach(function(t) {
                        "function" == typeof t && t.apply(e, n);
                    });
                }
            }, {
                key: "create",
                value: function() {
                    console.log("NOT IMPLEMENTED YET");
                }
            }, {
                key: "isSupported",
                value: function() {
                    var t = !1;
                    try {
                        t = window.Notification || window.webkitNotifications || navigator.mozNotification || window.external && void 0 !== window.external.msIsSiteMode();
                    } catch (t) {}
                    return t;
                }
            }, {
                key: "getPermissionStatus",
                value: function() {
                    var t = "default";
                    if (window.Notification && window.Notification.permissionLevel) t = window.Notification.permissionLevel; else if (window.webkitNotifications && window.webkitNotifications.checkPermission) switch (window.webkitNotifications.checkPermission()) {
                      case 1:
                        t = "default";
                        break;

                      case 0:
                        t = "granted";
                        break;

                      default:
                        t = "denied";
                    } else window.Notification && window.Notification.permission ? t = window.Notification.permission : navigator.mozNotification ? t = "granted" : window.external && void 0 !== window.external.msIsSiteMode() && (t = window.external.msIsSiteMode() ? "granted" : "default");
                    return t.toString().toLowerCase();
                }
            }, {
                key: "getEndpoint",
                value: function(t) {
                    var e = t.endpoint, t = t.subscriptionId;
                    return t && -1 === e.indexOf(t) && (e += "/" + t), e;
                }
            }, {
                key: "isSWRegistered",
                value: function() {
                    try {
                        return "activated" === navigator.serviceWorker.controller.state;
                    } catch (t) {
                        return !1;
                    }
                }
            }, {
                key: "unregisterWorker",
                value: function() {
                    var t = this;
                    "serviceWorker" in navigator && navigator.serviceWorker.getRegistrations().then(function(e) {
                        var n = !0, o = !1, i = void 0;
                        try {
                            for (var r, s = e[Symbol.iterator](); !(n = (r = s.next()).done); n = !0) r.value.unregister(), 
                            t.fire("onSubscriptionCancel");
                        } catch (t) {
                            o = !0, i = t;
                        } finally {
                            try {
                                !n && s.return && s.return();
                            } finally {
                                if (o) throw i;
                            }
                        }
                    });
                }
            }, {
                key: "requestSubscription",
                value: function() {
                    function i(o) {
                        "granted" === o ? (t.fire("onPermissionGranted"), "serviceWorker" in navigator ? navigator.serviceWorker.register(t.workerPath).then(function() {
                            navigator.serviceWorker.ready.then(function(t) {
                                n.fire("onWorkerSuccess"), t.pushManager.subscribe({
                                    userVisibleOnly: e
                                }).then(function(t) {
                                    var e = t.getKey("p256dh"), o = t.getKey("auth");
                                    n.subData = {
                                        endpoint: n.getEndpoint(t),
                                        p256dh: e ? window.btoa(String.fromCharCode.apply(null, new Uint8Array(e))) : null,
                                        auth: o ? window.btoa(String.fromCharCode.apply(null, new Uint8Array(o))) : null
                                    }, n.fire("onSubscriptionSuccess", [ n.subData ]);
                                }).catch(function(t) {
                                    n.fire("onWorkerError", [ t ]);
                                });
                            });
                        }) : n.fire("onWorkerNotSupported")) : "denied" === o && (t.fire("onPermissionDenied"), 
                        t.unregisterWorker());
                    }
                    var t = this, e = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0], n = this, o = this.getPermissionStatus();
                    "default" === o ? window.Notification && window.Notification.requestPermission ? window.Notification.requestPermission(i) : window.webkitNotifications && window.webkitNotifications.checkPermission && window.webkitNotifications.requestPermission(i) : i(o);
                }
            } ]), t;
        }();
    }, function(t, e, n) {
        !function(e, o) {
            !function(n) {
                t.exports = n();
            }(function() {
                "use strict";
                function i(t) {
                    return "function" == typeof t;
                }
                function a() {
                    var t = setTimeout;
                    return function() {
                        return t(c, 1);
                    };
                }
                function c() {
                    for (var t = 0; t < I; t += 2) (0, X[t])(X[t + 1]), X[t] = void 0, 
                    X[t + 1] = void 0;
                    I = 0;
                }
                function l(t, e) {
                    var n = arguments, o = this, i = new this.constructor(f), r = (void 0 === i[tt] && A(i), 
                    o._state);
                    return r ? function() {
                        var t = n[r - 1];
                        U(function() {
                            return P(r, i, t, o._result);
                        });
                    }() : S(o, i, t, e), i;
                }
                function d(t) {
                    var n;
                    return t && "object" == typeof t && t.constructor === this ? t : (g(n = new this(f), t), 
                    n);
                }
                function f() {}
                function m(t) {
                    try {
                        return t.then;
                    } catch (t) {
                        return it.error = t, it;
                    }
                }
                function y(t, e, n) {
                    U(function(t) {
                        var o = !1, i = function(t, e, n, o) {
                            try {
                                t.call(e, n, o);
                            } catch (t) {
                                return t;
                            }
                        }(n, e, function(n) {
                            o || (o = !0, (e !== n ? g : k)(t, n));
                        }, function(e) {
                            o || (o = !0, C(t, e));
                        }, t._label);
                        !o && i && (o = !0, C(t, i));
                    }, t);
                }
                function w(t, e, n) {
                    e.constructor === t.constructor && n === l && e.constructor.resolve === d ? function(t, e) {
                        e._state === nt ? k(t, e._result) : e._state === ot ? C(t, e._result) : S(e, void 0, function(e) {
                            return g(t, e);
                        }, function(e) {
                            return C(t, e);
                        });
                    }(t, e) : n === it ? (C(t, it.error), it.error = null) : void 0 !== n && i(n) ? y(t, e, n) : k(t, e);
                }
                function g(e, n) {
                    e === n ? C(e, new TypeError("You cannot resolve a promise with itself")) : function(t) {
                        var e = typeof t;
                        return null !== t && ("object" == e || "function" == e);
                    }(n) ? w(e, n, m(n)) : k(e, n);
                }
                function _(t) {
                    t._onerror && t._onerror(t._result), D(t);
                }
                function k(t, e) {
                    t._state === et && (t._result = e, t._state = nt, 0 !== t._subscribers.length && U(D, t));
                }
                function C(t, e) {
                    t._state === et && (t._state = ot, t._result = e, U(_, t));
                }
                function S(t, e, n, o) {
                    var i = t._subscribers, r = i.length;
                    t._onerror = null, i[r] = e, i[r + nt] = n, i[r + ot] = o, 0 === r && t._state && U(D, t);
                }
                function D(t) {
                    var e = t._subscribers, n = t._state;
                    if (0 !== e.length) {
                        for (var o, i = void 0, r = t._result, s = 0; s < e.length; s += 3) o = e[s], 
                        i = e[s + n], o ? P(n, o, i, r) : i(r);
                        t._subscribers.length = 0;
                    }
                }
                function x() {
                    this.error = null;
                }
                function P(t, e, n, o) {
                    var r = i(n), s = void 0, u = void 0, a = void 0, c = void 0;
                    if (r) {
                        if ((s = function(t, e) {
                            try {
                                return t(e);
                            } catch (t) {
                                return rt.error = t, rt;
                            }
                        }(n, o)) === rt ? (c = !0, u = s.error, s.error = null) : a = !0, 
                        e === s) return void C(e, new TypeError("A promises callback cannot return that same promise."));
                    } else s = o, a = !0;
                    e._state === et && (r && a ? g(e, s) : c ? C(e, u) : t === nt ? k(e, s) : t === ot && C(e, s));
                }
                function A(t) {
                    t[tt] = st++, t._state = void 0, t._result = void 0, t._subscribers = [];
                }
                function M(t, e) {
                    this._instanceConstructor = t, this.promise = new t(f), this.promise[tt] || A(this.promise), 
                    F(e) ? (this.length = e.length, this._remaining = e.length, 
                    this._result = new Array(this.length), 0 !== this.length && (this.length = this.length || 0, 
                    this._enumerate(e), 0 !== this._remaining) || k(this.promise, this._result)) : C(this.promise, new Error("Array Methods must be provided an Array"));
                }
                function Q(t) {
                    if (this[tt] = st++, this._result = this._state = void 0, this._subscribers = [], 
                    f !== t) {
                        if ("function" != typeof t) throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                        if (!(this instanceof Q)) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                        !function(t, e) {
                            try {
                                e(function(e) {
                                    g(t, e);
                                }, function(e) {
                                    C(t, e);
                                });
                            } catch (e) {
                                C(t, e);
                            }
                        }(this, t);
                    }
                }
                var F = Array.isArray || function(t) {
                    return "[object Array]" === Object.prototype.toString.call(t);
                }, I = 0, R = void 0, z = void 0, U = function(t, e) {
                    X[I] = t, X[I + 1] = e, 2 === (I += 2) && (z ? z(c) : Z());
                }, Y = "undefined" != typeof window ? window : void 0, K = Y || {}, G = K.MutationObserver || K.WebKitMutationObserver, K = "undefined" == typeof self && void 0 !== e && "[object process]" === {}.toString.call(e), J = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel, X = new Array(1e3), Z = void 0, Z = K ? function() {
                    return e.nextTick(c);
                } : (G ? function() {
                    var t = 0, e = new G(c), n = document.createTextNode("");
                    return e.observe(n, {
                        characterData: !0
                    }), function() {
                        n.data = t = ++t % 2;
                    };
                } : J ? function() {
                    var t = new MessageChannel();
                    return t.port1.onmessage = c, function() {
                        return t.port2.postMessage(0);
                    };
                } : void 0 === Y ? function() {
                    try {
                        var t = n(9);
                        return void 0 !== (R = t.runOnLoop || t.runOnContext) ? function() {
                            R(c);
                        } : a();
                    } catch (t) {
                        return a();
                    }
                } : a)(), tt = Math.random().toString(36).substring(16), et = void 0, nt = 1, ot = 2, it = new x(), rt = new x(), st = 0;
                return M.prototype._enumerate = function(t) {
                    for (var e = 0; this._state === et && e < t.length; e++) this._eachEntry(t[e], e);
                }, M.prototype._eachEntry = function(t, e) {
                    var i, r, n = this._instanceConstructor, o = n.resolve;
                    o === d ? (i = m(t)) === l && t._state !== et ? this._settledAt(t._state, e, t._result) : "function" != typeof i ? (this._remaining--, 
                    this._result[e] = t) : n === Q ? (w(r = new n(f), t, i), this._willSettleAt(r, e)) : this._willSettleAt(new n(function(e) {
                        return e(t);
                    }), e) : this._willSettleAt(o(t), e);
                }, M.prototype._settledAt = function(t, e, n) {
                    var o = this.promise;
                    o._state === et && (this._remaining--, t === ot ? C(o, n) : this._result[e] = n), 
                    0 === this._remaining && k(o, this._result);
                }, M.prototype._willSettleAt = function(t, e) {
                    var n = this;
                    S(t, void 0, function(t) {
                        return n._settledAt(nt, e, t);
                    }, function(t) {
                        return n._settledAt(ot, e, t);
                    });
                }, Q.all = function(t) {
                    return new M(this, t).promise;
                }, Q.race = function(t) {
                    var e = this;
                    return new e(F(t) ? function(n, o) {
                        for (var i = t.length, r = 0; r < i; r++) e.resolve(t[r]).then(n, o);
                    } : function(t, e) {
                        return e(new TypeError("You must pass an array to race."));
                    });
                }, Q.resolve = d, Q.reject = function(t) {
                    var n = new this(f);
                    return C(n, t), n;
                }, Q._setScheduler = function(t) {
                    z = t;
                }, Q._setAsap = function(t) {
                    U = t;
                }, Q._asap = U, Q.prototype = {
                    constructor: Q,
                    then: l,
                    catch: function(t) {
                        return this.then(null, t);
                    }
                }, Q.polyfill = function() {
                    var t = void 0;
                    if (void 0 !== o) t = o; else if ("undefined" != typeof self) t = self; else try {
                        t = Function("return this")();
                    } catch (t) {
                        throw new Error("polyfill failed because global object is unavailable in this environment");
                    }
                    var e = t.Promise;
                    if (e) {
                        var n = null;
                        try {
                            n = Object.prototype.toString.call(e.resolve());
                        } catch (t) {}
                        if ("[object Promise]" === n && !e.cast) return;
                    }
                    t.Promise = Q;
                }, Q.Promise = Q;
            });
        }.call(e, n(7), n(8));
    }, function(t, e) {}, function(t, e, n) {
        "use strict";
        function o(t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t) for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e.default = t, e;
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var r = function() {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), 
                    Object.defineProperty(t, o.key, o);
                }
            }
            return function(e, n, o) {
                return n && t(e.prototype, n), o && t(e, o), e;
            };
        }(), s = (n(5), n(4)), u = s && s.__esModule ? s : {
            default: s
        }, c = o(n(0)), d = o(n(1)), f = n(2), h = n(3), s = function() {
            function t() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
                return function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
                }(this, t), this.options = c.deepExtend({}, d.Defaults, e), d.Store[this.options.id] || (this.id = this.options.id || c.generateID("bar"), 
                this.closeTimer = -1, this.barDom = null, this.layoutDom = null, 
                this.progressDom = null, this.showing = !1, this.shown = !1, this.closed = !1, 
                this.closing = !1, this.killable = this.options.timeout || 0 < this.options.closeWith.length, 
                this.hasSound = 0 < this.options.sounds.sources.length, this.soundPlayed = !1, 
                this.listeners = {
                    beforeShow: [],
                    onShow: [],
                    afterShow: [],
                    onClose: [],
                    afterClose: [],
                    onClick: [],
                    onHover: [],
                    onTemplate: []
                }, this.promises = {
                    show: null,
                    close: null
                }, this.on("beforeShow", this.options.callbacks.beforeShow), this.on("onShow", this.options.callbacks.onShow), 
                this.on("afterShow", this.options.callbacks.afterShow), this.on("onClose", this.options.callbacks.onClose), 
                this.on("afterClose", this.options.callbacks.afterClose), this.on("onClick", this.options.callbacks.onClick), 
                this.on("onHover", this.options.callbacks.onHover), this.on("onTemplate", this.options.callbacks.onTemplate), 
                this);
            }
            return r(t, [ {
                key: "on",
                value: function(t) {
                    var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : function() {};
                    return "function" == typeof e && this.listeners.hasOwnProperty(t) && this.listeners[t].push(e), 
                    this;
                }
            }, {
                key: "show",
                value: function() {
                    var n, e = this;
                    return this.showing || this.shown || (!0 === this.options.killer ? t.closeAll() : "string" == typeof this.options.killer && t.closeAll(this.options.killer), 
                    (n = d.getQueueCounts(this.options.queue)).current >= n.maxVisible || d.PageHidden && this.options.visibilityControl ? (d.addToQueue(this), 
                    d.PageHidden && this.hasSound && c.inArray("docHidden", this.options.sounds.conditions) && c.createAudioElements(this), 
                    d.PageHidden && c.inArray("docHidden", this.options.titleCount.conditions) && d.docTitle.increment()) : (d.Store[this.id] = this, 
                    d.fire(this, "beforeShow"), this.showing = !0, this.closing ? this.showing = !1 : (d.build(this), 
                    d.handleModal(this), this.options.force ? this.layoutDom.insertBefore(this.barDom, this.layoutDom.firstChild) : this.layoutDom.appendChild(this.barDom), 
                    this.hasSound && !this.soundPlayed && c.inArray("docVisible", this.options.sounds.conditions) && c.createAudioElements(this), 
                    c.inArray("docVisible", this.options.titleCount.conditions) && d.docTitle.increment(), 
                    this.shown = !0, this.closed = !1, d.hasButtons(this) && Object.keys(this.options.buttons).forEach(function(t) {
                        var n = e.barDom.querySelector("#" + e.options.buttons[t].id);
                        c.addListener(n, "click", function(n) {
                            c.stopPropagation(n), e.options.buttons[t].cb(e);
                        });
                    }), this.progressDom = this.barDom.querySelector(".noty_progressbar"), 
                    c.inArray("click", this.options.closeWith) && (c.addClass(this.barDom, "noty_close_with_click"), 
                    c.addListener(this.barDom, "click", function(t) {
                        c.stopPropagation(t), d.fire(e, "onClick"), e.close();
                    }, !1)), c.addListener(this.barDom, "mouseenter", function() {
                        d.fire(e, "onHover");
                    }, !1), this.options.timeout && c.addClass(this.barDom, "noty_has_timeout"), 
                    this.options.progressBar && c.addClass(this.barDom, "noty_has_progressbar"), 
                    c.inArray("button", this.options.closeWith) && (c.addClass(this.barDom, "noty_close_with_button"), 
                    n = document.createElement("div"), c.addClass(n, "noty_close_button"), 
                    n.innerHTML = "", this.barDom.appendChild(n), c.addListener(n, "click", function(t) {
                        c.stopPropagation(t), e.close();
                    }, !1)), d.fire(this, "onShow"), null === this.options.animation.open ? this.promises.show = new u.default(function(t) {
                        t();
                    }) : "function" == typeof this.options.animation.open ? this.promises.show = new u.default(this.options.animation.open.bind(this)) : (c.addClass(this.barDom, this.options.animation.open), 
                    this.promises.show = new u.default(function(t) {
                        c.addListener(e.barDom, c.animationEndEvents, function() {
                            c.removeClass(e.barDom, e.options.animation.open), t();
                        });
                    })), this.promises.show.then(function() {
                        var t = e;
                        setTimeout(function() {
                            d.openFlow(t);
                        }, 100);
                    })))), this;
                }
            }, {
                key: "stop",
                value: function() {
                    return d.dequeueClose(this), this;
                }
            }, {
                key: "resume",
                value: function() {
                    return d.queueClose(this), this;
                }
            }, {
                key: "setTimeout",
                value: function(t) {
                    function e(e) {
                        return t.apply(this, arguments);
                    }
                    return e.toString = function() {
                        return t.toString();
                    }, e;
                }(function(t) {
                    var e;
                    return this.stop(), this.options.timeout = t, this.barDom && (this.options.timeout ? c.addClass(this.barDom, "noty_has_timeout") : c.removeClass(this.barDom, "noty_has_timeout"), 
                    e = this, setTimeout(function() {
                        e.resume();
                    }, 100)), this;
                })
            }, {
                key: "setText",
                value: function(t) {
                    var e = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                    return this.barDom && (this.barDom.querySelector(".noty_body").innerHTML = t), 
                    e && (this.options.text = t), this;
                }
            }, {
                key: "setType",
                value: function(t) {
                    var e = this, n = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                    return this.barDom && (c.classList(this.barDom).split(" ").forEach(function(t) {
                        "noty_type__" === t.substring(0, 11) && c.removeClass(e.barDom, t);
                    }), c.addClass(this.barDom, "noty_type__" + t)), n && (this.options.type = t), 
                    this;
                }
            }, {
                key: "setTheme",
                value: function(t) {
                    var e = this, n = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                    return this.barDom && (c.classList(this.barDom).split(" ").forEach(function(t) {
                        "noty_theme__" === t.substring(0, 12) && c.removeClass(e.barDom, t);
                    }), c.addClass(this.barDom, "noty_theme__" + t)), n && (this.options.theme = t), 
                    this;
                }
            }, {
                key: "close",
                value: function() {
                    var t = this;
                    return this.closed || (this.shown ? (d.fire(this, "onClose"), 
                    this.closing = !0, null === this.options.animation.close || !1 === this.options.animation.close ? this.promises.close = new u.default(function(t) {
                        t();
                    }) : "function" == typeof this.options.animation.close ? this.promises.close = new u.default(this.options.animation.close.bind(this)) : (c.addClass(this.barDom, this.options.animation.close), 
                    this.promises.close = new u.default(function(e) {
                        c.addListener(t.barDom, c.animationEndEvents, function() {
                            t.options.force ? c.remove(t.barDom) : d.ghostFix(t), 
                            e();
                        });
                    })), this.promises.close.then(function() {
                        d.closeFlow(t), d.handleModalClose(t);
                    }), this.closed = !0) : d.removeFromQueue(this)), this;
                }
            } ], [ {
                key: "closeAll",
                value: function() {
                    var t = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
                    return Object.keys(d.Store).forEach(function(e) {
                        t ? d.Store[e].options.queue === t && d.Store[e].killable && d.Store[e].close() : d.Store[e].killable && d.Store[e].close();
                    }), this;
                }
            }, {
                key: "clearQueue",
                value: function() {
                    var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "global";
                    return d.Queues.hasOwnProperty(t) && (d.Queues[t].queue = []), 
                    this;
                }
            }, {
                key: "overrideDefaults",
                value: function(t) {
                    return d.Defaults = c.deepExtend({}, d.Defaults, t), this;
                }
            }, {
                key: "setMaxVisible",
                value: function() {
                    var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : d.DefaultMaxVisible, e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "global";
                    return d.Queues.hasOwnProperty(e) || (d.Queues[e] = {
                        maxVisible: t,
                        queue: []
                    }), d.Queues[e].maxVisible = t, this;
                }
            }, {
                key: "button",
                value: function(t) {
                    return new f.NotyButton(t, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null, arguments[2], 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {});
                }
            }, {
                key: "version",
                value: function() {
                    return "3.2.0-beta";
                }
            }, {
                key: "Push",
                value: function(t) {
                    return new h.Push(t);
                }
            }, {
                key: "Queues",
                get: function() {
                    return d.Queues;
                }
            }, {
                key: "PageHidden",
                get: function() {
                    return d.PageHidden;
                }
            } ]), t;
        }();
        e.default = s, "undefined" != typeof window && c.visibilityChangeFlow(), 
        t.exports = e.default;
    }, function(t, e) {
        function n() {
            throw new Error("setTimeout has not been defined");
        }
        function o() {
            throw new Error("clearTimeout has not been defined");
        }
        function i(t) {
            if (l === setTimeout) return setTimeout(t, 0);
            if ((l === n || !l) && setTimeout) return (l = setTimeout)(t, 0);
            try {
                return l(t, 0);
            } catch (e) {
                try {
                    return l.call(null, t, 0);
                } catch (e) {
                    return l.call(this, t, 0);
                }
            }
        }
        function s() {
            m && h && (m = !1, h.length ? p = h.concat(p) : v = -1, p.length && u());
        }
        function u() {
            if (!m) {
                var t = i(s);
                m = !0;
                for (var e = p.length; e; ) {
                    for (h = p, p = []; ++v < e; ) h && h[v].run();
                    v = -1, e = p.length;
                }
                h = null, m = !1, function(t) {
                    if (d === clearTimeout) return clearTimeout(t);
                    if ((d === o || !d) && clearTimeout) return (d = clearTimeout)(t);
                    try {
                        d(t);
                    } catch (e) {
                        try {
                            return d.call(null, t);
                        } catch (e) {
                            return d.call(this, t);
                        }
                    }
                }(t);
            }
        }
        function a(t, e) {
            this.fun = t, this.array = e;
        }
        function c() {}
        var l, d, t = t.exports = {};
        try {
            l = "function" == typeof setTimeout ? setTimeout : n;
        } catch (t) {
            l = n;
        }
        try {
            d = "function" == typeof clearTimeout ? clearTimeout : o;
        } catch (t) {
            d = o;
        }
        var h, p = [], m = !1, v = -1;
        t.nextTick = function(t) {
            var e = new Array(arguments.length - 1);
            if (1 < arguments.length) for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
            p.push(new a(t, e)), 1 !== p.length || m || i(u);
        }, a.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, t.title = "browser", t.browser = !0, t.env = {}, t.argv = [], t.version = "", 
        t.versions = {}, t.on = c, t.addListener = c, t.once = c, t.off = c, t.removeListener = c, 
        t.removeAllListeners = c, t.emit = c, t.prependListener = c, t.prependOnceListener = c, 
        t.listeners = function(t) {
            return [];
        }, t.binding = function(t) {
            throw new Error("process.binding is not supported");
        }, t.cwd = function() {
            return "/";
        }, t.chdir = function(t) {
            throw new Error("process.chdir is not supported");
        }, t.umask = function() {
            return 0;
        };
    }, function(t, e) {
        var n = function() {
            return this;
        }();
        try {
            n = n || Function("return this")() || (0, eval)("this");
        } catch (t) {
            "object" == typeof window && (n = window);
        }
        t.exports = n;
    }, function(t, e) {} ], n = {}, e.m = t, e.c = n, e.i = function(t) {
        return t;
    }, e.d = function(t, n, o) {
        e.o(t, n) || Object.defineProperty(t, n, {
            configurable: !1,
            enumerable: !0,
            get: o
        });
    }, e.n = function(t) {
        var n = t && t.__esModule ? function() {
            return t.default;
        } : function() {
            return t;
        };
        return e.d(n, "a", n), n;
    }, e.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
    }, e.p = "", e(e.s = 6);
    function e(o) {
        var i;
        return (n[o] || (i = n[o] = {
            i: o,
            l: !1,
            exports: {}
        }, t[o].call(i.exports, i, i.exports, e), i.l = !0, i)).exports;
    }
    var t, n;
}), !function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.CodeMirror = factory();
}(this, function() {
    "use strict";
    var userAgent = navigator.userAgent, platform = navigator.platform, gecko = /gecko\/\d/i.test(userAgent), ie_upto10 = /MSIE \d/.test(userAgent), ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent), edge = /Edge\/(\d+)/.exec(userAgent), ie = ie_upto10 || ie_11up || edge, ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]), webkit = !edge && /WebKit\//.test(userAgent), ie_upto10 = webkit && /Qt\/\d+\.\d+/.test(userAgent), chrome = !edge && /Chrome\//.test(userAgent), presto = /Opera\//.test(userAgent), safari = /Apple Computer/.test(navigator.vendor), mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent), phantom = /PhantomJS/.test(userAgent), ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent), android = /Android/.test(userAgent), mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent), mac = ios || /Mac/.test(platform), chromeOS = /\bCrOS\b/.test(userAgent), windows = /win/i.test(platform), ie_11up = presto && userAgent.match(/Version\/(\d*\.\d*)/), flipCtrlCmd = ((ie_11up = ie_11up && Number(ie_11up[1])) && 15 <= ie_11up && (webkit = !(presto = !1)), 
    mac && (ie_upto10 || presto && (null == ie_11up || ie_11up < 12.11))), captureRightClick = gecko || ie && 9 <= ie_version;
    function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    var rmClass = function(node, cls) {
        var after, current = node.className, cls = classTest(cls).exec(current);
        cls && (after = current.slice(cls.index + cls[0].length), node.className = current.slice(0, cls.index) + (after ? cls[1] + after : ""));
    };
    function removeChildren(e) {
        for (var count = e.childNodes.length; 0 < count; --count) e.removeChild(e.firstChild);
        return e;
    }
    function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
    }
    function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className && (e.className = className), style && (e.style.cssText = style), 
        "string" == typeof content) e.appendChild(document.createTextNode(content)); else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
        return e;
    }
    function eltP(tag, content, className, style) {
        tag = elt(tag, content, className, style);
        return tag.setAttribute("role", "presentation"), tag;
    }
    function contains(parent, child) {
        if (3 == child.nodeType && (child = child.parentNode), parent.contains) return parent.contains(child);
        do {
            if ((child = 11 == child.nodeType ? child.host : child) == parent) return !0;
        } while (child = child.parentNode);
    }
    function activeElt() {
        var activeElement;
        try {
            activeElement = document.activeElement;
        } catch (e) {
            activeElement = document.body || null;
        }
        for (;activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement; ) activeElement = activeElement.shadowRoot.activeElement;
        return activeElement;
    }
    function addClass(node, cls) {
        var current = node.className;
        classTest(cls).test(current) || (node.className += (current ? " " : "") + cls);
    }
    function joinClasses(a, b) {
        for (var as = a.split(" "), i = 0; i < as.length; i++) as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
        return b;
    }
    var range = document.createRange ? function(node, start, end, endNode) {
        var r = document.createRange();
        return r.setEnd(endNode || node, end), r.setStart(node, start), r;
    } : function(node, start, end) {
        var r = document.body.createTextRange();
        try {
            r.moveToElementText(node.parentNode);
        } catch (e) {
            return r;
        }
        return r.collapse(!0), r.moveEnd("character", end), r.moveStart("character", start), 
        r;
    }, selectInput = function(node) {
        node.select();
    };
    function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
            return f.apply(null, args);
        };
    }
    function copyObj(obj, target, overwrite) {
        for (var prop in target = target || {}, obj) !obj.hasOwnProperty(prop) || !1 === overwrite && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
        return target;
    }
    function countColumn(string, end, tabSize, startIndex, startValue) {
        null == end && -1 == (end = string.search(/[^\s\u00a0]/)) && (end = string.length);
        for (var i = startIndex || 0, n = startValue || 0; ;) {
            var nextTab = string.indexOf("\t", i);
            if (nextTab < 0 || end <= nextTab) return n + (end - i);
            n = (n += nextTab - i) + (tabSize - n % tabSize), i = nextTab + 1;
        }
    }
    ios ? selectInput = function(node) {
        node.selectionStart = 0, node.selectionEnd = node.value.length;
    } : ie && (selectInput = function(node) {
        try {
            node.select();
        } catch (_e) {}
    });
    function Delayed() {
        this.id = null;
    }
    function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i) if (array[i] == elt) return i;
        return -1;
    }
    var scrollerGap = 30, Pass = {
        toString: function() {
            return "CodeMirror.Pass";
        }
    }, sel_dontScroll = {
        scroll: !(Delayed.prototype.set = function(ms, f) {
            clearTimeout(this.id), this.id = setTimeout(f, ms);
        })
    }, sel_mouse = {
        origin: "*mouse"
    }, sel_move = {
        origin: "+move"
    };
    function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0; ;) {
            var nextTab = string.indexOf("\t", pos), skipped = (nextTab = -1 == nextTab ? string.length : nextTab) - pos;
            if (nextTab == string.length || goal <= col + skipped) return pos + Math.min(skipped, goal - col);
            if (col += nextTab - pos, pos = nextTab + 1, goal <= (col += tabSize - col % tabSize)) return pos;
        }
    }
    var spaceStrs = [ "" ];
    function spaceStr(n) {
        for (;spaceStrs.length <= n; ) spaceStrs.push(lst(spaceStrs) + " ");
        return spaceStrs[n];
    }
    function lst(arr) {
        return arr[arr.length - 1];
    }
    function map(array, f) {
        for (var out = [], i = 0; i < array.length; i++) out[i] = f(array[i], i);
        return out;
    }
    function nothing() {}
    function createObj(base, props) {
        base = Object.create ? Object.create(base) : (nothing.prototype = base, 
        new nothing());
        return props && copyObj(props, base), base;
    }
    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch) {
        return /\w/.test(ch) || "" < ch && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    }
    function isWordChar(ch, helper) {
        return helper ? !!(-1 < helper.source.indexOf("\\w") && isWordCharBasic(ch)) || helper.test(ch) : isWordCharBasic(ch);
    }
    function isEmpty(obj) {
        for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return;
        return 1;
    }
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) {
        return 768 <= ch.charCodeAt(0) && extendingChars.test(ch);
    }
    function skipExtendingChars(str, pos, dir) {
        for (;(dir < 0 ? 0 < pos : pos < str.length) && isExtendingChar(str.charAt(pos)); ) pos += dir;
        return pos;
    }
    function findFirst(pred, from, to) {
        for (var dir = to < from ? -1 : 1; ;) {
            if (from == to) return from;
            var midF = (from + to) / 2, midF = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
            if (midF == from) return pred(midF) ? from : to;
            pred(midF) ? to = midF : from = midF + dir;
        }
    }
    function Display(place, doc, input) {
        var d = this, lines = (this.input = input, d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"), 
        d.scrollbarFiller.setAttribute("cm-not-content", "true"), d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"), 
        d.gutterFiller.setAttribute("cm-not-content", "true"), d.lineDiv = eltP("div", null, "CodeMirror-code"), 
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"), 
        d.cursorDiv = elt("div", null, "CodeMirror-cursors"), d.measure = elt("div", null, "CodeMirror-measure"), 
        d.lineMeasure = elt("div", null, "CodeMirror-measure"), d.lineSpace = eltP("div", [ d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv ], null, "position: relative; outline: none"), 
        eltP("div", [ d.lineSpace ], "CodeMirror-lines"));
        d.mover = elt("div", [ lines ], null, "position: relative"), d.sizer = elt("div", [ d.mover ], "CodeMirror-sizer"), 
        d.sizerWidth = null, d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"), 
        d.gutters = elt("div", null, "CodeMirror-gutters"), d.lineGutter = null, 
        d.scroller = elt("div", [ d.sizer, d.heightForcer, d.gutters ], "CodeMirror-scroll"), 
        d.scroller.setAttribute("tabIndex", "-1"), d.wrapper = elt("div", [ d.scrollbarFiller, d.gutterFiller, d.scroller ], "CodeMirror"), 
        ie && ie_version < 8 && (d.gutters.style.zIndex = -1, d.scroller.style.paddingRight = 0), 
        webkit || gecko && mobile || (d.scroller.draggable = !0), place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper)), 
        d.viewFrom = d.viewTo = doc.first, d.reportedViewFrom = d.reportedViewTo = doc.first, 
        d.view = [], d.renderedView = null, d.externalMeasured = null, d.viewOffset = 0, 
        d.lastWrapHeight = d.lastWrapWidth = 0, d.updateLineNumbers = null, d.nativeBarWidth = d.barHeight = d.barWidth = 0, 
        d.scrollbarsClipped = !1, d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null, 
        d.alignWidgets = !1, d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, 
        d.maxLine = null, d.maxLineLength = 0, d.maxLineChanged = !1, d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null, 
        d.shift = !1, d.selForContextMenu = null, d.activeTouch = null, input.init(d);
    }
    function getLine(doc, n) {
        if ((n -= doc.first) < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
        for (var chunk = doc; !chunk.lines; ) for (var i = 0; ;++i) {
            var child = chunk.children[i], sz = child.chunkSize();
            if (n < sz) {
                chunk = child;
                break;
            }
            n -= sz;
        }
        return chunk.lines[n];
    }
    function getBetween(doc, start, end) {
        var out = [], n = start.line;
        return doc.iter(start.line, end.line + 1, function(line) {
            line = line.text;
            n == end.line && (line = line.slice(0, end.ch)), n == start.line && (line = line.slice(start.ch)), 
            out.push(line), ++n;
        }), out;
    }
    function getLines(doc, from, to) {
        var out = [];
        return doc.iter(from, to, function(line) {
            out.push(line.text);
        }), out;
    }
    function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff) for (var n = line; n; n = n.parent) n.height += diff;
    }
    function lineNo(line) {
        if (null == line.parent) return null;
        for (var cur = line.parent, no = indexOf(cur.lines, line), chunk = cur.parent; chunk; chunk = (cur = chunk).parent) for (var i = 0; chunk.children[i] != cur; ++i) no += chunk.children[i].chunkSize();
        return no + cur.first;
    }
    function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
            for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
                var child = chunk.children[i$1], ch = child.height;
                if (h < ch) {
                    chunk = child;
                    continue outer;
                }
                h -= ch, n += child.chunkSize();
            }
            return n;
        } while (!chunk.lines);
        for (var i = 0; i < chunk.lines.length; ++i) {
            var lh = chunk.lines[i].height;
            if (h < lh) break;
            h -= lh;
        }
        return n + i;
    }
    function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
    }
    function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
    }
    function Pos(line, ch, sticky) {
        if (void 0 === sticky && (sticky = null), !(this instanceof Pos)) return new Pos(line, ch, sticky);
        this.line = line, this.ch = ch, this.sticky = sticky;
    }
    function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
    }
    function equalCursorPos(a, b) {
        return a.sticky == b.sticky && 0 == cmp(a, b);
    }
    function copyPos(x) {
        return Pos(x.line, x.ch);
    }
    function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
    }
    function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
    }
    function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
        var last;
        return pos.line < doc.first ? Pos(doc.first, 0) : (last = doc.first + doc.size - 1, 
        pos.line > last ? Pos(last, getLine(doc, last).text.length) : function(pos, linelen) {
            var ch = pos.ch;
            return null == ch || linelen < ch ? Pos(pos.line, linelen) : ch < 0 ? Pos(pos.line, 0) : pos;
        }(pos, getLine(doc, pos.line).text.length));
    }
    function clipPosArray(doc, array) {
        for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
        return out;
    }
    var sawReadOnlySpans = !1, sawCollapsedSpans = !1;
    function MarkedSpan(marker, from, to) {
        this.marker = marker, this.from = from, this.to = to;
    }
    function getMarkedSpanFor(spans, marker) {
        if (spans) for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if (span.marker == marker) return span;
        }
    }
    function stretchSpansOverChange(doc, change) {
        if (change.full) return null;
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans, doc = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !doc) return null;
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = 0 == cmp(change.from, change.to), first = function(old, startCh, isInsert) {
            var nw;
            if (old) for (var i = 0; i < old.length; ++i) {
                var endsAfter, span = old[i], marker = span.marker;
                !(null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh)) && (span.from != startCh || "bookmark" != marker.type || isInsert && span.marker.insertLeft) || (endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh), 
                (nw = nw || []).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to)));
            }
            return nw;
        }(oldFirst, startCh, isInsert), last = function(old, endCh, isInsert) {
            var nw;
            if (old) for (var i = 0; i < old.length; ++i) {
                var startsBefore, span = old[i], marker = span.marker;
                !(null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)) && (span.from != endCh || "bookmark" != marker.type || isInsert && !span.marker.insertLeft) || (startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh), 
                (nw = nw || []).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, null == span.to ? null : span.to - endCh)));
            }
            return nw;
        }(doc, endCh, isInsert), sameLine = 1 == change.text.length, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) for (var i = 0; i < first.length; ++i) {
            var found, span = first[i];
            null == span.to && ((found = getMarkedSpanFor(last, span.marker)) ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh);
        }
        if (last) for (var i$1 = 0; i$1 < last.length; ++i$1) {
            var span$1 = last[i$1];
            null != span$1.to && (span$1.to += offset), null == span$1.from ? getMarkedSpanFor(first, span$1.marker) || (span$1.from = offset, 
            sameLine && (first = first || []).push(span$1)) : (span$1.from += offset, 
            sameLine && (first = first || []).push(span$1));
        }
        first = first && clearEmptySpans(first), last && last != first && (last = clearEmptySpans(last));
        var newMarkers = [ first ];
        if (!sameLine) {
            var gapMarkers, gap = change.text.length - 2;
            if (0 < gap && first) for (var i$2 = 0; i$2 < first.length; ++i$2) null == first[i$2].to && (gapMarkers = gapMarkers || []).push(new MarkedSpan(first[i$2].marker, null, null));
            for (var i$3 = 0; i$3 < gap; ++i$3) newMarkers.push(gapMarkers);
            newMarkers.push(last);
        }
        return newMarkers;
    }
    function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            null != span.from && span.from == span.to && !1 !== span.marker.clearWhenEmpty && spans.splice(i--, 1);
        }
        return spans.length ? spans : null;
    }
    function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (spans) {
            for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
            line.markedSpans = null;
        }
    }
    function attachMarkedSpans(line, spans) {
        if (spans) {
            for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
            line.markedSpans = spans;
        }
    }
    function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a, b) {
        var bPos, fromCmp, lenDiff = a.lines.length - b.lines.length;
        return 0 != lenDiff ? lenDiff : (lenDiff = a.find(), bPos = b.find(), (fromCmp = cmp(lenDiff.from, bPos.from) || extraLeft(a) - extraLeft(b)) ? -fromCmp : cmp(lenDiff.to, bPos.to) || extraRight(a) - extraRight(b) || b.id - a.id);
    }
    function collapsedSpanAtSide(line, start) {
        var found, sps = sawCollapsedSpans && line.markedSpans;
        if (sps) for (var sp, i = 0; i < sps.length; ++i) (sp = sps[i]).marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
        return found;
    }
    function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, !0);
    }
    function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, !1);
    }
    function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
        var doc = getLine(doc, lineNo$$1), sps = sawCollapsedSpans && doc.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];
            if (sp.marker.collapsed) {
                var found = sp.marker.find(0), fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker), toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                if (!(0 <= fromCmp && toCmp <= 0 || fromCmp <= 0 && 0 <= toCmp) && (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? 0 <= cmp(found.to, from) : 0 < cmp(found.to, from)) || 0 <= fromCmp && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))) return 1;
            }
        }
    }
    function visualLine(line) {
        for (var merged; merged = collapsedSpanAtStart(line); ) line = merged.find(-1, !0).line;
        return line;
    }
    function visualLineNo(doc, lineN) {
        var doc = getLine(doc, lineN), vis = visualLine(doc);
        return doc == vis ? lineN : lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine()) return lineN;
        var merged, line = getLine(doc, lineN);
        if (!lineIsHidden(doc, line)) return lineN;
        for (;merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
        return lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) for (var sp, i = 0; i < sps.length; ++i) if ((sp = sps[i]).marker.collapsed) {
            if (null == sp.from) return !0;
            if (!sp.marker.widgetNode && 0 == sp.from && sp.marker.inclusiveLeft && function lineIsHiddenInner(doc, line, span) {
                {
                    var end;
                    if (null == span.to) return end = span.marker.find(1, !0), lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
                }
                if (span.marker.inclusiveRight && span.to == line.text.length) return !0;
                for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) if ((sp = line.markedSpans[i]).marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return !0;
            }(doc, line, sp)) return !0;
        }
    }
    function heightAtLine(lineObj) {
        for (var h = 0, chunk = (lineObj = visualLine(lineObj)).parent, i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i];
            if (line == lineObj) break;
            h += line.height;
        }
        for (var p = chunk.parent; p; p = (chunk = p).parent) for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
            var cur = p.children[i$1];
            if (cur == chunk) break;
            h += cur.height;
        }
        return h;
    }
    function lineLength(line) {
        if (0 == line.height) return 0;
        for (var merged, len = line.text.length, cur = line; merged = collapsedSpanAtStart(cur); ) {
            var found = merged.find(0, !0), cur = found.from.line;
            len += found.from.ch - found.to.ch;
        }
        for (cur = line; merged = collapsedSpanAtEnd(cur); ) var found$1 = merged.find(0, !0), len = (len -= cur.text.length - found$1.from.ch) + ((cur = found$1.to.line).text.length - found$1.to.ch);
        return len;
    }
    function findMaxLine(cm) {
        var d = cm.display, cm = cm.doc;
        d.maxLine = getLine(cm, cm.first), d.maxLineLength = lineLength(d.maxLine), 
        d.maxLineChanged = !0, cm.iter(function(line) {
            var len = lineLength(line);
            len > d.maxLineLength && (d.maxLineLength = len, d.maxLine = line);
        });
    }
    var bidiOther = null;
    function getBidiPartAt(order, ch, sticky) {
        var found;
        bidiOther = null;
        for (var i = 0; i < order.length; ++i) {
            var cur = order[i];
            if (cur.from < ch && cur.to > ch) return i;
            cur.to == ch && (cur.from != cur.to && "before" == sticky ? found = i : bidiOther = i), 
            cur.from == ch && (cur.from != cur.to && "before" != sticky ? found = i : bidiOther = i);
        }
        return null != found ? found : bidiOther;
    }
    bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, isNeutral = /[stwN]/, 
    isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    var bidiRE, isNeutral, isStrong, countsAsLeft, countsAsNum, bidiOrdering = function(str, direction) {
        var outerType = "ltr" == direction ? "L" : "R";
        if (0 == str.length || "ltr" == direction && !bidiRE.test(str)) return !1;
        for (var code, len = str.length, types = [], i = 0; i < len; ++i) types.push((code = str.charCodeAt(i)) <= 247 ? "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(code) : 1424 <= code && code <= 1524 ? "R" : 1536 <= code && code <= 1785 ? "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(code - 1536) : 1774 <= code && code <= 2220 ? "r" : 8192 <= code && code <= 8203 ? "w" : 8204 == code ? "b" : "L");
        for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
            var type = types[i$1];
            "m" == type ? types[i$1] = prev : prev = type;
        }
        for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
            var type$1 = types[i$2];
            "1" == type$1 && "r" == cur ? types[i$2] = "n" : isStrong.test(type$1) && "r" == (cur = type$1) && (types[i$2] = "R");
        }
        for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
            var type$2 = types[i$3];
            "+" == type$2 && "1" == prev$1 && "1" == types[i$3 + 1] ? types[i$3] = "1" : "," != type$2 || prev$1 != types[i$3 + 1] || "1" != prev$1 && "n" != prev$1 || (types[i$3] = prev$1), 
            prev$1 = type$2;
        }
        for (var i$4 = 0; i$4 < len; ++i$4) {
            var type$3 = types[i$4];
            if ("," == type$3) types[i$4] = "N"; else if ("%" == type$3) {
                for (var end = void 0, end = i$4 + 1; end < len && "%" == types[end]; ++end);
                for (var replace = i$4 && "!" == types[i$4 - 1] || end < len && "1" == types[end] ? "1" : "N", j = i$4; j < end; ++j) types[j] = replace;
                i$4 = end - 1;
            }
        }
        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
            var type$4 = types[i$5];
            "L" == cur$1 && "1" == type$4 ? types[i$5] = "L" : isStrong.test(type$4) && (cur$1 = type$4);
        }
        for (var i$6 = 0; i$6 < len; ++i$6) if (isNeutral.test(types[i$6])) {
            for (var end$1 = void 0, end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1);
            for (var before = "L" == (i$6 ? types[i$6 - 1] : outerType), replace$1 = before == ("L" == (end$1 < len ? types[end$1] : outerType)) ? before ? "L" : "R" : outerType, j$1 = i$6; j$1 < end$1; ++j$1) types[j$1] = replace$1;
            i$6 = end$1 - 1;
        }
        for (var m, order = [], i$7 = 0; i$7 < len; ) if (countsAsLeft.test(types[i$7])) {
            var start = i$7;
            for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7);
            order.push(new BidiSpan(0, start, i$7));
        } else {
            var pos = i$7, at = order.length;
            for (++i$7; i$7 < len && "L" != types[i$7]; ++i$7);
            for (var j$2 = pos; j$2 < i$7; ) if (countsAsNum.test(types[j$2])) {
                pos < j$2 && order.splice(at, 0, new BidiSpan(1, pos, j$2));
                var nstart = j$2;
                for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2);
                order.splice(at, 0, new BidiSpan(2, nstart, j$2)), pos = j$2;
            } else ++j$2;
            pos < i$7 && order.splice(at, 0, new BidiSpan(1, pos, i$7));
        }
        return 1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length, 
        order.unshift(new BidiSpan(0, 0, m[0].length))), 1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length, 
        order.push(new BidiSpan(0, len - m[0].length, len))), "rtl" == direction ? order.reverse() : order;
    };
    function BidiSpan(level, from, to) {
        this.level = level, this.from = from, this.to = to;
    }
    function getOrder(line, direction) {
        var order = line.order;
        return order = null == order ? line.order = bidiOrdering(line.text, direction) : order;
    }
    var noHandlers = [], on = function(emitter, type, f) {
        emitter.addEventListener ? emitter.addEventListener(type, f, !1) : emitter.attachEvent ? emitter.attachEvent("on" + type, f) : (emitter = emitter._handlers || (emitter._handlers = {}))[type] = (emitter[type] || noHandlers).concat(f);
    };
    function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers;
    }
    function off(emitter, type, f) {
        var arr;
        emitter.removeEventListener ? emitter.removeEventListener(type, f, !1) : emitter.detachEvent ? emitter.detachEvent("on" + type, f) : (arr = (emitter = emitter._handlers) && emitter[type]) && -1 < (f = indexOf(arr, f)) && (emitter[type] = arr.slice(0, f).concat(arr.slice(f + 1)));
    }
    function signal(emitter, type) {
        var handlers = getHandlers(emitter, type);
        if (handlers.length) for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
    }
    function signalDOMEvent(cm, e, override) {
        return "string" == typeof e && (e = {
            type: e,
            preventDefault: function() {
                this.defaultPrevented = !0;
            }
        }), signal(cm, override || e.type, cm, e), e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (arr) for (var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []), i = 0; i < arr.length; ++i) -1 == indexOf(set, arr[i]) && set.push(arr[i]);
    }
    function hasHandler(emitter, type) {
        return 0 < getHandlers(emitter, type).length;
    }
    function eventMixin(ctor) {
        ctor.prototype.on = function(type, f) {
            on(this, type, f);
        }, ctor.prototype.off = function(type, f) {
            off(this, type, f);
        };
    }
    function e_preventDefault(e) {
        e.preventDefault ? e.preventDefault() : e.returnValue = !1;
    }
    function e_stopPropagation(e) {
        e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
    }
    function e_defaultPrevented(e) {
        return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue;
    }
    function e_stop(e) {
        e_preventDefault(e), e_stopPropagation(e);
    }
    function e_target(e) {
        return e.target || e.srcElement;
    }
    function e_button(e) {
        var b = e.which;
        return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)), 
        b = mac && e.ctrlKey && 1 == b ? 3 : b;
    }
    var zwspSupported, badBidiRects, dragAndDrop = !(ie && ie_version < 9) && ("draggable" in (edge = elt("div")) || "dragDrop" in edge);
    var splitLinesAuto = 3 != "\n\nb".split(/\n/).length ? function(string) {
        for (var pos = 0, result = [], l = string.length; pos <= l; ) {
            var nl = string.indexOf("\n", pos), line = (-1 == nl && (nl = string.length), 
            string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl)), rt = line.indexOf("\r");
            -1 != rt ? (result.push(line.slice(0, rt)), pos += rt + 1) : (result.push(line), 
            pos = nl + 1);
        }
        return result;
    } : function(string) {
        return string.split(/\r\n?|\n/);
    }, hasSelection = window.getSelection ? function(te) {
        try {
            return te.selectionStart != te.selectionEnd;
        } catch (e) {
            return !1;
        }
    } : function(te) {
        var range$$1;
        try {
            range$$1 = te.ownerDocument.selection.createRange();
        } catch (e) {}
        return !(!range$$1 || range$$1.parentElement() != te) && 0 != range$$1.compareEndPoints("StartToEnd", range$$1);
    }, hasCopyEvent = "oncopy" in (platform = elt("div")) || (platform.setAttribute("oncopy", "return;"), 
    "function" == typeof platform.oncopy), badZoomedRects = null;
    var modes = {}, mimeModes = {};
    function resolveMode(spec) {
        if ("string" == typeof spec && mimeModes.hasOwnProperty(spec)) spec = mimeModes[spec]; else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            (spec = createObj(found = "string" == typeof found ? {
                name: found
            } : found, spec)).name = found.name;
        } else {
            if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) return resolveMode("application/xml");
            if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) return resolveMode("application/json");
        }
        return "string" == typeof spec ? {
            name: spec
        } : spec || {
            name: "null"
        };
    }
    function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) return getMode(options, "text/plain");
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
            var prop, exts = modeExtensions[spec.name];
            for (prop in exts) exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]), 
            modeObj[prop] = exts[prop]);
        }
        if (modeObj.name = spec.name, spec.helperType && (modeObj.helperType = spec.helperType), 
        spec.modeProps) for (var prop$1 in spec.modeProps) modeObj[prop$1] = spec.modeProps[prop$1];
        return modeObj;
    }
    var modeExtensions = {};
    function extendMode(mode, properties) {
        copyObj(properties, modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {});
    }
    function copyState(mode, state) {
        if (!0 === state) return state;
        if (mode.copyState) return mode.copyState(state);
        var n, nstate = {};
        for (n in state) {
            var val = state[n];
            val instanceof Array && (val = val.concat([])), nstate[n] = val;
        }
        return nstate;
    }
    function innerMode(mode, state) {
        for (var info; mode.innerMode && (info = mode.innerMode(state)) && info.mode != mode; ) state = info.state, 
        mode = info.mode;
        return info || {
            mode: mode,
            state: state
        };
    }
    function startState(mode, a1, a2) {
        return !mode.startState || mode.startState(a1, a2);
    }
    function SavedContext(state, lookAhead) {
        this.state = state, this.lookAhead = lookAhead;
    }
    var StringStream = function(string, tabSize, lineOracle) {
        this.pos = this.start = 0, this.string = string, this.tabSize = tabSize || 8, 
        this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = lineOracle;
    }, Context = (StringStream.prototype.eol = function() {
        return this.pos >= this.string.length;
    }, StringStream.prototype.sol = function() {
        return this.pos == this.lineStart;
    }, StringStream.prototype.peek = function() {
        return this.string.charAt(this.pos) || void 0;
    }, StringStream.prototype.next = function() {
        if (this.pos < this.string.length) return this.string.charAt(this.pos++);
    }, StringStream.prototype.eat = function(match) {
        var ch = this.string.charAt(this.pos), match = "string" == typeof match ? ch == match : ch && (match.test ? match.test(ch) : match(ch));
        if (match) return ++this.pos, ch;
    }, StringStream.prototype.eatWhile = function(match) {
        for (var start = this.pos; this.eat(match); );
        return this.pos > start;
    }, StringStream.prototype.eatSpace = function() {
        for (var start = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); ) ++this.pos;
        return this.pos > start;
    }, StringStream.prototype.skipToEnd = function() {
        this.pos = this.string.length;
    }, StringStream.prototype.skipTo = function(ch) {
        ch = this.string.indexOf(ch, this.pos);
        if (-1 < ch) return this.pos = ch, !0;
    }, StringStream.prototype.backUp = function(n) {
        this.pos -= n;
    }, StringStream.prototype.column = function() {
        return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), 
        this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    }, StringStream.prototype.indentation = function() {
        return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    }, StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
        var match;
        return "string" != typeof pattern ? (match = this.string.slice(this.pos).match(pattern)) && 0 < match.index ? null : (match && !1 !== consume && (this.pos += match[0].length), 
        match) : (match = function(str) {
            return caseInsensitive ? str.toLowerCase() : str;
        })(this.string.substr(this.pos, pattern.length)) == match(pattern) ? (!1 !== consume && (this.pos += pattern.length), 
        !0) : void 0;
    }, StringStream.prototype.current = function() {
        return this.string.slice(this.start, this.pos);
    }, StringStream.prototype.hideFirstChars = function(n, inner) {
        this.lineStart += n;
        try {
            return inner();
        } finally {
            this.lineStart -= n;
        }
    }, StringStream.prototype.lookAhead = function(n) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n);
    }, function(doc, state, line, lookAhead) {
        this.state = state, this.doc = doc, this.line = line, this.maxLookAhead = lookAhead || 0;
    });
    function highlightLine(cm, line, context, forceToEnd) {
        for (var st = [ cm.state.modeGen ], lineClasses = {}, forceToEnd = (runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
            st.push(end, style);
        }, lineClasses, forceToEnd), context.state), o = 0; o < cm.state.overlays.length; ++o) !function(o) {
            var overlay = cm.state.overlays[o], i = 1, at = 0;
            context.state = !0, runMode(cm, line.text, overlay.mode, context, function(end, style) {
                for (var start = i; at < end; ) {
                    var i_end = st[i];
                    end < i_end && st.splice(i, 1, end, st[i + 1], i_end), i += 2, 
                    at = Math.min(end, i_end);
                }
                if (style) if (overlay.opaque) st.splice(start, i - start, end, "overlay " + style), 
                i = start + 2; else for (;start < i; start += 2) {
                    var cur = st[start + 1];
                    st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
                }
            }, lineClasses);
        }(o);
        return context.state = forceToEnd, {
            styles: st,
            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
    }
    function getLineStyles(cm, line, updateFrontier) {
        var context, resetState, result;
        return line.styles && line.styles[0] == cm.state.modeGen || (context = getContextBefore(cm, lineNo(line)), 
        resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state), 
        result = highlightLine(cm, line, context), resetState && (context.state = resetState), 
        line.stateAfter = context.save(!resetState), line.styles = result.styles, 
        result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null), 
        updateFrontier === cm.doc.highlightFrontier && (cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier))), 
        line.styles;
    }
    function getContextBefore(cm, n, precise) {
        var start, saved, context, doc = cm.doc, display = cm.display;
        return doc.mode.startState ? (saved = (start = function(cm, n, precise) {
            for (var minindent, minline, doc = cm.doc, lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; lim < search; --search) {
                if (search <= doc.first) return doc.first;
                var line = getLine(doc, search - 1), after = line.stateAfter;
                if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) return search;
                after = countColumn(line.text, null, cm.options.tabSize);
                (null == minline || after < minindent) && (minline = search - 1, 
                minindent = after);
            }
            return minline;
        }(cm, n, precise)) > doc.first && getLine(doc, start - 1).stateAfter, context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start), 
        doc.iter(start, n, function(line) {
            processLine(cm, line.text, context);
            var pos = context.line;
            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null, 
            context.nextLine();
        }), precise && (doc.modeFrontier = context.line), context) : new Context(doc, !0, n);
    }
    function processLine(cm, text, context, startAt) {
        var mode = cm.doc.mode, stream = new StringStream(text, cm.options.tabSize, context);
        for (stream.start = stream.pos = startAt || 0, "" == text && callBlankLine(mode, context.state); !stream.eol(); ) readToken(mode, stream, context.state), 
        stream.start = stream.pos;
    }
    function callBlankLine(mode, state) {
        return mode.blankLine ? mode.blankLine(state) : mode.innerMode && (mode = innerMode(mode, state)).mode.blankLine ? mode.mode.blankLine(mode.state) : void 0;
    }
    function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
            inner && (inner[0] = innerMode(mode, state).mode);
            var style = mode.token(stream, state);
            if (stream.pos > stream.start) return style;
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
    }
    Context.prototype.lookAhead = function(n) {
        var line = this.doc.getLine(this.line + n);
        return null != line && n > this.maxLookAhead && (this.maxLookAhead = n), 
        line;
    }, Context.prototype.nextLine = function() {
        this.line++, 0 < this.maxLookAhead && this.maxLookAhead--;
    }, Context.fromSaved = function(doc, saved, line) {
        return saved instanceof SavedContext ? new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) : new Context(doc, copyState(doc.mode, saved), line);
    }, Context.prototype.save = function(copy) {
        copy = !1 !== copy ? copyState(this.doc.mode, this.state) : this.state;
        return 0 < this.maxLookAhead ? new SavedContext(copy, this.maxLookAhead) : copy;
    };
    var Token = function(stream, type, state) {
        this.start = stream.start, this.end = stream.pos, this.string = stream.current(), 
        this.type = type || null, this.state = state;
    };
    function takeToken(cm, pos, precise, asArray) {
        var style, tokens, doc = cm.doc, mode = doc.mode, line = getLine(doc, (pos = clipPos(doc, pos)).line), context = getContextBefore(cm, pos.line, precise), stream = new StringStream(line.text, cm.options.tabSize, context);
        for (asArray && (tokens = []); (asArray || stream.pos < pos.ch) && !stream.eol(); ) stream.start = stream.pos, 
        style = readToken(mode, stream, context.state), asArray && tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
        return asArray ? tokens : new Token(stream, style, context.state);
    }
    function extractLineClasses(type, output) {
        if (type) for (;;) {
            var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!lineClass) break;
            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
            var prop = lineClass[1] ? "bgClass" : "textClass";
            null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(output[prop]) || (output[prop] += " " + lineClass[2]);
        }
        return type;
    }
    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans, curStart = (null == flattenSpans && (flattenSpans = cm.options.flattenSpans), 
        0), curStyle = null, stream = new StringStream(text, cm.options.tabSize, context), inner = cm.options.addModeClass && [ null ];
        for ("" == text && extractLineClasses(callBlankLine(mode, context.state), lineClasses); !stream.eol(); ) {
            var mName, style = stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1, 
            forceToEnd && processLine(cm, text, context, stream.pos), stream.pos = text.length, 
            null) : extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
            if (!inner || (mName = inner[0].name) && (style = "m-" + (style ? mName + " " + style : mName)), 
            !flattenSpans || curStyle != style) {
                for (;curStart < stream.start; ) f(curStart = Math.min(stream.start, curStart + 5e3), curStyle);
                curStyle = style;
            }
            stream.start = stream.pos;
        }
        for (;curStart < stream.pos; ) {
            var pos = Math.min(stream.pos, curStart + 5e3);
            f(pos, curStyle), curStart = pos;
        }
    }
    var Line = function(text, markedSpans, estimateHeight) {
        this.text = text, attachMarkedSpans(this, markedSpans), this.height = estimateHeight ? estimateHeight(this) : 1;
    };
    Line.prototype.lineNo = function() {
        return lineNo(this);
    }, eventMixin(Line);
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options) {
        return !style || /^\s*$/.test(style) ? null : (options = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache)[style] || (options[style] = style.replace(/\S+/g, "cm-$&"));
    }
    function buildLineContent(cm, lineView) {
        var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null), builder = {
            pre: eltP("pre", [ content ], "CodeMirror-line"),
            content: content,
            col: 0,
            pos: 0,
            cm: cm,
            trailingSpace: !1,
            splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
        };
        lineView.measure = {};
        for (var r0, txt, i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
            var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0, measure = (builder.pos = 0, 
            builder.addToken = buildToken, measure = cm.display.measure, txt = r0 = void 0, 
            (null != badBidiRects ? badBidiRects : (txt = removeChildrenAndAdd(measure, document.createTextNode("AA")), 
            r0 = range(txt, 0, 1).getBoundingClientRect(), txt = range(txt, 1, 2).getBoundingClientRect(), 
            removeChildren(measure), r0 && r0.left != r0.right && (badBidiRects = txt.right - r0.right < 3))) && (order = getOrder(line, cm.doc.direction)) && (builder.addToken = function(inner, order) {
                return function(builder, text, style, startStyle, endStyle, title, css) {
                    style = style ? style + " cm-force-border" : "cm-force-border";
                    for (var start = builder.pos, end = start + text.length; ;) {
                        for (var part = void 0, i = 0; i < order.length && !((part = order[i]).to > start && part.from <= start); i++);
                        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
                        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css), 
                        startStyle = null, text = text.slice(part.to - start), start = part.to;
                    }
                };
            }(builder.addToken, order)), builder.map = [], lineView != cm.display.externalMeasured && lineNo(line));
            !function(line, builder, styles) {
                var spans = line.markedSpans, allText = line.text, at = 0;
                if (spans) for (var style, css, spanStyle, spanEndStyle, spanStartStyle, title, collapsed, len = allText.length, pos = 0, i = 1, text = "", nextChange = 0; ;) {
                    if (nextChange == pos) {
                        spanStyle = spanEndStyle = spanStartStyle = title = css = "", 
                        collapsed = null, nextChange = 1 / 0;
                        for (var foundBookmarks = [], endStyles = void 0, j = 0; j < spans.length; ++j) {
                            var sp = spans[j], m = sp.marker;
                            "bookmark" == m.type && sp.from == pos && m.widgetNode ? foundBookmarks.push(m) : sp.from <= pos && (null == sp.to || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos) ? (null != sp.to && sp.to != pos && nextChange > sp.to && (nextChange = sp.to, 
                            spanEndStyle = ""), m.className && (spanStyle += " " + m.className), 
                            m.css && (css = (css ? css + ";" : "") + m.css), m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle), 
                            m.endStyle && sp.to == nextChange && (endStyles = endStyles || []).push(m.endStyle, sp.to), 
                            m.title && !title && (title = m.title), m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp)) : sp.from > pos && nextChange > sp.from && (nextChange = sp.from);
                        }
                        if (endStyles) for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) endStyles[j$1 + 1] == nextChange && (spanEndStyle += " " + endStyles[j$1]);
                        if (!collapsed || collapsed.from == pos) for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                        if (collapsed && (collapsed.from || 0) == pos) {
                            if (buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from), 
                            null == collapsed.to) return;
                            collapsed.to == pos && (collapsed = !1);
                        }
                    }
                    if (len <= pos) break;
                    for (var upto = Math.min(len, nextChange); ;) {
                        if (text) {
                            var tokenText, end = pos + text.length;
                            if (collapsed || (tokenText = upto < end ? text.slice(0, upto - pos) : text, 
                            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css)), 
                            upto <= end) {
                                text = text.slice(upto - pos), pos = upto;
                                break;
                            }
                            pos = end, spanStartStyle = "";
                        }
                        text = allText.slice(at, at = styles[i++]), style = interpretTokenStyle(styles[i++], builder.cm.options);
                    }
                } else for (var i$1 = 1; i$1 < styles.length; i$1 += 2) builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
            }(line, builder, getLineStyles(cm, line, measure)), line.styleClasses && (line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "")), 
            line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))), 
            0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(function(measure) {
                var test;
                return null == zwspSupported && (test = elt("span", ""), removeChildrenAndAdd(measure, elt("span", [ test, document.createTextNode("x") ])), 
                0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && 2 < test.offsetHeight && !(ie && ie_version < 8))), 
                (measure = zwspSupported ? elt("span", "") : elt("span", "", null, "display: inline-block; width: 1px; margin-right: -1px")).setAttribute("cm-text", ""), 
                measure;
            }(cm.display.measure))), 0 == i ? (lineView.measure.map = builder.map, 
            lineView.measure.cache = {}) : ((lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map), 
            (lineView.measure.caches || (lineView.measure.caches = [])).push({}));
        }
        return webkit && (content = builder.content.lastChild, (/\bcm-tab\b/.test(content.className) || content.querySelector && content.querySelector(".cm-tab")) && (builder.content.className = "cm-tab-wrap-hack")), 
        signal(cm, "renderLine", cm, lineView.line, builder.pre), builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || "")), 
        builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "", "cm-invalidchar");
        return token.title = "\\u" + ch.charCodeAt(0).toString(16), token.setAttribute("aria-label", token.title), 
        token;
    }
    function buildToken(builder, text, style, startStyle, endStyle, title, css) {
        if (text) {
            var displayText = builder.splitSpaces ? function(text, trailingBefore) {
                if (1 < text.length && !/  /.test(text)) return text;
                for (var spaceBefore = trailingBefore, result = "", i = 0; i < text.length; i++) {
                    var ch = text.charAt(i);
                    " " != ch || !spaceBefore || i != text.length - 1 && 32 != text.charCodeAt(i + 1) || (ch = ""), 
                    result += ch, spaceBefore = " " == ch;
                }
                return result;
            }(text, builder.trailingSpace) : text, special = builder.cm.state.specialChars, mustWrap = !1;
            if (special.test(text)) for (var content = document.createDocumentFragment(), pos = 0; ;) {
                special.lastIndex = pos;
                var m = special.exec(text), skipped = m ? m.index - pos : text.length - pos;
                if (skipped && (txt = document.createTextNode(displayText.slice(pos, pos + skipped)), 
                ie && ie_version < 9 ? content.appendChild(elt("span", [ txt ])) : content.appendChild(txt), 
                builder.map.push(builder.pos, builder.pos + skipped, txt), builder.col += skipped, 
                builder.pos += skipped), !m) break;
                pos += 1 + skipped;
                var txt = void 0;
                "\t" == m[0] ? (skipped = (skipped = builder.cm.options.tabSize) - builder.col % skipped, 
                (txt = content.appendChild(elt("span", spaceStr(skipped), "cm-tab"))).setAttribute("role", "presentation"), 
                txt.setAttribute("cm-text", "\t"), builder.col += skipped) : ("\r" == m[0] || "\n" == m[0] ? (txt = content.appendChild(elt("span", "\r" == m[0] ? "" : "", "cm-invalidchar"))).setAttribute("cm-text", m[0]) : ((txt = builder.cm.options.specialCharPlaceholder(m[0])).setAttribute("cm-text", m[0]), 
                ie && ie_version < 9 ? content.appendChild(elt("span", [ txt ])) : content.appendChild(txt)), 
                builder.col += 1), builder.map.push(builder.pos, builder.pos + 1, txt), 
                builder.pos++;
            } else builder.col += text.length, content = document.createTextNode(displayText), 
            builder.map.push(builder.pos, builder.pos + text.length, content), ie && ie_version < 9 && (mustWrap = !0), 
            builder.pos += text.length;
            if (builder.trailingSpace = 32 == displayText.charCodeAt(text.length - 1), 
            style || startStyle || endStyle || mustWrap || css) return mustWrap = style || "", 
            startStyle && (mustWrap += startStyle), endStyle && (mustWrap += endStyle), 
            style = elt("span", [ content ], mustWrap, css), title && (style.title = title), 
            builder.content.appendChild(style);
            builder.content.appendChild(content);
        }
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        widget && builder.map.push(builder.pos, builder.pos + size, widget), !ignoreWidget && builder.cm.display.input.needsContentAttribute && (widget = widget || builder.content.appendChild(document.createElement("span"))).setAttribute("cm-marker", marker.id), 
        widget && (builder.cm.display.input.setUneditable(widget), builder.content.appendChild(widget)), 
        builder.pos += size, builder.trailingSpace = !1;
    }
    function LineView(doc, line, lineN) {
        this.line = line, this.rest = function(line) {
            for (var merged, lines; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line, 
            (lines = lines || []).push(line);
            return lines;
        }(line), this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1, 
        this.node = this.text = null, this.hidden = lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
        for (var array = [], pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos), nextPos = pos + view.size;
            array.push(view);
        }
        return array;
    }
    var operationGroup = null;
    function finishOperation(op, endCb) {
        op = op.ownsGroup;
        if (op) try {
            !function(group) {
                var callbacks = group.delayedCallbacks, i = 0;
                do {
                    for (;i < callbacks.length; i++) callbacks[i].call(null);
                    for (var j = 0; j < group.ops.length; j++) {
                        var op = group.ops[j];
                        if (op.cursorActivityHandlers) for (;op.cursorActivityCalled < op.cursorActivityHandlers.length; ) op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                    }
                } while (i < callbacks.length);
            }(op);
        } finally {
            operationGroup = null, endCb(op);
        }
    }
    var orphanDelayedCallbacks = null;
    function signalLater(emitter, type) {
        var arr = getHandlers(emitter, type);
        if (arr.length) for (var list, args = Array.prototype.slice.call(arguments, 2), i = (operationGroup ? list = operationGroup.delayedCallbacks : orphanDelayedCallbacks ? list = orphanDelayedCallbacks : (list = orphanDelayedCallbacks = [], 
        setTimeout(fireOrphanDelayed, 0)), 0); i < arr.length; ++i) !function(i) {
            list.push(function() {
                return arr[i].apply(null, args);
            });
        }(i);
    }
    function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i) delayed[i]();
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            "text" == type ? function(cm, lineView) {
                var cls = lineView.text.className, built = getLineContent(cm, lineView);
                lineView.text == lineView.node && (lineView.node = built.pre);
                lineView.text.parentNode.replaceChild(built.pre, lineView.text), 
                lineView.text = built.pre, built.bgClass != lineView.bgClass || built.textClass != lineView.textClass ? (lineView.bgClass = built.bgClass, 
                lineView.textClass = built.textClass, updateLineClasses(cm, lineView)) : cls && (lineView.text.className = cls);
            }(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(cm, lineView) : "widget" == type && function(cm, lineView, dims) {
                lineView.alignable && (lineView.alignable = null);
                for (var node = lineView.node.firstChild, next = void 0; node; node = next) next = node.nextSibling, 
                "CodeMirror-linewidget" == node.className && lineView.node.removeChild(node);
                insertLineWidgets(cm, lineView, dims);
            }(cm, lineView, dims);
        }
        lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
        return lineView.node == lineView.text && (lineView.node = elt("div", null, null, "position: relative"), 
        lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text), 
        lineView.node.appendChild(lineView.text), ie && ie_version < 8 && (lineView.node.style.zIndex = 2)), 
        lineView.node;
    }
    function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        return ext && ext.line == lineView.line ? (cm.display.externalMeasured = null, 
        lineView.measure = ext.measure, ext.built) : buildLineContent(cm, lineView);
    }
    function updateLineClasses(cm, lineView) {
        !function(cm, lineView) {
            var wrap, cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
            cls && (cls += " CodeMirror-linebackground"), lineView.background ? cls ? lineView.background.className = cls : (lineView.background.parentNode.removeChild(lineView.background), 
            lineView.background = null) : cls && (wrap = ensureLineWrapped(lineView), 
            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild), 
            cm.display.input.setUneditable(lineView.background));
        }(cm, lineView), lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
        cm = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = cm || "";
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
        lineView.gutter && (lineView.node.removeChild(lineView.gutter), lineView.gutter = null), 
        lineView.gutterBackground && (lineView.node.removeChild(lineView.gutterBackground), 
        lineView.gutterBackground = null), lineView.line.gutterClass && (wrap = ensureLineWrapped(lineView), 
        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"), 
        cm.display.input.setUneditable(lineView.gutterBackground), wrap.insertBefore(lineView.gutterBackground, lineView.text));
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
            var wrap = ensureLineWrapped(lineView), gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
            if (cm.display.input.setUneditable(gutterWrap), wrap.insertBefore(gutterWrap, lineView.text), 
            lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass), 
            !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"))), 
            markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
                var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                found && gutterWrap.appendChild(elt("div", [ found ], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
            }
        }
    }
    function insertLineWidgets(cm, lineView, dims) {
        if (insertLineWidgetsFor(cm, lineView.line, lineView, dims, !0), lineView.rest) for (var i = 0; i < lineView.rest.length; i++) insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, !1);
    }
    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (line.widgets) for (var wrap = ensureLineWrapped(lineView), i = 0, ws = line.widgets; i < ws.length; ++i) {
            var widget = ws[i], node = elt("div", [ widget.node ], "CodeMirror-linewidget");
            widget.handleMouseEvents || node.setAttribute("cm-ignore-events", "true"), 
            !function(widget, node, lineView, dims) {
                widget.noHScroll && ((lineView.alignable || (lineView.alignable = [])).push(node), 
                lineView = dims.wrapperWidth, node.style.left = dims.fixedPos + "px", 
                widget.coverGutter || (lineView -= dims.gutterTotalWidth, node.style.paddingLeft = dims.gutterTotalWidth + "px"), 
                node.style.width = lineView + "px");
                widget.coverGutter && (node.style.zIndex = 5, node.style.position = "relative", 
                widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"));
            }(widget, node, lineView, dims), cm.display.input.setUneditable(node), 
            allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node), 
            signalLater(widget, "redraw");
        }
    }
    function widgetHeight(widget) {
        var cm, parentStyle;
        return null != widget.height ? widget.height : (cm = widget.doc.cm) ? (contains(document.body, widget.node) || (parentStyle = "position: relative;", 
        widget.coverGutter && (parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"), 
        widget.noHScroll && (parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"), 
        removeChildrenAndAdd(cm.display.measure, elt("div", [ widget.node ], null, parentStyle))), 
        widget.height = widget.node.parentNode.offsetHeight) : 0;
    }
    function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == display.sizer && n != display.mover) return 1;
    }
    function paddingTop(display) {
        return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
        var e;
        return display.cachedPaddingH || (e = removeChildrenAndAdd(display.measure, elt("pre", "x")), 
        e = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, 
        e = {
            left: parseInt(e.paddingLeft),
            right: parseInt(e.paddingRight)
        }, isNaN(e.left) || isNaN(e.right) || (display.cachedPaddingH = e), e);
    }
    function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) return {
            map: lineView.measure.map,
            cache: lineView.measure.cache
        };
        for (var i = 0; i < lineView.rest.length; i++) if (lineView.rest[i] == line) return {
            map: lineView.measure.maps[i],
            cache: lineView.measure.caches[i]
        };
        for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) if (lineNo(lineView.rest[i$1]) > lineN) return {
            map: lineView.measure.maps[i$1],
            cache: lineView.measure.caches[i$1],
            before: !0
        };
    }
    function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }
    function findViewForLine(cm, lineN) {
        return lineN >= cm.display.viewFrom && lineN < cm.display.viewTo ? cm.display.view[findViewIndex(cm, lineN)] : (cm = cm.display.externalMeasured) && lineN >= cm.lineN && lineN < cm.lineN + cm.size ? cm : void 0;
    }
    function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line), view = findViewForLine(cm, lineN), cm = (view && !view.text ? view = null : view && view.changes && (updateLineForChanges(cm, view, lineN, getDimensions(cm)), 
        cm.curOp.forceUpdate = !0), mapFromLineView(view = view || function(cm, line) {
            var lineN = lineNo(line = visualLine(line)), lineN = ((line = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)).lineN = lineN, 
            line.built = buildLineContent(cm, line));
            return line.text = lineN.pre, removeChildrenAndAdd(cm.display.lineMeasure, lineN.pre), 
            line;
        }(cm, line), line, lineN));
        return {
            line: line,
            view: view,
            rect: null,
            map: cm.map,
            cache: cm.cache,
            before: cm.before,
            hasHeights: !1
        };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        var found, key = (ch = prepared.before ? -1 : ch) + (bias || "");
        return prepared.cache.hasOwnProperty(key) ? found = prepared.cache[key] : (prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect()), 
        prepared.hasHeights || (function(cm, lineView, rect) {
            var wrapping = cm.options.lineWrapping, cm = wrapping && displayWidth(cm);
            if (!lineView.measure.heights || wrapping && lineView.measure.width != cm) {
                var heights = lineView.measure.heights = [];
                if (wrapping) {
                    lineView.measure.width = cm;
                    for (var rects = lineView.text.firstChild.getClientRects(), i = 0; i < rects.length - 1; i++) {
                        var cur = rects[i], next = rects[i + 1];
                        2 < Math.abs(cur.bottom - next.bottom) && heights.push((cur.bottom + next.top) / 2 - rect.top);
                    }
                }
                heights.push(rect.bottom - rect.top);
            }
        }(cm, prepared.view, prepared.rect), prepared.hasHeights = !0), (found = function(cm, prepared, ch, bias) {
            var rect, place = nodeAndOffsetInLineMap(prepared.map, ch, bias), node = place.node, start = place.start, end = place.end, collapse = place.collapse;
            if (3 == node.nodeType) {
                for (var i$1 = 0; i$1 < 4; i$1++) {
                    for (;start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start)); ) --start;
                    for (;place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end)); ) ++end;
                    if ((rect = ie && ie_version < 9 && 0 == start && end == place.coverEnd - place.coverStart ? node.parentNode.getBoundingClientRect() : function(rects, bias) {
                        var rect = nullRect;
                        if ("left" == bias) for (var i = 0; i < rects.length && (rect = rects[i]).left == rect.right; i++); else for (var i$1 = rects.length - 1; 0 <= i$1 && (rect = rects[i$1]).left == rect.right; i$1--);
                        return rect;
                    }(range(node, start, end).getClientRects(), bias)).left || rect.right || 0 == start) break;
                    end = start, start -= 1, collapse = "right";
                }
                ie && ie_version < 11 && (rect = function(measure, rect) {
                    var scaleY;
                    return window.screen && null != screen.logicalXDPI && screen.logicalXDPI != screen.deviceXDPI && function(measure) {
                        var normal;
                        return null != badZoomedRects ? badZoomedRects : (normal = (measure = removeChildrenAndAdd(measure, elt("span", "x"))).getBoundingClientRect(), 
                        measure = range(measure, 0, 1).getBoundingClientRect(), 
                        badZoomedRects = 1 < Math.abs(normal.left - measure.left));
                    }(measure) ? (measure = screen.logicalXDPI / screen.deviceXDPI, 
                    scaleY = screen.logicalYDPI / screen.deviceYDPI, {
                        left: rect.left * measure,
                        right: rect.right * measure,
                        top: rect.top * scaleY,
                        bottom: rect.bottom * scaleY
                    }) : rect;
                }(cm.display.measure, rect));
            } else 0 < start && (collapse = bias = "right"), rect = cm.options.lineWrapping && 1 < (ch = node.getClientRects()).length ? ch["right" == bias ? ch.length - 1 : 0] : node.getBoundingClientRect();
            !(ie && ie_version < 9) || start || rect && (rect.left || rect.right) || (ch = node.parentNode.getClientRects()[0], 
            rect = ch ? {
                left: ch.left,
                right: ch.left + charWidth(cm.display),
                top: ch.top,
                bottom: ch.bottom
            } : nullRect);
            for (var ch = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top, mid = (ch + rbot) / 2, heights = prepared.view.measure.heights, i = 0; i < heights.length - 1 && !(mid < heights[i]); i++);
            var top = i ? heights[i - 1] : 0, bot = heights[i], top = {
                left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left,
                right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left,
                top: top,
                bottom: bot
            };
            rect.left || rect.right || (top.bogus = !0);
            cm.options.singleCursorHeightPerLine || (top.rtop = ch, top.rbottom = rbot);
            return top;
        }(cm, prepared, ch, bias)).bogus || (prepared.cache[key] = found)), {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
        };
    }
    var measureText, nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    function nodeAndOffsetInLineMap(map$$1, ch, bias) {
        for (var node, start, end, collapse, mStart, mEnd, i = 0; i < map$$1.length; i += 3) if (mStart = map$$1[i], 
        mEnd = map$$1[i + 1], ch < mStart ? (start = 0, end = 1, collapse = "left") : ch < mEnd ? end = (start = ch - mStart) + 1 : (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) && (start = (end = mEnd - mStart) - 1, 
        mEnd <= ch && (collapse = "right")), null != start) {
            if (node = map$$1[i + 2], mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias), 
            "left" == bias && 0 == start) for (;i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft; ) node = map$$1[2 + (i -= 3)], 
            collapse = "left";
            if ("right" == bias && start == mEnd - mStart) for (;i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft; ) node = map$$1[(i += 3) + 2], 
            collapse = "right";
            break;
        }
        return {
            node: node,
            start: start,
            end: end,
            collapse: collapse,
            coverStart: mStart,
            coverEnd: mEnd
        };
    }
    function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure && (lineView.measure.cache = {}, lineView.measure.heights = null, 
        lineView.rest)) for (var i = 0; i < lineView.rest.length; i++) lineView.measure.caches[i] = {};
    }
    function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null, removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++) clearLineMeasurementCacheFor(cm.display.view[i]);
    }
    function clearCaches(cm) {
        clearLineMeasurementCache(cm), cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null, 
        cm.options.lineWrapping || (cm.display.maxLineChanged = !0), cm.display.lineNumChars = null;
    }
    function pageScrollX() {
        return chrome && android ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
        return chrome && android ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function widgetTopHeight(lineObj) {
        var height = 0;
        if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) lineObj.widgets[i].above && (height += widgetHeight(lineObj.widgets[i]));
        return height;
    }
    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        return includeWidgets || (includeWidgets = widgetTopHeight(lineObj), rect.top += includeWidgets, 
        rect.bottom += includeWidgets), "line" != context && (context = context || "local", 
        includeWidgets = heightAtLine(lineObj), "local" == context ? includeWidgets += paddingTop(cm.display) : includeWidgets -= cm.display.viewOffset, 
        "page" != context && "window" != context || (includeWidgets += (lineObj = cm.display.lineSpace.getBoundingClientRect()).top + ("window" == context ? 0 : pageScrollY()), 
        cm = lineObj.left + ("window" == context ? 0 : pageScrollX()), rect.left += cm, 
        rect.right += cm), rect.top += includeWidgets, rect.bottom += includeWidgets), 
        rect;
    }
    function fromCoordSystem(cm, coords, context) {
        var left;
        return "div" == context ? coords : (left = coords.left, coords = coords.top, 
        "page" == context ? (left -= pageScrollX(), coords -= pageScrollY()) : "local" != context && context || (left += (context = cm.display.sizer.getBoundingClientRect()).left, 
        coords += context.top), {
            left: left - (context = cm.display.lineSpace.getBoundingClientRect()).left,
            top: coords - context.top
        });
    }
    function charCoords(cm, pos, context, lineObj, bias) {
        return intoCoordSystem(cm, lineObj = lineObj || getLine(cm.doc, pos.line), measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        function get(ch, right) {
            ch = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
            return right ? ch.left = ch.right : ch.right = ch.left, intoCoordSystem(cm, lineObj, ch, context);
        }
        lineObj = lineObj || getLine(cm.doc, pos.line), preparedMeasure = preparedMeasure || prepareMeasureForLine(cm, lineObj);
        var other, partPos, order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, pos = pos.sticky;
        return ch >= lineObj.text.length ? (ch = lineObj.text.length, pos = "before") : ch <= 0 && (ch = 0, 
        pos = "after"), order ? (partPos = getBidiPartAt(order, ch, pos), other = bidiOther, 
        partPos = getBidi(ch, partPos, "before" == pos), null != other && (partPos.other = getBidi(ch, other, "before" != pos)), 
        partPos) : get("before" == pos ? ch - 1 : ch, "before" == pos);
        function getBidi(ch, partPos, invert) {
            return get(invert ? ch - 1 : ch, 1 == order[partPos].level != invert);
        }
    }
    function estimateCoords(cm, pos) {
        var left = 0, pos = (pos = clipPos(cm.doc, pos), cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch), 
        getLine(cm.doc, pos.line)), cm = heightAtLine(pos) + paddingTop(cm.display);
        return {
            left: left,
            right: left,
            top: cm,
            bottom: cm + pos.height
        };
    }
    function PosWithInfo(line, ch, sticky, outside, xRel) {
        line = Pos(line, ch, sticky);
        return line.xRel = xRel, outside && (line.outside = !0), line;
    }
    function coordsChar(cm, x, y) {
        var doc = cm.doc;
        if ((y += cm.display.viewOffset) < 0) return PosWithInfo(doc.first, 0, null, !0, -1);
        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (last < lineN) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, !0, 1);
        x < 0 && (x = 0);
        for (var lineObj = getLine(doc, lineN); ;) {
            var found = function(cm, lineObj, lineNo$$1, x, y) {
                y -= heightAtLine(lineObj);
                var preparedMeasure = prepareMeasureForLine(cm, lineObj), widgetHeight$$1 = widgetTopHeight(lineObj), begin = 0, end = lineObj.text.length, ltr = !0, order = getOrder(lineObj, cm.doc.direction);
                order && (order = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y), 
                ltr = 1 != order.level, begin = ltr ? order.from : order.to - 1, 
                end = ltr ? order.to : order.from - 1);
                var chAround = null, boxAround = null, order = findFirst(function(ch) {
                    var box = measureCharPrepared(cm, preparedMeasure, ch);
                    return box.top += widgetHeight$$1, box.bottom += widgetHeight$$1, 
                    boxIsAfter(box, x, y, !1) && (box.top <= y && box.left <= x && (chAround = ch, 
                    boxAround = box), 1);
                }, begin, end), outside = !1;
                {
                    var atLeft, atStart;
                    boxAround ? (atLeft = x - boxAround.left < boxAround.right - x, 
                    order = chAround + ((atStart = atLeft == ltr) ? 0 : 1), atStart = atStart ? "after" : "before", 
                    atLeft = atLeft ? boxAround.left : boxAround.right) : (ltr || order != end && order != begin || order++, 
                    atStart = 0 == order || order != lineObj.text.length && measureCharPrepared(cm, preparedMeasure, order - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? "after" : "before", 
                    end = cursorCoords(cm, Pos(lineNo$$1, order, atStart), "line", lineObj, preparedMeasure), 
                    atLeft = end.left, outside = y < end.top || y >= end.bottom);
                }
                return order = skipExtendingChars(lineObj.text, order, 1), PosWithInfo(lineNo$$1, order, atStart, outside, x - atLeft);
            }(cm, lineObj, lineN, x, y), merged = collapsedSpanAtEnd(lineObj), mergedPos = merged && merged.find(0, !0);
            if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && 0 < found.xRel)) return found;
            lineN = lineNo(lineObj = mergedPos.to.line);
        }
    }
    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
        y -= widgetTopHeight(lineObj);
        var lineObj = lineObj.text.length, begin = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
        }, lineObj, 0);
        return {
            begin: begin,
            end: findFirst(function(ch) {
                return measureCharPrepared(cm, preparedMeasure, ch).top > y;
            }, begin, lineObj)
        };
    }
    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        return wrappedLineExtent(cm, lineObj, preparedMeasure = preparedMeasure || prepareMeasureForLine(cm, lineObj), intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top);
    }
    function boxIsAfter(box, x, y, left) {
        return !(box.bottom <= y) && (box.top > y || (left ? box.left : box.right) > x);
    }
    function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
        var ltr, index = findFirst(function(i) {
            var i = order[i], ltr = 1 != i.level;
            return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? i.to : i.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, !0);
        }, 0, order.length - 1), part = order[index];
        return 0 < index && (ltr = 1 != part.level, boxIsAfter(ltr = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure), x, y, !0) && ltr.top > y && (part = order[index - 1])), 
        part;
    }
    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
        for (var lineObj = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = lineObj.begin, end = lineObj.end, part = null, closestDist = null, i = 0; i < order.length; i++) {
            var endX, p = order[i];
            p.from >= end || p.to <= begin || (endX = (endX = measureCharPrepared(cm, preparedMeasure, 1 != p.level ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right) < x ? x - endX + 1e9 : endX - x, 
            (!part || endX < closestDist) && (part = p, closestDist = endX));
        }
        return part = (part = (part = part || order[order.length - 1]).from < begin ? {
            from: begin,
            to: part.to,
            level: part.level
        } : part).to > end ? {
            from: part.from,
            to: end,
            level: part.level
        } : part;
    }
    function textHeight(display) {
        if (null != display.cachedTextHeight) return display.cachedTextHeight;
        if (null == measureText) {
            measureText = elt("pre");
            for (var i = 0; i < 49; ++i) measureText.appendChild(document.createTextNode("x")), 
            measureText.appendChild(elt("br"));
            measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        return 3 < height && (display.cachedTextHeight = height), removeChildren(display.measure), 
        height || 1;
    }
    function charWidth(display) {
        var pre, anchor;
        return null != display.cachedCharWidth ? display.cachedCharWidth : (anchor = elt("span", "xxxxxxxxxx"), 
        pre = elt("pre", [ anchor ]), removeChildrenAndAdd(display.measure, pre), 
        2 < (anchor = ((pre = anchor.getBoundingClientRect()).right - pre.left) / 10) && (display.cachedCharWidth = anchor), 
        anchor || 10);
    }
    function getDimensions(cm) {
        for (var d = cm.display, left = {}, width = {}, gutterLeft = d.gutters.clientLeft, n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, 
        ++i) left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft, 
        width[cm.options.gutters[i]] = n.clientWidth;
        return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
        };
    }
    function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping, perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
            if (lineIsHidden(cm.doc, line)) return 0;
            var widgetsHeight = 0;
            if (line.widgets) for (var i = 0; i < line.widgets.length; i++) line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
            return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th;
        };
    }
    function estimateLineHeights(cm) {
        var doc = cm.doc, est = estimateHeight(cm);
        doc.iter(function(line) {
            var estHeight = est(line);
            estHeight != line.height && updateLineHeight(line, estHeight);
        });
    }
    function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && "true" == e_target(e).getAttribute("cm-not-content")) return null;
        var x, liberal = display.lineSpace.getBoundingClientRect();
        try {
            x = e.clientX - liberal.left, y = e.clientY - liberal.top;
        } catch (e) {
            return null;
        }
        var y, display = coordsChar(cm, x, y);
        return forRect && 1 == display.xRel && (liberal = getLine(cm.doc, display.line).text).length == display.ch && (y = countColumn(liberal, liberal.length, cm.options.tabSize) - liberal.length, 
        display = Pos(display.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - y))), 
        display;
    }
    function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) return null;
        if ((n -= cm.display.viewFrom) < 0) return null;
        for (var view = cm.display.view, i = 0; i < view.length; i++) if ((n -= view[i].size) < 0) return i;
    }
    function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary) {
        void 0 === primary && (primary = !0);
        for (var range$$1, collapsed, doc = cm.doc, result = {}, curFragment = result.cursors = document.createDocumentFragment(), selFragment = result.selection = document.createDocumentFragment(), i = 0; i < doc.sel.ranges.length; i++) !primary && i == doc.sel.primIndex || (range$$1 = doc.sel.ranges[i]).from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom || (((collapsed = range$$1.empty()) || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range$$1.head, curFragment), 
        collapsed || function(cm, range$$1, output) {
            var display = cm.display, doc = cm.doc, fragment = document.createDocumentFragment(), padding = paddingH(cm.display), leftSide = padding.left, rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
            function add(left, top, width, bottom) {
                top < 0 && (top = 0), top = Math.round(top), bottom = Math.round(bottom), 
                fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
            }
            function drawForLine(line, fromArg, toArg) {
                var start, end, lineObj = getLine(doc, line), lineLen = lineObj.text.length;
                function coords(ch, bias) {
                    return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
                }
                var order = getOrder(lineObj, doc.direction);
                return function(order, from, to, f) {
                    if (!order) return f(from, to, "ltr", 0);
                    for (var found = !1, i = 0; i < order.length; ++i) {
                        var part = order[i];
                        (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr", i), 
                        found = !0);
                    }
                    found || f(from, to, "ltr");
                }(order, fromArg || 0, null == toArg ? lineLen : toArg, function(from, to, dir, i) {
                    var toRight, topLeft, fromPos = coords(from, "ltr" == dir ? "left" : "right"), toPos = coords(to - 1, "ltr" == dir ? "right" : "left");
                    "ltr" == dir ? (dir = null == fromArg && 0 == from ? leftSide : fromPos.left, 
                    toRight = null == toArg && to == lineLen ? rightSide : toPos.right, 
                    toPos.top - fromPos.top <= 3 ? add(dir, toPos.top, toRight - dir, toPos.bottom) : (add(dir, fromPos.top, null, fromPos.bottom), 
                    fromPos.bottom < toPos.top && add(leftSide, fromPos.bottom, null, toPos.top), 
                    add(leftSide, toPos.top, toPos.right, toPos.bottom))) : from < to && (toRight = null == fromArg && 0 == from ? rightSide : fromPos.right, 
                    dir = null == toArg && to == lineLen ? leftSide : toPos.left, 
                    toPos.top - fromPos.top <= 3 ? add(dir, toPos.top, toRight - dir, toPos.bottom) : (topLeft = leftSide, 
                    add(topLeft = i ? coords((i = wrappedLineExtentChar(cm, lineObj, null, from).end) - (/\s/.test(lineObj.text.charAt(i - 1)) ? 2 : 1), "left").left : topLeft, fromPos.top, toRight - topLeft, fromPos.bottom), 
                    fromPos.bottom < toPos.top && add(leftSide, fromPos.bottom, null, toPos.top), 
                    order.length, from = coords(wrappedLineExtentChar(cm, lineObj, from = null, to).begin, "right").right - dir, 
                    add(dir, toPos.top, from, toPos.bottom))), (!start || cmpCoords(fromPos, start) < 0) && (start = fromPos), 
                    cmpCoords(toPos, start) < 0 && (start = toPos), (!end || cmpCoords(fromPos, end) < 0) && (end = fromPos), 
                    cmpCoords(toPos, end) < 0 && (end = toPos);
                }), {
                    start: start,
                    end: end
                };
            }
            display = range$$1.from(), padding = range$$1.to();
            {
                var toLine;
                display.line == padding.line ? drawForLine(display.line, display.ch, padding.ch) : (range$$1 = getLine(doc, display.line), 
                toLine = getLine(doc, padding.line), toLine = visualLine(range$$1) == visualLine(toLine), 
                display = drawForLine(display.line, display.ch, toLine ? range$$1.text.length + 1 : null).end, 
                range$$1 = drawForLine(padding.line, toLine ? 0 : null, padding.ch).start, 
                toLine && (display.top < range$$1.top - 2 ? (add(display.right, display.top, null, display.bottom), 
                add(leftSide, range$$1.top, range$$1.left, range$$1.bottom)) : add(display.right, display.top, range$$1.left - display.right, display.bottom)), 
                display.bottom < range$$1.top && add(leftSide, display.bottom, null, range$$1.top));
            }
            output.appendChild(fragment);
        }(cm, range$$1, selFragment));
        return result;
    }
    function drawSelectionCursor(cm, head, output) {
        var head = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine), cursor = output.appendChild(elt("div", "", "CodeMirror-cursor"));
        cursor.style.left = head.left + "px", cursor.style.top = head.top + "px", 
        cursor.style.height = Math.max(0, head.bottom - head.top) * cm.options.cursorHeight + "px", 
        head.other && ((cursor = output.appendChild(elt("div", "", "CodeMirror-cursor CodeMirror-secondarycursor"))).style.display = "", 
        cursor.style.left = head.other.left + "px", cursor.style.top = head.other.top + "px", 
        cursor.style.height = .85 * (head.other.bottom - head.other.top) + "px");
    }
    function cmpCoords(a, b) {
        return a.top - b.top || a.left - b.left;
    }
    function restartBlink(cm) {
        var display, on;
        cm.state.focused && (display = cm.display, clearInterval(display.blinker), 
        on = !0, display.cursorDiv.style.visibility = "", 0 < cm.options.cursorBlinkRate ? display.blinker = setInterval(function() {
            return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
        }, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden"));
    }
    function ensureFocus(cm) {
        cm.state.focused || (cm.display.input.focus(), onFocus(cm));
    }
    function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = !0, setTimeout(function() {
            cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1, onBlur(cm));
        }, 100);
    }
    function onFocus(cm, e) {
        cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1), "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm, e), 
        cm.state.focused = !0, addClass(cm.display.wrapper, "CodeMirror-focused"), 
        cm.curOp || cm.display.selForContextMenu == cm.doc.sel || (cm.display.input.reset(), 
        webkit && setTimeout(function() {
            return cm.display.input.reset(!0);
        }, 20)), cm.display.input.receivedFocus()), restartBlink(cm));
    }
    function onBlur(cm, e) {
        cm.state.delayingBlurEvent || (cm.state.focused && (signal(cm, "blur", cm, e), 
        cm.state.focused = !1, rmClass(cm.display.wrapper, "CodeMirror-focused")), 
        clearInterval(cm.display.blinker), setTimeout(function() {
            cm.state.focused || (cm.display.shift = !1);
        }, 150));
    }
    function updateHeightsInViewport(cm) {
        for (var display = cm.display, prevBottom = display.lineDiv.offsetTop, i = 0; i < display.view.length; i++) {
            var cur = display.view[i], height = void 0;
            if (!cur.hidden) {
                ie && ie_version < 8 ? (height = (bot = cur.node.offsetTop + cur.node.offsetHeight) - prevBottom, 
                prevBottom = bot) : height = (bot = cur.node.getBoundingClientRect()).bottom - bot.top;
                var bot, diff = cur.line.height - height;
                if (height < 2 && (height = textHeight(display)), (.005 < diff || diff < -.005) && (updateLineHeight(cur.line, height), 
                updateWidgetHeight(cur.line), cur.rest)) for (var j = 0; j < cur.rest.length; j++) updateWidgetHeight(cur.rest[j]);
            }
        }
    }
    function updateWidgetHeight(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; ++i) line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
    }
    function visibleLines(display, doc, viewport) {
        var ensureFrom, top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop, top = Math.floor(top - paddingTop(display)), bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight, top = lineAtHeight(doc, top), bottom = lineAtHeight(doc, bottom);
        return viewport && viewport.ensure && (ensureFrom = viewport.ensure.from.line, 
        viewport = viewport.ensure.to.line, ensureFrom < top ? bottom = lineAtHeight(doc, heightAtLine(getLine(doc, top = ensureFrom)) + display.wrapper.clientHeight) : Math.min(viewport, doc.lastLine()) >= bottom && (top = lineAtHeight(doc, heightAtLine(getLine(doc, viewport)) - display.wrapper.clientHeight), 
        bottom = viewport)), {
            from: top,
            to: Math.max(bottom, top + 1)
        };
    }
    function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
            for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, left = comp + "px", i = 0; i < view.length; i++) if (!view[i].hidden) {
                cm.options.fixedGutter && (view[i].gutter && (view[i].gutter.style.left = left), 
                view[i].gutterBackground && (view[i].gutterBackground.style.left = left));
                var align = view[i].alignable;
                if (align) for (var j = 0; j < align.length; j++) align[j].style.left = left;
            }
            cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px");
        }
    }
    function maybeUpdateLineNumberWidth(cm) {
        var doc, display, innerW, test;
        if (cm.options.lineNumbers) return doc = cm.doc, doc = lineNumberFor(cm.options, doc.first + doc.size - 1), 
        display = cm.display, doc.length != display.lineNumChars ? (innerW = (test = display.measure.appendChild(elt("div", [ elt("div", doc) ], "CodeMirror-linenumber CodeMirror-gutter-elt"))).firstChild.offsetWidth, 
        test = test.offsetWidth - innerW, display.lineGutter.style.width = "", display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - test) + 1, 
        display.lineNumWidth = display.lineNumInnerWidth + test, display.lineNumChars = display.lineNumInnerWidth ? doc.length : -1, 
        display.lineGutter.style.width = display.lineNumWidth + "px", updateGutterSpace(cm), 
        1) : void 0;
    }
    function calculateScrollPos(cm, rect) {
        var display = cm.display, snapMargin = textHeight(cm.display), screentop = (rect.top < 0 && (rect.top = 0), 
        (cm.curOp && null != cm.curOp.scrollTop ? cm.curOp : display.scroller).scrollTop), screen = displayHeight(cm), result = {}, docBottom = (rect.bottom - rect.top > screen && (rect.bottom = rect.top + screen), 
        cm.doc.height + paddingVert(display)), atTop = rect.top < snapMargin, snapMargin = rect.bottom > docBottom - snapMargin, snapMargin = (rect.top < screentop ? result.scrollTop = atTop ? 0 : rect.top : rect.bottom > screentop + screen && ((atTop = Math.min(rect.top, (snapMargin ? docBottom : rect.bottom) - screen)) != screentop && (result.scrollTop = atTop)), 
        (cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp : display.scroller).scrollLeft), docBottom = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0), screen = rect.right - rect.left > docBottom;
        return screen && (rect.right = rect.left + docBottom), rect.left < 10 ? result.scrollLeft = 0 : rect.left < snapMargin ? result.scrollLeft = Math.max(0, rect.left - (screen ? 0 : 10)) : rect.right > docBottom + snapMargin - 3 && (result.scrollLeft = rect.right + (screen ? 0 : 10) - docBottom), 
        result;
    }
    function addToScrollTop(cm, top) {
        null != top && (resolveScrollToPos(cm), cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc : cm.curOp).scrollTop + top);
    }
    function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor();
        cm.curOp.scrollToPos = {
            from: cur,
            to: cur,
            margin: cm.options.cursorScrollMargin
        };
    }
    function scrollToCoords(cm, x, y) {
        null == x && null == y || resolveScrollToPos(cm), null != x && (cm.curOp.scrollLeft = x), 
        null != y && (cm.curOp.scrollTop = y);
    }
    function resolveScrollToPos(cm) {
        var range$$1 = cm.curOp.scrollToPos;
        range$$1 && (cm.curOp.scrollToPos = null, scrollToCoordsRange(cm, estimateCoords(cm, range$$1.from), estimateCoords(cm, range$$1.to), range$$1.margin));
    }
    function scrollToCoordsRange(cm, from, to, margin) {
        from = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, from.scrollLeft, from.scrollTop);
    }
    function updateScrollTop(cm, val) {
        Math.abs(cm.doc.scrollTop - val) < 2 || (gecko || updateDisplaySimple(cm, {
            top: val
        }), setScrollTop(cm, val, !0), gecko && updateDisplaySimple(cm), startWorker(cm, 100));
    }
    function setScrollTop(cm, val, forceScroll) {
        val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val), 
        cm.display.scroller.scrollTop == val && !forceScroll || (cm.doc.scrollTop = val, 
        cm.display.scrollbars.setScrollTop(val), cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val));
    }
    function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth), 
        (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll || (cm.doc.scrollLeft = val, 
        alignHorizontally(cm), cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val), 
        cm.display.scrollbars.setScrollLeft(val));
    }
    function measureForScrollbars(cm) {
        var d = cm.display, gutterW = d.gutters.offsetWidth, docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
        };
    }
    function NativeScrollbars(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [ elt("div", null, null, "min-width: 1px") ], "CodeMirror-vscrollbar"), horiz = this.horiz = elt("div", [ elt("div", null, null, "height: 100%; min-height: 1px") ], "CodeMirror-hscrollbar");
        place(vert), place(horiz), on(vert, "scroll", function() {
            vert.clientHeight && scroll(vert.scrollTop, "vertical");
        }), on(horiz, "scroll", function() {
            horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal");
        }), this.checkedZeroWidth = !1, ie && ie_version < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
    }
    function NullScrollbars() {}
    NativeScrollbars.prototype.update = function(measure) {
        var totalHeight, needsH = measure.scrollWidth > measure.clientWidth + 1, needsV = measure.scrollHeight > measure.clientHeight + 1, sWidth = measure.nativeBarWidth;
        return needsV ? (this.vert.style.display = "block", this.vert.style.bottom = needsH ? sWidth + "px" : "0", 
        totalHeight = measure.viewHeight - (needsH ? sWidth : 0), this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px") : (this.vert.style.display = "", 
        this.vert.firstChild.style.height = "0"), needsH ? (this.horiz.style.display = "block", 
        this.horiz.style.right = needsV ? sWidth + "px" : "0", this.horiz.style.left = measure.barLeft + "px", 
        totalHeight = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0), 
        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalHeight) + "px") : (this.horiz.style.display = "", 
        this.horiz.firstChild.style.width = "0"), !this.checkedZeroWidth && 0 < measure.clientHeight && (0 == sWidth && this.zeroWidthHack(), 
        this.checkedZeroWidth = !0), {
            right: needsV ? sWidth : 0,
            bottom: needsH ? sWidth : 0
        };
    }, NativeScrollbars.prototype.setScrollLeft = function(pos) {
        this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    }, NativeScrollbars.prototype.setScrollTop = function(pos) {
        this.vert.scrollTop != pos && (this.vert.scrollTop = pos), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    }, NativeScrollbars.prototype.zeroWidthHack = function() {
        this.horiz.style.height = this.vert.style.width = mac && !mac_geMountainLion ? "12px" : "18px", 
        this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", 
        this.disableHoriz = new Delayed(), this.disableVert = new Delayed();
    }, NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
        bar.style.pointerEvents = "auto", delay.set(1e3, function maybeDisable() {
            var box = bar.getBoundingClientRect();
            ("vert" == type ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1)) != bar ? bar.style.pointerEvents = "none" : delay.set(1e3, maybeDisable);
        });
    }, NativeScrollbars.prototype.clear = function() {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz), parent.removeChild(this.vert);
    };
    function updateScrollbars(cm, measure) {
        measure = measure || measureForScrollbars(cm);
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) startWidth != cm.display.barWidth && cm.options.lineWrapping && updateHeightsInViewport(cm), 
        updateScrollbarsInner(cm, measureForScrollbars(cm)), startWidth = cm.display.barWidth, 
        startHeight = cm.display.barHeight;
    }
    function updateScrollbarsInner(cm, measure) {
        var d = cm.display, sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px", d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px", 
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent", 
        sizes.right && sizes.bottom ? (d.scrollbarFiller.style.display = "block", 
        d.scrollbarFiller.style.height = sizes.bottom + "px", d.scrollbarFiller.style.width = sizes.right + "px") : d.scrollbarFiller.style.display = "", 
        sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block", 
        d.gutterFiller.style.height = sizes.bottom + "px", d.gutterFiller.style.width = measure.gutterWidth + "px") : d.gutterFiller.style.display = "";
    }
    NullScrollbars.prototype.update = function() {
        return {
            bottom: 0,
            right: 0
        };
    }, NullScrollbars.prototype.setScrollLeft = function() {}, NullScrollbars.prototype.setScrollTop = function() {}, 
    NullScrollbars.prototype.clear = function() {};
    var scrollbarModel = {
        native: NativeScrollbars,
        null: NullScrollbars
    };
    function initScrollbars(cm) {
        cm.display.scrollbars && (cm.display.scrollbars.clear(), cm.display.scrollbars.addClass && rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)), 
        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller), on(node, "mousedown", function() {
                cm.state.focused && setTimeout(function() {
                    return cm.display.input.focus();
                }, 0);
            }), node.setAttribute("cm-not-content", "true");
        }, function(pos, axis) {
            ("horizontal" == axis ? setScrollLeft : updateScrollTop)(cm, pos);
        }, cm), cm.display.scrollbars.addClass && addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
    var nextOpId = 0;
    function startOperation(cm) {
        cm.curOp = {
            cm: cm,
            viewChanged: !1,
            startHeight: cm.doc.height,
            forceUpdate: !1,
            updateInput: null,
            typing: !1,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: !1,
            updateMaxLine: !1,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: !1,
            id: ++nextOpId
        }, cm = cm.curOp, operationGroup ? operationGroup.ops.push(cm) : cm.ownsGroup = operationGroup = {
            ops: [ cm ],
            delayedCallbacks: []
        };
    }
    function endOperation(cm) {
        finishOperation(cm.curOp, function(group) {
            for (var i = 0; i < group.ops.length; i++) group.ops[i].cm.curOp = null;
            !function(group) {
                for (var ops = group.ops, i = 0; i < ops.length; i++) !function(op) {
                    var cm = op.cm, display = cm.display;
                    (function(cm) {
                        var display = cm.display;
                        !display.scrollbarsClipped && display.scroller.offsetWidth && (display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth, 
                        display.heightForcer.style.height = scrollGap(cm) + "px", 
                        display.sizer.style.marginBottom = -display.nativeBarWidth + "px", 
                        display.sizer.style.borderRightWidth = scrollGap(cm) + "px", 
                        display.scrollbarsClipped = !0);
                    })(cm), op.updateMaxLine && findMaxLine(cm);
                    op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping, 
                    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
                        top: op.scrollTop,
                        ensure: op.scrollToPos
                    }, op.forceUpdate);
                }(ops[i]);
                for (var i$1 = 0; i$1 < ops.length; i$1++) !function(op) {
                    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
                }(ops[i$1]);
                for (var i$2 = 0; i$2 < ops.length; i$2++) !function(op) {
                    var cm = op.cm, display = cm.display;
                    op.updatedDisplay && updateHeightsInViewport(cm);
                    op.barMeasure = measureForScrollbars(cm), display.maxLineChanged && !cm.options.lineWrapping && (op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3, 
                    cm.display.sizerWidth = op.adjustWidthTo, op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth), 
                    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm)));
                    (op.updatedDisplay || op.selectionChanged) && (op.preparedSelection = display.input.prepareSelection());
                }(ops[i$2]);
                for (var i$3 = 0; i$3 < ops.length; i$3++) !function(op) {
                    var cm = op.cm;
                    null != op.adjustWidthTo && (cm.display.sizer.style.minWidth = op.adjustWidthTo + "px", 
                    op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), !0), 
                    cm.display.maxLineChanged = !1);
                    var takeFocus = op.focus && op.focus == activeElt();
                    op.preparedSelection && cm.display.input.showSelection(op.preparedSelection, takeFocus);
                    !op.updatedDisplay && op.startHeight == cm.doc.height || updateScrollbars(cm, op.barMeasure);
                    op.updatedDisplay && setDocumentHeight(cm, op.barMeasure);
                    op.selectionChanged && restartBlink(cm);
                    cm.state.focused && op.updateInput && cm.display.input.reset(op.typing);
                    takeFocus && ensureFocus(op.cm);
                }(ops[i$3]);
                for (var i$4 = 0; i$4 < ops.length; i$4++) !function(op) {
                    var cm = op.cm, display = cm.display, doc = cm.doc;
                    op.updatedDisplay && postUpdateDisplay(cm, op.update);
                    null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null);
                    null != op.scrollTop && setScrollTop(cm, op.scrollTop, op.forceScroll);
                    null != op.scrollLeft && setScrollLeft(cm, op.scrollLeft, !0, !0);
                    {
                        var rect;
                        op.scrollToPos && (rect = function(cm, pos, end, margin) {
                            null == margin && (margin = 0), cm.options.lineWrapping || pos != end || (end = "before" == (pos = pos.ch ? Pos(pos.line, "before" == pos.sticky ? pos.ch - 1 : pos.ch, "after") : pos).sticky ? Pos(pos.line, pos.ch + 1, "before") : pos);
                            for (var limit = 0; limit < 5; limit++) {
                                var rect, changed = !1, coords = cursorCoords(cm, pos), endCoords = end && end != pos ? cursorCoords(cm, end) : coords, coords = calculateScrollPos(cm, rect = {
                                    left: Math.min(coords.left, endCoords.left),
                                    top: Math.min(coords.top, endCoords.top) - margin,
                                    right: Math.max(coords.left, endCoords.left),
                                    bottom: Math.max(coords.bottom, endCoords.bottom) + margin
                                }), endCoords = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
                                if (null != coords.scrollTop && (updateScrollTop(cm, coords.scrollTop), 
                                1 < Math.abs(cm.doc.scrollTop - endCoords) && (changed = !0)), 
                                null != coords.scrollLeft && (setScrollLeft(cm, coords.scrollLeft), 
                                1 < Math.abs(cm.doc.scrollLeft - startLeft) && (changed = !0)), 
                                !changed) break;
                            }
                            return rect;
                        }(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin), 
                        function(cm, rect) {
                            var display, doScroll, box;
                            signalDOMEvent(cm, "scrollCursorIntoView") || (box = (display = cm.display).sizer.getBoundingClientRect(), 
                            doScroll = null, rect.top + box.top < 0 ? doScroll = !0 : rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1), 
                            null == doScroll || phantom || (box = elt("div", "", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;"), 
                            cm.display.lineSpace.appendChild(box), box.scrollIntoView(doScroll), 
                            cm.display.lineSpace.removeChild(box)));
                        }(cm, rect));
                    }
                    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
                    if (hidden) for (var i = 0; i < hidden.length; ++i) hidden[i].lines.length || signal(hidden[i], "hide");
                    if (unhidden) for (var i$1 = 0; i$1 < unhidden.length; ++i$1) unhidden[i$1].lines.length && signal(unhidden[i$1], "unhide");
                    display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop);
                    op.changeObjs && signal(cm, "changes", cm, op.changeObjs);
                    op.update && op.update.finish();
                }(ops[i$4]);
            }(group);
        });
    }
    function runInOp(cm, f) {
        if (cm.curOp) return f();
        startOperation(cm);
        try {
            return f();
        } finally {
            endOperation(cm);
        }
    }
    function operation(cm, f) {
        return function() {
            if (cm.curOp) return f.apply(cm, arguments);
            startOperation(cm);
            try {
                return f.apply(cm, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function methodOp(f) {
        return function() {
            if (this.curOp) return f.apply(this, arguments);
            startOperation(this);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(this);
            }
        };
    }
    function docMethodOp(f) {
        return function() {
            var cm = this.cm;
            if (!cm || cm.curOp) return f.apply(this, arguments);
            startOperation(cm);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function regChange(cm, from, to, lendiff) {
        null == from && (from = cm.doc.first), null == to && (to = cm.doc.first + cm.doc.size);
        var cutBot, display = cm.display, cut = ((lendiff = lendiff || 0) && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from), 
        cm.curOp.viewChanged = !0, from >= display.viewTo ? sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm) : to <= display.viewFrom ? sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom ? resetView(cm) : (display.viewFrom += lendiff, 
        display.viewTo += lendiff) : from <= display.viewFrom && to >= display.viewTo ? resetView(cm) : from <= display.viewFrom ? (cut = viewCuttingPoint(cm, to, to + lendiff, 1)) ? (display.view = display.view.slice(cut.index), 
        display.viewFrom = cut.lineN, display.viewTo += lendiff) : resetView(cm) : to >= display.viewTo ? (cut = viewCuttingPoint(cm, from, from, -1)) ? (display.view = display.view.slice(0, cut.index), 
        display.viewTo = cut.lineN) : resetView(cm) : (cut = viewCuttingPoint(cm, from, from, -1), 
        cutBot = viewCuttingPoint(cm, to, to + lendiff, 1), cut && cutBot ? (display.view = display.view.slice(0, cut.index).concat(buildViewArray(cm, cut.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index)), 
        display.viewTo += lendiff) : resetView(cm)), display.externalMeasured);
        cut && (to < cut.lineN ? cut.lineN += lendiff : from < cut.lineN + cut.size && (display.externalMeasured = null));
    }
    function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = !0;
        var display = cm.display, ext = cm.display.externalMeasured;
        ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null), 
        line < display.viewFrom || line >= display.viewTo || null != (ext = display.view[findViewIndex(cm, line)]).node && -1 == indexOf(display = ext.changes || (ext.changes = []), type) && display.push(type);
    }
    function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first, cm.display.view = [], 
        cm.display.viewOffset = 0;
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
        var diff, index = findViewIndex(cm, oldN), view = cm.display.view;
        if (sawCollapsedSpans && newN != cm.doc.first + cm.doc.size) {
            for (var n = cm.display.viewFrom, i = 0; i < index; i++) n += view[i].size;
            if (n != oldN) {
                if (0 < dir) {
                    if (index == view.length - 1) return null;
                    diff = n + view[index].size - oldN, index++;
                } else diff = n - oldN;
                oldN += diff, newN += diff;
            }
            for (;visualLineNo(cm.doc, newN) != newN; ) {
                if (index == (dir < 0 ? 0 : view.length - 1)) return null;
                newN += dir * view[index - (dir < 0 ? 1 : 0)].size, index += dir;
            }
        }
        return {
            index: index,
            lineN: newN
        };
    }
    function countDirtyView(cm) {
        for (var view = cm.display.view, dirty = 0, i = 0; i < view.length; i++) {
            var lineView = view[i];
            lineView.hidden || lineView.node && !lineView.changes || ++dirty;
        }
        return dirty;
    }
    function startWorker(cm, time) {
        cm.doc.highlightFrontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
    function highlightWorker(cm) {
        var end, context, changedLines, doc = cm.doc;
        doc.highlightFrontier >= cm.display.viewTo || (end = +new Date() + cm.options.workTime, 
        context = getContextBefore(cm, doc.highlightFrontier), changedLines = [], 
        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
            if (context.line >= cm.display.viewFrom) {
                for (var oldStyles = line.styles, resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null, highlighted = highlightLine(cm, line, context, !0), resetState = (resetState && (context.state = resetState), 
                line.styles = highlighted.styles, line.styleClasses), highlighted = highlighted.classes, ischange = (highlighted ? line.styleClasses = highlighted : resetState && (line.styleClasses = null), 
                !oldStyles || oldStyles.length != line.styles.length || resetState != highlighted && (!resetState || !highlighted || resetState.bgClass != highlighted.bgClass || resetState.textClass != highlighted.textClass)), i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
                ischange && changedLines.push(context.line), line.stateAfter = context.save();
            } else line.text.length <= cm.options.maxHighlightLength && processLine(cm, line.text, context), 
            line.stateAfter = context.line % 5 == 0 ? context.save() : null;
            if (context.nextLine(), +new Date() > end) return startWorker(cm, cm.options.workDelay), 
            !0;
        }), doc.highlightFrontier = context.line, doc.modeFrontier = Math.max(doc.modeFrontier, context.line), 
        changedLines.length && runInOp(cm, function() {
            for (var i = 0; i < changedLines.length; i++) regLineChange(cm, changedLines[i], "text");
        }));
    }
    var DisplayUpdate = function(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport, this.visible = visibleLines(display, cm.doc, viewport), 
        this.editorIsHidden = !display.wrapper.offsetWidth, this.wrapperHeight = display.wrapper.clientHeight, 
        this.wrapperWidth = display.wrapper.clientWidth, this.oldDisplayWidth = displayWidth(cm), 
        this.force = force, this.dims = getDimensions(cm), this.events = [];
    };
    function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc = cm.doc;
        if (update.editorIsHidden) return resetView(cm), !1;
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && 0 == countDirtyView(cm)) return !1;
        maybeUpdateLineNumberWidth(cm) && (resetView(cm), update.dims = getDimensions(cm));
        var end = doc.first + doc.size, from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first), to = Math.min(end, update.visible.to + cm.options.viewportMargin), doc = (display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom)), 
        display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo)), 
        sawCollapsedSpans && (from = visualLineNo(cm.doc, from), to = visualLineEndNo(cm.doc, to)), 
        from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth), end = (!function(cm, from, to) {
            var display = cm.display;
            0 == display.view.length || from >= display.viewTo || to <= display.viewFrom ? (display.view = buildViewArray(cm, from, to), 
            display.viewFrom = from) : (display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from))), 
            display.viewFrom = from, display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))), 
            display.viewTo = to;
        }(cm, from, to), display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom)), 
        cm.display.mover.style.top = display.viewOffset + "px", countDirtyView(cm));
        return !(!doc && 0 == end && !update.force && display.renderedView == display.view && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo)) && (from = function(cm) {
            var active, sel;
            return !cm.hasFocus() && (active = activeElt()) && contains(cm.display.lineDiv, active) ? (active = {
                activeElt: active
            }, window.getSelection && (sel = window.getSelection()).anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode) && (active.anchorNode = sel.anchorNode, 
            active.anchorOffset = sel.anchorOffset, active.focusNode = sel.focusNode, 
            active.focusOffset = sel.focusOffset), active) : null;
        }(cm), 4 < end && (display.lineDiv.style.display = "none"), function(cm, updateNumbersFrom, dims) {
            var display = cm.display, lineNumbers = cm.options.lineNumbers, container = display.lineDiv, cur = container.firstChild;
            function rm(node) {
                var next = node.nextSibling;
                return webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node), 
                next;
            }
            for (var view = display.view, lineN = display.viewFrom, i = 0; i < view.length; i++) {
                var lineView = view[i];
                if (!lineView.hidden) if (lineView.node && lineView.node.parentNode == container) {
                    for (;cur != lineView.node; ) cur = rm(cur);
                    var updateNumber = lineNumbers && null != updateNumbersFrom && updateNumbersFrom <= lineN && lineView.lineNumber;
                    lineView.changes && (-1 < indexOf(lineView.changes, "gutter") && (updateNumber = !1), 
                    updateLineForChanges(cm, lineView, lineN, dims)), updateNumber && (removeChildren(lineView.lineNumber), 
                    lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))), 
                    cur = lineView.node.nextSibling;
                } else {
                    updateNumber = function(cm, lineView, lineN, dims) {
                        var built = getLineContent(cm, lineView);
                        return lineView.text = lineView.node = built.pre, built.bgClass && (lineView.bgClass = built.bgClass), 
                        built.textClass && (lineView.textClass = built.textClass), 
                        updateLineClasses(cm, lineView), updateLineGutter(cm, lineView, lineN, dims), 
                        insertLineWidgets(cm, lineView, dims), lineView.node;
                    }(cm, lineView, lineN, dims);
                    container.insertBefore(updateNumber, cur);
                }
                lineN += lineView.size;
            }
            for (;cur; ) cur = rm(cur);
        }(cm, display.updateLineNumbers, update.dims), 4 < end && (display.lineDiv.style.display = ""), 
        display.renderedView = display.view, (to = from) && to.activeElt && to.activeElt != activeElt() && (to.activeElt.focus(), 
        to.anchorNode && contains(document.body, to.anchorNode) && contains(document.body, to.focusNode) && (end = window.getSelection(), 
        (from = document.createRange()).setEnd(to.anchorNode, to.anchorOffset), 
        from.collapse(!1), end.removeAllRanges(), end.addRange(from), end.extend(to.focusNode, to.focusOffset))), 
        removeChildren(display.cursorDiv), removeChildren(display.selectionDiv), 
        display.gutters.style.height = display.sizer.style.minHeight = 0, doc && (display.lastWrapHeight = update.wrapperHeight, 
        display.lastWrapWidth = update.wrapperWidth, startWorker(cm, 400)), !(display.updateLineNumbers = null));
    }
    function postUpdateDisplay(cm, update) {
        for (var viewport = update.viewport, first = !0; (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm) || (viewport && null != viewport.top && (viewport = {
            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
        }), update.visible = visibleLines(cm.display, cm.doc, viewport), !(update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo))) && updateDisplayIfNeeded(cm, update); first = !1) {
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure), 
            update.force = !1;
        }
        update.signal(cm, "update", cm), cm.display.viewFrom == cm.display.reportedViewFrom && cm.display.viewTo == cm.display.reportedViewTo || (update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo), 
        cm.display.reportedViewFrom = cm.display.viewFrom, cm.display.reportedViewTo = cm.display.viewTo);
    }
    function updateDisplaySimple(cm, viewport) {
        var barMeasure, viewport = new DisplayUpdate(cm, viewport);
        updateDisplayIfNeeded(cm, viewport) && (updateHeightsInViewport(cm), postUpdateDisplay(cm, viewport), 
        barMeasure = measureForScrollbars(cm), updateSelection(cm), updateScrollbars(cm, barMeasure), 
        setDocumentHeight(cm, barMeasure), viewport.finish());
    }
    function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + "px";
    }
    function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px", cm.display.heightForcer.style.top = measure.docHeight + "px", 
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
    }
    function updateGutters(cm) {
        for (var gutters = cm.display.gutters, specs = cm.options.gutters, i = (removeChildren(gutters), 
        0); i < specs.length; ++i) {
            var gutterClass = specs[i], gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
            "CodeMirror-linenumbers" == gutterClass && ((cm.display.lineGutter = gElt).style.width = (cm.display.lineNumWidth || 1) + "px");
        }
        gutters.style.display = i ? "" : "none", updateGutterSpace(cm);
    }
    function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        -1 == found && options.lineNumbers ? options.gutters = options.gutters.concat([ "CodeMirror-linenumbers" ]) : -1 < found && !options.lineNumbers && (options.gutters = options.gutters.slice(0), 
        options.gutters.splice(found, 1));
    }
    DisplayUpdate.prototype.signal = function(emitter, type) {
        hasHandler(emitter, type) && this.events.push(arguments);
    }, DisplayUpdate.prototype.finish = function() {
        for (var i = 0; i < this.events.length; i++) signal.apply(null, this.events[i]);
    };
    var wheelSamples = 0, wheelPixelsPerUnit = null;
    function wheelEventDelta(e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        return null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail), 
        null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta), 
        {
            x: dx,
            y: dy
        };
    }
    function wheelEventPixels(e) {
        e = wheelEventDelta(e);
        return e.x *= wheelPixelsPerUnit, e.y *= wheelPixelsPerUnit, e;
    }
    function onScrollWheel(cm, e) {
        var top, bot, delta = wheelEventDelta(e), dx = delta.x, delta = delta.y, display = cm.display, scroll = display.scroller, canScrollX = scroll.scrollWidth > scroll.clientWidth, canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (dx && canScrollX || delta && canScrollY) {
            if (delta && mac && webkit) outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) for (var i = 0; i < view.length; i++) if (view[i].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
            }
            !dx || gecko || presto || null == wheelPixelsPerUnit ? (delta && null != wheelPixelsPerUnit && (canScrollX = delta * wheelPixelsPerUnit, 
            bot = (top = cm.doc.scrollTop) + display.wrapper.clientHeight, canScrollX < 0 ? top = Math.max(0, top + canScrollX - 50) : bot = Math.min(cm.doc.height, bot + canScrollX + 50), 
            updateDisplaySimple(cm, {
                top: top,
                bottom: bot
            })), wheelSamples < 20 && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft, 
            display.wheelStartY = scroll.scrollTop, display.wheelDX = dx, display.wheelDY = delta, 
            setTimeout(function() {
                var movedX, movedY;
                null != display.wheelStartX && (movedX = scroll.scrollLeft - display.wheelStartX, 
                movedY = (movedY = scroll.scrollTop - display.wheelStartY) && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX, 
                display.wheelStartX = display.wheelStartY = null, movedY && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + movedY) / (wheelSamples + 1), 
                ++wheelSamples));
            }, 200)) : (display.wheelDX += dx, display.wheelDY += delta))) : (delta && canScrollY && updateScrollTop(cm, Math.max(0, scroll.scrollTop + delta * wheelPixelsPerUnit)), 
            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)), 
            delta && !canScrollY || e_preventDefault(e), display.wheelStartX = null);
        }
    }
    ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
    var Selection = function(ranges, primIndex) {
        this.ranges = ranges, this.primIndex = primIndex;
    }, Range = (Selection.prototype.primary = function() {
        return this.ranges[this.primIndex];
    }, Selection.prototype.equals = function(other) {
        if (other != this) {
            if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return !1;
            for (var i = 0; i < this.ranges.length; i++) {
                var here = this.ranges[i], there = other.ranges[i];
                if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) return !1;
            }
        }
        return !0;
    }, Selection.prototype.deepCopy = function() {
        for (var out = [], i = 0; i < this.ranges.length; i++) out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
        return new Selection(out, this.primIndex);
    }, Selection.prototype.somethingSelected = function() {
        for (var i = 0; i < this.ranges.length; i++) if (!this.ranges[i].empty()) return !0;
        return !1;
    }, Selection.prototype.contains = function(pos, end) {
        end = end || pos;
        for (var i = 0; i < this.ranges.length; i++) {
            var range = this.ranges[i];
            if (0 <= cmp(end, range.from()) && cmp(pos, range.to()) <= 0) return i;
        }
        return -1;
    }, function(anchor, head) {
        this.anchor = anchor, this.head = head;
    });
    function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function(a, b) {
            return cmp(a.from(), b.from());
        }), primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
            var from, to, cur = ranges[i], prev = ranges[i - 1];
            0 <= cmp(prev.to(), cur.from()) && (from = minPos(prev.from(), cur.from()), 
            to = maxPos(prev.to(), cur.to()), cur = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head, 
            i <= primIndex && --primIndex, ranges.splice(--i, 2, new Range(cur ? to : from, cur ? from : to)));
        }
        return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
        return new Selection([ new Range(anchor, head || anchor) ], 0);
    }
    function changeEnd(change) {
        return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to;
    }
    function adjustForChange(pos, change) {
        var line, ch;
        return cmp(pos, change.from) < 0 ? pos : cmp(pos, change.to) <= 0 ? changeEnd(change) : (line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, 
        ch = pos.ch, pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch), 
        Pos(line, ch));
    }
    function computeSelAfterChange(doc, change) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return normalizeSelection(out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
        return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch);
    }
    function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption), resetModeState(cm);
    }
    function resetModeState(cm) {
        cm.doc.iter(function(line) {
            line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null);
        }), cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first, startWorker(cm, 100), 
        cm.state.modeGen++, cm.curOp && regChange(cm);
    }
    function isWholeLineUpdate(doc, change) {
        return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
        function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
            !function(line, text, markedSpans, estimateHeight) {
                line.text = text, line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null), 
                null != line.order && (line.order = null), detachMarkedSpans(line), 
                attachMarkedSpans(line, markedSpans), (text = estimateHeight ? estimateHeight(line) : 1) != line.height && updateLineHeight(line, text);
            }(line, text, spans, estimateHeight$$1), signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
            for (var result = [], i = start; i < end; ++i) result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
            return result;
        }
        var added, from = change.from, to = change.to, text = change.text, firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line), lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
        change.full ? (doc.insert(0, linesFor(0, text.length)), doc.remove(text.length, doc.size - text.length)) : isWholeLineUpdate(doc, change) ? (added = linesFor(0, text.length - 1), 
        update(lastLine, lastLine.text, lastSpans), nlines && doc.remove(from.line, nlines), 
        added.length && doc.insert(from.line, added)) : firstLine == lastLine ? 1 == text.length ? update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans) : ((added = linesFor(1, text.length - 1)).push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1)), 
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), 
        doc.insert(from.line + 1, added)) : 1 == text.length ? (update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)), 
        doc.remove(from.line + 1, nlines)) : (update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), 
        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans), added = linesFor(1, text.length - 1), 
        1 < nlines && doc.remove(from.line + 1, nlines - 1), doc.insert(from.line + 1, added)), 
        signalLater(doc, "change", doc, change);
    }
    function linkedDocs(doc, f, sharedHistOnly) {
        !function propagate(doc, skip, sharedHist) {
            if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
                var shared, rel = doc.linked[i];
                rel.doc != skip && (shared = sharedHist && rel.sharedHist, sharedHistOnly && !shared || (f(rel.doc, shared), 
                propagate(rel.doc, doc, shared)));
            }
        }(doc, null, !0);
    }
    function attachDoc(cm, doc) {
        if (doc.cm) throw new Error("This document is already in use.");
        cm.doc = doc, estimateLineHeights(doc.cm = cm), loadMode(cm), setDirectionClass(cm), 
        cm.options.lineWrapping || findMaxLine(cm), cm.options.mode = doc.modeOption, 
        regChange(cm);
    }
    function setDirectionClass(cm) {
        ("rtl" == cm.doc.direction ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
    }
    function History(startGen) {
        this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, 
        this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, 
        this.generation = this.maxGeneration = startGen || 1;
    }
    function historyChangeFromChange(doc, change) {
        var histChange = {
            from: copyPos(change.from),
            to: changeEnd(change),
            text: getBetween(doc, change.from, change.to)
        };
        return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), 
        linkedDocs(doc, function(doc) {
            return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, !0), histChange;
    }
    function clearSelectionEvents(array) {
        for (;array.length; ) {
            if (!lst(array).ranges) break;
            array.pop();
        }
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
        var cur, last, hist = doc.history, time = (hist.undone.length = 0, +new Date());
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || "*" == change.origin.charAt(0))) && (cur = function(hist, force) {
            return force ? (clearSelectionEvents(hist.done), lst(hist.done)) : hist.done.length && !lst(hist.done).ranges ? lst(hist.done) : 1 < hist.done.length && !hist.done[hist.done.length - 2].ranges ? (hist.done.pop(), 
            lst(hist.done)) : void 0;
        }(hist, hist.lastOp == opId))) last = lst(cur.changes), 0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? last.to = changeEnd(change) : cur.changes.push(historyChangeFromChange(doc, change)); else {
            var before = lst(hist.done);
            for (before && before.ranges || pushSelectionToHistory(doc.sel, hist.done), 
            cur = {
                changes: [ historyChangeFromChange(doc, change) ],
                generation: hist.generation
            }, hist.done.push(cur); hist.done.length > hist.undoDepth; ) hist.done.shift(), 
            hist.done[0].ranges || hist.done.shift();
        }
        hist.done.push(selAfter), hist.generation = ++hist.maxGeneration, hist.lastModTime = hist.lastSelTime = time, 
        hist.lastOp = hist.lastSelOp = opId, hist.lastOrigin = hist.lastSelOrigin = change.origin, 
        last || signal(doc, "historyAdded");
    }
    function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history, origin = options && options.origin;
        opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || function(doc, origin, prev, sel) {
            return "*" == (origin = origin.charAt(0)) || "+" == origin && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
        }(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done), 
        hist.lastSelTime = +new Date(), hist.lastSelOrigin = origin, hist.lastSelOp = opId, 
        options && !1 !== options.clearRedo && clearSelectionEvents(hist.undone);
    }
    function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        top && top.ranges && top.equals(sel) || dest.push(sel);
    }
    function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
            line.markedSpans && ((existing = existing || (change["spans_" + doc.id] = {}))[n] = line.markedSpans), 
            ++n;
        });
    }
    function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found) return null;
        for (var nw = [], i = 0; i < change.text.length; ++i) nw.push(function(spans) {
            if (!spans) return null;
            for (var out, i = 0; i < spans.length; ++i) spans[i].marker.explicitlyCleared ? out = out || spans.slice(0, i) : out && out.push(spans[i]);
            return out ? out.length ? out : null : spans;
        }(found[i]));
        return nw;
    }
    function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change), stretched = stretchSpansOverChange(doc, change);
        if (!old) return stretched;
        if (stretched) for (var i = 0; i < old.length; ++i) {
            var oldCur = old[i], stretchCur = stretched[i];
            if (oldCur && stretchCur) spans: for (var j = 0; j < stretchCur.length; ++j) {
                for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k) if (oldCur[k].marker == span.marker) continue spans;
                oldCur.push(span);
            } else stretchCur && (old[i] = stretchCur);
        }
        return old;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
        for (var copy = [], i = 0; i < events.length; ++i) {
            var event = events[i];
            if (event.ranges) copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event); else {
                var changes = event.changes, newChanges = [];
                copy.push({
                    changes: newChanges
                });
                for (var j = 0; j < changes.length; ++j) {
                    var m, change = changes[j];
                    if (newChanges.push({
                        from: change.from,
                        to: change.to,
                        text: change.text
                    }), newGroup) for (var prop in change) (m = prop.match(/^spans_(\d+)$/)) && -1 < indexOf(newGroup, Number(m[1])) && (lst(newChanges)[prop] = change[prop], 
                    delete change[prop]);
                }
            }
        }
        return copy;
    }
    function extendRange(range, head, other, extend) {
        return extend ? (extend = range.anchor, other && ((range = cmp(head, extend) < 0) != cmp(other, extend) < 0 ? (extend = head, 
        head = other) : range != cmp(head, other) < 0 && (head = other)), new Range(extend, head)) : new Range(other || head, head);
    }
    function extendSelection(doc, head, other, options, extend) {
        null == extend && (extend = doc.cm && (doc.cm.display.shift || doc.extend)), 
        setSelection(doc, new Selection([ extendRange(doc.sel.primary(), head, other, extend) ], 0), options);
    }
    function extendSelections(doc, heads, options) {
        for (var out = [], extend = doc.cm && (doc.cm.display.shift || doc.extend), i = 0; i < doc.sel.ranges.length; i++) out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
        setSelection(doc, normalizeSelection(out, doc.sel.primIndex), options);
    }
    function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range, setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
    }
    function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
    }
    function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done, last = lst(done);
        last && last.ranges ? setSelectionNoUndo(doc, done[done.length - 1] = sel, options) : setSelection(doc, sel, options);
    }
    function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options), addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc, sel, options) {
        (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = function(doc, sel, options) {
            return options = {
                ranges: sel.ranges,
                update: function(ranges) {
                    this.ranges = [];
                    for (var i = 0; i < ranges.length; i++) this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
                },
                origin: options && options.origin
            }, signal(doc, "beforeSelectionChange", doc, options), doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, options), 
            options.ranges != sel.ranges ? normalizeSelection(options.ranges, options.ranges.length - 1) : sel;
        }(doc, sel, options));
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, !0)), options && !1 === options.scroll || !doc.cm || ensureCursorVisible(doc.cm);
    }
    function setSelectionInner(doc, sel) {
        sel.equals(doc.sel) || (doc.sel = sel, doc.cm && (doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = !0, 
        signalCursorActivity(doc.cm)), signalLater(doc, "cursorActivity", doc));
    }
    function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, !1));
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
        for (var out, i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i], old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i], newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear), old = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
            !out && newAnchor == range.anchor && old == range.head || ((out = out || sel.ranges.slice(0, i))[i] = new Range(newAnchor, old));
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel;
    }
    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);
        if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((null == sp.from || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                if (mayClear && (signal(m, "beforeCursorEnter"), m.explicitlyCleared)) {
                    if (line.markedSpans) {
                        --i;
                        continue;
                    }
                    break;
                }
                if (m.atomic) {
                    if (oldPos) {
                        var sp = m.find(dir < 0 ? 1 : -1), diff = void 0;
                        if ((sp = (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) ? movePos(doc, sp, -dir, sp && sp.line == pos.line ? line : null) : sp) && sp.line == pos.line && (diff = cmp(sp, oldPos)) && (dir < 0 ? diff < 0 : 0 < diff)) return skipAtomicInner(doc, sp, pos, dir, mayClear);
                    }
                    diff = m.find(dir < 0 ? -1 : 1);
                    return (diff = (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) ? movePos(doc, diff, dir, diff.line == pos.line ? line : null) : diff) ? skipAtomicInner(doc, diff, pos, dir, mayClear) : null;
                }
            }
        }
        return pos;
    }
    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        bias = bias || 1, mayClear = skipAtomicInner(doc, pos, oldPos, bias, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, bias, !0) || skipAtomicInner(doc, pos, oldPos, -bias, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -bias, !0);
        return mayClear || (doc.cantEdit = !0, Pos(doc.first, 0));
    }
    function movePos(doc, pos, dir, line) {
        return dir < 0 && 0 == pos.ch ? pos.line > doc.first ? clipPos(doc, Pos(pos.line - 1)) : null : 0 < dir && pos.ch == (line || getLine(doc, pos.line)).text.length ? pos.line < doc.first + doc.size - 1 ? Pos(pos.line + 1, 0) : null : new Pos(pos.line, pos.ch + dir);
    }
    function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
    }
    function filterChange(doc, change, update) {
        var obj = {
            canceled: !1,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
                return obj.canceled = !0;
            }
        };
        return update && (obj.update = function(from, to, text, origin) {
            from && (obj.from = clipPos(doc, from)), to && (obj.to = clipPos(doc, to)), 
            text && (obj.text = text), void 0 !== origin && (obj.origin = origin);
        }), signal(doc, "beforeChange", doc, obj), doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj), 
        obj.canceled ? null : {
            from: obj.from,
            to: obj.to,
            text: obj.text,
            origin: obj.origin
        };
    }
    function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
            if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            if (doc.cm.state.suppressEdits) return;
        }
        if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
            var split = sawReadOnlySpans && !ignoreReadOnly && function(doc, from, to) {
                var markers = null;
                if (doc.iter(from.line, to.line + 1, function(line) {
                    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                        var mark = line.markedSpans[i].marker;
                        !mark.readOnly || markers && -1 != indexOf(markers, mark) || (markers = markers || []).push(mark);
                    }
                }), !markers) return null;
                for (var parts = [ {
                    from: from,
                    to: to
                } ], i = 0; i < markers.length; ++i) for (var mk = markers[i], m = mk.find(0), j = 0; j < parts.length; ++j) {
                    var newParts, dfrom, dto, p = parts[j];
                    cmp(p.to, m.from) < 0 || 0 < cmp(p.from, m.to) || (newParts = [ j, 1 ], 
                    dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to), (dfrom < 0 || !mk.inclusiveLeft && !dfrom) && newParts.push({
                        from: p.from,
                        to: m.from
                    }), (0 < dto || !mk.inclusiveRight && !dto) && newParts.push({
                        from: m.to,
                        to: p.to
                    }), parts.splice.apply(parts, newParts), j += newParts.length - 3);
                }
                return parts;
            }(doc, change.from, change.to);
            if (split) for (var i = split.length - 1; 0 <= i; --i) makeChangeInner(doc, {
                from: split[i].from,
                to: split[i].to,
                text: i ? [ "" ] : change.text,
                origin: change.origin
            }); else makeChangeInner(doc, change);
        }
    }
    function makeChangeInner(doc, change) {
        var selAfter, rebased;
        1 == change.text.length && "" == change.text[0] && 0 == cmp(change.from, change.to) || (selAfter = computeSelAfterChange(doc, change), 
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN), 
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change)), 
        rebased = [], linkedDocs(doc, function(doc, sharedHist) {
            sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change), 
            rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        }));
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (!doc.cm || !doc.cm.state.suppressEdits || allowSelectionOnly) {
            for (var event, hist = doc.history, selAfter = doc.sel, source = "undo" == type ? hist.done : hist.undone, dest = "undo" == type ? hist.undone : hist.done, i = 0; i < source.length && (event = source[i], 
            allowSelectionOnly ? !event.ranges || event.equals(doc.sel) : event.ranges); i++);
            if (i != source.length) {
                for (hist.lastOrigin = hist.lastSelOrigin = null; (event = source.pop()).ranges; ) {
                    if (pushSelectionToHistory(event, dest), allowSelectionOnly && !event.equals(doc.sel)) return void setSelection(doc, event, {
                        clearRedo: !1
                    });
                    selAfter = event;
                }
                for (var antiChanges = [], filter = (pushSelectionToHistory(selAfter, dest), 
                dest.push({
                    changes: antiChanges,
                    generation: hist.generation
                }), hist.generation = event.generation || ++hist.maxGeneration, 
                hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")), i$1 = event.changes.length - 1; 0 <= i$1; --i$1) {
                    var returned = function(i) {
                        var change = event.changes[i];
                        if (change.origin = type, filter && !filterChange(doc, change, !1)) return source.length = 0, 
                        {};
                        antiChanges.push(historyChangeFromChange(doc, change));
                        var after = i ? computeSelAfterChange(doc, change) : lst(source), rebased = (makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change)), 
                        !i && doc.cm && doc.cm.scrollIntoView({
                            from: change.from,
                            to: changeEnd(change)
                        }), []);
                        linkedDocs(doc, function(doc, sharedHist) {
                            sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change), 
                            rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
                        });
                    }(i$1);
                    if (returned) return returned.v;
                }
            }
        }
    }
    function shiftDoc(doc, distance) {
        if (0 != distance && (doc.first += distance, doc.sel = new Selection(map(doc.sel.ranges, function(range) {
            return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex), doc.cm)) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) regLineChange(doc.cm, l, "gutter");
        }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        var shift;
        change.to.line < doc.first ? shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line)) : change.from.line > doc.lastLine() || (change.from.line < doc.first && (shiftDoc(doc, shift = change.text.length - 1 - (doc.first - change.from.line)), 
        change = {
            from: Pos(doc.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [ lst(change.text) ],
            origin: change.origin
        }), shift = doc.lastLine(), (change = change.to.line > shift ? {
            from: change.from,
            to: Pos(shift, getLine(doc, shift).text.length),
            text: [ change.text[0] ],
            origin: change.origin
        } : change).removed = getBetween(doc, change.from, change.to), selAfter = selAfter || computeSelAfterChange(doc, change), 
        doc.cm ? function(cm, change, spans) {
            var doc = cm.doc, display = cm.display, from = change.from, to = change.to, recomputeMaxLength = !1, checkWidthStart = from.line;
            cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(getLine(doc, from.line))), 
            doc.iter(checkWidthStart, to.line + 1, function(line) {
                if (line == display.maxLine) return recomputeMaxLength = !0;
            }));
            -1 < doc.sel.contains(change.from, change.to) && signalCursorActivity(cm);
            updateDoc(doc, change, spans, estimateHeight(cm)), cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
                var len = lineLength(line);
                len > display.maxLineLength && (display.maxLine = line, display.maxLineLength = len, 
                display.maxLineChanged = !0, recomputeMaxLength = !1);
            }), recomputeMaxLength && (cm.curOp.updateMaxLine = !0));
            (function(doc, n) {
                if (doc.modeFrontier = Math.min(doc.modeFrontier, n), !(doc.highlightFrontier < n - 10)) {
                    for (var start = doc.first, line = n - 1; start < line; line--) {
                        var saved = getLine(doc, line).stateAfter;
                        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
                            start = line + 1;
                            break;
                        }
                    }
                    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
                }
            })(doc, from.line), startWorker(cm, 400);
            spans = change.text.length - (to.line - from.line) - 1;
            change.full ? regChange(cm) : from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, spans) : regLineChange(cm, from.line, "text");
            checkWidthStart = hasHandler(cm, "changes"), doc = hasHandler(cm, "change");
            (doc || checkWidthStart) && (spans = {
                from: from,
                to: to,
                text: change.text,
                removed: change.removed,
                origin: change.origin
            }, doc && signalLater(cm, "change", cm, spans), checkWidthStart && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(spans));
            cm.display.selForContextMenu = null;
        }(doc.cm, change, spans) : updateDoc(doc, change, spans), setSelectionNoUndo(doc, selAfter, sel_dontScroll));
    }
    function replaceRange(doc, code, from, to, origin) {
        var assign;
        cmp(to = to || from, from) < 0 && (from = (assign = [ to, from ])[0], to = assign[1]), 
        "string" == typeof code && (code = doc.splitLines(code)), makeChange(doc, {
            from: from,
            to: to,
            text: code,
            origin: origin
        });
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
        to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from, 
        pos.ch = 0);
    }
    function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
            var sub = array[i], ok = !0;
            if (sub.ranges) {
                sub.copied || ((sub = array[i] = sub.deepCopy()).copied = !0);
                for (var j = 0; j < sub.ranges.length; j++) rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff), 
                rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
            } else {
                for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
                    var cur = sub.changes[j$1];
                    if (to < cur.from.line) cur.from = Pos(cur.from.line + diff, cur.from.ch), 
                    cur.to = Pos(cur.to.line + diff, cur.to.ch); else if (from <= cur.to.line) {
                        ok = !1;
                        break;
                    }
                }
                ok || (array.splice(0, i + 1), i = 0);
            }
        }
    }
    function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, change = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, change), rebaseHistArray(hist.undone, from, to, change);
    }
    function changeLine(doc, handle, changeType, op) {
        var no = handle, line = handle;
        return "number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle), 
        null == no ? null : (op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType), 
        line);
    }
    function LeafChunk(lines) {
        this.lines = lines, this.parent = null;
        for (var height = 0, i = 0; i < lines.length; ++i) lines[i].parent = this, 
        height += lines[i].height;
        this.height = height;
    }
    function BranchChunk(children) {
        this.children = children;
        for (var size = 0, height = 0, i = 0; i < children.length; ++i) {
            var ch = children[i];
            size += ch.chunkSize(), height += ch.height, ch.parent = this;
        }
        this.size = size, this.height = height, this.parent = null;
    }
    Range.prototype.from = function() {
        return minPos(this.anchor, this.head);
    }, Range.prototype.to = function() {
        return maxPos(this.anchor, this.head);
    }, Range.prototype.empty = function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }, LeafChunk.prototype = {
        chunkSize: function() {
            return this.lines.length;
        },
        removeInner: function(at, n) {
            for (var i = at, e = at + n; i < e; ++i) {
                var line = this.lines[i];
                this.height -= line.height, !function(line) {
                    line.parent = null, detachMarkedSpans(line);
                }(line), signalLater(line, "delete");
            }
            this.lines.splice(at, n);
        },
        collapse: function(lines) {
            lines.push.apply(lines, this.lines);
        },
        insertInner: function(at, lines, height) {
            this.height += height, this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
        },
        iterN: function(at, n, op) {
            for (var e = at + n; at < e; ++at) if (op(this.lines[at])) return !0;
        }
    }, BranchChunk.prototype = {
        chunkSize: function() {
            return this.size;
        },
        removeInner: function(at, n) {
            this.size -= n;
            for (var lines, i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var rm = Math.min(n, sz - at), oldHeight = child.height;
                    if (child.removeInner(at, rm), this.height -= oldHeight - child.height, 
                    sz == rm && (this.children.splice(i--, 1), child.parent = null), 
                    0 == (n -= rm)) break;
                    at = 0;
                } else at -= sz;
            }
            this.size - n < 25 && (1 < this.children.length || !(this.children[0] instanceof LeafChunk)) && (this.collapse(lines = []), 
            this.children = [ new LeafChunk(lines) ], this.children[0].parent = this);
        },
        collapse: function(lines) {
            for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
        },
        insertInner: function(at, lines, height) {
            this.size += lines.length, this.height += height;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at <= sz) {
                    if (child.insertInner(at, lines, height), child.lines && 50 < child.lines.length) {
                        for (var remaining = child.lines.length % 25 + 25, pos = remaining; pos < child.lines.length; ) {
                            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                            child.height -= leaf.height, this.children.splice(++i, 0, leaf), 
                            leaf.parent = this;
                        }
                        child.lines = child.lines.slice(0, remaining), this.maybeSpill();
                    }
                    break;
                }
                at -= sz;
            }
        },
        maybeSpill: function() {
            if (!(this.children.length <= 10)) {
                var me = this;
                do {
                    var myIndex, sibling = new BranchChunk(me.children.splice(me.children.length - 5, 5));
                } while (me.parent ? (me.size -= sibling.size, me.height -= sibling.height, 
                myIndex = indexOf(me.parent.children, me), me.parent.children.splice(myIndex + 1, 0, sibling)) : (((myIndex = new BranchChunk(me.children)).parent = me).children = [ myIndex, sibling ], 
                me = myIndex), sibling.parent = me.parent, 10 < me.children.length);
                me.parent.maybeSpill();
            }
        },
        iterN: function(at, n, op) {
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var used = Math.min(n, sz - at);
                    if (child.iterN(at, used, op)) return !0;
                    if (0 == (n -= used)) break;
                    at = 0;
                } else at -= sz;
            }
        }
    };
    function LineWidget(doc, node, options) {
        if (options) for (var opt in options) options.hasOwnProperty(opt) && (this[opt] = options[opt]);
        this.doc = doc, this.node = node;
    }
    function adjustScrollWhenAboveVisible(cm, line, diff) {
        heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollTop(cm, diff);
    }
    LineWidget.prototype.clear = function() {
        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (null != no && ws) {
            for (var i = 0; i < ws.length; ++i) ws[i] == this && ws.splice(i--, 1);
            ws.length || (line.widgets = null);
            var height = widgetHeight(this);
            updateLineHeight(line, Math.max(0, line.height - height)), cm && (runInOp(cm, function() {
                adjustScrollWhenAboveVisible(cm, line, -height), regLineChange(cm, no, "widget");
            }), signalLater(cm, "lineWidgetCleared", cm, this, no));
        }
    }, LineWidget.prototype.changed = function() {
        var this$1 = this, oldH = this.height, cm = this.doc.cm, line = this.line, diff = (this.height = null, 
        widgetHeight(this) - oldH);
        diff && (updateLineHeight(line, line.height + diff), cm && runInOp(cm, function() {
            cm.curOp.forceUpdate = !0, adjustScrollWhenAboveVisible(cm, line, diff), 
            signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
        }));
    }, eventMixin(LineWidget);
    function TextMarker(doc, type) {
        this.lines = [], this.type = type, this.doc = doc, this.id = ++nextMarkerId;
    }
    var nextMarkerId = 0;
    function markText(doc, from, to, options, type) {
        if (options && options.shared) return function(doc, from, to, options, type) {
            (options = copyObj(options)).shared = !1;
            var markers = [ markText(doc, from, to, options, type) ], primary = markers[0], widget = options.widgetNode;
            return linkedDocs(doc, function(doc) {
                widget && (options.widgetNode = widget.cloneNode(!0)), markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
                for (var i = 0; i < doc.linked.length; ++i) if (doc.linked[i].isParent) return;
                primary = lst(markers);
            }), new SharedTextMarker(markers, primary);
        }(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);
        var marker = new TextMarker(doc, type), type = cmp(from, to);
        if (options && copyObj(options, marker, !1), !(0 < type || 0 == type && !1 !== marker.clearWhenEmpty)) {
            if (marker.replacedWith && (marker.collapsed = !0, marker.widgetNode = eltP("span", [ marker.replacedWith ], "CodeMirror-widget"), 
            options.handleMouseEvents || marker.widgetNode.setAttribute("cm-ignore-events", "true"), 
            options.insertLeft && (marker.widgetNode.insertLeft = !0)), marker.collapsed) {
                if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
                sawCollapsedSpans = !0;
            }
            marker.addToHistory && addChangeToHistory(doc, {
                from: from,
                to: to,
                origin: "markText"
            }, doc.sel, NaN);
            var updateMaxLine, curLine = from.line, cm = doc.cm;
            if (doc.iter(curLine, to.line + 1, function(line) {
                cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = !0), 
                marker.collapsed && curLine != from.line && updateLineHeight(line, 0), 
                function(line, span) {
                    line.markedSpans = line.markedSpans ? line.markedSpans.concat([ span ]) : [ span ], 
                    span.marker.attachLine(line);
                }(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null)), 
                ++curLine;
            }), marker.collapsed && doc.iter(from.line, to.line + 1, function(line) {
                lineIsHidden(doc, line) && updateLineHeight(line, 0);
            }), marker.clearOnEnter && on(marker, "beforeCursorEnter", function() {
                return marker.clear();
            }), marker.readOnly && (sawReadOnlySpans = !0, (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()), 
            marker.collapsed && (marker.id = ++nextMarkerId, marker.atomic = !0), 
            cm) {
                if (updateMaxLine && (cm.curOp.updateMaxLine = !0), marker.collapsed) regChange(cm, from.line, to.line + 1); else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
                marker.atomic && reCheckSelection(cm.doc), signalLater(cm, "markerAdded", cm, marker);
            }
        }
        return marker;
    }
    TextMarker.prototype.clear = function() {
        if (!this.explicitlyCleared) {
            for (var found, cm = this.doc.cm, withOp = cm && !cm.curOp, min = (withOp && startOperation(cm), 
            !hasHandler(this, "clear") || (found = this.find()) && signalLater(this, "clear", found.from, found.to), 
            null), max = null, i = 0; i < this.lines.length; ++i) {
                var line = this.lines[i], span = getMarkedSpanFor(line.markedSpans, this);
                cm && !this.collapsed ? regLineChange(cm, lineNo(line), "text") : cm && (null != span.to && (max = lineNo(line)), 
                null != span.from && (min = lineNo(line))), line.markedSpans = function(spans, span) {
                    for (var r, i = 0; i < spans.length; ++i) spans[i] != span && (r = r || []).push(spans[i]);
                    return r;
                }(line.markedSpans, span), null == span.from && this.collapsed && !lineIsHidden(this.doc, line) && cm && updateLineHeight(line, textHeight(cm.display));
            }
            if (cm && this.collapsed && !cm.options.lineWrapping) for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
                var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
                len > cm.display.maxLineLength && (cm.display.maxLine = visual, 
                cm.display.maxLineLength = len, cm.display.maxLineChanged = !0);
            }
            null != min && cm && this.collapsed && regChange(cm, min, max + 1), 
            this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, 
            cm && reCheckSelection(cm.doc)), cm && signalLater(cm, "markerCleared", cm, this, min, max), 
            withOp && endOperation(cm), this.parent && this.parent.clear();
        }
    }, TextMarker.prototype.find = function(side, lineObj) {
        var from, to;
        null == side && "bookmark" == this.type && (side = 1);
        for (var i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i], span = getMarkedSpanFor(line.markedSpans, this);
            if (null != span.from && (from = Pos(lineObj ? line : lineNo(line), span.from), 
            -1 == side)) return from;
            if (null != span.to && (to = Pos(lineObj ? line : lineNo(line), span.to), 
            1 == side)) return to;
        }
        return from && {
            from: from,
            to: to
        };
    }, TextMarker.prototype.changed = function() {
        var this$1 = this, pos = this.find(-1, !0), widget = this, cm = this.doc.cm;
        pos && cm && runInOp(cm, function() {
            var line = pos.line, lineN = lineNo(pos.line), lineN = findViewForLine(cm, lineN);
            lineN && (clearLineMeasurementCacheFor(lineN), cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0), 
            cm.curOp.updateMaxLine = !0, lineIsHidden(widget.doc, line) || null == widget.height || (lineN = widget.height, 
            widget.height = null, (lineN = widgetHeight(widget) - lineN) && updateLineHeight(line, line.height + lineN)), 
            signalLater(cm, "markerChanged", cm, this$1);
        });
    }, TextMarker.prototype.attachLine = function(line) {
        var op;
        this.lines.length || !this.doc.cm || (op = this.doc.cm.curOp).maybeHiddenMarkers && -1 != indexOf(op.maybeHiddenMarkers, this) || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this), 
        this.lines.push(line);
    }, TextMarker.prototype.detachLine = function(line) {
        this.lines.splice(indexOf(this.lines, line), 1), !this.lines.length && this.doc.cm && ((line = this.doc.cm.curOp).maybeHiddenMarkers || (line.maybeHiddenMarkers = [])).push(this);
    }, eventMixin(TextMarker);
    var SharedTextMarker = function(markers, primary) {
        this.markers = markers, this.primary = primary;
        for (var i = 0; i < markers.length; ++i) markers[i].parent = this;
    };
    function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
            return m.parent;
        });
    }
    function detachSharedMarkers(markers) {
        for (var i = 0; i < markers.length; i++) !function(i) {
            var marker = markers[i], linked = [ marker.primary.doc ];
            linkedDocs(marker.primary.doc, function(d) {
                return linked.push(d);
            });
            for (var j = 0; j < marker.markers.length; j++) {
                var subMarker = marker.markers[j];
                -1 == indexOf(linked, subMarker.doc) && (subMarker.parent = null, 
                marker.markers.splice(j--, 1));
            }
        }(i);
    }
    SharedTextMarker.prototype.clear = function() {
        if (!this.explicitlyCleared) {
            this.explicitlyCleared = !0;
            for (var i = 0; i < this.markers.length; ++i) this.markers[i].clear();
            signalLater(this, "clear");
        }
    }, SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj);
    }, eventMixin(SharedTextMarker);
    function Doc(text, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep, direction);
        null == firstLine && (firstLine = 0), BranchChunk.call(this, [ new LeafChunk([ new Line("", null) ]) ]), 
        this.first = firstLine, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, 
        this.cleanGeneration = 1, firstLine = Pos(this.modeFrontier = this.highlightFrontier = firstLine, 0), 
        this.sel = simpleSelection(firstLine), this.history = new History(null), 
        this.id = ++nextDocId, this.modeOption = mode, this.lineSep = lineSep, this.direction = "rtl" == direction ? "rtl" : "ltr", 
        this.extend = !1, "string" == typeof text && (text = this.splitLines(text)), 
        updateDoc(this, {
            from: firstLine,
            to: firstLine,
            text: text
        }), setSelection(this, simpleSelection(firstLine), sel_dontScroll);
    }
    var nextDocId = 0, lastDrop = ((Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function(from, to, op) {
            op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from);
        },
        insert: function(at, lines) {
            for (var height = 0, i = 0; i < lines.length; ++i) height += lines[i].height;
            this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n) {
            this.removeInner(at - this.first, n);
        },
        getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            return !1 === lineSep ? lines : lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function(code) {
            var top = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
                from: top,
                to: Pos(last, getLine(this, last).text.length),
                text: this.splitLines(code),
                origin: "setValue",
                full: !0
            }, !0), this.cm && scrollToCoords(this.cm, 0, 0), setSelection(this, simpleSelection(top), sel_dontScroll);
        }),
        replaceRange: function(code, from, to, origin) {
            replaceRange(this, code, from = clipPos(this, from), to = to ? clipPos(this, to) : from, origin);
        },
        getRange: function(from, to, lineSep) {
            from = getBetween(this, clipPos(this, from), clipPos(this, to));
            return !1 === lineSep ? from : from.join(lineSep || this.lineSeparator());
        },
        getLine: function(line) {
            line = this.getLineHandle(line);
            return line && line.text;
        },
        getLineHandle: function(line) {
            if (isLine(this, line)) return getLine(this, line);
        },
        getLineNumber: lineNo,
        getLineHandleVisualStart: function(line) {
            return visualLine(line = "number" == typeof line ? getLine(this, line) : line);
        },
        lineCount: function() {
            return this.size;
        },
        firstLine: function() {
            return this.first;
        },
        lastLine: function() {
            return this.first + this.size - 1;
        },
        clipPos: function(pos) {
            return clipPos(this, pos);
        },
        getCursor: function(start) {
            var range$$1 = this.sel.primary(), start = null == start || "head" == start ? range$$1.head : "anchor" == start ? range$$1.anchor : "end" == start || "to" == start || !1 === start ? range$$1.to() : range$$1.from();
            return start;
        },
        listSelections: function() {
            return this.sel.ranges;
        },
        somethingSelected: function() {
            return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function(line, ch, options) {
            setSimpleSelection(this, clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
            extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
            extendSelections(this, clipPosArray(this, map(this.sel.ranges, f)), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
            if (ranges.length) {
                for (var out = [], i = 0; i < ranges.length; i++) out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
                setSelection(this, normalizeSelection(out, primary = null == primary ? Math.min(ranges.length - 1, this.sel.primIndex) : primary), options);
            }
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor))), 
            setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
        }),
        getSelection: function(lineSep) {
            for (var ranges = this.sel.ranges, i = 0; i < ranges.length; i++) var sel = getBetween(this, ranges[i].from(), ranges[i].to()), lines = lines ? lines.concat(sel) : sel;
            return !1 === lineSep ? lines : lines.join(lineSep || this.lineSeparator());
        },
        getSelections: function(lineSep) {
            for (var parts = [], ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                !1 !== lineSep && (sel = sel.join(lineSep || this.lineSeparator())), 
                parts[i] = sel;
            }
            return parts;
        },
        replaceSelection: function(code, collapse, origin) {
            for (var dup = [], i = 0; i < this.sel.ranges.length; i++) dup[i] = code;
            this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
            for (var changes = [], sel = this.sel, i = 0; i < sel.ranges.length; i++) {
                var range$$1 = sel.ranges[i];
                changes[i] = {
                    from: range$$1.from(),
                    to: range$$1.to(),
                    text: this.splitLines(code[i]),
                    origin: origin
                };
            }
            for (var collapse = collapse && "end" != collapse && function(doc, changes, hint) {
                for (var out = [], newPrev = oldPrev = Pos(doc.first, 0), i = 0; i < changes.length; i++) {
                    var change = changes[i], from = offsetPos(change.from, oldPrev, newPrev), to = offsetPos(changeEnd(change), oldPrev, newPrev), oldPrev = change.to, newPrev = to;
                    "around" == hint ? (change = cmp((change = doc.sel.ranges[i]).head, change.anchor) < 0, 
                    out[i] = new Range(change ? to : from, change ? from : to)) : out[i] = new Range(from, from);
                }
                return new Selection(out, doc.sel.primIndex);
            }(this, changes, collapse), i$1 = changes.length - 1; 0 <= i$1; i$1--) makeChange(this, changes[i$1]);
            collapse ? setSelectionReplaceHistory(this, collapse) : this.cm && ensureCursorVisible(this.cm);
        }),
        undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", !0);
        }),
        redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", !0);
        }),
        setExtending: function(val) {
            this.extend = val;
        },
        getExtending: function() {
            return this.extend;
        },
        historySize: function() {
            for (var hist = this.history, done = 0, undone = 0, i = 0; i < hist.done.length; i++) hist.done[i].ranges || ++done;
            for (var i$1 = 0; i$1 < hist.undone.length; i$1++) hist.undone[i$1].ranges || ++undone;
            return {
                undo: done,
                redo: undone
            };
        },
        clearHistory: function() {
            this.history = new History(this.history.maxGeneration);
        },
        markClean: function() {
            this.cleanGeneration = this.changeGeneration(!0);
        },
        changeGeneration: function(forceSplit) {
            return forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), 
            this.history.generation;
        },
        isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function() {
            return {
                done: copyHistoryArray(this.history.done),
                undone: copyHistoryArray(this.history.undone)
            };
        },
        setHistory: function(histData) {
            var hist = this.history = new History(this.history.maxGeneration);
            hist.done = copyHistoryArray(histData.done.slice(0), null, !0), hist.undone = copyHistoryArray(histData.undone.slice(0), null, !0);
        },
        setGutterMarker: docMethodOp(function(line, gutterID, value) {
            return changeLine(this, line, "gutter", function(line) {
                var markers = line.gutterMarkers || (line.gutterMarkers = {});
                return !(markers[gutterID] = value) && isEmpty(markers) && (line.gutterMarkers = null), 
                1;
            });
        }),
        clearGutter: docMethodOp(function(gutterID) {
            var this$1 = this;
            this.iter(function(line) {
                line.gutterMarkers && line.gutterMarkers[gutterID] && changeLine(this$1, line, "gutter", function() {
                    return line.gutterMarkers[gutterID] = null, isEmpty(line.gutterMarkers) && (line.gutterMarkers = null), 
                    1;
                });
            });
        }),
        lineInfo: function(line) {
            var n;
            if ("number" == typeof line) {
                if (!isLine(this, line)) return null;
                if (n = line, !(line = getLine(this, line))) return null;
            } else if (null == (n = lineNo(line))) return null;
            return {
                line: n,
                handle: line,
                text: line.text,
                gutterMarkers: line.gutterMarkers,
                textClass: line.textClass,
                bgClass: line.bgClass,
                wrapClass: line.wrapClass,
                widgets: line.widgets
            };
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
                if (line[prop]) {
                    if (classTest(cls).test(line[prop])) return;
                    line[prop] += " " + cls;
                } else line[prop] = cls;
                return 1;
            });
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass", cur = line[prop];
                if (cur) {
                    if (null == cls) line[prop] = null; else {
                        var found = cur.match(classTest(cls));
                        if (!found) return;
                        var end = found.index + found[0].length;
                        line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null;
                    }
                    return 1;
                }
            });
        }),
        addLineWidget: docMethodOp(function(handle, node, options) {
            return function(doc, handle, node, options) {
                var widget = new LineWidget(doc, node, options), cm = doc.cm;
                return cm && widget.noHScroll && (cm.display.alignWidgets = !0), 
                changeLine(doc, handle, "widget", function(line) {
                    var widgets = line.widgets || (line.widgets = []);
                    return null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget), 
                    widget.line = line, cm && !lineIsHidden(doc, line) && (widgets = heightAtLine(line) < doc.scrollTop, 
                    updateLineHeight(line, line.height + widgetHeight(widget)), 
                    widgets && addToScrollTop(cm, widget.height), cm.curOp.forceUpdate = !0), 
                    1;
                }), signalLater(cm, "lineWidgetAdded", cm, widget, "number" == typeof handle ? handle : lineNo(handle)), 
                widget;
            }(this, handle, node, options);
        }),
        removeLineWidget: function(widget) {
            widget.clear();
        },
        markText: function(from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function(pos, options) {
            options = {
                replacedWith: options && (null == options.nodeType ? options.widget : options),
                insertLeft: options && options.insertLeft,
                clearWhenEmpty: !1,
                shared: options && options.shared,
                handleMouseEvents: options && options.handleMouseEvents
            };
            return markText(this, pos = clipPos(this, pos), pos, options, "bookmark");
        },
        findMarksAt: function(pos) {
            var markers = [], spans = getLine(this, (pos = clipPos(this, pos)).line).markedSpans;
            if (spans) for (var i = 0; i < spans.length; ++i) {
                var span = spans[i];
                (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker);
            }
            return markers;
        },
        findMarks: function(from, to, filter) {
            from = clipPos(this, from), to = clipPos(this, to);
            var found = [], lineNo$$1 = from.line;
            return this.iter(from.line, to.line + 1, function(line) {
                var spans = line.markedSpans;
                if (spans) for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    null != span.to && lineNo$$1 == from.line && from.ch >= span.to || null == span.from && lineNo$$1 != from.line || null != span.from && lineNo$$1 == to.line && span.from >= to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker);
                }
                ++lineNo$$1;
            }), found;
        },
        getAllMarks: function() {
            var markers = [];
            return this.iter(function(line) {
                var sps = line.markedSpans;
                if (sps) for (var i = 0; i < sps.length; ++i) null != sps[i].from && markers.push(sps[i].marker);
            }), markers;
        },
        posFromIndex: function(off) {
            var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
            return this.iter(function(line) {
                line = line.text.length + sepSize;
                if (off < line) return ch = off, !0;
                off -= line, ++lineNo$$1;
            }), clipPos(this, Pos(lineNo$$1, ch));
        },
        indexFromPos: function(coords) {
            var sepSize, index = (coords = clipPos(this, coords)).ch;
            return coords.line < this.first || coords.ch < 0 ? 0 : (sepSize = this.lineSeparator().length, 
            this.iter(this.first, coords.line, function(line) {
                index += line.text.length + sepSize;
            }), index);
        },
        copy: function(copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
            return doc.scrollTop = this.scrollTop, doc.scrollLeft = this.scrollLeft, 
            doc.sel = this.sel, doc.extend = !1, copyHistory && (doc.history.undoDepth = this.history.undoDepth, 
            doc.setHistory(this.getHistory())), doc;
        },
        linkedDoc: function(options) {
            for (var from = this.first, to = this.first + this.size, to = (null != (options = options || {}).from && options.from > from && (from = options.from), 
            null != options.to && options.to < to && (to = options.to), new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction)), doc = (options.sharedHist && (to.history = this.history), 
            (this.linked || (this.linked = [])).push({
                doc: to,
                sharedHist: options.sharedHist
            }), to.linked = [ {
                doc: this,
                isParent: !0,
                sharedHist: options.sharedHist
            } ], to), markers = findSharedMarkers(this), i = 0; i < markers.length; i++) {
                var marker = markers[i], pos = marker.find(), mFrom = doc.clipPos(pos.from), pos = doc.clipPos(pos.to);
                cmp(mFrom, pos) && (mFrom = markText(doc, mFrom, pos, marker.primary, marker.primary.type), 
                marker.markers.push(mFrom), mFrom.parent = marker);
            }
            return to;
        },
        unlinkDoc: function(other) {
            var splitIds;
            if (other instanceof CodeMirror$1 && (other = other.doc), this.linked) for (var i = 0; i < this.linked.length; ++i) {
                var link = this.linked[i];
                if (link.doc == other) {
                    this.linked.splice(i, 1), other.unlinkDoc(this), detachSharedMarkers(findSharedMarkers(this));
                    break;
                }
            }
            other.history == this.history && (splitIds = [ other.id ], linkedDocs(other, function(doc) {
                return splitIds.push(doc.id);
            }, !0), other.history = new History(null), other.history.done = copyHistoryArray(this.history.done, splitIds), 
            other.history.undone = copyHistoryArray(this.history.undone, splitIds));
        },
        iterLinkedDocs: function(f) {
            linkedDocs(this, f);
        },
        getMode: function() {
            return this.mode;
        },
        getEditor: function() {
            return this.cm;
        },
        splitLines: function(str) {
            return this.lineSep ? str.split(this.lineSep) : splitLinesAuto(str);
        },
        lineSeparator: function() {
            return this.lineSep || "\n";
        },
        setDirection: docMethodOp(function(dir) {
            var cm;
            (dir = "rtl" != dir ? "ltr" : dir) != this.direction && (this.direction = dir, 
            this.iter(function(line) {
                return line.order = null;
            }), this.cm && runInOp(cm = this.cm, function() {
                setDirectionClass(cm), regChange(cm);
            }));
        })
    })).eachLine = Doc.prototype.iter, 0);
    function onDrop(e) {
        var cm = this;
        if (clearDragCursor(cm), !signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
            e_preventDefault(e), ie && (lastDrop = +new Date());
            var pos = posFromMouse(cm, e, !0), files = e.dataTransfer.files;
            if (pos && !cm.isReadOnly()) if (files && files.length && window.FileReader && window.File) for (var n = files.length, text = Array(n), read = 0, i = 0; i < n; ++i) !function(file, i) {
                var reader;
                cm.options.allowDropFileTypes && -1 == indexOf(cm.options.allowDropFileTypes, file.type) || ((reader = new FileReader()).onload = operation(cm, function() {
                    var content = reader.result;
                    /[\x00-\x08\x0e-\x1f]{2}/.test(content) && (content = ""), text[i] = content, 
                    ++read == n && (content = {
                        from: pos = clipPos(cm.doc, pos),
                        to: pos,
                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                        origin: "paste"
                    }, makeChange(cm.doc, content), setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(content))));
                }), reader.readAsText(file));
            }(files[i], i); else if (cm.state.draggingText && -1 < cm.doc.sel.contains(pos)) cm.state.draggingText(e), 
            setTimeout(function() {
                return cm.display.input.focus();
            }, 20); else try {
                var selected, text$1 = e.dataTransfer.getData("Text");
                if (text$1) {
                    if (cm.state.draggingText && !cm.state.draggingText.copy && (selected = cm.listSelections()), 
                    setSelectionNoUndo(cm.doc, simpleSelection(pos, pos)), selected) for (var i$1 = 0; i$1 < selected.length; ++i$1) replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                    cm.replaceSelection(text$1, "around", "paste"), cm.display.input.focus();
                }
            } catch (e) {}
        }
    }
    function clearDragCursor(cm) {
        cm.display.dragCursor && (cm.display.lineSpace.removeChild(cm.display.dragCursor), 
        cm.display.dragCursor = null);
    }
    function forEachCodeMirror(f) {
        if (document.getElementsByClassName) for (var byClass = document.getElementsByClassName("CodeMirror"), i = 0; i < byClass.length; i++) {
            var cm = byClass[i].CodeMirror;
            cm && f(cm);
        }
    }
    var globalsRegistered = !1;
    function ensureGlobalHandlers() {
        var resizeTimer;
        globalsRegistered || (on(window, "resize", function() {
            null == resizeTimer && (resizeTimer = setTimeout(function() {
                resizeTimer = null, forEachCodeMirror(onResize);
            }, 100));
        }), on(window, "blur", function() {
            return forEachCodeMirror(onBlur);
        }), globalsRegistered = !0);
    }
    function onResize(cm) {
        var d = cm.display;
        d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth || (d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, 
        d.scrollbarsClipped = !1, cm.setSize());
    }
    for (var keyNames = {
        3: "Enter",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        127: "Delete",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
    }, i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    for (var i$1 = 65; i$1 <= 90; i$1++) keyNames[i$1] = String.fromCharCode(i$1);
    for (var i$2 = 1; i$2 <= 12; i$2++) keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
    var keyMap = {};
    function normalizeKeyName(name) {
        var alt, ctrl, shift, cmd, parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        for (var i = 0; i < parts.length - 1; i++) {
            var mod = parts[i];
            if (/^(cmd|meta|m)$/i.test(mod)) cmd = !0; else if (/^a(lt)?$/i.test(mod)) alt = !0; else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = !0; else {
                if (!/^s(hift)?$/i.test(mod)) throw new Error("Unrecognized modifier name: " + mod);
                shift = !0;
            }
        }
        return alt && (name = "Alt-" + name), ctrl && (name = "Ctrl-" + name), cmd && (name = "Cmd-" + name), 
        name = shift ? "Shift-" + name : name;
    }
    function normalizeKeyMap(keymap) {
        var keyname, prop, copy = {};
        for (keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];
            if (!/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
                if ("..." != value) for (var keys = map(keyname.split(" "), normalizeKeyName), i = 0; i < keys.length; i++) {
                    var val = void 0, name = void 0, val = i == keys.length - 1 ? (name = keys.join(" "), 
                    value) : (name = keys.slice(0, i + 1).join(" "), "..."), prev = copy[name];
                    if (prev) {
                        if (prev != val) throw new Error("Inconsistent bindings for " + name);
                    } else copy[name] = val;
                }
                delete keymap[keyname];
            }
        }
        for (prop in copy) keymap[prop] = copy[prop];
        return keymap;
    }
    function lookupKey(key, map$$1, handle, context) {
        var found = (map$$1 = getKeyMap(map$$1)).call ? map$$1.call(key, context) : map$$1[key];
        if (!1 === found) return "nothing";
        if ("..." === found) return "multi";
        if (null != found && handle(found)) return "handled";
        if (map$$1.fallthrough) {
            if ("[object Array]" != Object.prototype.toString.call(map$$1.fallthrough)) return lookupKey(key, map$$1.fallthrough, handle, context);
            for (var i = 0; i < map$$1.fallthrough.length; i++) {
                var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
                if (result) return result;
            }
        }
    }
    function isModifierKey(value) {
        value = "string" == typeof value ? value : keyNames[value.keyCode];
        return "Ctrl" == value || "Alt" == value || "Shift" == value || "Mod" == value;
    }
    function addModifierNames(name, event, noShift) {
        var base = name;
        return event.altKey && "Alt" != base && (name = "Alt-" + name), (flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name), 
        (flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Cmd" != base && (name = "Cmd-" + name), 
        name = !noShift && event.shiftKey && "Shift" != base ? "Shift-" + name : name;
    }
    function keyName(event, noShift) {
        var name;
        return (!presto || 34 != event.keyCode || !event.char) && (null != (name = keyNames[event.keyCode]) && !event.altGraphKey && addModifierNames(name, event, noShift));
    }
    function getKeyMap(val) {
        return "string" == typeof val ? keyMap[val] : val;
    }
    function deleteNearSelection(cm, compute) {
        for (var ranges = cm.doc.sel.ranges, kill = [], i = 0; i < ranges.length; i++) {
            for (var toKill = compute(ranges[i]); kill.length && cmp(toKill.from, lst(kill).to) <= 0; ) {
                var replaced = kill.pop();
                if (cmp(replaced.from, toKill.from) < 0) {
                    toKill.from = replaced.from;
                    break;
                }
            }
            kill.push(toKill);
        }
        runInOp(cm, function() {
            for (var i = kill.length - 1; 0 <= i; i--) replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
            ensureCursorVisible(cm);
        });
    }
    function moveCharLogically(line, ch, dir) {
        ch = skipExtendingChars(line.text, ch + dir, dir);
        return ch < 0 || ch > line.text.length ? null : ch;
    }
    function moveLogically(line, start, dir) {
        line = moveCharLogically(line, start.ch, dir);
        return null == line ? null : new Pos(start.line, line, dir < 0 ? "after" : "before");
    }
    function endOfLine(visually, cm, lineObj, lineNo, dir) {
        if (visually) {
            var sticky, prep, ch, targetTop, visually = getOrder(lineObj, cm.doc.direction);
            if (visually) return sticky = dir < 0 == (1 == (visually = dir < 0 ? lst(visually) : visually[0]).level) ? "after" : "before", 
            0 < visually.level ? (prep = prepareMeasureForLine(cm, lineObj), ch = dir < 0 ? lineObj.text.length - 1 : 0, 
            targetTop = measureCharPrepared(cm, prep, ch).top, ch = findFirst(function(ch) {
                return measureCharPrepared(cm, prep, ch).top == targetTop;
            }, dir < 0 == (1 == visually.level) ? visually.from : visually.to - 1, ch), 
            "before" == sticky && (ch = moveCharLogically(lineObj, ch, 1))) : ch = dir < 0 ? visually.to : visually.from, 
            new Pos(lineNo, ch, sticky);
        }
        return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
    }
    function moveVisually(cm, line, start, dir) {
        var bidi = getOrder(line, cm.doc.direction);
        if (!bidi) return moveLogically(line, start, dir);
        start.ch >= line.text.length ? (start.ch = line.text.length, start.sticky = "before") : start.ch <= 0 && (start.ch = 0, 
        start.sticky = "after");
        var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
        if ("ltr" == cm.doc.direction && part.level % 2 == 0 && (0 < dir ? part.to > start.ch : part.from < start.ch)) return moveLogically(line, start, dir);
        function mv(pos, dir) {
            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
        }
        function getWrappedLineExtent(ch) {
            return cm.options.lineWrapping ? (prep = prep || prepareMeasureForLine(cm, line), 
            wrappedLineExtentChar(cm, line, prep, ch)) : {
                begin: 0,
                end: line.text.length
            };
        }
        var prep, wrappedLineExtent = getWrappedLineExtent("before" == start.sticky ? mv(start, -1) : start.ch);
        if ("rtl" == cm.doc.direction || 1 == part.level) {
            var moveInStorageOrder = 1 == part.level == dir < 0, ch = mv(start, moveInStorageOrder ? 1 : -1);
            if (null != ch && (moveInStorageOrder ? ch <= part.to && ch <= wrappedLineExtent.end : ch >= part.from && ch >= wrappedLineExtent.begin)) return new Pos(start.line, ch, moveInStorageOrder ? "before" : "after");
        }
        function searchInVisualLine(partPos, dir, wrappedLineExtent) {
            for (var getRes = function(ch, moveInStorageOrder) {
                return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
            }; 0 <= partPos && partPos < bidi.length; partPos += dir) {
                var part = bidi[partPos], moveInStorageOrder = 0 < dir == (1 != part.level), ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
                if (part.from <= ch && ch < part.to) return getRes(ch, moveInStorageOrder);
                if (ch = moveInStorageOrder ? part.from : mv(part.to, -1), wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) return getRes(ch, moveInStorageOrder);
            }
        }
        part = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
        return part || (null == (ch = 0 < dir ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1)) || 0 < dir && ch == line.text.length || !(part = searchInVisualLine(0 < dir ? 0 : bidi.length - 1, dir, getWrappedLineExtent(ch))) ? null : part);
    }
    keyMap.basic = {
        Left: "goCharLeft",
        Right: "goCharRight",
        Up: "goLineUp",
        Down: "goLineDown",
        End: "goLineEnd",
        Home: "goLineStartSmart",
        PageUp: "goPageUp",
        PageDown: "goPageDown",
        Delete: "delCharAfter",
        Backspace: "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        Tab: "defaultTab",
        "Shift-Tab": "indentAuto",
        Enter: "newlineAndIndent",
        Insert: "toggleOverwrite",
        Esc: "singleSelection"
    }, keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
    }, keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight",
        "Alt-B": "goWordLeft",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
    }, keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: [ "basic", "emacsy" ]
    }, keyMap.default = mac ? keyMap.macDefault : keyMap.pcDefault;
    var commands = {
        selectAll: selectAll,
        singleSelection: function(cm) {
            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function(cm) {
            return deleteNearSelection(cm, function(range) {
                var len;
                return range.empty() ? (len = getLine(cm.doc, range.head.line).text.length, 
                range.head.ch == len && range.head.line < cm.lastLine() ? {
                    from: range.head,
                    to: Pos(range.head.line + 1, 0)
                } : {
                    from: range.head,
                    to: Pos(range.head.line, len)
                }) : {
                    from: range.from(),
                    to: range.to()
                };
            });
        },
        deleteLine: function(cm) {
            return deleteNearSelection(cm, function(range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                };
            });
        },
        delLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: range.from()
                };
            });
        },
        delWrappedLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return {
                    from: cm.coordsChar({
                        left: 0,
                        top: top
                    }, "div"),
                    to: range.from()
                };
            });
        },
        delWrappedLineRight: function(cm) {
            return deleteNearSelection(cm, function(range) {
                var top = cm.charCoords(range.head, "div").top + 5, top = cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, "div");
                return {
                    from: range.from(),
                    to: top
                };
            });
        },
        undo: function(cm) {
            return cm.undo();
        },
        redo: function(cm) {
            return cm.redo();
        },
        undoSelection: function(cm) {
            return cm.undoSelection();
        },
        redoSelection: function(cm) {
            return cm.redoSelection();
        },
        goDocStart: function(cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function(cm) {
            return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return lineStart(cm, range.head.line);
            }, {
                origin: "+move",
                bias: 1
            });
        },
        goLineStartSmart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return lineStartSmart(cm, range.head);
            }, {
                origin: "+move",
                bias: 1
            });
        },
        goLineEnd: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return function(cm, lineN) {
                    var line = getLine(cm.doc, lineN), visual = function(line) {
                        for (var merged; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
                        return line;
                    }(line);
                    visual != line && (lineN = lineNo(visual));
                    return endOfLine(!0, cm, line, lineN, -1);
                }(cm, range.head.line);
            }, {
                origin: "+move",
                bias: -1
            });
        },
        goLineRight: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                range = cm.cursorCoords(range.head, "div").top + 5;
                return cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: range
                }, "div");
            }, sel_move);
        },
        goLineLeft: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                range = cm.cursorCoords(range.head, "div").top + 5;
                return cm.coordsChar({
                    left: 0,
                    top: range
                }, "div");
            }, sel_move);
        },
        goLineLeftSmart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                var top = cm.cursorCoords(range.head, "div").top + 5, top = cm.coordsChar({
                    left: 0,
                    top: top
                }, "div");
                return top.ch < cm.getLine(top.line).search(/\S/) ? lineStartSmart(cm, range.head) : top;
            }, sel_move);
        },
        goLineUp: function(cm) {
            return cm.moveV(-1, "line");
        },
        goLineDown: function(cm) {
            return cm.moveV(1, "line");
        },
        goPageUp: function(cm) {
            return cm.moveV(-1, "page");
        },
        goPageDown: function(cm) {
            return cm.moveV(1, "page");
        },
        goCharLeft: function(cm) {
            return cm.moveH(-1, "char");
        },
        goCharRight: function(cm) {
            return cm.moveH(1, "char");
        },
        goColumnLeft: function(cm) {
            return cm.moveH(-1, "column");
        },
        goColumnRight: function(cm) {
            return cm.moveH(1, "column");
        },
        goWordLeft: function(cm) {
            return cm.moveH(-1, "word");
        },
        goGroupRight: function(cm) {
            return cm.moveH(1, "group");
        },
        goGroupLeft: function(cm) {
            return cm.moveH(-1, "group");
        },
        goWordRight: function(cm) {
            return cm.moveH(1, "word");
        },
        delCharBefore: function(cm) {
            return cm.deleteH(-1, "char");
        },
        delCharAfter: function(cm) {
            return cm.deleteH(1, "char");
        },
        delWordBefore: function(cm) {
            return cm.deleteH(-1, "word");
        },
        delWordAfter: function(cm) {
            return cm.deleteH(1, "word");
        },
        delGroupBefore: function(cm) {
            return cm.deleteH(-1, "group");
        },
        delGroupAfter: function(cm) {
            return cm.deleteH(1, "group");
        },
        indentAuto: function(cm) {
            return cm.indentSelection("smart");
        },
        indentMore: function(cm) {
            return cm.indentSelection("add");
        },
        indentLess: function(cm) {
            return cm.indentSelection("subtract");
        },
        insertTab: function(cm) {
            return cm.replaceSelection("\t");
        },
        insertSoftTab: function(cm) {
            for (var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize, i = 0; i < ranges.length; i++) {
                var pos = ranges[i].from(), pos = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                spaces.push(spaceStr(tabSize - pos % tabSize));
            }
            cm.replaceSelections(spaces);
        },
        defaultTab: function(cm) {
            cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab");
        },
        transposeChars: function(cm) {
            return runInOp(cm, function() {
                for (var cur, line, prev, ranges = cm.listSelections(), newSel = [], i = 0; i < ranges.length; i++) ranges[i].empty() && (cur = ranges[i].head, 
                (line = getLine(cm.doc, cur.line).text) && (0 < (cur = cur.ch == line.length ? new Pos(cur.line, cur.ch - 1) : cur).ch ? (cur = new Pos(cur.line, cur.ch + 1), 
                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose")) : cur.line > cm.doc.first && ((prev = getLine(cm.doc, cur.line - 1).text) && (cur = new Pos(cur.line, 1), 
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose")))), 
                newSel.push(new Range(cur, cur)));
                cm.setSelections(newSel);
            });
        },
        newlineAndIndent: function(cm) {
            return runInOp(cm, function() {
                for (var i = (sels = cm.listSelections()).length - 1; 0 <= i; i--) cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
                for (var sels = cm.listSelections(), i$1 = 0; i$1 < sels.length; i$1++) cm.indentLine(sels[i$1].from().line, null, !0);
                ensureCursorVisible(cm);
            });
        },
        openLine: function(cm) {
            return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function(cm) {
            return cm.toggleOverwrite();
        }
    };
    function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN), visual = visualLine(line);
        return endOfLine(!0, cm, visual, lineN = visual != line ? lineNo(visual) : lineN, 1);
    }
    function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line), line = getLine(cm.doc, start.line), cm = getOrder(line, cm.doc.direction);
        return cm && 0 != cm[0].level ? start : (cm = Math.max(0, line.text.search(/\S/)), 
        line = pos.line == start.line && pos.ch <= cm && pos.ch, Pos(start.line, line ? 0 : cm, start.sticky));
    }
    function doHandleBinding(cm, bound, dropShift) {
        if ("string" == typeof bound && !(bound = commands[bound])) return !1;
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift, done = !1;
        try {
            cm.isReadOnly() && (cm.state.suppressEdits = !0), dropShift && (cm.display.shift = !1), 
            done = bound(cm) != Pass;
        } finally {
            cm.display.shift = prevShift, cm.state.suppressEdits = !1;
        }
        return done;
    }
    var stopSeq = new Delayed();
    function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
            if (isModifierKey(name)) return "handled";
            stopSeq.set(50, function() {
                cm.state.keySeq == seq && (cm.state.keySeq = null, cm.display.input.reset());
            }), name = seq + " " + name;
        }
        handle = function(cm, name, handle) {
            for (var i = 0; i < cm.state.keyMaps.length; i++) {
                var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
                if (result) return result;
            }
            return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
        }(cm, name, handle);
        return "multi" == handle && (cm.state.keySeq = name), "handled" == handle && signalLater(cm, "keyHandled", cm, name, e), 
        "handled" != handle && "multi" != handle || (e_preventDefault(e), restartBlink(cm)), 
        seq && !handle && /\'$/.test(name) ? (e_preventDefault(e), !0) : !!handle;
    }
    function handleKeyBinding(cm, e) {
        var name = keyName(e, !0);
        return !!name && (e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function(b) {
            return doHandleBinding(cm, b, !0);
        }) || dispatchKey(cm, name, e, function(b) {
            if ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b);
        }) : dispatchKey(cm, name, e, function(b) {
            return doHandleBinding(cm, b);
        }));
    }
    var lastStoppedKey = null;
    function onKeyDown(e) {
        var code, handled, cm = this;
        cm.curOp.focus = activeElt(), signalDOMEvent(cm, e) || (ie && ie_version < 11 && 27 == e.keyCode && (e.returnValue = !1), 
        code = e.keyCode, cm.display.shift = 16 == code || e.shiftKey, handled = handleKeyBinding(cm, e), 
        presto && (lastStoppedKey = handled ? code : null, !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")), 
        18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || function(cm) {
            var lineDiv = cm.display.lineDiv;
            function up(e) {
                18 != e.keyCode && e.altKey || (rmClass(lineDiv, "CodeMirror-crosshair"), 
                off(document, "keyup", up), off(document, "mouseover", up));
            }
            addClass(lineDiv, "CodeMirror-crosshair"), on(document, "keyup", up), 
            on(document, "mouseover", up);
        }(cm));
    }
    function onKeyUp(e) {
        16 == e.keyCode && (this.doc.sel.shift = !1), signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
        var charCode, keyCode, cm = this;
        eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey || (keyCode = e.keyCode, 
        charCode = e.charCode, presto && keyCode == lastStoppedKey ? (lastStoppedKey = null, 
        e_preventDefault(e)) : presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e) || "\b" == (keyCode = String.fromCharCode(null == charCode ? keyCode : charCode)) || function(cm, e, ch) {
            return dispatchKey(cm, "'" + ch + "'", e, function(b) {
                return doHandleBinding(cm, b, !0);
            });
        }(cm, e, keyCode) || cm.display.input.onKeyPress(e));
    }
    function PastClick(time, pos, button) {
        this.time = time, this.pos = pos, this.button = button;
    }
    var lastClick, lastDoubleClick;
    function onMouseDown(e) {
        var pos, button, repeat, cm = this, display = cm.display;
        signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch() || (display.input.ensurePolled(), 
        display.shift = e.shiftKey, eventInWidget(display, e) ? webkit || (display.scroller.draggable = !1, 
        setTimeout(function() {
            return display.scroller.draggable = !0;
        }, 100)) : clickInGutter(cm, e) || (pos = posFromMouse(cm, e), button = e_button(e), 
        repeat = pos ? function(pos, button) {
            var now = +new Date();
            return lastDoubleClick && lastDoubleClick.compare(now, pos, button) ? (lastClick = lastDoubleClick = null, 
            "triple") : lastClick && lastClick.compare(now, pos, button) ? (lastDoubleClick = new PastClick(now, pos, button), 
            lastClick = null, "double") : (lastClick = new PastClick(now, pos, button), 
            lastDoubleClick = null, "single");
        }(pos, button) : "single", window.focus(), 1 == button && cm.state.selectingText && cm.state.selectingText(e), 
        pos && function(cm, button, pos, repeat, event) {
            var name = "Click";
            "double" == repeat ? name = "Double" + name : "triple" == repeat && (name = "Triple" + name);
            return dispatchKey(cm, addModifierNames(name = (1 == button ? "Left" : 2 == button ? "Middle" : "Right") + name, event), event, function(bound) {
                if (!(bound = "string" == typeof bound ? commands[bound] : bound)) return !1;
                var done = !1;
                try {
                    cm.isReadOnly() && (cm.state.suppressEdits = !0), done = bound(cm, pos) != Pass;
                } finally {
                    cm.state.suppressEdits = !1;
                }
                return done;
            });
        }(cm, button, pos, repeat, e) || (1 == button ? pos ? function(cm, pos, repeat, event) {
            ie ? setTimeout(bind(ensureFocus, cm), 0) : cm.curOp.focus = activeElt();
            var behavior = function(cm, repeat, event) {
                var option = cm.getOption("configureMouse"), option = option ? option(cm, repeat, event) : {};
                {
                    var rect;
                    null == option.unit && (rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey, 
                    option.unit = rect ? "rectangle" : "single" == repeat ? "char" : "double" == repeat ? "word" : "line");
                }
                null != option.extend && !cm.doc.extend || (option.extend = cm.doc.extend || event.shiftKey);
                null == option.addNew && (option.addNew = mac ? event.metaKey : event.ctrlKey);
                null == option.moveOnDrag && (option.moveOnDrag = !(mac ? event.altKey : event.ctrlKey));
                return option;
            }(cm, repeat, event), sel = cm.doc.sel;
            (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && "single" == repeat && -1 < (repeat = sel.contains(pos)) && (cmp((repeat = sel.ranges[repeat]).from(), pos) < 0 || 0 < pos.xRel) && (0 < cmp(repeat.to(), pos) || pos.xRel < 0) ? function(cm, event, pos, behavior) {
                var display = cm.display, moved = !1, dragEnd = operation(cm, function(e) {
                    webkit && (display.scroller.draggable = !1), cm.state.draggingText = !1, 
                    off(document, "mouseup", dragEnd), off(document, "mousemove", mouseMove), 
                    off(display.scroller, "dragstart", dragStart), off(display.scroller, "drop", dragEnd), 
                    moved || (e_preventDefault(e), behavior.addNew || extendSelection(cm.doc, pos, null, null, behavior.extend), 
                    webkit || ie && 9 == ie_version ? setTimeout(function() {
                        document.body.focus(), display.input.focus();
                    }, 20) : display.input.focus());
                }), mouseMove = function(e2) {
                    moved = moved || 10 <= Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY);
                }, dragStart = function() {
                    return moved = !0;
                };
                webkit && (display.scroller.draggable = !0);
                (cm.state.draggingText = dragEnd).copy = !behavior.moveOnDrag, display.scroller.dragDrop && display.scroller.dragDrop();
                on(document, "mouseup", dragEnd), on(document, "mousemove", mouseMove), 
                on(display.scroller, "dragstart", dragStart), on(display.scroller, "drop", dragEnd), 
                delayBlurEvent(cm), setTimeout(function() {
                    return display.input.focus();
                }, 20);
            } : function(cm, event, start, behavior) {
                var display = cm.display, doc = cm.doc;
                e_preventDefault(event);
                var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
                behavior.addNew && !behavior.extend ? (ourIndex = doc.sel.contains(start), 
                ourRange = -1 < ourIndex ? ranges[ourIndex] : new Range(start, start)) : (ourRange = doc.sel.primary(), 
                ourIndex = doc.sel.primIndex);
                "rectangle" == behavior.unit ? (behavior.addNew || (ourRange = new Range(start, start)), 
                start = posFromMouse(cm, event, !0, !0), ourIndex = -1) : (event = rangeForUnit(cm, start, behavior.unit), 
                ourRange = behavior.extend ? extendRange(ourRange, event.anchor, event.head, behavior.extend) : event);
                behavior.addNew ? -1 == ourIndex ? (ourIndex = ranges.length, setSelection(doc, normalizeSelection(ranges.concat([ ourRange ]), ourIndex), {
                    scroll: !1,
                    origin: "*mouse"
                })) : 1 < ranges.length && ranges[ourIndex].empty() && "char" == behavior.unit && !behavior.extend ? (setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
                    scroll: !1,
                    origin: "*mouse"
                }), startSel = doc.sel) : replaceOneSelection(doc, ourIndex, ourRange, sel_mouse) : (setSelection(doc, new Selection([ ourRange ], ourIndex = 0), sel_mouse), 
                startSel = doc.sel);
                var lastPos = start;
                function extendTo(pos) {
                    if (0 != cmp(lastPos, pos)) if (lastPos = pos, "rectangle" == behavior.unit) {
                        for (var ranges = [], tabSize = cm.options.tabSize, startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize), posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize), left = Math.min(startCol, posCol), right = Math.max(startCol, posCol), line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                            left == right ? ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                        }
                        ranges.length || ranges.push(new Range(start, start)), setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                            origin: "*mouse",
                            scroll: !1
                        }), cm.scrollIntoView(pos);
                    } else {
                        var head, startCol = ourRange, posCol = rangeForUnit(cm, pos, behavior.unit), pos = startCol.anchor, pos = 0 < cmp(posCol.anchor, pos) ? (head = posCol.head, 
                        minPos(startCol.from(), posCol.anchor)) : (head = posCol.anchor, 
                        maxPos(startCol.to(), posCol.head)), startCol = startSel.ranges.slice(0);
                        startCol[ourIndex] = function(cm, range$$1) {
                            var anchor = range$$1.anchor, head = range$$1.head, anchorLine = getLine(cm.doc, anchor.line);
                            if (0 == cmp(anchor, head) && anchor.sticky == head.sticky) return range$$1;
                            anchorLine = getOrder(anchorLine);
                            if (!anchorLine) return range$$1;
                            var index = getBidiPartAt(anchorLine, anchor.ch, anchor.sticky), part = anchorLine[index];
                            if (part.from != anchor.ch && part.to != anchor.ch) return range$$1;
                            var boundary = index + (part.from == anchor.ch == (1 != part.level) ? 0 : 1);
                            if (0 == boundary || boundary == anchorLine.length) return range$$1;
                            part = head.line != anchor.line ? 0 < (head.line - anchor.line) * ("ltr" == cm.doc.direction ? 1 : -1) : (cm = getBidiPartAt(anchorLine, head.ch, head.sticky), 
                            index = cm - index || (head.ch - anchor.ch) * (1 == part.level ? -1 : 1), 
                            cm == boundary - 1 || cm == boundary ? index < 0 : 0 < index);
                            cm = anchorLine[boundary + (part ? -1 : 0)], index = part == (1 == cm.level), 
                            anchorLine = index ? cm.from : cm.to, boundary = index ? "after" : "before";
                            return anchor.ch == anchorLine && anchor.sticky == boundary ? range$$1 : new Range(new Pos(anchor.line, anchorLine, boundary), head);
                        }(cm, new Range(clipPos(doc, pos), head)), setSelection(doc, normalizeSelection(startCol, ourIndex), sel_mouse);
                    }
                }
                var editorSize = display.wrapper.getBoundingClientRect(), counter = 0;
                function done(e) {
                    cm.state.selectingText = !1, counter = 1 / 0, e_preventDefault(e), 
                    display.input.focus(), off(document, "mousemove", move), off(document, "mouseup", up), 
                    doc.history.lastSelOrigin = null;
                }
                var move = operation(cm, function(e) {
                    (e_button(e) ? function extend(e) {
                        var visible, outside, curCount = ++counter, cur = posFromMouse(cm, e, !0, "rectangle" == behavior.unit);
                        cur && (0 != cmp(cur, lastPos) ? (cm.curOp.focus = activeElt(), 
                        extendTo(cur), visible = visibleLines(display, doc), (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function() {
                            counter == curCount && extend(e);
                        }), 150)) : (outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0) && setTimeout(operation(cm, function() {
                            counter == curCount && (display.scroller.scrollTop += outside, 
                            extend(e));
                        }), 50));
                    } : done)(e);
                }), up = operation(cm, done);
                cm.state.selectingText = up, on(document, "mousemove", move), on(document, "mouseup", up);
            })(cm, event, pos, behavior);
        }(cm, pos, repeat, e) : e_target(e) == display.scroller && e_preventDefault(e) : 2 == button ? (pos && extendSelection(cm.doc, pos), 
        setTimeout(function() {
            return display.input.focus();
        }, 20)) : 3 == button && (captureRightClick ? onContextMenu(cm, e) : delayBlurEvent(cm)))));
    }
    function rangeForUnit(cm, pos, unit) {
        return "char" == unit ? new Range(pos, pos) : "word" == unit ? cm.findWordAt(pos) : "line" == unit ? new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) : (unit = unit(cm, pos), 
        new Range(unit.from, unit.to));
    }
    function gutterEvent(cm, e, type, prevent) {
        var mX, mY;
        if (e.touches) mX = e.touches[0].clientX, mY = e.touches[0].clientY; else try {
            mX = e.clientX, mY = e.clientY;
        } catch (e) {
            return !1;
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return !1;
        prevent && e_preventDefault(e);
        var display = cm.display, prevent = display.lineDiv.getBoundingClientRect();
        if (mY > prevent.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
        mY -= prevent.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
            var g = display.gutters.childNodes[i];
            if (g && g.getBoundingClientRect().right >= mX) return signal(cm, type, cm, lineAtHeight(cm.doc, mY), cm.options.gutters[i], e), 
            e_defaultPrevented(e);
        }
    }
    function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", !0);
    }
    function onContextMenu(cm, e) {
        eventInWidget(cm.display, e) || function(cm, e) {
            return hasHandler(cm, "gutterContextMenu") && gutterEvent(cm, e, "gutterContextMenu", !1);
        }(cm, e) || signalDOMEvent(cm, e, "contextmenu") || cm.display.input.onContextMenu(e);
    }
    function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), 
        clearCaches(cm);
    }
    PastClick.prototype.compare = function(time, pos, button) {
        return this.time + 400 > time && 0 == cmp(pos, this.pos) && button == this.button;
    };
    var Init = {
        toString: function() {
            return "CodeMirror.Init";
        }
    }, defaults = {}, optionHandlers = {};
    function guttersChanged(cm) {
        updateGutters(cm), regChange(cm), alignHorizontally(cm);
    }
    function dragDropChanged(cm, value, old) {
        !value != !(old && old != Init) && (old = cm.display.dragFunctions, (value = value ? on : off)(cm.display.scroller, "dragstart", old.start), 
        value(cm.display.scroller, "dragenter", old.enter), value(cm.display.scroller, "dragover", old.over), 
        value(cm.display.scroller, "dragleave", old.leave), value(cm.display.scroller, "drop", old.drop));
    }
    function wrappingChanged(cm) {
        cm.options.lineWrapping ? (addClass(cm.display.wrapper, "CodeMirror-wrap"), 
        cm.display.sizer.style.minWidth = "", cm.display.sizerWidth = null) : (rmClass(cm.display.wrapper, "CodeMirror-wrap"), 
        findMaxLine(cm)), estimateLineHeights(cm), regChange(cm), clearCaches(cm), 
        setTimeout(function() {
            return updateScrollbars(cm);
        }, 100);
    }
    function CodeMirror$1(place, options) {
        var this$1 = this;
        if (!(this instanceof CodeMirror$1)) return new CodeMirror$1(place, options);
        this.options = options = options ? copyObj(options) : {}, copyObj(defaults, options, !1), 
        setGuttersForLineNumbers(options);
        var opt, doc = options.value, input = ("string" == typeof doc && (doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction)), 
        this.doc = doc, new CodeMirror$1.inputStyles[options.inputStyle](this)), place = this.display = new Display(place, doc, input), cm = (updateGutters(place.wrapper.CodeMirror = this), 
        themeChanged(this), options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), 
        initScrollbars(this), this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: !1,
            delayingBlurEvent: !1,
            focused: !1,
            suppressEdits: !1,
            pasteIncoming: !1,
            cutIncoming: !1,
            selectingText: !1,
            draggingText: !1,
            highlight: new Delayed(),
            keySeq: null,
            specialChars: null
        }, options.autofocus && !mobile && place.input.focus(), ie && ie_version < 11 && setTimeout(function() {
            return this$1.display.input.reset(!0);
        }, 20), this), d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown)), on(d.scroller, "dblclick", ie && ie_version < 11 ? operation(cm, function(e) {
            var pos;
            signalDOMEvent(cm, e) || (!(pos = posFromMouse(cm, e)) || clickInGutter(cm, e) || eventInWidget(cm.display, e) || (e_preventDefault(e), 
            e = cm.findWordAt(pos), extendSelection(cm.doc, e.anchor, e.head)));
        }) : function(e) {
            return signalDOMEvent(cm, e) || e_preventDefault(e);
        }), captureRightClick || on(d.scroller, "contextmenu", function(e) {
            return onContextMenu(cm, e);
        });
        var touchFinished, prevTouch = {
            end: 0
        };
        function finishTouch() {
            d.activeTouch && (touchFinished = setTimeout(function() {
                return d.activeTouch = null;
            }, 1e3), (prevTouch = d.activeTouch).end = +new Date());
        }
        function farAway(touch, other) {
            var dx;
            return null == other.left || 400 < (dx = other.left - touch.left) * dx + (dx = other.top - touch.top) * dx;
        }
        on(d.scroller, "touchstart", function(e) {
            var now;
            signalDOMEvent(cm, e) || function(e) {
                if (1 == e.touches.length) return (e = e.touches[0]).radiusX <= 1 && e.radiusY <= 1;
            }(e) || clickInGutter(cm, e) || (d.input.ensurePolled(), clearTimeout(touchFinished), 
            now = +new Date(), d.activeTouch = {
                start: now,
                moved: !1,
                prev: now - prevTouch.end <= 300 ? prevTouch : null
            }, 1 == e.touches.length && (d.activeTouch.left = e.touches[0].pageX, 
            d.activeTouch.top = e.touches[0].pageY));
        }), on(d.scroller, "touchmove", function() {
            d.activeTouch && (d.activeTouch.moved = !0);
        }), on(d.scroller, "touchend", function(e) {
            var pos, touch = d.activeTouch;
            touch && !eventInWidget(d, e) && null != touch.left && !touch.moved && new Date() - touch.start < 300 && (pos = cm.coordsChar(d.activeTouch, "page"), 
            touch = !touch.prev || farAway(touch, touch.prev) ? new Range(pos, pos) : !touch.prev.prev || farAway(touch, touch.prev.prev) ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))), 
            cm.setSelection(touch.anchor, touch.head), cm.focus(), e_preventDefault(e)), 
            finishTouch();
        }), on(d.scroller, "touchcancel", finishTouch), on(d.scroller, "scroll", function() {
            d.scroller.clientHeight && (updateScrollTop(cm, d.scroller.scrollTop), 
            setScrollLeft(cm, d.scroller.scrollLeft, !0), signal(cm, "scroll", cm));
        }), on(d.scroller, "mousewheel", function(e) {
            return onScrollWheel(cm, e);
        }), on(d.scroller, "DOMMouseScroll", function(e) {
            return onScrollWheel(cm, e);
        }), on(d.wrapper, "scroll", function() {
            return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        }), d.dragFunctions = {
            enter: function(e) {
                signalDOMEvent(cm, e) || e_stop(e);
            },
            over: function(e) {
                signalDOMEvent(cm, e) || (!function(cm, e) {
                    (e = posFromMouse(cm, e)) && (drawSelectionCursor(cm, e, e = document.createDocumentFragment()), 
                    cm.display.dragCursor || (cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), 
                    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)), 
                    removeChildrenAndAdd(cm.display.dragCursor, e));
                }(cm, e), e_stop(e));
            },
            start: function(e) {
                return function(cm, e) {
                    var img;
                    ie && (!cm.state.draggingText || +new Date() - lastDrop < 100) ? e_stop(e) : signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (e.dataTransfer.setData("Text", cm.getSelection()), 
                    e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !safari && ((img = elt("img", null, null, "position: fixed; left: 0; top: 0;")).src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", 
                    presto && (img.width = img.height = 1, cm.display.wrapper.appendChild(img), 
                    img._top = img.offsetTop), e.dataTransfer.setDragImage(img, 0, 0), 
                    presto && img.parentNode.removeChild(img)));
                }(cm, e);
            },
            drop: operation(cm, onDrop),
            leave: function(e) {
                signalDOMEvent(cm, e) || clearDragCursor(cm);
            }
        };
        input = d.input.getField();
        for (opt in on(input, "keyup", function(e) {
            return onKeyUp.call(cm, e);
        }), on(input, "keydown", operation(cm, onKeyDown)), on(input, "keypress", operation(cm, onKeyPress)), 
        on(input, "focus", function(e) {
            return onFocus(cm, e);
        }), on(input, "blur", function(e) {
            return onBlur(cm, e);
        }), ensureGlobalHandlers(), startOperation(this), this.curOp.forceUpdate = !0, 
        attachDoc(this, doc), options.autofocus && !mobile || this.hasFocus() ? setTimeout(bind(onFocus, this), 20) : onBlur(this), 
        optionHandlers) optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this$1, options[opt], Init);
        maybeUpdateLineNumberWidth(this), options.finishInit && options.finishInit(this);
        for (var i = 0; i < initHooks.length; ++i) initHooks[i](this$1);
        endOperation(this), webkit && options.lineWrapping && "optimizelegibility" == getComputedStyle(place.lineDiv).textRendering && (place.lineDiv.style.textRendering = "auto");
    }
    CodeMirror$1.defaults = defaults, CodeMirror$1.optionHandlers = optionHandlers;
    var initHooks = [];
    function indentLine(cm, n, how, aggressive) {
        var state, doc = cm.doc, tabSize = ("smart" == (how = null == how ? "add" : how) && (doc.mode.indent ? state = getContextBefore(cm, n).state : how = "prev"), 
        cm.options.tabSize), line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize), curSpaceString = (line.stateAfter && (line.stateAfter = null), 
        line.text.match(/^\s*/)[0]);
        if (aggressive || /\S/.test(line.text)) {
            if ("smart" == how && ((indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)) == Pass || 150 < indentation)) {
                if (!aggressive) return;
                how = "prev";
            }
        } else indentation = 0, how = "not";
        "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how);
        var indentation = Math.max(0, indentation), indentString = "", pos = 0;
        if (cm.options.indentWithTabs) for (var i = Math.floor(indentation / tabSize); i; --i) pos += tabSize, 
        indentString += "\t";
        if (pos < indentation && (indentString += spaceStr(indentation - pos)), 
        indentString != curSpaceString) return replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input"), 
        !(line.stateAfter = null);
        for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
            var range = doc.sel.ranges[i$1];
            if (range.head.line == n && range.head.ch < curSpaceString.length) {
                range = Pos(n, curSpaceString.length);
                replaceOneSelection(doc, i$1, new Range(range, range));
                break;
            }
        }
    }
    CodeMirror$1.defineInitHook = function(f) {
        return initHooks.push(f);
    };
    var lastCopied = null;
    function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
    }
    function applyTextInput(cm, inserted, deleted, sel, origin) {
        var updateInput, doc = cm.doc, paste = (cm.display.shift = !1, sel = sel || doc.sel, 
        cm.state.pasteIncoming || "paste" == origin), textLines = splitLinesAuto(inserted), multiPaste = null;
        if (paste && 1 < sel.ranges.length) if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) for (var multiPaste = [], i = 0; i < lastCopied.text.length; i++) multiPaste.push(doc.splitLines(lastCopied.text[i]));
        } else textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection && (multiPaste = map(textLines, function(l) {
            return [ l ];
        }));
        for (var i$1 = sel.ranges.length - 1; 0 <= i$1; i$1--) {
            var range$$1 = sel.ranges[i$1], from = range$$1.from(), to = range$$1.to(), range$$1 = (range$$1.empty() && (deleted && 0 < deleted ? from = Pos(from.line, from.ch - deleted) : cm.state.overwrite && !paste ? to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) : lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted && (from = to = Pos(from.line, 0))), 
            updateInput = cm.curOp.updateInput, {
                from: from,
                to: to,
                text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
            });
            makeChange(cm.doc, range$$1), signalLater(cm, "inputRead", cm, range$$1);
        }
        inserted && !paste && triggerElectric(cm, inserted), ensureCursorVisible(cm), 
        cm.curOp.updateInput = updateInput, cm.curOp.typing = !0, cm.state.pasteIncoming = cm.state.cutIncoming = !1;
    }
    function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");
        return pasted && (e.preventDefault(), cm.isReadOnly() || cm.options.disableInput || runInOp(cm, function() {
            return applyTextInput(cm, pasted, 0, null, "paste");
        }), 1);
    }
    function triggerElectric(cm, inserted) {
        if (cm.options.electricChars && cm.options.smartIndent) for (var sel = cm.doc.sel, i = sel.ranges.length - 1; 0 <= i; i--) {
            var range$$1 = sel.ranges[i];
            if (!(100 < range$$1.head.ch || i && sel.ranges[i - 1].head.line == range$$1.head.line)) {
                var mode = cm.getModeAt(range$$1.head), indented = !1;
                if (mode.electricChars) {
                    for (var j = 0; j < mode.electricChars.length; j++) if (-1 < inserted.indexOf(mode.electricChars.charAt(j))) {
                        indented = indentLine(cm, range$$1.head.line, "smart");
                        break;
                    }
                } else mode.electricInput && mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)) && (indented = indentLine(cm, range$$1.head.line, "smart"));
                indented && signalLater(cm, "electricInput", cm, range$$1.head.line);
            }
        }
    }
    function copyableRanges(cm) {
        for (var text = [], ranges = [], i = 0; i < cm.doc.sel.ranges.length; i++) {
            var line = cm.doc.sel.ranges[i].head.line, line = {
                anchor: Pos(line, 0),
                head: Pos(line + 1, 0)
            };
            ranges.push(line), text.push(cm.getRange(line.anchor, line.head));
        }
        return {
            text: text,
            ranges: ranges
        };
    }
    function disableBrowserMagic(field, spellcheck) {
        field.setAttribute("autocorrect", "off"), field.setAttribute("autocapitalize", "off"), 
        field.setAttribute("spellcheck", !!spellcheck);
    }
    function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"), div = elt("div", [ te ], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        return webkit ? te.style.width = "1000px" : te.setAttribute("wrap", "off"), 
        ios && (te.style.border = "1px solid black"), disableBrowserMagic(te), div;
    }
    function findPosH(doc, pos, dir, unit, visually) {
        var oldPos = pos, origDir = dir, lineObj = getLine(doc, pos.line);
        function moveOnce(boundToLine) {
            var next = visually ? moveVisually(doc.cm, lineObj, pos, dir) : moveLogically(lineObj, pos, dir);
            if (null == next) {
                if (boundToLine || (boundToLine = pos.line + dir) < doc.first || boundToLine >= doc.first + doc.size || (pos = new Pos(boundToLine, pos.ch, pos.sticky), 
                !(lineObj = getLine(doc, boundToLine)))) return;
                pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);
            } else pos = next;
            return 1;
        }
        if ("char" == unit) moveOnce(); else if ("column" == unit) moveOnce(!0); else if ("word" == unit || "group" == unit) for (var sawType = null, group = "group" == unit, helper = doc.cm && doc.cm.getHelper(pos, "wordChars"), first = !0; !(dir < 0) || moveOnce(!first); first = !1) {
            var cur = lineObj.text.charAt(pos.ch) || "\n", cur = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
            if (!group || first || cur || (cur = "s"), sawType && sawType != cur) {
                dir < 0 && (dir = 1, moveOnce(), pos.sticky = "after");
                break;
            }
            if (cur && (sawType = cur), 0 < dir && !moveOnce(!first)) break;
        }
        unit = skipAtomic(doc, pos, oldPos, origDir, !0);
        return equalCursorPos(oldPos, unit) && (unit.hitSide = !0), unit;
    }
    function findPosV(cm, pos, dir, unit) {
        var pageSize, y, target, doc = cm.doc, x = pos.left;
        for ("page" == unit ? (pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), 
        pageSize = Math.max(pageSize - .5 * textHeight(cm.display), 3), y = (0 < dir ? pos.bottom : pos.top) + dir * pageSize) : "line" == unit && (y = 0 < dir ? pos.bottom + 3 : pos.top - 3); (target = coordsChar(cm, x, y)).outside; ) {
            if (dir < 0 ? y <= 0 : y >= doc.height) {
                target.hitSide = !0;
                break;
            }
            y += 5 * dir;
        }
        return target;
    }
    function ContentEditableInput(cm) {
        this.cm = cm, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, 
        this.polling = new Delayed(), this.composing = null, this.gracePeriod = !1, 
        this.readDOMTimeout = null;
    }
    function posToDOM(cm, pos) {
        var info, side, view = findViewForLine(cm, pos.line);
        return !view || view.hidden ? null : (info = mapFromLineView(view, view = getLine(cm.doc, pos.line), pos.line), 
        side = "left", (view = getOrder(view, cm.doc.direction)) && (side = getBidiPartAt(view, pos.ch) % 2 ? "right" : "left"), 
        (cm = nodeAndOffsetInLineMap(info.map, pos.ch, side)).offset = "right" == cm.collapse ? cm.end : cm.start, 
        cm);
    }
    function badPos(pos, bad) {
        return bad && (pos.bad = !0), pos;
    }
    function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
            if (!(lineNode = cm.display.lineDiv.childNodes[offset])) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), !0);
            node = null, offset = 0;
        } else for (lineNode = node; ;lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) return null;
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
        }
        for (var i = 0; i < cm.display.view.length; i++) {
            var lineView = cm.display.view[i];
            if (lineView.node == lineNode) return function(lineView, node, offset) {
                var wrapper = lineView.text.firstChild, bad = !1;
                if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), !0);
                if (node == wrapper) if (bad = !0, node = wrapper.childNodes[offset], 
                offset = 0, !node) return badPos(Pos(lineNo(line = lineView.rest ? lst(lineView.rest) : lineView.line), line.text.length), bad);
                var line = 3 == node.nodeType ? node : null, topNode = node;
                line || 1 != node.childNodes.length || 3 != node.firstChild.nodeType || (line = node.firstChild, 
                offset = offset && line.nodeValue.length);
                for (;topNode.parentNode != wrapper; ) topNode = topNode.parentNode;
                var measure = lineView.measure, maps = measure.maps;
                function find(textNode, topNode, offset) {
                    for (var i = -1; i < (maps ? maps.length : 0); i++) for (var map$$1 = i < 0 ? measure.map : maps[i], j = 0; j < map$$1.length; j += 3) {
                        var line, ch, curNode = map$$1[j + 2];
                        if (curNode == textNode || curNode == topNode) return line = lineNo(i < 0 ? lineView.line : lineView.rest[i]), 
                        ch = map$$1[j] + offset, Pos(line, ch = offset < 0 || curNode != textNode ? map$$1[j + (offset ? 1 : 0)] : ch);
                    }
                }
                var found = find(line, topNode, offset);
                if (found) return badPos(found, bad);
                for (var after = topNode.nextSibling, dist = line ? line.nodeValue.length - offset : 0; after; after = after.nextSibling) {
                    if (found = find(after, after.firstChild, 0)) return badPos(Pos(found.line, found.ch - dist), bad);
                    dist += after.textContent.length;
                }
                for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
                    if (found = find(before, before.firstChild, -1)) return badPos(Pos(found.line, found.ch + dist$1), bad);
                    dist$1 += before.textContent.length;
                }
            }(lineView, node, offset);
        }
    }
    ContentEditableInput.prototype.init = function(display) {
        var this$1 = this, input = this, cm = input.cm, div = input.div = display.lineDiv;
        function onCopyCut(e) {
            if (!signalDOMEvent(cm, e)) {
                if (cm.somethingSelected()) setLastCopied({
                    lineWise: !1,
                    text: cm.getSelections()
                }), "cut" == e.type && cm.replaceSelection("", null, "cut"); else {
                    if (!cm.options.lineWiseCopyCut) return;
                    var ranges = copyableRanges(cm);
                    setLastCopied({
                        lineWise: !0,
                        text: ranges.text
                    }), "cut" == e.type && cm.operation(function() {
                        cm.setSelections(ranges.ranges, 0, sel_dontScroll), cm.replaceSelection("", null, "cut");
                    });
                }
                if (e.clipboardData) {
                    e.clipboardData.clearData();
                    var content = lastCopied.text.join("\n");
                    if (e.clipboardData.setData("Text", content), e.clipboardData.getData("Text") == content) return void e.preventDefault();
                }
                var kludge = hiddenTextarea(), content = kludge.firstChild, hadFocus = (cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild), 
                content.value = lastCopied.text.join("\n"), document.activeElement);
                selectInput(content), setTimeout(function() {
                    cm.display.lineSpace.removeChild(kludge), hadFocus.focus(), 
                    hadFocus == div && input.showPrimarySelection();
                }, 50);
            }
        }
        disableBrowserMagic(div, cm.options.spellcheck), on(div, "paste", function(e) {
            signalDOMEvent(cm, e) || handlePaste(e, cm) || ie_version <= 11 && setTimeout(operation(cm, function() {
                return this$1.updateFromDOM();
            }), 20);
        }), on(div, "compositionstart", function(e) {
            this$1.composing = {
                data: e.data,
                done: !1
            };
        }), on(div, "compositionupdate", function(e) {
            this$1.composing || (this$1.composing = {
                data: e.data,
                done: !1
            });
        }), on(div, "compositionend", function(e) {
            this$1.composing && (e.data != this$1.composing.data && this$1.readFromDOMSoon(), 
            this$1.composing.done = !0);
        }), on(div, "touchstart", function() {
            return input.forceCompositionEnd();
        }), on(div, "input", function() {
            this$1.composing || this$1.readFromDOMSoon();
        }), on(div, "copy", onCopyCut), on(div, "cut", onCopyCut);
    }, ContentEditableInput.prototype.prepareSelection = function() {
        var result = prepareSelection(this.cm, !1);
        return result.focus = this.cm.state.focused, result;
    }, ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
        info && this.cm.display.view.length && ((info.focus || takeFocus) && this.showPrimarySelection(), 
        this.showMultipleSelections(info));
    }, ContentEditableInput.prototype.showPrimarySelection = function() {
        var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary(), from = prim.from(), prim = prim.to();
        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || prim.line < cm.display.viewFrom) sel.removeAllRanges(); else {
            var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset), curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
            if (!curAnchor || curAnchor.bad || !curFocus || curFocus.bad || 0 != cmp(minPos(curAnchor, curFocus), from) || 0 != cmp(maxPos(curAnchor, curFocus), prim)) {
                var curAnchor = cm.display.view, curFocus = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
                    node: curAnchor[0].measure.map[2],
                    offset: 0
                }, from = prim.line < cm.display.viewTo && posToDOM(cm, prim);
                if (from || (from = {
                    node: (curAnchor = (prim = curAnchor[curAnchor.length - 1].measure).maps ? prim.maps[prim.maps.length - 1] : prim.map)[curAnchor.length - 1],
                    offset: curAnchor[curAnchor.length - 2] - curAnchor[curAnchor.length - 3]
                }), curFocus && from) {
                    var rng, prim = sel.rangeCount && sel.getRangeAt(0);
                    try {
                        rng = range(curFocus.node, curFocus.offset, from.offset, from.node);
                    } catch (e) {}
                    rng && (!gecko && cm.state.focused && (sel.collapse(curFocus.node, curFocus.offset), 
                    rng.collapsed) || (sel.removeAllRanges(), sel.addRange(rng)), 
                    prim && null == sel.anchorNode ? sel.addRange(prim) : gecko && this.startGracePeriod()), 
                    this.rememberSelection();
                } else sel.removeAllRanges();
            }
        }
    }, ContentEditableInput.prototype.startGracePeriod = function() {
        var this$1 = this;
        clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
            this$1.gracePeriod = !1, this$1.selectionChanged() && this$1.cm.operation(function() {
                return this$1.cm.curOp.selectionChanged = !0;
            });
        }, 20);
    }, ContentEditableInput.prototype.showMultipleSelections = function(info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors), removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    }, ContentEditableInput.prototype.rememberSelection = function() {
        var sel = window.getSelection();
        this.lastAnchorNode = sel.anchorNode, this.lastAnchorOffset = sel.anchorOffset, 
        this.lastFocusNode = sel.focusNode, this.lastFocusOffset = sel.focusOffset;
    }, ContentEditableInput.prototype.selectionInEditor = function() {
        var sel = window.getSelection();
        return !!sel.rangeCount && (sel = sel.getRangeAt(0).commonAncestorContainer, 
        contains(this.div, sel));
    }, ContentEditableInput.prototype.focus = function() {
        "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0), 
        this.div.focus());
    }, ContentEditableInput.prototype.blur = function() {
        this.div.blur();
    }, ContentEditableInput.prototype.getField = function() {
        return this.div;
    }, ContentEditableInput.prototype.supportsTouch = function() {
        return !0;
    }, ContentEditableInput.prototype.receivedFocus = function() {
        var input = this;
        this.selectionInEditor() ? this.pollSelection() : runInOp(this.cm, function() {
            return input.cm.curOp.selectionChanged = !0;
        }), this.polling.set(this.cm.options.pollInterval, function poll() {
            input.cm.state.focused && (input.pollSelection(), input.polling.set(input.cm.options.pollInterval, poll));
        });
    }, ContentEditableInput.prototype.selectionChanged = function() {
        var sel = window.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    }, ContentEditableInput.prototype.pollSelection = function() {
        var sel, cm, anchor, head;
        null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged() && (sel = window.getSelection(), 
        cm = this.cm, android && chrome && this.cm.options.gutters.length && function(node) {
            for (var scan = node; scan; scan = scan.parentNode) if (/CodeMirror-gutter-wrapper/.test(scan.className)) return 1;
            return;
        }(sel.anchorNode) ? (this.cm.triggerOnKeyDown({
            type: "keydown",
            keyCode: 8,
            preventDefault: Math.abs
        }), this.blur(), this.focus()) : this.composing || (this.rememberSelection(), 
        anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset), head = domToPos(cm, sel.focusNode, sel.focusOffset), 
        anchor && head && runInOp(cm, function() {
            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll), 
            (anchor.bad || head.bad) && (cm.curOp.selectionChanged = !0);
        })));
    }, ContentEditableInput.prototype.pollContent = function() {
        null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
        var fromLine, cm = this.cm, display = cm.display, sel = cm.doc.sel.primary(), from = sel.from(), sel = sel.to();
        if (0 == from.ch && from.line > cm.firstLine() && (from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length)), 
        sel.ch == getLine(cm.doc, sel.line).text.length && sel.line < cm.lastLine() && (sel = Pos(sel.line + 1, 0)), 
        from.line < display.viewFrom || sel.line > display.viewTo - 1) return !1;
        var toLine, fromIndex = from.line == display.viewFrom || 0 == (fromIndex = findViewIndex(cm, from.line)) ? (fromLine = lineNo(display.view[0].line), 
        display.view[0].node) : (fromLine = lineNo(display.view[fromIndex].line), 
        display.view[fromIndex - 1].node.nextSibling), sel = findViewIndex(cm, sel.line), display = sel == display.view.length - 1 ? (toLine = display.viewTo - 1, 
        display.lineDiv.lastChild) : (toLine = lineNo(display.view[sel + 1].line) - 1, 
        display.view[sel + 1].node.previousSibling);
        if (!fromIndex) return !1;
        for (var newText = cm.doc.splitLines(function(cm, from, to, fromLine, toLine) {
            var text = "", closing = !1, lineSep = cm.doc.lineSeparator();
            function close() {
                closing && (text += lineSep, closing = !1);
            }
            function addText(str) {
                str && (close(), text += str);
            }
            for (;!function walk(node) {
                if (1 == node.nodeType) {
                    var cmText = node.getAttribute("cm-text");
                    if (null != cmText) addText(cmText || node.textContent.replace(/\u200b/g, "")); else if (cmText = node.getAttribute("cm-marker")) (cmText = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), (id = +cmText, 
                    function(marker) {
                        return marker.id == id;
                    }))).length && (cmText = cmText[0].find(0)) && addText(getBetween(cm.doc, cmText.from, cmText.to).join(lineSep)); else if ("false" != node.getAttribute("contenteditable")) {
                        (cmText = /^(pre|div|p)$/i.test(node.nodeName)) && close();
                        for (var i = 0; i < node.childNodes.length; i++) walk(node.childNodes[i]);
                        cmText && (closing = !0);
                    }
                } else 3 == node.nodeType && addText(node.nodeValue);
                var id;
            }(from), from != to; ) from = from.nextSibling;
            return text;
        }(cm, fromIndex, display, fromLine, toLine)), oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length)); 1 < newText.length && 1 < oldText.length; ) if (lst(newText) == lst(oldText)) newText.pop(), 
        oldText.pop(), toLine--; else {
            if (newText[0] != oldText[0]) break;
            newText.shift(), oldText.shift(), fromLine++;
        }
        for (var cutFront = 0, cutEnd = 0, newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length); cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront); ) ++cutFront;
        for (var newBot = lst(newText), oldBot = lst(oldText), maxCutEnd = Math.min(newBot.length - (1 == newText.length ? cutFront : 0), oldBot.length - (1 == oldText.length ? cutFront : 0)); cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1); ) ++cutEnd;
        if (1 == newText.length && 1 == oldText.length && fromLine == from.line) for (;cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1); ) cutFront--, 
        cutEnd++;
        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, ""), 
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
        sel = Pos(fromLine, cutFront), fromIndex = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
        return 1 < newText.length || newText[0] || cmp(sel, fromIndex) ? (replaceRange(cm.doc, newText, sel, fromIndex, "+input"), 
        !0) : void 0;
    }, ContentEditableInput.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
    }, ContentEditableInput.prototype.reset = function() {
        this.forceCompositionEnd();
    }, ContentEditableInput.prototype.forceCompositionEnd = function() {
        this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, 
        this.updateFromDOM(), this.div.blur(), this.div.focus());
    }, ContentEditableInput.prototype.readFromDOMSoon = function() {
        var this$1 = this;
        null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
            if (this$1.readDOMTimeout = null, this$1.composing) {
                if (!this$1.composing.done) return;
                this$1.composing = null;
            }
            this$1.updateFromDOM();
        }, 80));
    }, ContentEditableInput.prototype.updateFromDOM = function() {
        var this$1 = this;
        !this.cm.isReadOnly() && this.pollContent() || runInOp(this.cm, function() {
            return regChange(this$1.cm);
        });
    }, ContentEditableInput.prototype.setUneditable = function(node) {
        node.contentEditable = "false";
    }, ContentEditableInput.prototype.onKeyPress = function(e) {
        0 != e.charCode && (e.preventDefault(), this.cm.isReadOnly() || operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0));
    }, ContentEditableInput.prototype.readOnlyChanged = function(val) {
        this.div.contentEditable = String("nocursor" != val);
    }, ContentEditableInput.prototype.onContextMenu = function() {}, ContentEditableInput.prototype.resetPosition = function() {}, 
    ContentEditableInput.prototype.needsContentAttribute = !0;
    function TextareaInput(cm) {
        this.cm = cm, this.prevInput = "", this.pollingFast = !1, this.polling = new Delayed(), 
        this.hasSelection = !1, this.composing = null;
    }
    TextareaInput.prototype.init = function(display) {
        var this$1 = this, input = this, cm = this.cm, div = this.wrapper = hiddenTextarea(), te = this.textarea = div.firstChild;
        function prepareCopyCut(e) {
            if (!signalDOMEvent(cm, e)) {
                if (cm.somethingSelected()) setLastCopied({
                    lineWise: !1,
                    text: cm.getSelections()
                }); else {
                    if (!cm.options.lineWiseCopyCut) return;
                    var ranges = copyableRanges(cm);
                    setLastCopied({
                        lineWise: !0,
                        text: ranges.text
                    }), "cut" == e.type ? cm.setSelections(ranges.ranges, null, sel_dontScroll) : (input.prevInput = "", 
                    te.value = ranges.text.join("\n"), selectInput(te));
                }
                "cut" == e.type && (cm.state.cutIncoming = !0);
            }
        }
        display.wrapper.insertBefore(div, display.wrapper.firstChild), ios && (te.style.width = "0px"), 
        on(te, "input", function() {
            ie && 9 <= ie_version && this$1.hasSelection && (this$1.hasSelection = null), 
            input.poll();
        }), on(te, "paste", function(e) {
            signalDOMEvent(cm, e) || handlePaste(e, cm) || (cm.state.pasteIncoming = !0, 
            input.fastPoll());
        }), on(te, "cut", prepareCopyCut), on(te, "copy", prepareCopyCut), on(display.scroller, "paste", function(e) {
            eventInWidget(display, e) || signalDOMEvent(cm, e) || (cm.state.pasteIncoming = !0, 
            input.focus());
        }), on(display.lineSpace, "selectstart", function(e) {
            eventInWidget(display, e) || e_preventDefault(e);
        }), on(te, "compositionstart", function() {
            var start = cm.getCursor("from");
            input.composing && input.composing.range.clear(), input.composing = {
                start: start,
                range: cm.markText(start, cm.getCursor("to"), {
                    className: "CodeMirror-composing"
                })
            };
        }), on(te, "compositionend", function() {
            input.composing && (input.poll(), input.composing.range.clear(), input.composing = null);
        });
    }, TextareaInput.prototype.prepareSelection = function() {
        var lineOff, cm = this.cm, display = cm.display, doc = cm.doc, result = prepareSelection(cm);
        return cm.options.moveInputWithCursor && (cm = cursorCoords(cm, doc.sel.primary().head, "div"), 
        doc = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect(), 
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, cm.top + lineOff.top - doc.top)), 
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, cm.left + lineOff.left - doc.left))), 
        result;
    }, TextareaInput.prototype.showSelection = function(drawn) {
        var display = this.cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors), removeChildrenAndAdd(display.selectionDiv, drawn.selection), 
        null != drawn.teTop && (this.wrapper.style.top = drawn.teTop + "px", this.wrapper.style.left = drawn.teLeft + "px");
    }, TextareaInput.prototype.reset = function(typing) {
        var cm, content;
        this.contextMenuPending || this.composing || ((cm = this.cm).somethingSelected() ? (this.prevInput = "", 
        content = cm.getSelection(), this.textarea.value = content, cm.state.focused && selectInput(this.textarea), 
        ie && 9 <= ie_version && (this.hasSelection = content)) : typing || (this.prevInput = this.textarea.value = "", 
        ie && 9 <= ie_version && (this.hasSelection = null)));
    }, TextareaInput.prototype.getField = function() {
        return this.textarea;
    }, TextareaInput.prototype.supportsTouch = function() {
        return !1;
    }, TextareaInput.prototype.focus = function() {
        if ("nocursor" != this.cm.options.readOnly && (!mobile || activeElt() != this.textarea)) try {
            this.textarea.focus();
        } catch (e) {}
    }, TextareaInput.prototype.blur = function() {
        this.textarea.blur();
    }, TextareaInput.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
    }, TextareaInput.prototype.receivedFocus = function() {
        this.slowPoll();
    }, TextareaInput.prototype.slowPoll = function() {
        var this$1 = this;
        this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
            this$1.poll(), this$1.cm.state.focused && this$1.slowPoll();
        });
    }, TextareaInput.prototype.fastPoll = function() {
        var missed = !1, input = this;
        input.pollingFast = !0, input.polling.set(20, function p() {
            input.poll() || missed ? (input.pollingFast = !1, input.slowPoll()) : (missed = !0, 
            input.polling.set(60, p));
        });
    }, TextareaInput.prototype.poll = function() {
        var this$1 = this, cm = this.cm, input = this.textarea, prevInput = this.prevInput;
        if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) return !1;
        var text = input.value;
        if (text == prevInput && !cm.somethingSelected()) return !1;
        if (ie && 9 <= ie_version && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) return cm.display.input.reset(), 
        !1;
        if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (8203 != first || prevInput || (prevInput = ""), 8666 == first) return this.reset(), 
            this.cm.execCommand("undo");
        }
        for (var same = 0, l = Math.min(prevInput.length, text.length); same < l && prevInput.charCodeAt(same) == text.charCodeAt(same); ) ++same;
        return runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null), 
            1e3 < text.length || -1 < text.indexOf("\n") ? input.value = this$1.prevInput = "" : this$1.prevInput = text, 
            this$1.composing && (this$1.composing.range.clear(), this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
                className: "CodeMirror-composing"
            }));
        }), !0;
    }, TextareaInput.prototype.ensurePolled = function() {
        this.pollingFast && this.poll() && (this.pollingFast = !1);
    }, TextareaInput.prototype.onKeyPress = function() {
        ie && 9 <= ie_version && (this.hasSelection = null), this.fastPoll();
    }, TextareaInput.prototype.onContextMenu = function(e) {
        var oldCSS, oldWrapperCSS, oldScrollY, mouseup, input = this, cm = input.cm, display = cm.display, te = input.textarea, pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
        function prepareSelectAllHack() {
            var selected, extval;
            null != te.selectionStart && (extval = "" + ((selected = cm.somethingSelected()) ? te.value : ""), 
            te.value = "", te.value = extval, input.prevInput = selected ? "" : "", 
            te.selectionStart = 1, te.selectionEnd = extval.length, display.selForContextMenu = cm.doc.sel);
        }
        function rehide() {
            var i, poll;
            input.contextMenuPending = !1, input.wrapper.style.cssText = oldWrapperCSS, 
            te.style.cssText = oldCSS, ie && ie_version < 9 && display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos), 
            null != te.selectionStart && ((!ie || ie_version < 9) && prepareSelectAllHack(), 
            i = 0, poll = function() {
                display.selForContextMenu == cm.doc.sel && 0 == te.selectionStart && 0 < te.selectionEnd && "" == input.prevInput ? operation(cm, selectAll)(cm) : i++ < 10 ? display.detectingSelectAll = setTimeout(poll, 500) : (display.selForContextMenu = null, 
                display.input.reset());
            }, display.detectingSelectAll = setTimeout(poll, 200));
        }
        pos && !presto && (cm.options.resetSelectionOnContextMenu && -1 == cm.doc.sel.contains(pos) && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll), 
        oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText, 
        input.wrapper.style.cssText = "position: absolute", pos = input.wrapper.getBoundingClientRect(), 
        te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - pos.top - 5) + "px; left: " + (e.clientX - pos.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", 
        webkit && (oldScrollY = window.scrollY), display.input.focus(), webkit && window.scrollTo(null, oldScrollY), 
        display.input.reset(), cm.somethingSelected() || (te.value = input.prevInput = " "), 
        input.contextMenuPending = !0, display.selForContextMenu = cm.doc.sel, clearTimeout(display.detectingSelectAll), 
        ie && 9 <= ie_version && prepareSelectAllHack(), captureRightClick ? (e_stop(e), 
        mouseup = function() {
            off(window, "mouseup", mouseup), setTimeout(rehide, 20);
        }, on(window, "mouseup", mouseup)) : setTimeout(rehide, 50));
    }, TextareaInput.prototype.readOnlyChanged = function(val) {
        val || this.reset(), this.textarea.disabled = "nocursor" == val;
    }, TextareaInput.prototype.setUneditable = function() {}, TextareaInput.prototype.needsContentAttribute = !1, 
    function(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;
        function option(name, deflt, handle, notOnInit) {
            CodeMirror.defaults[name] = deflt, handle && (optionHandlers[name] = notOnInit ? function(cm, val, old) {
                old != Init && handle(cm, val, old);
            } : handle);
        }
        CodeMirror.defineOption = option, CodeMirror.Init = Init, option("value", "", function(cm, val) {
            return cm.setValue(val);
        }, !0), option("mode", null, function(cm, val) {
            cm.doc.modeOption = val, loadMode(cm);
        }, !0), option("indentUnit", 2, loadMode, !0), option("indentWithTabs", !1), 
        option("smartIndent", !0), option("tabSize", 4, function(cm) {
            resetModeState(cm), clearCaches(cm), regChange(cm);
        }, !0), option("lineSeparator", null, function(cm, val) {
            if (cm.doc.lineSep = val) {
                var newBreaks = [], lineNo = cm.doc.first;
                cm.doc.iter(function(line) {
                    for (var pos = 0; ;) {
                        var found = line.text.indexOf(val, pos);
                        if (-1 == found) break;
                        pos = found + val.length, newBreaks.push(Pos(lineNo, found));
                    }
                    lineNo++;
                });
                for (var i = newBreaks.length - 1; 0 <= i; i--) replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
            }
        }), option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
            cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g"), 
            old != Init && cm.refresh();
        }), option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
            return cm.refresh();
        }, !0), option("electricChars", !0), option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
            throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, !0), option("spellcheck", !1, function(cm, val) {
            return cm.getInputField().spellcheck = val;
        }, !0), option("rtlMoveVisually", !windows), option("wholeLineUpdateBefore", !0), 
        option("theme", "default", function(cm) {
            themeChanged(cm), guttersChanged(cm);
        }, !0), option("keyMap", "default", function(cm, val, old) {
            val = getKeyMap(val), old = old != Init && getKeyMap(old);
            old && old.detach && old.detach(cm, val), val.attach && val.attach(cm, old || null);
        }), option("extraKeys", null), option("configureMouse", null), option("lineWrapping", !1, wrappingChanged, !0), 
        option("gutters", [], function(cm) {
            setGuttersForLineNumbers(cm.options), guttersChanged(cm);
        }, !0), option("fixedGutter", !0, function(cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0", 
            cm.refresh();
        }, !0), option("coverGutterNextToScrollbar", !1, function(cm) {
            return updateScrollbars(cm);
        }, !0), option("scrollbarStyle", "native", function(cm) {
            initScrollbars(cm), updateScrollbars(cm), cm.display.scrollbars.setScrollTop(cm.doc.scrollTop), 
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, !0), option("lineNumbers", !1, function(cm) {
            setGuttersForLineNumbers(cm.options), guttersChanged(cm);
        }, !0), option("firstLineNumber", 1, guttersChanged, !0), option("lineNumberFormatter", function(integer) {
            return integer;
        }, guttersChanged, !0), option("showCursorWhenSelecting", !1, updateSelection, !0), 
        option("resetSelectionOnContextMenu", !0), option("lineWiseCopyCut", !0), 
        option("pasteLinesPerSelection", !0), option("readOnly", !1, function(cm, val) {
            "nocursor" == val && (onBlur(cm), cm.display.input.blur()), cm.display.input.readOnlyChanged(val);
        }), option("disableInput", !1, function(cm, val) {
            val || cm.display.input.reset();
        }, !0), option("dragDrop", !0, dragDropChanged), option("allowDropFileTypes", null), 
        option("cursorBlinkRate", 530), option("cursorScrollMargin", 0), option("cursorHeight", 1, updateSelection, !0), 
        option("singleCursorHeightPerLine", !0, updateSelection, !0), option("workTime", 100), 
        option("workDelay", 100), option("flattenSpans", !0, resetModeState, !0), 
        option("addModeClass", !1, resetModeState, !0), option("pollInterval", 100), 
        option("undoDepth", 200, function(cm, val) {
            return cm.doc.history.undoDepth = val;
        }), option("historyEventDelay", 1250), option("viewportMargin", 10, function(cm) {
            return cm.refresh();
        }, !0), option("maxHighlightLength", 1e4, resetModeState, !0), option("moveInputWithCursor", !0, function(cm, val) {
            val || cm.display.input.resetPosition();
        }), option("tabindex", null, function(cm, val) {
            return cm.display.input.getField().tabIndex = val || "";
        }), option("autofocus", null), option("direction", "ltr", function(cm, val) {
            return cm.doc.setDirection(val);
        }, !0);
    }(CodeMirror$1), function(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers, helpers = CodeMirror.helpers = {};
        CodeMirror.prototype = {
            constructor: CodeMirror,
            focus: function() {
                window.focus(), this.display.input.focus();
            },
            setOption: function(option, value) {
                var options = this.options, old = options[option];
                options[option] == value && "mode" != option || (options[option] = value, 
                optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old), 
                signal(this, "optionChange", this, option));
            },
            getOption: function(option) {
                return this.options[option];
            },
            getDoc: function() {
                return this.doc;
            },
            addKeyMap: function(map$$1, bottom) {
                this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
            },
            removeKeyMap: function(map$$1) {
                for (var maps = this.state.keyMaps, i = 0; i < maps.length; ++i) if (maps[i] == map$$1 || maps[i].name == map$$1) return maps.splice(i, 1), 
                !0;
            },
            addOverlay: methodOp(function(spec, options) {
                var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                if (mode.startState) throw new Error("Overlays may not be stateful.");
                for (var array = this.state.overlays, mode = {
                    mode: mode,
                    modeSpec: spec,
                    opaque: options && options.opaque,
                    priority: options && options.priority || 0
                }, score = function(overlay) {
                    return overlay.priority;
                }, pos = 0, priority = score(mode); pos < array.length && score(array[pos]) <= priority; ) pos++;
                array.splice(pos, 0, mode), this.state.modeGen++, regChange(this);
            }),
            removeOverlay: methodOp(function(spec) {
                for (var overlays = this.state.overlays, i = 0; i < overlays.length; ++i) {
                    var cur = overlays[i].modeSpec;
                    if (cur == spec || "string" == typeof spec && cur.name == spec) return overlays.splice(i, 1), 
                    this.state.modeGen++, void regChange(this);
                }
            }),
            indentLine: methodOp(function(n, dir, aggressive) {
                "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"), 
                isLine(this.doc, n) && indentLine(this, n, dir, aggressive);
            }),
            indentSelection: methodOp(function(how) {
                for (var ranges = this.doc.sel.ranges, end = -1, i = 0; i < ranges.length; i++) {
                    var range$$1 = ranges[i];
                    if (range$$1.empty()) range$$1.head.line > end && (indentLine(this, range$$1.head.line, how, !0), 
                    end = range$$1.head.line, i == this.doc.sel.primIndex && ensureCursorVisible(this)); else {
                        for (var from = range$$1.from(), range$$1 = range$$1.to(), start = Math.max(end, from.line), end = Math.min(this.lastLine(), range$$1.line - (range$$1.ch ? 0 : 1)) + 1, j = start; j < end; ++j) indentLine(this, j, how);
                        range$$1 = this.doc.sel.ranges;
                        0 == from.ch && ranges.length == range$$1.length && 0 < range$$1[i].from().ch && replaceOneSelection(this.doc, i, new Range(from, range$$1[i].to()), sel_dontScroll);
                    }
                }
            }),
            getTokenAt: function(pos, precise) {
                return takeToken(this, pos, precise);
            },
            getLineTokens: function(line, precise) {
                return takeToken(this, Pos(line), precise, !0);
            },
            getTokenTypeAt: function(pos) {
                pos = clipPos(this.doc, pos);
                var type, styles = getLineStyles(this, getLine(this.doc, pos.line)), before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                if (0 == ch) type = styles[2]; else for (;;) {
                    var mid = before + after >> 1;
                    if ((mid ? styles[2 * mid - 1] : 0) >= ch) after = mid; else {
                        if (!(styles[2 * mid + 1] < ch)) {
                            type = styles[2 * mid + 2];
                            break;
                        }
                        before = 1 + mid;
                    }
                }
                pos = type ? type.indexOf("overlay ") : -1;
                return pos < 0 ? type : 0 == pos ? null : type.slice(0, pos - 1);
            },
            getModeAt: function(pos) {
                var mode = this.doc.mode;
                return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode;
            },
            getHelper: function(pos, type) {
                return this.getHelpers(pos, type)[0];
            },
            getHelpers: function(pos, type) {
                var found = [];
                if (helpers.hasOwnProperty(type)) {
                    var help = helpers[type], mode = this.getModeAt(pos);
                    if ("string" == typeof mode[type]) help[mode[type]] && found.push(help[mode[type]]); else if (mode[type]) for (var i = 0; i < mode[type].length; i++) {
                        var val = help[mode[type][i]];
                        val && found.push(val);
                    } else mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
                    for (var i$1 = 0; i$1 < help._global.length; i$1++) {
                        var cur = help._global[i$1];
                        cur.pred(mode, this) && -1 == indexOf(found, cur.val) && found.push(cur.val);
                    }
                }
                return found;
            },
            getStateAfter: function(line, precise) {
                var doc = this.doc;
                return getContextBefore(this, (line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line)) + 1, precise).state;
            },
            cursorCoords: function(start, mode) {
                var range$$1 = this.doc.sel.primary(), start = null == start ? range$$1.head : "object" == typeof start ? clipPos(this.doc, start) : start ? range$$1.from() : range$$1.to();
                return cursorCoords(this, start, mode || "page");
            },
            charCoords: function(pos, mode) {
                return charCoords(this, clipPos(this.doc, pos), mode || "page");
            },
            coordsChar: function(coords, mode) {
                return coordsChar(this, (coords = fromCoordSystem(this, coords, mode || "page")).left, coords.top);
            },
            lineAtHeight: function(height, mode) {
                return height = fromCoordSystem(this, {
                    top: height,
                    left: 0
                }, mode || "page").top, lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function(line, mode, includeWidgets) {
                var end = !1, last = "number" == typeof line ? (last = this.doc.first + this.doc.size - 1, 
                line < this.doc.first ? line = this.doc.first : last < line && (line = last, 
                end = !0), getLine(this.doc, line)) : line;
                return intoCoordSystem(this, last, {
                    top: 0,
                    left: 0
                }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(last) : 0);
            },
            defaultTextHeight: function() {
                return textHeight(this.display);
            },
            defaultCharWidth: function() {
                return charWidth(this.display);
            },
            getViewport: function() {
                return {
                    from: this.display.viewFrom,
                    to: this.display.viewTo
                };
            },
            addWidget: function(pos, node, scroll, vert, horiz) {
                var hspace, vspace, display = this.display, top = (pos = cursorCoords(this, clipPos(this.doc, pos))).bottom, left = pos.left;
                node.style.position = "absolute", node.setAttribute("cm-ignore-events", "true"), 
                this.display.input.setUneditable(node), display.sizer.appendChild(node), 
                "over" == vert ? top = pos.top : "above" != vert && "near" != vert || (vspace = Math.max(display.wrapper.clientHeight, this.doc.height), 
                hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth), 
                ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom), 
                left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth)), 
                node.style.top = top + "px", node.style.left = node.style.right = "", 
                "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth, 
                node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2), 
                node.style.left = left + "px"), scroll && (vert = this, vspace = {
                    left: left,
                    top: top,
                    right: left + node.offsetWidth,
                    bottom: top + node.offsetHeight
                }, null != (vspace = calculateScrollPos(vert, vspace)).scrollTop && updateScrollTop(vert, vspace.scrollTop), 
                null != vspace.scrollLeft && setScrollLeft(vert, vspace.scrollLeft));
            },
            triggerOnKeyDown: methodOp(onKeyDown),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            triggerOnMouseDown: methodOp(onMouseDown),
            execCommand: function(cmd) {
                if (commands.hasOwnProperty(cmd)) return commands[cmd].call(null, this);
            },
            triggerElectric: methodOp(function(text) {
                triggerElectric(this, text);
            }),
            findPosH: function(from, amount, unit, visually) {
                for (var dir = 1, cur = (amount < 0 && (dir = -1, amount = -amount), 
                clipPos(this.doc, from)), i = 0; i < amount && !(cur = findPosH(this.doc, cur, dir, unit, visually)).hitSide; ++i);
                return cur;
            },
            moveH: methodOp(function(dir, unit) {
                var this$1 = this;
                this.extendSelectionsBy(function(range$$1) {
                    return this$1.display.shift || this$1.doc.extend || range$$1.empty() ? findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) : dir < 0 ? range$$1.from() : range$$1.to();
                }, sel_move);
            }),
            deleteH: methodOp(function(dir, unit) {
                var sel = this.doc.sel, doc = this.doc;
                sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function(range$$1) {
                    var other = findPosH(doc, range$$1.head, dir, unit, !1);
                    return dir < 0 ? {
                        from: other,
                        to: range$$1.head
                    } : {
                        from: range$$1.head,
                        to: other
                    };
                });
            }),
            findPosV: function(from, amount, unit, goalColumn) {
                for (var dir = 1, x = goalColumn, cur = (amount < 0 && (dir = -1, 
                amount = -amount), clipPos(this.doc, from)), i = 0; i < amount; ++i) {
                    var coords = cursorCoords(this, cur, "div");
                    if (null == x ? x = coords.left : coords.left = x, (cur = findPosV(this, coords, dir, unit)).hitSide) break;
                }
                return cur;
            },
            moveV: methodOp(function(dir, unit) {
                var this$1 = this, doc = this.doc, goals = [], collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
                if (doc.extendSelectionsBy(function(range$$1) {
                    var headPos, pos;
                    return collapse ? dir < 0 ? range$$1.from() : range$$1.to() : (headPos = cursorCoords(this$1, range$$1.head, "div"), 
                    null != range$$1.goalColumn && (headPos.left = range$$1.goalColumn), 
                    goals.push(headPos.left), pos = findPosV(this$1, headPos, dir, unit), 
                    "page" == unit && range$$1 == doc.sel.primary() && addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top), 
                    pos);
                }, sel_move), goals.length) for (var i = 0; i < doc.sel.ranges.length; i++) doc.sel.ranges[i].goalColumn = goals[i];
            }),
            findWordAt: function(pos) {
                var line = getLine(this.doc, pos.line).text, start = pos.ch, end = pos.ch;
                if (line) {
                    for (var helper = this.getHelper(pos, "wordChars"), startChar = ("before" != pos.sticky && end != line.length || !start ? ++end : --start, 
                    line.charAt(start)), check = isWordChar(startChar, helper) ? function(ch) {
                        return isWordChar(ch, helper);
                    } : /\s/.test(startChar) ? function(ch) {
                        return /\s/.test(ch);
                    } : function(ch) {
                        return !/\s/.test(ch) && !isWordChar(ch);
                    }; 0 < start && check(line.charAt(start - 1)); ) --start;
                    for (;end < line.length && check(line.charAt(end)); ) ++end;
                }
                return new Range(Pos(pos.line, start), Pos(pos.line, end));
            },
            toggleOverwrite: function(value) {
                null != value && value == this.state.overwrite || (((this.state.overwrite = !this.state.overwrite) ? addClass : rmClass)(this.display.cursorDiv, "CodeMirror-overwrite"), 
                signal(this, "overwriteToggle", this, this.state.overwrite));
            },
            hasFocus: function() {
                return this.display.input.getField() == activeElt();
            },
            isReadOnly: function() {
                return !(!this.options.readOnly && !this.doc.cantEdit);
            },
            scrollTo: methodOp(function(x, y) {
                scrollToCoords(this, x, y);
            }),
            getScrollInfo: function() {
                var scroller = this.display.scroller;
                return {
                    left: scroller.scrollLeft,
                    top: scroller.scrollTop,
                    height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                    width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                    clientHeight: displayHeight(this),
                    clientWidth: displayWidth(this)
                };
            },
            scrollIntoView: methodOp(function(range$$1, margin) {
                null == range$$1 ? (range$$1 = {
                    from: this.doc.sel.primary().head,
                    to: null
                }, null == margin && (margin = this.options.cursorScrollMargin)) : "number" == typeof range$$1 ? range$$1 = {
                    from: Pos(range$$1, 0),
                    to: null
                } : null == range$$1.from && (range$$1 = {
                    from: range$$1,
                    to: null
                }), range$$1.to || (range$$1.to = range$$1.from), range$$1.margin = margin || 0, 
                null != range$$1.from.line ? function(cm, range$$1) {
                    resolveScrollToPos(cm), cm.curOp.scrollToPos = range$$1;
                }(this, range$$1) : scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
            }),
            setSize: methodOp(function(width, height) {
                function interpret(val) {
                    return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val;
                }
                var this$1 = this, lineNo$$1 = (null != width && (this.display.wrapper.style.width = interpret(width)), 
                null != height && (this.display.wrapper.style.height = interpret(height)), 
                this.options.lineWrapping && clearLineMeasurementCache(this), this.display.viewFrom);
                this.doc.iter(lineNo$$1, this.display.viewTo, function(line) {
                    if (line.widgets) for (var i = 0; i < line.widgets.length; i++) if (line.widgets[i].noHScroll) {
                        regLineChange(this$1, lineNo$$1, "widget");
                        break;
                    }
                    ++lineNo$$1;
                }), this.curOp.forceUpdate = !0, signal(this, "refresh", this);
            }),
            operation: function(f) {
                return runInOp(this, f);
            },
            startOperation: function() {
                return startOperation(this);
            },
            endOperation: function() {
                return endOperation(this);
            },
            refresh: methodOp(function() {
                var oldHeight = this.display.cachedTextHeight;
                regChange(this), this.curOp.forceUpdate = !0, clearCaches(this), 
                scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop), updateGutterSpace(this), 
                (null == oldHeight || .5 < Math.abs(oldHeight - textHeight(this.display))) && estimateLineHeights(this), 
                signal(this, "refresh", this);
            }),
            swapDoc: methodOp(function(doc) {
                var old = this.doc;
                return old.cm = null, attachDoc(this, doc), clearCaches(this), this.display.input.reset(), 
                scrollToCoords(this, doc.scrollLeft, doc.scrollTop), this.curOp.forceScroll = !0, 
                signalLater(this, "swapDoc", this, old), old;
            }),
            getInputField: function() {
                return this.display.input.getField();
            },
            getWrapperElement: function() {
                return this.display.wrapper;
            },
            getScrollerElement: function() {
                return this.display.scroller;
            },
            getGutterElement: function() {
                return this.display.gutters;
            }
        }, eventMixin(CodeMirror), CodeMirror.registerHelper = function(type, name, value) {
            helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {
                _global: []
            }), helpers[type][name] = value;
        }, CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
            CodeMirror.registerHelper(type, name, value), helpers[type]._global.push({
                pred: predicate,
                val: value
            });
        };
    }(CodeMirror$1);
    var prop, dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
    for (prop in Doc.prototype) Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror$1.prototype[prop] = function(method) {
        return function() {
            return method.apply(this.doc, arguments);
        };
    }(Doc.prototype[prop]));
    return eventMixin(Doc), CodeMirror$1.inputStyles = {
        textarea: TextareaInput,
        contenteditable: ContentEditableInput
    }, CodeMirror$1.defineMode = function(name) {
        CodeMirror$1.defaults.mode || "null" == name || (CodeMirror$1.defaults.mode = name), 
        function(name, mode) {
            2 < arguments.length && (mode.dependencies = Array.prototype.slice.call(arguments, 2)), 
            modes[name] = mode;
        }.apply(this, arguments);
    }, CodeMirror$1.defineMIME = function(mime, spec) {
        mimeModes[mime] = spec;
    }, CodeMirror$1.defineMode("null", function() {
        return {
            token: function(stream) {
                return stream.skipToEnd();
            }
        };
    }), CodeMirror$1.defineMIME("text/plain", "null"), CodeMirror$1.defineExtension = function(name, func) {
        CodeMirror$1.prototype[name] = func;
    }, CodeMirror$1.defineDocExtension = function(name, func) {
        Doc.prototype[name] = func;
    }, CodeMirror$1.fromTextArea = function(textarea, options) {
        var hasFocus;
        function save() {
            textarea.value = cm.getValue();
        }
        if ((options = options ? copyObj(options) : {}).value = textarea.value, 
        !options.tabindex && textarea.tabIndex && (options.tabindex = textarea.tabIndex), 
        !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder), 
        null == options.autofocus && (hasFocus = activeElt(), options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body), 
        textarea.form && (on(textarea.form, "submit", save), !options.leaveSubmitMethodAlone)) {
            var form = textarea.form, realSubmit = form.submit;
            try {
                var wrappedSubmit = form.submit = function() {
                    save(), form.submit = realSubmit, form.submit(), form.submit = wrappedSubmit;
                };
            } catch (e) {}
        }
        options.finishInit = function(cm) {
            cm.save = save, cm.getTextArea = function() {
                return textarea;
            }, cm.toTextArea = function() {
                cm.toTextArea = isNaN, save(), textarea.parentNode.removeChild(cm.getWrapperElement()), 
                textarea.style.display = "", textarea.form && (off(textarea.form, "submit", save), 
                "function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit));
            };
        }, textarea.style.display = "none";
        var cm = CodeMirror$1(function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
    }, (userAgent = CodeMirror$1).off = off, userAgent.on = on, userAgent.wheelEventPixels = wheelEventPixels, 
    userAgent.Doc = Doc, userAgent.splitLines = splitLinesAuto, userAgent.countColumn = countColumn, 
    userAgent.findColumn = findColumn, userAgent.isWordChar = isWordCharBasic, userAgent.Pass = Pass, 
    userAgent.signal = signal, userAgent.Line = Line, userAgent.changeEnd = changeEnd, 
    userAgent.scrollbarModel = scrollbarModel, userAgent.Pos = Pos, userAgent.cmpPos = cmp, 
    userAgent.modes = modes, userAgent.mimeModes = mimeModes, userAgent.resolveMode = resolveMode, 
    userAgent.getMode = getMode, userAgent.modeExtensions = modeExtensions, userAgent.extendMode = extendMode, 
    userAgent.copyState = copyState, userAgent.startState = startState, userAgent.innerMode = innerMode, 
    userAgent.commands = commands, userAgent.keyMap = keyMap, userAgent.keyName = keyName, 
    userAgent.isModifierKey = isModifierKey, userAgent.lookupKey = lookupKey, userAgent.normalizeKeyMap = normalizeKeyMap, 
    userAgent.StringStream = StringStream, userAgent.SharedTextMarker = SharedTextMarker, 
    userAgent.TextMarker = TextMarker, userAgent.LineWidget = LineWidget, userAgent.e_preventDefault = e_preventDefault, 
    userAgent.e_stopPropagation = e_stopPropagation, userAgent.e_stop = e_stop, 
    userAgent.addClass = addClass, userAgent.contains = contains, userAgent.rmClass = rmClass, 
    userAgent.keyNames = keyNames, CodeMirror$1.version = "5.30.0", CodeMirror$1;
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("choicescript", function(conf, parserConf) {
        function cmdRegExp(words) {
            return new RegExp("^\\s*\\*(" + words.join("|") + ")(?: .*)?$");
        }
        var jumpCommands = [ "ending", "finish", "gosub_scene", "gosub", "goto_random_scene", "goto_scene", "gotoref", "goto", "label", "redirect_scene", "return" ], indentCommands = [ "achievement", "choice", "if", "scene_list", "elseif", "else", "elsif", "fake_choice", "stat_chart" ], dedentCommands = [ "finish", "goto_scene", "goto", "ending", "redirect_scene" ], csPlusCommands = [ "console_log", "console_track", "console_track_all", "console_untrack_all", "console_untrack", "console_clear", "console_track_list", "cside_theme_set", "cside_theme_apply" ], choiceOption = /^\s+(?:\*(hide_reuse|allow_reuse|disable_reuse|(if|selectable_if) .+) )?#.+/, builtins = cmdRegExp([ "abort", "achievement", "achieve", "advertisement", "ai", "allow_reuse", "author", "bug", "check_achievements", "check_purchase", "check_registration", "choice", "create", "create_array", "delay_break", "delay_ending", "delete", "delete_array", "disable_reuse", "elseif", "elsif", "else", "end_trial", "ending", "fake_choice", "finish", "finish_advertisement", "gosub_scene", "gosub", "goto_random_scene", "goto_scene", "gotoref", "goto", "hide_reuse", "if", "ifid", "image", "input_number", "input_text", "kindle_image", "kindle_product", "kindle_search", "line_break", "link_button", "link", "login", "looplimit", "more_games", "page_break", "params", "print", "purchase", "purchase_discount", "rand", "redirect_scene", "reset", "restart", "restore_game", "restore_purchases", "return", "save_game", "selectable_if", "scene_list", "script", "setref", "set", "share_this_game", "show_password", "sound", "stat_chart", "subscribe", "temp", "temp_array", "timer", "title", "track_event", "youtube" ]), indentCommands = cmdRegExp(indentCommands), dedentCommands = cmdRegExp(dedentCommands), TOKENS = {
            start: [ {
                regex: /\s*\*comment(?:\b.*)?/,
                token: "comment"
            }, {
                regex: cmdRegExp(jumpCommands),
                token: "keyword"
            }, {
                regex: /\s+(\*hide_reuse |\*allow_reuse |\*disable_reuse ){0,1}(\*if .+ ?|\*selectable_if .+ ?){0,1}#.+/,
                token: "operator"
            }, {
                regex: builtins,
                token: "builtin"
            }, {
                regex: cmdRegExp(csPlusCommands),
                token: "cs-plus"
            }, {
                regex: choiceOption,
                token: "variable"
            }, {
                regex: /([A-Za-z\u00C0-\u00FF\u0100-\u017F]+'[A-Za-z\u00C0-\u00FF\u0100-\u017F]+|[A-Za-z\u00C0-\u00FF\u0100-\u017F]{2,}|[AaI]'?)(?=$|[\s\.,:;\?'\-\!])/,
                token: "word"
            }, {
                regex: /\$!{0,2}\{[\w\{\}\+\-&\*/\s0-9#]+(\[[\w0-9\[\]]+\])*\}/,
                token: "variable"
            }, {
                regex: /\@\{.*}/,
                token: "variable"
            }, {
                regex: /[\{\}]/,
                token: "curly-bracket"
            }, {
                regex: /[\(\)]/,
                token: "standard-bracket"
            }, {
                regex: /[\[\]]/,
                token: "square-bracket"
            }, {
                regex: /(--|\.\.\.)/,
                token: "formattable"
            } ]
        };
        return {
            startState: function() {
                return {
                    next: "start",
                    lastToken: null
                };
            },
            token: function(stream, state) {
                for (;stream.pos == stream.start; ) var style = function(stream, state) {
                    var next_rule = state.next || "start";
                    if (next_rule) {
                        state.next = state.next;
                        var nr = TOKENS[next_rule];
                        if (nr.splice) {
                            for (var i$ = 0; i$ < nr.length; ++i$) {
                                var r = nr[i$];
                                if (r.regex && stream.match(r.regex)) return state.next = r.next || state.next, 
                                r.token;
                            }
                            return stream.next(), "null";
                        }
                        if (stream.match(r = TOKENS[next_rule])) return r.regex && stream.match(r.regex) ? (state.next = r.next, 
                        r.token) : (stream.next(), "null");
                    }
                    return stream.next(), "error";
                }(stream, state);
                return state.lastToken = {
                    style: style,
                    indent: stream.indentation(),
                    content: stream.current()
                }, style;
            },
            indent: function(state) {
                var indentation;
                return void 0 === state.lastToken || null === state.lastToken || (indentation = state.lastToken.indent || 0, 
                state.lastToken.content.match(indentCommands) || state.lastToken.content.match(choiceOption) ? indentation += conf.indentUnit : state.lastToken.content.match(dedentCommands) && (indentation -= conf.indentUnit), 
                indentation < 0) ? 0 : indentation;
            },
            blankLine: function(state) {
                state.lastToken = {
                    style: "blank-line",
                    indent: 0,
                    content: ""
                };
            },
            fold: "indent"
        };
    }), CodeMirror.defineMIME("text/x-choicescript", "choicescript");
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    function dialogDiv(cm, template, bottom) {
        cm = cm.getWrapperElement().appendChild(document.createElement("div"));
        return cm.className = bottom ? "CodeMirror-dialog CodeMirror-dialog-bottom" : "CodeMirror-dialog CodeMirror-dialog-top", 
        "string" == typeof template ? cm.innerHTML = template : cm.appendChild(template), 
        cm;
    }
    function closeNotification(cm, newVal) {
        cm.state.currentNotificationClose && cm.state.currentNotificationClose(), 
        cm.state.currentNotificationClose = newVal;
    }
    CodeMirror.defineExtension("openDialog", function(template, callback, options) {
        options = options || {}, closeNotification(this, null);
        var dialog = dialogDiv(this, template, options.bottom), closed = !1, me = this;
        function close(newVal) {
            "string" == typeof newVal ? inp.value = newVal : closed || (closed = !0, 
            dialog.parentNode.removeChild(dialog), me.focus(), options.onClose && options.onClose(dialog));
        }
        var inp = dialog.getElementsByTagName("input")[0];
        return inp ? (inp.focus(), options.value && (inp.value = options.value, 
        !1 !== options.selectValueOnOpen && inp.select()), options.onInput && CodeMirror.on(inp, "input", function(e) {
            options.onInput(e, inp.value, close);
        }), options.onKeyUp && CodeMirror.on(inp, "keyup", function(e) {
            options.onKeyUp(e, inp.value, close);
        }), CodeMirror.on(inp, "keydown", function(e) {
            options && options.onKeyDown && options.onKeyDown(e, inp.value, close) || ((27 == e.keyCode || !1 !== options.closeOnEnter && 13 == e.keyCode) && (inp.blur(), 
            CodeMirror.e_stop(e), close()), 13 == e.keyCode && callback(inp.value, e));
        }), !1 !== options.closeOnBlur && CodeMirror.on(inp, "blur", close)) : (template = dialog.getElementsByTagName("button")[0]) && (CodeMirror.on(template, "click", function() {
            close(), me.focus();
        }), !1 !== options.closeOnBlur && CodeMirror.on(template, "blur", close), 
        template.focus()), close;
    }), CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options && options.bottom), buttons = dialog.getElementsByTagName("button"), closed = !1, me = this, blurring = 1;
        function close() {
            closed || (closed = !0, dialog.parentNode.removeChild(dialog), me.focus());
        }
        buttons[0].focus();
        for (var i = 0; i < buttons.length; ++i) {
            var b = buttons[i];
            !function(callback) {
                CodeMirror.on(b, "click", function(e) {
                    CodeMirror.e_preventDefault(e), close(), callback && callback(me);
                });
            }(callbacks[i]), CodeMirror.on(b, "blur", function() {
                --blurring, setTimeout(function() {
                    blurring <= 0 && close();
                }, 200);
            }), CodeMirror.on(b, "focus", function() {
                ++blurring;
            });
        }
    }), CodeMirror.defineExtension("openNotification", function(template, options) {
        closeNotification(this, close);
        var doneTimer, dialog = dialogDiv(this, template, options && options.bottom), closed = !1, template = options && void 0 !== options.duration ? options.duration : 5e3;
        function close() {
            closed || (closed = !0, clearTimeout(doneTimer), dialog.parentNode.removeChild(dialog));
        }
        return CodeMirror.on(dialog, "click", function(e) {
            CodeMirror.e_preventDefault(e), close();
        }), template && (doneTimer = setTimeout(close, template)), close;
    });
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function Completion(cm, options) {
        this.cm = cm, this.options = options, this.widget = null, this.debounce = 0, 
        this.tick = 0, this.startPos = this.cm.getCursor("start"), this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
        var self = this;
        cm.on("cursorActivity", this.activityFunc = function() {
            self.cursorActivity();
        });
    }
    CodeMirror.showHint = function(cm, getHints, options) {
        if (!getHints) return cm.showHint(options);
        options && options.async && (getHints.async = !0);
        var newOpts = {
            hint: getHints
        };
        if (options) for (var prop in options) newOpts[prop] = options[prop];
        return cm.showHint(newOpts);
    }, CodeMirror.defineExtension("showHint", function(options) {
        options = function(cm, pos, options) {
            var editor = cm.options.hintOptions, out = {};
            for (prop in defaultOptions) out[prop] = defaultOptions[prop];
            if (editor) for (var prop in editor) void 0 !== editor[prop] && (out[prop] = editor[prop]);
            if (options) for (var prop in options) void 0 !== options[prop] && (out[prop] = options[prop]);
            out.hint.resolve && (out.hint = out.hint.resolve(cm, pos));
            return out;
        }(this, this.getCursor("start"), options);
        var selections = this.listSelections();
        if (!(1 < selections.length)) {
            if (this.somethingSelected()) {
                if (!options.hint.supportsSelection) return;
                for (var i = 0; i < selections.length; i++) if (selections[i].head.line != selections[i].anchor.line) return;
            }
            this.state.completionActive && this.state.completionActive.close();
            options = this.state.completionActive = new Completion(this, options);
            options.options.hint && (CodeMirror.signal(this, "startCompletion", this), 
            options.update(!0));
        }
    });
    var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
        return setTimeout(fn, 1e3 / 60);
    }, cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
    function getText(completion) {
        return "string" == typeof completion ? completion : completion.text;
    }
    function getHintElement(hintsElement, el) {
        for (;el && el != hintsElement; ) {
            if ("LI" === el.nodeName.toUpperCase() && el.parentNode == hintsElement) return el;
            el = el.parentNode;
        }
    }
    function Widget(completion, data) {
        this.completion = completion, this.data = data, this.picked = !1;
        for (var widget = this, cm = completion.cm, hints = this.hints = document.createElement("ul"), completions = (hints.className = "CodeMirror-hints", 
        this.selectedHint = data.selectedHint || 0, data.list), i = 0; i < completions.length; ++i) {
            var elt = hints.appendChild(document.createElement("li")), cur = completions[i], className = "CodeMirror-hint" + (i != this.selectedHint ? "" : " CodeMirror-hint-active");
            null != cur.className && (className = cur.className + " " + className), 
            elt.className = className, cur.render ? cur.render(elt, data, cur) : elt.appendChild(document.createTextNode(cur.displayText || getText(cur))), 
            elt.hintId = i;
        }
        var closingOnBlur, pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null), left = pos.left, top = pos.bottom, below = !0, winW = (hints.style.left = left + "px", 
        hints.style.top = top + "px", window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth)), winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight), box = ((completion.options.container || document.body).appendChild(hints), 
        hints.getBoundingClientRect()), overlapY = box.bottom - winH, scrolls = hints.scrollHeight > hints.clientHeight + 1, startScroll = cm.getScrollInfo(), winH = (0 < overlapY && (overlapY = box.bottom - box.top, 
        0 < pos.top - (pos.bottom - box.top) - overlapY ? (hints.style.top = (top = pos.top - overlapY) + "px", 
        below = !1) : winH < overlapY && (hints.style.height = winH - 5 + "px", 
        hints.style.top = (top = pos.bottom - box.top) + "px", overlapY = cm.getCursor(), 
        data.from.ch != overlapY.ch && (pos = cm.cursorCoords(overlapY), hints.style.left = (left = pos.left) + "px", 
        box = hints.getBoundingClientRect()))), box.right - winW);
        if (0 < winH && (box.right - box.left > winW && (hints.style.width = winW - 5 + "px", 
        winH -= box.right - box.left - winW), hints.style.left = (left = pos.left - winH) + "px"), 
        scrolls) for (var node = hints.firstChild; node; node = node.nextSibling) node.style.paddingRight = cm.display.nativeBarWidth + "px";
        return cm.addKeyMap(this.keyMap = function(completion, handle) {
            var baseMap = {
                Up: function() {
                    handle.moveFocus(-1);
                },
                Down: function() {
                    handle.moveFocus(1);
                },
                PageUp: function() {
                    handle.moveFocus(1 - handle.menuSize(), !0);
                },
                PageDown: function() {
                    handle.moveFocus(handle.menuSize() - 1, !0);
                },
                Home: function() {
                    handle.setFocus(0);
                },
                End: function() {
                    handle.setFocus(handle.length - 1);
                },
                Enter: handle.pick,
                Tab: handle.pick,
                Esc: handle.close
            }, custom = completion.options.customKeys, ourMap = custom ? {} : baseMap;
            function addBinding(key, val) {
                var bound = "string" != typeof val ? function(cm) {
                    return val(cm, handle);
                } : baseMap.hasOwnProperty(val) ? baseMap[val] : val;
                ourMap[key] = bound;
            }
            if (custom) for (var key in custom) custom.hasOwnProperty(key) && addBinding(key, custom[key]);
            var extra = completion.options.extraKeys;
            if (extra) for (var key in extra) extra.hasOwnProperty(key) && addBinding(key, extra[key]);
            return ourMap;
        }(completion, {
            moveFocus: function(n, avoidWrap) {
                widget.changeActive(widget.selectedHint + n, avoidWrap);
            },
            setFocus: function(n) {
                widget.changeActive(n);
            },
            menuSize: function() {
                return widget.screenAmount();
            },
            length: completions.length,
            close: function() {
                completion.close();
            },
            pick: function() {
                widget.pick();
            },
            data: data
        })), completion.options.closeOnUnfocus && (cm.on("blur", this.onBlur = function() {
            closingOnBlur = setTimeout(function() {
                completion.close();
            }, 100);
        }), cm.on("focus", this.onFocus = function() {
            clearTimeout(closingOnBlur);
        })), cm.on("scroll", this.onScroll = function() {
            var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect(), newTop = top + startScroll.top - curScroll.top, point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
            if (below || (point += hints.offsetHeight), point <= editor.top || point >= editor.bottom) return completion.close();
            hints.style.top = newTop + "px", hints.style.left = left + startScroll.left - curScroll.left + "px";
        }), CodeMirror.on(hints, "dblclick", function(e) {
            e = getHintElement(hints, e.target || e.srcElement);
            e && null != e.hintId && (widget.changeActive(e.hintId), widget.pick());
        }), CodeMirror.on(hints, "click", function(e) {
            e = getHintElement(hints, e.target || e.srcElement);
            e && null != e.hintId && (widget.changeActive(e.hintId), completion.options.completeOnSingleClick && widget.pick());
        }), CodeMirror.on(hints, "mousedown", function() {
            setTimeout(function() {
                cm.focus();
            }, 20);
        }), CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]), 
        !0;
    }
    function fetchHints(hint, cm, options, callback) {
        hint.async ? hint(cm, callback, options) : (hint = hint(cm, options)) && hint.then ? hint.then(callback) : callback(hint);
    }
    Completion.prototype = {
        close: function() {
            this.active() && (this.cm.state.completionActive = null, this.tick = null, 
            this.cm.off("cursorActivity", this.activityFunc), this.widget && this.data && CodeMirror.signal(this.data, "close"), 
            this.widget && this.widget.close(), CodeMirror.signal(this.cm, "endCompletion", this.cm));
        },
        active: function() {
            return this.cm.state.completionActive == this;
        },
        pick: function(data, i) {
            i = data.list[i];
            i.hint ? i.hint(this.cm, data, i) : this.cm.replaceRange(getText(i), i.from || data.from, i.to || data.to, "complete"), 
            CodeMirror.signal(data, "pick", i), this.close();
        },
        cursorActivity: function() {
            this.debounce && (cancelAnimationFrame(this.debounce), this.debounce = 0);
            var self, pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
            pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < this.startPos.ch || this.cm.somethingSelected() || pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)) ? this.close() : ((self = this).debounce = requestAnimationFrame(function() {
                self.update();
            }), this.widget && this.widget.disable());
        },
        update: function(first) {
            var self, myTick;
            null != this.tick && (myTick = ++(self = this).tick, fetchHints(this.options.hint, this.cm, this.options, function(data) {
                self.tick == myTick && self.finishUpdate(data, first);
            }));
        },
        finishUpdate: function(data, first) {
            this.data && CodeMirror.signal(this.data, "update");
            var old, nw, first = this.widget && this.widget.picked || first && this.options.completeSingle;
            this.widget && this.widget.close(), data && this.data && (old = this.data, 
            nw = data, 0 < CodeMirror.cmpPos(nw.from, old.from) && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch) || (this.data = data) && data.list.length && (first && 1 == data.list.length ? this.pick(data, 0) : (this.widget = new Widget(this, data), 
            CodeMirror.signal(data, "shown")));
        }
    }, Widget.prototype = {
        close: function() {
            var cm;
            this.completion.widget == this && (this.completion.widget = null, this.hints.parentNode.removeChild(this.hints), 
            this.completion.cm.removeKeyMap(this.keyMap), cm = this.completion.cm, 
            this.completion.options.closeOnUnfocus && (cm.off("blur", this.onBlur), 
            cm.off("focus", this.onFocus)), cm.off("scroll", this.onScroll));
        },
        disable: function() {
            this.completion.cm.removeKeyMap(this.keyMap);
            var widget = this;
            this.keyMap = {
                Enter: function() {
                    widget.picked = !0;
                }
            }, this.completion.cm.addKeyMap(this.keyMap);
        },
        pick: function() {
            this.completion.pick(this.data, this.selectedHint);
        },
        changeActive: function(i, avoidWrap) {
            i >= this.data.list.length ? i = avoidWrap ? this.data.list.length - 1 : 0 : i < 0 && (i = avoidWrap ? 0 : this.data.list.length - 1), 
            this.selectedHint != i && ((avoidWrap = this.hints.childNodes[this.selectedHint]).className = avoidWrap.className.replace(" CodeMirror-hint-active", ""), 
            (avoidWrap = this.hints.childNodes[this.selectedHint = i]).className += " CodeMirror-hint-active", 
            avoidWrap.offsetTop < this.hints.scrollTop ? this.hints.scrollTop = avoidWrap.offsetTop - 3 : avoidWrap.offsetTop + avoidWrap.offsetHeight > this.hints.scrollTop + this.hints.clientHeight && (this.hints.scrollTop = avoidWrap.offsetTop + avoidWrap.offsetHeight - this.hints.clientHeight + 3), 
            CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], avoidWrap));
        },
        screenAmount: function() {
            return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
        }
    }, CodeMirror.registerHelper("hint", "auto", {
        resolve: function(cm, pos) {
            var words, helpers = cm.getHelpers(pos, "hint");
            return helpers.length ? ((pos = function(cm, callback, options) {
                var app = function(cm, helpers) {
                    if (!cm.somethingSelected()) return helpers;
                    for (var result = [], i = 0; i < helpers.length; i++) helpers[i].supportsSelection && result.push(helpers[i]);
                    return result;
                }(cm, helpers);
                !function run(i) {
                    if (i == app.length) return callback(null);
                    fetchHints(app[i], cm, options, function(result) {
                        result && 0 < result.list.length ? callback(result) : run(i + 1);
                    });
                }(0);
            }).async = !0, pos.supportsSelection = !0, pos) : (words = cm.getHelper(cm.getCursor(), "hintWords")) ? function(cm) {
                return CodeMirror.hint.fromList(cm, {
                    words: words
                });
            } : CodeMirror.hint.anyword ? function(cm, options) {
                return CodeMirror.hint.anyword(cm, options);
            } : function() {};
        }
    }), CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
        for (var term, cur = cm.getCursor(), cm = cm.getTokenAt(cur), to = CodeMirror.Pos(cur.line, cm.end), found = (cur = cm.string && /\w/.test(cm.string[cm.string.length - 1]) ? (term = cm.string, 
        CodeMirror.Pos(cur.line, cm.start)) : (term = "", to), []), i = 0; i < options.words.length; i++) {
            var word = options.words[i];
            word.slice(0, term.length) == term && found.push(word);
        }
        if (found.length) return {
            list: found,
            from: cur,
            to: to
        };
    }), CodeMirror.commands.autocomplete = CodeMirror.showHint;
    var defaultOptions = {
        hint: CodeMirror.hint.auto,
        completeSingle: !0,
        alignWithWord: !0,
        closeCharacters: /[\s()\[\]{};:>,]/,
        closeOnUnfocus: !0,
        completeOnSingleClick: !0,
        container: null,
        customKeys: null,
        extraKeys: null
    };
    CodeMirror.defineOption("hintOptions", null);
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    var WORD = /[\w$]+/;
    CodeMirror.registerHelper("hint", "anyword", function(editor, options) {
        for (var word = options && options.word || WORD, range = options && options.range || 500, cur = editor.getCursor(), curLine = editor.getLine(cur.line), end = cur.ch, start = end; start && word.test(curLine.charAt(start - 1)); ) --start;
        for (var curWord = start != end && curLine.slice(start, end), list = options && options.list || [], seen = {}, re = new RegExp(word.source, "g"), dir = -1; dir <= 1; dir += 2) for (var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir; line != endLine; line += dir) for (var m, text = editor.getLine(line); m = re.exec(text); ) line == cur.line && m[0] === curWord || curWord && 0 != m[0].lastIndexOf(curWord, 0) || Object.prototype.hasOwnProperty.call(seen, m[0]) || (seen[m[0]] = !0, 
        list.push(m[0]));
        return {
            list: list,
            from: CodeMirror.Pos(cur.line, start),
            to: CodeMirror.Pos(cur.line, end)
        };
    });
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineOption("fullScreen", !1, function(cm, val, old) {
        !(old = old == CodeMirror.Init ? !1 : old) != !val && (val ? function(cm) {
            var wrap = cm.getWrapperElement();
            cm.state.fullScreenRestore = {
                scrollTop: window.pageYOffset,
                scrollLeft: window.pageXOffset,
                width: wrap.style.width,
                height: wrap.style.height
            }, wrap.style.width = "", wrap.style.height = "auto", wrap.className += " CodeMirror-fullscreen", 
            document.documentElement.style.overflow = "hidden", cm.refresh();
        } : function(cm) {
            var wrap = cm.getWrapperElement(), info = (wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, ""), 
            document.documentElement.style.overflow = "", cm.state.fullScreenRestore);
            wrap.style.width = info.width, wrap.style.height = info.height, window.scrollTo(info.scrollLeft, info.scrollTop), 
            cm.refresh();
        })(cm);
    });
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (null == document.documentMode || document.documentMode < 8), Pos = CodeMirror.Pos, matching = {
        "(": ")>",
        ")": "(<",
        "[": "]>",
        "]": "[<",
        "{": "}>",
        "}": "{<"
    };
    function findMatchingBracket(cm, where, config) {
        var style, line = cm.getLineHandle(where.line), pos = where.ch - 1, afterCursor = config && config.afterCursor, afterCursor = !(afterCursor = null == afterCursor ? /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className) : afterCursor) && 0 <= pos && matching[line.text.charAt(pos)] || matching[line.text.charAt(++pos)];
        return !afterCursor || (line = ">" == afterCursor.charAt(1) ? 1 : -1, config && config.strict && 0 < line != (pos == where.ch) || (style = cm.getTokenTypeAt(Pos(where.line, pos + 1)), 
        null == (cm = scanForBracket(cm, Pos(where.line, pos + (0 < line ? 1 : 0)), line, style || null, config)))) ? null : {
            from: Pos(where.line, pos),
            to: cm && cm.pos,
            match: cm && cm.ch == afterCursor.charAt(0),
            forward: 0 < line
        };
    }
    function scanForBracket(cm, where, dir, style, config) {
        for (var maxScanLen = config && config.maxScanLineLength || 1e4, maxScanLines = config && config.maxScanLines || 1e3, stack = [], re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/, lineEnd = 0 < dir ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines), lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
            var line = cm.getLine(lineNo);
            if (line) {
                var pos = 0 < dir ? 0 : line.length - 1, end = 0 < dir ? line.length : -1;
                if (!(line.length > maxScanLen)) for (lineNo == where.line && (pos = where.ch - (dir < 0 ? 1 : 0)); pos != end; pos += dir) {
                    var ch = line.charAt(pos);
                    if (re.test(ch) && (void 0 === style || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) if (">" == matching[ch].charAt(1) == 0 < dir) stack.push(ch); else {
                        if (!stack.length) return {
                            pos: Pos(lineNo, pos),
                            ch: ch
                        };
                        stack.pop();
                    }
                }
            }
        }
        return lineNo - dir != (0 < dir ? cm.lastLine() : cm.firstLine()) && null;
    }
    function matchBrackets(cm, autoclear, config) {
        for (var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, marks = [], ranges = cm.listSelections(), i = 0; i < ranges.length; i++) {
            var style, match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
            match && cm.getLine(match.from.line).length <= maxHighlightLen && (style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket", 
            marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {
                className: style
            })), match.to && cm.getLine(match.to.line).length <= maxHighlightLen && marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {
                className: style
            })));
        }
        if (marks.length) {
            ie_lt8 && cm.state.focused && cm.focus();
            function clear() {
                cm.operation(function() {
                    for (var i = 0; i < marks.length; i++) marks[i].clear();
                });
            }
            if (!autoclear) return clear;
            setTimeout(clear, 800);
        }
    }
    var currentlyHighlighted = null;
    function doMatchBrackets(cm) {
        cm.operation(function() {
            currentlyHighlighted && (currentlyHighlighted(), currentlyHighlighted = null), 
            currentlyHighlighted = matchBrackets(cm, !1, cm.state.matchBrackets);
        });
    }
    CodeMirror.defineOption("matchBrackets", !1, function(cm, val, old) {
        old && old != CodeMirror.Init && (cm.off("cursorActivity", doMatchBrackets), 
        currentlyHighlighted && (currentlyHighlighted(), currentlyHighlighted = null)), 
        val && (cm.state.matchBrackets = "object" == typeof val ? val : {}, cm.on("cursorActivity", doMatchBrackets));
    }), CodeMirror.defineExtension("matchBrackets", function() {
        matchBrackets(this, !0);
    }), CodeMirror.defineExtension("findMatchingBracket", function(pos, config, oldConfig) {
        return findMatchingBracket(this, pos, config = !oldConfig && "boolean" != typeof config ? config : oldConfig ? (oldConfig.strict = config, 
        oldConfig) : config ? {
            strict: !0
        } : null);
    }), CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config) {
        return scanForBracket(this, pos, dir, style, config);
    });
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function ensureState(states, name) {
        if (!states.hasOwnProperty(name)) throw new Error("Undefined state " + name + " in simple mode");
    }
    function toRegex(val, caret) {
        var flags;
        return val ? (flags = "", val = val instanceof RegExp ? (val.ignoreCase && (flags = "i"), 
        val.source) : String(val), new RegExp((!1 === caret ? "" : "^") + "(?:" + val + ")", flags)) : /(?:)/;
    }
    function Rule(data, states) {
        (data.next || data.push) && ensureState(states, data.next || data.push), 
        this.regex = toRegex(data.regex), this.token = function(val) {
            if (!val) return null;
            if (val.apply) return val;
            if ("string" == typeof val) return val.replace(/\./g, " ");
            for (var result = [], i = 0; i < val.length; i++) result.push(val[i] && val[i].replace(/\./g, " "));
            return result;
        }(data.token), this.data = data;
    }
    CodeMirror.defineSimpleMode = function(name, states) {
        CodeMirror.defineMode(name, function(config) {
            return CodeMirror.simpleMode(config, states);
        });
    }, CodeMirror.simpleMode = function(config, states) {
        ensureState(states, "start");
        var state, states_ = {}, meta = states.meta || {}, hasIndentation = !1;
        for (state in states) if (state != meta && states.hasOwnProperty(state)) for (var list = states_[state] = [], orig = states[state], i = 0; i < orig.length; i++) {
            var data = orig[i];
            list.push(new Rule(data, states)), (data.indent || data.dedent) && (hasIndentation = !0);
        }
        var mode = {
            startState: function() {
                return {
                    state: "start",
                    pending: null,
                    local: null,
                    localState: null,
                    indent: hasIndentation ? [] : null
                };
            },
            copyState: function(state) {
                var s = {
                    state: state.state,
                    pending: state.pending,
                    local: state.local,
                    localState: null,
                    indent: state.indent && state.indent.slice(0)
                };
                state.localState && (s.localState = CodeMirror.copyState(state.local.mode, state.localState)), 
                state.stack && (s.stack = state.stack.slice(0));
                for (var pers = state.persistentStates; pers; pers = pers.next) s.persistentStates = {
                    mode: pers.mode,
                    spec: pers.spec,
                    state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),
                    next: s.persistentStates
                };
                return s;
            },
            token: function(states, config) {
                return function(stream, state) {
                    var tok, pend;
                    if (state.pending) return pend = state.pending.shift(), 0 == state.pending.length && (state.pending = null), 
                    stream.pos += pend.text.length, pend.token;
                    if (state.local) return state.local.end && stream.match(state.local.end) ? (tok = state.local.endToken || null, 
                    state.local = state.localState = null) : (tok = state.local.mode.token(stream, state.localState), 
                    state.local.endScan && (pend = state.local.endScan.exec(stream.current())) && (stream.pos = stream.start + pend.index)), 
                    tok;
                    for (var curState = states[state.state], i = 0; i < curState.length; i++) {
                        var rule = curState[i], matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
                        if (matches) {
                            rule.data.next ? state.state = rule.data.next : rule.data.push ? ((state.stack || (state.stack = [])).push(state.state), 
                            state.state = rule.data.push) : rule.data.pop && state.stack && state.stack.length && (state.state = state.stack.pop()), 
                            rule.data.mode && !function(config, state, spec, token) {
                                var pers;
                                if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next) (spec.spec ? function cmp(a, b) {
                                    if (a === b) return !0;
                                    if (!a || "object" != typeof a || !b || "object" != typeof b) return !1;
                                    var props = 0;
                                    for (var prop in a) if (a.hasOwnProperty(prop)) {
                                        if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return !1;
                                        props++;
                                    }
                                    for (var prop in b) b.hasOwnProperty(prop) && props--;
                                    return 0 == props;
                                }(spec.spec, p.spec) : spec.mode == p.mode) && (pers = p);
                                var config = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec), lState = pers ? pers.state : CodeMirror.startState(config);
                                spec.persistent && !pers && (state.persistentStates = {
                                    mode: config,
                                    spec: spec.spec,
                                    state: lState,
                                    next: state.persistentStates
                                });
                                state.localState = lState, state.local = {
                                    mode: config,
                                    end: spec.end && toRegex(spec.end),
                                    endScan: spec.end && !1 !== spec.forceEnd && toRegex(spec.end, !1),
                                    endToken: token && token.join ? token[token.length - 1] : token
                                };
                            }(config, state, rule.data.mode, rule.token), rule.data.indent && state.indent.push(stream.indentation() + config.indentUnit), 
                            rule.data.dedent && state.indent.pop();
                            var token = rule.token;
                            if (token && token.apply && (token = token(matches)), 
                            2 < matches.length && rule.token && "string" != typeof rule.token) {
                                state.pending = [];
                                for (var j = 2; j < matches.length; j++) matches[j] && state.pending.push({
                                    text: matches[j],
                                    token: rule.token[j - 1]
                                });
                                return stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0)), 
                                token[0];
                            }
                            return token && token.join ? token[0] : token;
                        }
                    }
                    return stream.next(), null;
                };
            }(states_, config),
            innerMode: function(state) {
                return state.local && {
                    mode: state.local.mode,
                    state: state.localState
                };
            },
            indent: function(states, meta) {
                return function(state, textAfter, line) {
                    if (state.local && state.local.mode.indent) return state.local.mode.indent(state.localState, textAfter, line);
                    if (null == state.indent || state.local || meta.dontIndentStates && -1 < function(val, arr) {
                        for (var i = 0; i < arr.length; i++) if (arr[i] === val) return !0;
                    }(state.state, meta.dontIndentStates)) return CodeMirror.Pass;
                    var pos = state.indent.length - 1, rules = states[state.state];
                    scan: for (;;) {
                        for (var i = 0; i < rules.length; i++) {
                            var rule = rules[i];
                            if (rule.data.dedent && !1 !== rule.data.dedentIfLineStart) {
                                var m = rule.regex.exec(textAfter);
                                if (m && m[0]) {
                                    pos--, (rule.next || rule.push) && (rules = states[rule.next || rule.push]), 
                                    textAfter = textAfter.slice(m[0].length);
                                    continue scan;
                                }
                            }
                        }
                        break;
                    }
                    return pos < 0 ? 0 : state.indent[pos];
                };
            }(states_, meta)
        };
        if (meta) for (var prop in meta) meta.hasOwnProperty(prop) && (mode[prop] = meta[prop]);
        return mode;
    };
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    CodeMirror.overlayMode = function(base, overlay, combine) {
        return {
            startState: function() {
                return {
                    base: CodeMirror.startState(base),
                    overlay: CodeMirror.startState(overlay),
                    basePos: 0,
                    baseCur: null,
                    overlayPos: 0,
                    overlayCur: null,
                    streamSeen: null
                };
            },
            copyState: function(state) {
                return {
                    base: CodeMirror.copyState(base, state.base),
                    overlay: CodeMirror.copyState(overlay, state.overlay),
                    basePos: state.basePos,
                    baseCur: null,
                    overlayPos: state.overlayPos,
                    overlayCur: null
                };
            },
            token: function(stream, state) {
                return (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) && (state.streamSeen = stream, 
                state.basePos = state.overlayPos = stream.start), stream.start == state.basePos && (state.baseCur = base.token(stream, state.base), 
                state.basePos = stream.pos), stream.start == state.overlayPos && (stream.pos = stream.start, 
                state.overlayCur = overlay.token(stream, state.overlay), state.overlayPos = stream.pos), 
                stream.pos = Math.min(state.basePos, state.overlayPos), null == state.overlayCur ? state.baseCur : null != state.baseCur && state.overlay.combineTokens || combine && null == state.overlay.combineTokens ? state.baseCur + " " + state.overlayCur : state.overlayCur;
            },
            indent: base.indent && function(state, textAfter) {
                return base.indent(state.base, textAfter);
            },
            electricChars: base.electricChars,
            innerMode: function(state) {
                return {
                    state: state.base,
                    mode: base
                };
            },
            blankLine: function(state) {
                var baseToken, overlayToken;
                return base.blankLine && (baseToken = base.blankLine(state.base)), 
                null == (overlayToken = overlay.blankLine ? overlay.blankLine(state.overlay) : overlayToken) ? baseToken : combine && null != baseToken ? baseToken + " " + overlayToken : overlayToken;
            }
        };
    };
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("./searchcursor"), require("../dialog/dialog")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror", "./searchcursor", "../dialog/dialog" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function SearchState() {
        this.posFrom = this.posTo = this.lastQuery = this.query = null, this.overlay = null;
    }
    function getSearchState(cm) {
        return cm.state.search || (cm.state.search = new SearchState());
    }
    function queryCaseInsensitive(query) {
        return "string" == typeof query && query == query.toLowerCase();
    }
    function getSearchCursor(cm, query, pos) {
        return cm.getSearchCursor(query, pos, {
            caseFold: queryCaseInsensitive(query),
            multiline: !0
        });
    }
    function dialog(cm, text, shortText, deflt, f) {
        cm.openDialog ? cm.openDialog(text, f, {
            value: deflt,
            selectValueOnOpen: !0
        }) : f(prompt(shortText, deflt));
    }
    function parseString(string) {
        return string.replace(/\\(.)/g, function(_, ch) {
            return "n" == ch ? "\n" : "r" == ch ? "\r" : ch;
        });
    }
    function parseQuery(query) {
        var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
        if (isRE) try {
            query = new RegExp(isRE[1], -1 == isRE[2].indexOf("i") ? "" : "i");
        } catch (e) {} else query = parseString(query);
        return query = ("string" == typeof query ? "" == query : query.test("")) ? /x^/ : query;
    }
    var queryDialog = '<span class="CodeMirror-search-label">Search:</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>';
    function startSearch(cm, state, query) {
        state.queryText = query, state.query = parseQuery(query), cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query)), 
        state.overlay = function(query, caseInsensitive) {
            return "string" == typeof query ? query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g") : query.global || (query = new RegExp(query.source, query.ignoreCase ? "gi" : "g")), 
            {
                token: function(stream) {
                    query.lastIndex = stream.pos;
                    var match = query.exec(stream.string);
                    if (match && match.index == stream.pos) return stream.pos += match[0].length || 1, 
                    "searching";
                    match ? stream.pos = match.index : stream.skipToEnd();
                }
            };
        }(state.query, queryCaseInsensitive(state.query)), cm.addOverlay(state.overlay), 
        cm.showMatchesOnScrollbar && (state.annotate && (state.annotate.clear(), 
        state.annotate = null), state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query)));
    }
    function doSearch(cm, rev, persistent, immediate) {
        var state = getSearchState(cm);
        if (state.query) return findNext(cm, rev);
        var hiding, searchNext, q = cm.getSelection() || state.lastQuery;
        q instanceof RegExp && "x^" == q.source && (q = null), persistent && cm.openDialog ? (hiding = null, 
        function(cm, text, deflt, onEnter, onKeyDown) {
            cm.openDialog(text, onEnter, {
                value: deflt,
                selectValueOnOpen: !0,
                closeOnEnter: !1,
                onClose: function() {
                    clearSearch(cm);
                },
                onKeyDown: onKeyDown
            });
        }(cm, queryDialog, q, searchNext = function(query, event) {
            CodeMirror.e_stop(event), query && (query != state.queryText && (startSearch(cm, state, query), 
            state.posFrom = state.posTo = cm.getCursor()), hiding && (hiding.style.opacity = 1), 
            findNext(cm, event.shiftKey, function(_, to) {
                var dialog;
                to.line < 3 && document.querySelector && (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) && dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top && ((hiding = dialog).style.opacity = .4);
            }));
        }, function(event, query) {
            var keyName = CodeMirror.keyName(event), extra = cm.getOption("extraKeys"), extra = extra && extra[keyName] || CodeMirror.keyMap[cm.getOption("keyMap")][keyName];
            "findNext" == extra || "findPrev" == extra || "findPersistentNext" == extra || "findPersistentPrev" == extra ? (CodeMirror.e_stop(event), 
            startSearch(cm, getSearchState(cm), query), cm.execCommand(extra)) : "find" != extra && "findPersistent" != extra || (CodeMirror.e_stop(event), 
            searchNext(query, event));
        }), immediate && q && (startSearch(cm, state, q), findNext(cm, rev))) : dialog(cm, queryDialog, "Search for:", q, function(query) {
            query && !state.query && cm.operation(function() {
                startSearch(cm, state, query), state.posFrom = state.posTo = cm.getCursor(), 
                findNext(cm, rev);
            });
        });
    }
    function findNext(cm, rev, callback) {
        cm.operation(function() {
            var state = getSearchState(cm), cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
            (cursor.find(rev) || (cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0))).find(rev)) && (cm.setSelection(cursor.from(), cursor.to()), 
            cm.scrollIntoView({
                from: cursor.from(),
                to: cursor.to()
            }, 20), state.posFrom = cursor.from(), state.posTo = cursor.to(), callback && callback(cursor.from(), cursor.to()));
        });
    }
    function clearSearch(cm) {
        cm.operation(function() {
            var state = getSearchState(cm);
            state.lastQuery = state.query, state.query && (state.query = state.queryText = null, 
            cm.removeOverlay(state.overlay), state.annotate && (state.annotate.clear(), 
            state.annotate = null));
        });
    }
    function replaceAll(cm, query, text) {
        cm.operation(function() {
            for (var match, cursor = getSearchCursor(cm, query); cursor.findNext(); ) "string" != typeof query ? (match = cm.getRange(cursor.from(), cursor.to()).match(query), 
            cursor.replace(text.replace(/\$(\d)/g, function(_, i) {
                return match[i];
            }))) : cursor.replace(text);
        });
    }
    function replace(cm, all) {
        var query, dialogText;
        cm.getOption("readOnly") || (query = cm.getSelection() || getSearchState(cm).lastQuery, 
        dialog(cm, (dialogText = '<span class="CodeMirror-search-label">' + (all ? "Replace all:" : "Replace:") + "</span>") + ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>', dialogText, query, function(query) {
            query && (query = parseQuery(query), dialog(cm, '<span class="CodeMirror-search-label">With:</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>', "Replace with:", "", function(text) {
                var cursor, advance, doReplace;
                text = parseString(text), all ? replaceAll(cm, query, text) : (clearSearch(cm), 
                cursor = getSearchCursor(cm, query, cm.getCursor("from")), doReplace = function(match) {
                    cursor.replace("string" == typeof query ? text : text.replace(/\$(\d)/g, function(_, i) {
                        return match[i];
                    })), advance();
                }, (advance = function() {
                    var match, start = cursor.from();
                    !(match = cursor.findNext()) && (cursor = getSearchCursor(cm, query), 
                    !(match = cursor.findNext()) || start && cursor.from().line == start.line && cursor.from().ch == start.ch) || (cm.setSelection(cursor.from(), cursor.to()), 
                    cm.scrollIntoView({
                        from: cursor.from(),
                        to: cursor.to()
                    }), function(cm, text, shortText, fs) {
                        cm.openConfirm ? cm.openConfirm(text, fs) : confirm(shortText) && fs[0]();
                    }(cm, '<span class="CodeMirror-search-label">Replace?</span> <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>', "Replace?", [ function() {
                        doReplace(match);
                    }, advance, function() {
                        replaceAll(cm, query, text);
                    } ]));
                })());
            }));
        }));
    }
    CodeMirror.commands.find = function(cm) {
        clearSearch(cm), doSearch(cm);
    }, CodeMirror.commands.findPersistent = function(cm) {
        clearSearch(cm), doSearch(cm, !1, !0);
    }, CodeMirror.commands.findPersistentNext = function(cm) {
        doSearch(cm, !1, !0, !0);
    }, CodeMirror.commands.findPersistentPrev = function(cm) {
        doSearch(cm, !0, !0, !0);
    }, CodeMirror.commands.findNext = doSearch, CodeMirror.commands.findPrev = function(cm) {
        doSearch(cm, !0);
    }, CodeMirror.commands.clearSearch = clearSearch, CodeMirror.commands.replace = replace, 
    CodeMirror.commands.replaceAll = function(cm) {
        replace(cm, !0);
    };
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    var doFold, noFold, Pos = CodeMirror.Pos;
    function ensureGlobal(regexp) {
        return regexp.global ? regexp : new RegExp(regexp.source, function(regexp) {
            var flags = regexp.flags;
            return null != flags ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
        }(regexp) + "g");
    }
    function searchRegexpForward(doc, regexp, start) {
        regexp = ensureGlobal(regexp);
        for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, 
        ch = 0) {
            regexp.lastIndex = ch;
            var string = doc.getLine(line), string = regexp.exec(string);
            if (string) return {
                from: Pos(line, string.index),
                to: Pos(line, string.index + string[0].length),
                match: string
            };
        }
    }
    function searchRegexpForwardMultiline(doc, regexp, start) {
        if (!/\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source)) return searchRegexpForward(doc, regexp, start);
        regexp = ensureGlobal(regexp);
        for (var chunk = 1, line = start.line, last = doc.lastLine(); line <= last; ) {
            for (var i = 0; i < chunk; i++) var curLine = doc.getLine(line++), string = null == string ? curLine : string + "\n" + curLine;
            chunk *= 2, regexp.lastIndex = start.ch;
            var inside, startLine, before, match = regexp.exec(string);
            if (match) return before = string.slice(0, match.index).split("\n"), 
            inside = match[0].split("\n"), startLine = start.line + before.length - 1, 
            before = before[before.length - 1].length, {
                from: Pos(startLine, before),
                to: Pos(startLine + inside.length - 1, 1 == inside.length ? before + inside[0].length : inside[inside.length - 1].length),
                match: match
            };
        }
    }
    function lastMatchIn(string, regexp) {
        for (var match, cutOff = 0; ;) {
            regexp.lastIndex = cutOff;
            var newMatch = regexp.exec(string);
            if (!newMatch) return match;
            if ((cutOff = (match = newMatch).index + (match[0].length || 1)) == string.length) return match;
        }
    }
    function searchRegexpBackward(doc, regexp, start) {
        regexp = ensureGlobal(regexp);
        for (var line = start.line, ch = start.ch, first = doc.firstLine(); first <= line; line--, 
        ch = -1) {
            var string = doc.getLine(line), string = lastMatchIn(string = -1 < ch ? string.slice(0, ch) : string, regexp);
            if (string) return {
                from: Pos(line, string.index),
                to: Pos(line, string.index + string[0].length),
                match: string
            };
        }
    }
    function searchRegexpBackwardMultiline(doc, regexp, start) {
        regexp = ensureGlobal(regexp);
        for (var chunk = 1, line = start.line, first = doc.firstLine(); first <= line; ) {
            for (var i = 0; i < chunk; i++) var curLine = doc.getLine(line--), string = null == string ? curLine.slice(0, start.ch) : curLine + "\n" + string;
            chunk *= 2;
            var inside, startLine, before, match = lastMatchIn(string, regexp);
            if (match) return before = string.slice(0, match.index).split("\n"), 
            inside = match[0].split("\n"), startLine = line + before.length, before = before[before.length - 1].length, 
            {
                from: Pos(startLine, before),
                to: Pos(startLine + inside.length - 1, 1 == inside.length ? before + inside[0].length : inside[inside.length - 1].length),
                match: match
            };
        }
    }
    function adjustPos(orig, folded, pos, foldFunc) {
        if (orig.length == folded.length) return pos;
        for (var min = 0, max = pos + Math.max(0, orig.length - folded.length); ;) {
            if (min == max) return min;
            var mid = min + max >> 1, len = foldFunc(orig.slice(0, mid)).length;
            if (len == pos) return mid;
            pos < len ? max = mid : min = 1 + mid;
        }
    }
    function searchStringForward(doc, query, start, caseFold) {
        if (!query.length) return null;
        var fold = caseFold ? doFold : noFold, lines = fold(query).split(/\r|\n\r?/);
        search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, 
        ch = 0) {
            var orig = doc.getLine(line).slice(ch), string = fold(orig);
            if (1 == lines.length) {
                var found = string.indexOf(lines[0]);
                if (-1 != found) return start = adjustPos(orig, string, found, fold) + ch, 
                {
                    from: Pos(line, adjustPos(orig, string, found, fold) + ch),
                    to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)
                };
            } else {
                found = string.length - lines[0].length;
                if (string.slice(found) == lines[0]) {
                    for (var i = 1; i < lines.length - 1; i++) if (fold(doc.getLine(line + i)) != lines[i]) continue search;
                    var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1];
                    if (end.slice(0, lastLine.length) == lastLine) return {
                        from: Pos(line, adjustPos(orig, string, found, fold) + ch),
                        to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))
                    };
                }
            }
        }
    }
    function searchStringBackward(doc, query, start, caseFold) {
        if (!query.length) return null;
        var fold = caseFold ? doFold : noFold, lines = fold(query).split(/\r|\n\r?/);
        search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; first <= line; line--, 
        ch = -1) {
            var orig = doc.getLine(line), string = fold(orig = -1 < ch ? orig.slice(0, ch) : orig);
            if (1 == lines.length) {
                var found = string.lastIndexOf(lines[0]);
                if (-1 != found) return {
                    from: Pos(line, adjustPos(orig, string, found, fold)),
                    to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))
                };
            } else {
                found = lines[lines.length - 1];
                if (string.slice(0, found.length) == found) {
                    for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++) if (fold(doc.getLine(start + i)) != lines[i]) continue search;
                    var top = doc.getLine(line + 1 - lines.length), topString = fold(top);
                    if (topString.slice(topString.length - lines[0].length) == lines[0]) return {
                        from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
                        to: Pos(line, adjustPos(orig, string, found.length, fold))
                    };
                }
            }
        }
    }
    function SearchCursor(doc, query, pos, options) {
        var caseFold;
        this.atOccurrence = !1, this.doc = doc, pos = pos ? doc.clipPos(pos) : Pos(0, 0), 
        this.pos = {
            from: pos,
            to: pos
        }, "object" == typeof options ? caseFold = options.caseFold : (caseFold = options, 
        options = null), "string" == typeof query ? (null == caseFold && (caseFold = !1), 
        this.matches = function(reverse, pos) {
            return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold);
        }) : (query = ensureGlobal(query), options && !1 === options.multiline ? this.matches = function(reverse, pos) {
            return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos);
        } : this.matches = function(reverse, pos) {
            return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos);
        });
    }
    noFold = String.prototype.normalize ? (doFold = function(str) {
        return str.normalize("NFD").toLowerCase();
    }, function(str) {
        return str.normalize("NFD");
    }) : (doFold = function(str) {
        return str.toLowerCase();
    }, function(str) {
        return str;
    }), SearchCursor.prototype = {
        findNext: function() {
            return this.find(!1);
        },
        findPrevious: function() {
            return this.find(!0);
        },
        find: function(reverse) {
            for (var end, result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to)); result && 0 == CodeMirror.cmpPos(result.from, result.to); ) reverse ? result.from.ch ? result.from = Pos(result.from.line, result.from.ch - 1) : result = result.from.line == this.doc.firstLine() ? null : this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1))) : result.to.ch < this.doc.getLine(result.to.line).length ? result.to = Pos(result.to.line, result.to.ch + 1) : result = result.to.line == this.doc.lastLine() ? null : this.matches(reverse, Pos(result.to.line + 1, 0));
            return result ? (this.pos = result, this.atOccurrence = !0, this.pos.match || !0) : (end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0), 
            this.pos = {
                from: end,
                to: end
            }, this.atOccurrence = !1);
        },
        from: function() {
            if (this.atOccurrence) return this.pos.from;
        },
        to: function() {
            if (this.atOccurrence) return this.pos.to;
        },
        replace: function(newText, origin) {
            this.atOccurrence && (newText = CodeMirror.splitLines(newText), this.doc.replaceRange(newText, this.pos.from, this.pos.to, origin), 
            this.pos.to = Pos(this.pos.from.line + newText.length - 1, newText[newText.length - 1].length + (1 == newText.length ? this.pos.from.ch : 0)));
        }
    }, CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this.doc, query, pos, caseFold);
    }), CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this, query, pos, caseFold);
    }), CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
        for (var ranges = [], cur = this.getSearchCursor(query, this.getCursor("from"), caseFold); cur.findNext() && !(0 < CodeMirror.cmpPos(cur.to(), this.getCursor("to"))); ) ranges.push({
            anchor: cur.from(),
            head: cur.to()
        });
        ranges.length && this.setSelections(ranges, 0);
    });
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function Annotation(cm, options) {
        function scheduleRedraw(delay) {
            clearTimeout(self.doRedraw), self.doRedraw = setTimeout(function() {
                self.redraw();
            }, delay);
        }
        this.cm = cm, this.options = options, this.buttonHeight = options.scrollButtonHeight || cm.getOption("scrollButtonHeight"), 
        this.annotations = [], this.doRedraw = this.doUpdate = null, this.div = cm.getWrapperElement().appendChild(document.createElement("div")), 
        this.div.style.cssText = "position: absolute; right: 0; top: 0; z-index: 7; pointer-events: none", 
        this.computeScale();
        var self = this;
        cm.on("refresh", this.resizeHandler = function() {
            clearTimeout(self.doUpdate), self.doUpdate = setTimeout(function() {
                self.computeScale() && scheduleRedraw(20);
            }, 100);
        }), cm.on("markerAdded", this.resizeHandler), cm.on("markerCleared", this.resizeHandler), 
        !1 !== options.listenForChanges && cm.on("change", this.changeHandler = function() {
            scheduleRedraw(250);
        });
    }
    CodeMirror.defineExtension("annotateScrollbar", function(options) {
        return new Annotation(this, options = "string" == typeof options ? {
            className: options
        } : options);
    }), CodeMirror.defineOption("scrollButtonHeight", 0), Annotation.prototype.computeScale = function() {
        var cm = this.cm, cm = (cm.getWrapperElement().clientHeight - cm.display.barHeight - 2 * this.buttonHeight) / cm.getScrollerElement().scrollHeight;
        if (cm != this.hScale) return this.hScale = cm, !0;
    }, Annotation.prototype.update = function(annotations) {
        this.annotations = annotations, this.redraw();
    }, Annotation.prototype.redraw = function(compute) {
        !1 !== compute && this.computeScale();
        var cm = this.cm, hScale = this.hScale, frag = document.createDocumentFragment(), anns = this.annotations, wrapping = cm.getOption("lineWrapping"), singleLineH = wrapping && 1.5 * cm.defaultTextHeight(), curLine = null, curLineObj = null;
        function getY(pos, top) {
            return curLine != pos.line && (curLine = pos.line, curLineObj = cm.getLineHandle(curLine)), 
            curLineObj.widgets && curLineObj.widgets.length || wrapping && curLineObj.height > singleLineH ? cm.charCoords(pos, "local")[top ? "top" : "bottom"] : cm.heightAtLine(curLineObj, "local") + (top ? 0 : curLineObj.height);
        }
        var lastLine = cm.lastLine();
        if (cm.display.barWidth) for (var nextTop, i = 0; i < anns.length; i++) {
            var ann = anns[i];
            if (!(ann.to.line > lastLine)) {
                for (var height, elt, top = nextTop || getY(ann.from, !0) * hScale, bottom = getY(ann.to, !1) * hScale; i < anns.length - 1 && !(anns[i + 1].to.line > lastLine) && !(bottom + .9 < (nextTop = getY(anns[i + 1].from, !0) * hScale)); ) bottom = getY((ann = anns[++i]).to, !1) * hScale;
                bottom != top && (height = Math.max(bottom - top, 3), (elt = frag.appendChild(document.createElement("div"))).style.cssText = "position: absolute; right: 0px; width: " + Math.max(cm.display.barWidth - 1, 2) + "px; top: " + (top + this.buttonHeight) + "px; height: " + height + "px", 
                elt.className = this.options.className, ann.id && elt.setAttribute("annotation-id", ann.id));
            }
        }
        this.div.textContent = "", this.div.appendChild(frag);
    }, Annotation.prototype.clear = function() {
        this.cm.off("refresh", this.resizeHandler), this.cm.off("markerAdded", this.resizeHandler), 
        this.cm.off("markerCleared", this.resizeHandler), this.changeHandler && this.cm.off("change", this.changeHandler), 
        this.div.parentNode.removeChild(this.div);
    };
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("./searchcursor"), require("../scroll/annotatescrollbar")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror", "./searchcursor", "../scroll/annotatescrollbar" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function SearchAnnotation(cm, query, caseFold, options) {
        this.cm = cm;
        var prop, annotateOptions = {
            listenForChanges: !1
        };
        for (prop in this.options = options) annotateOptions[prop] = options[prop];
        annotateOptions.className || (annotateOptions.className = "CodeMirror-search-match"), 
        this.annotation = cm.annotateScrollbar(annotateOptions), this.query = query, 
        this.caseFold = caseFold, this.gap = {
            from: cm.firstLine(),
            to: cm.lastLine() + 1
        }, this.matches = [], this.update = null, this.findMatches(), this.annotation.update(this.matches);
        var self = this;
        cm.on("change", this.changeHandler = function(_cm, change) {
            self.onChange(change);
        });
    }
    CodeMirror.defineExtension("showMatchesOnScrollbar", function(query, caseFold, options) {
        return new SearchAnnotation(this, query, caseFold, options = (options = "string" == typeof options ? {
            className: options
        } : options) || {});
    });
    function offsetLine(line, changeStart, sizeChange) {
        return line <= changeStart ? line : Math.max(changeStart, line + sizeChange);
    }
    SearchAnnotation.prototype.findMatches = function() {
        if (this.gap) {
            for (var i = 0; i < this.matches.length; i++) {
                if ((match = this.matches[i]).from.line >= this.gap.to) break;
                match.to.line >= this.gap.from && this.matches.splice(i--, 1);
            }
            for (var match, cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold), maxMatches = this.options && this.options.maxMatches || 1e3; cursor.findNext(); ) {
                if ((match = {
                    from: cursor.from(),
                    to: cursor.to()
                }).from.line >= this.gap.to) break;
                if (this.matches.splice(i++, 0, match), this.matches.length > maxMatches) break;
            }
            this.gap = null;
        }
    }, SearchAnnotation.prototype.onChange = function(change) {
        var startLine = change.from.line, endLine = CodeMirror.changeEnd(change).line, sizeChange = endLine - change.to.line;
        if (this.gap ? (this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line), 
        this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line)) : this.gap = {
            from: change.from.line,
            to: endLine + 1
        }, sizeChange) for (var i = 0; i < this.matches.length; i++) {
            var match = this.matches[i], newFrom = offsetLine(match.from.line, startLine, sizeChange), newFrom = (newFrom != match.from.line && (match.from = CodeMirror.Pos(newFrom, match.from.ch)), 
            offsetLine(match.to.line, startLine, sizeChange));
            newFrom != match.to.line && (match.to = CodeMirror.Pos(newFrom, match.to.ch));
        }
        clearTimeout(this.update);
        var self = this;
        this.update = setTimeout(function() {
            self.updateAfterChange();
        }, 250);
    }, SearchAnnotation.prototype.updateAfterChange = function() {
        this.findMatches(), this.annotation.update(this.matches);
    }, SearchAnnotation.prototype.clear = function() {
        this.cm.off("change", this.changeHandler), this.annotation.clear();
    };
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("../dialog/dialog")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror", "../dialog/dialog" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function interpretLine(cm, string) {
        var num = Number(string);
        return /^[-+]/.test(string) ? cm.getCursor().line + num : num - 1;
    }
    CodeMirror.commands.jumpToLine = function(cm) {
        var cur = cm.getCursor();
        !function(cm, text, shortText, deflt, f) {
            cm.openDialog ? cm.openDialog(text, f, {
                value: deflt,
                selectValueOnOpen: !0
            }) : f(prompt(shortText, deflt));
        }(cm, 'Jump to line: <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use line:column or scroll% syntax)</span>', "Jump to line:", cur.line + 1 + ":" + cur.ch, function(posStr) {
            var match, line;
            posStr && ((match = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr)) ? cm.setCursor(interpretLine(cm, match[1]), Number(match[2])) : (match = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr)) ? (line = Math.round(cm.lineCount() * Number(match[1]) / 100), 
            /^[-+]/.test(match[1]) && (line = cur.line + line + 1), cm.setCursor(line - 1, cur.ch)) : (match = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) && cm.setCursor(interpretLine(cm, match[1]), cur.ch));
        });
    }, CodeMirror.keyMap.default["Alt-G"] = "jumpToLine";
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("./matchesonscrollbar")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror", "./matchesonscrollbar" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    var defaults = {
        style: "matchhighlight",
        minChars: 2,
        delay: 100,
        wordsOnly: !1,
        annotateScrollbar: !1,
        showToken: !1,
        trim: !0
    };
    function State(options) {
        for (var name in this.options = {}, defaults) this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name];
        this.overlay = this.timeout = null, this.matchesonscroll = null, this.active = !1;
    }
    function cursorActivity(cm) {
        var state = cm.state.matchHighlighter;
        (state.active || cm.hasFocus()) && scheduleHighlight(cm, state);
    }
    function onFocus(cm) {
        var state = cm.state.matchHighlighter;
        state.active || (state.active = !0, scheduleHighlight(cm, state));
    }
    function scheduleHighlight(cm, state) {
        clearTimeout(state.timeout), state.timeout = setTimeout(function() {
            highlightMatches(cm);
        }, state.options.delay);
    }
    function addOverlay(cm, query, hasBoundary, style) {
        var state = cm.state.matchHighlighter;
        cm.addOverlay(state.overlay = function(query, hasBoundary, style) {
            return {
                token: function(stream) {
                    if (stream.match(query) && (!hasBoundary || function(stream, re) {
                        return !(stream.start && re.test(stream.string.charAt(stream.start - 1)) || stream.pos != stream.string.length && re.test(stream.string.charAt(stream.pos)));
                    }(stream, hasBoundary))) return style;
                    stream.next(), stream.skipTo(query.charAt(0)) || stream.skipToEnd();
                }
            };
        }(query, hasBoundary, style)), state.options.annotateScrollbar && cm.showMatchesOnScrollbar && (style = hasBoundary ? new RegExp("\\b" + query + "\\b") : query, 
        state.matchesonscroll = cm.showMatchesOnScrollbar(style, !1, {
            className: "CodeMirror-selection-highlight-scrollbar"
        }));
    }
    function removeOverlay(cm) {
        var state = cm.state.matchHighlighter;
        state.overlay && (cm.removeOverlay(state.overlay), state.overlay = null, 
        state.matchesonscroll && (state.matchesonscroll.clear(), state.matchesonscroll = null));
    }
    function highlightMatches(cm) {
        cm.operation(function() {
            var state = cm.state.matchHighlighter;
            if (removeOverlay(cm), !cm.somethingSelected() && state.options.showToken) {
                for (var re = !0 === state.options.showToken ? /[\w$]/ : state.options.showToken, cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start; start && re.test(line.charAt(start - 1)); ) --start;
                for (;end < line.length && re.test(line.charAt(end)); ) ++end;
                start < end && addOverlay(cm, line.slice(start, end), re, state.options.style);
            } else {
                var cur = cm.getCursor("from"), to = cm.getCursor("to");
                cur.line != to.line || state.options.wordsOnly && !function(cm, from, to) {
                    if (null !== cm.getRange(from, to).match(/^\w+$/)) {
                        if (0 < from.ch) {
                            var pos = {
                                line: from.line,
                                ch: from.ch - 1
                            };
                            if (null === cm.getRange(pos, from).match(/\W/)) return;
                        }
                        if (to.ch < cm.getLine(from.line).length) {
                            pos = {
                                line: to.line,
                                ch: to.ch + 1
                            };
                            if (null === cm.getRange(to, pos).match(/\W/)) return;
                        }
                        return 1;
                    }
                }(cm, cur, to) || (cur = cm.getRange(cur, to), (cur = state.options.trim ? cur.replace(/^\s+|\s+$/g, "") : cur).length >= state.options.minChars && addOverlay(cm, cur, !1, state.options.style));
            }
        });
    }
    CodeMirror.defineOption("highlightSelectionMatches", !1, function(cm, val, old) {
        old && old != CodeMirror.Init && (removeOverlay(cm), clearTimeout(cm.state.matchHighlighter.timeout), 
        cm.state.matchHighlighter = null, cm.off("cursorActivity", cursorActivity), 
        cm.off("focus", onFocus)), val && (old = cm.state.matchHighlighter = new State(val), 
        cm.hasFocus() ? (old.active = !0, highlightMatches(cm)) : cm.on("focus", onFocus), 
        cm.on("cursorActivity", cursorActivity));
    });
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function doFold(cm, pos, options, force) {
        options && options.call ? (finder = options, options = null) : finder = getOption(cm, options, "rangeFinder"), 
        "number" == typeof pos && (pos = CodeMirror.Pos(pos, 0));
        var finder, minSize = getOption(cm, options, "minFoldSize");
        function getRange(allowFolded) {
            var range = finder(cm, pos);
            if (!range || range.to.line - range.from.line < minSize) return null;
            for (var marks = cm.findMarksAt(range.from), i = 0; i < marks.length; ++i) if (marks[i].__isFold && "fold" !== force) {
                if (!allowFolded) return null;
                range.cleared = !0, marks[i].clear();
            }
            return range;
        }
        var myWidget, myRange, range = getRange(!0);
        if (getOption(cm, options, "scanUp")) for (;!range && pos.line > cm.firstLine(); ) pos = CodeMirror.Pos(pos.line - 1, 0), 
        range = getRange(!1);
        range && !range.cleared && "unfold" !== force && (myWidget = function(cm, options) {
            cm = getOption(cm, options, "widget");
            "string" == typeof cm ? (options = document.createTextNode(cm), (cm = document.createElement("span")).appendChild(options), 
            cm.className = "CodeMirror-foldmarker") : cm = cm && cm.cloneNode(!0);
            return cm;
        }(cm, options), CodeMirror.on(myWidget, "mousedown", function(e) {
            myRange.clear(), CodeMirror.e_preventDefault(e);
        }), (myRange = cm.markText(range.from, range.to, {
            replacedWith: myWidget,
            clearOnEnter: getOption(cm, options, "clearOnEnter"),
            __isFold: !0
        })).on("clear", function(from, to) {
            CodeMirror.signal(cm, "unfold", cm, from, to);
        }), CodeMirror.signal(cm, "fold", cm, range.from, range.to));
    }
    CodeMirror.newFoldFunction = function(rangeFinder, widget) {
        return function(cm, pos) {
            doFold(cm, pos, {
                rangeFinder: rangeFinder,
                widget: widget
            });
        };
    }, CodeMirror.defineExtension("foldCode", function(pos, options, force) {
        doFold(this, pos, options, force);
    }), CodeMirror.defineExtension("isFolded", function(pos) {
        for (var marks = this.findMarksAt(pos), i = 0; i < marks.length; ++i) if (marks[i].__isFold) return !0;
    }), CodeMirror.commands.toggleFold = function(cm) {
        cm.foldCode(cm.getCursor());
    }, CodeMirror.commands.fold = function(cm) {
        cm.foldCode(cm.getCursor(), null, "fold");
    }, CodeMirror.commands.unfold = function(cm) {
        cm.foldCode(cm.getCursor(), null, "unfold");
    }, CodeMirror.commands.foldAll = function(cm) {
        cm.operation(function() {
            for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");
        });
    }, CodeMirror.commands.unfoldAll = function(cm) {
        cm.operation(function() {
            for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");
        });
    }, CodeMirror.registerHelper("fold", "combine", function() {
        var funcs = Array.prototype.slice.call(arguments, 0);
        return function(cm, start) {
            for (var i = 0; i < funcs.length; ++i) {
                var found = funcs[i](cm, start);
                if (found) return found;
            }
        };
    }), CodeMirror.registerHelper("fold", "auto", function(cm, start) {
        for (var helpers = cm.getHelpers(start, "fold"), i = 0; i < helpers.length; i++) {
            var cur = helpers[i](cm, start);
            if (cur) return cur;
        }
    });
    var defaultOptions = {
        rangeFinder: CodeMirror.fold.auto,
        widget: "",
        minFoldSize: 0,
        scanUp: !1,
        clearOnEnter: !0
    };
    function getOption(cm, options, name) {
        return (options && void 0 !== options[name] || (options = cm.options.foldOptions) && void 0 !== options[name] ? options : defaultOptions)[name];
    }
    CodeMirror.defineOption("foldOptions", null), CodeMirror.defineExtension("foldOption", function(options, name) {
        return getOption(this, options, name);
    });
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("./foldcode")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror", "./foldcode" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineOption("foldGutter", !1, function(cm, val, old) {
        old && old != CodeMirror.Init && (cm.clearGutter(cm.state.foldGutter.options.gutter), 
        cm.state.foldGutter = null, cm.off("gutterClick", onGutterClick), cm.off("change", onChange), 
        cm.off("viewportChange", onViewportChange), cm.off("fold", onFold), cm.off("unfold", onFold), 
        cm.off("swapDoc", onChange)), val && (cm.state.foldGutter = new State(function(opts) {
            !0 === opts && (opts = {});
            null == opts.gutter && (opts.gutter = "CodeMirror-foldgutter");
            null == opts.indicatorOpen && (opts.indicatorOpen = "CodeMirror-foldgutter-open");
            null == opts.indicatorFolded && (opts.indicatorFolded = "CodeMirror-foldgutter-folded");
            return opts;
        }(val)), updateInViewport(cm), cm.on("gutterClick", onGutterClick), cm.on("change", onChange), 
        cm.on("viewportChange", onViewportChange), cm.on("fold", onFold), cm.on("unfold", onFold), 
        cm.on("swapDoc", onChange));
    });
    var Pos = CodeMirror.Pos;
    function State(options) {
        this.options = options, this.from = this.to = 0;
    }
    function isFolded(cm, line) {
        for (var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0)), i = 0; i < marks.length; ++i) if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];
    }
    function marker(spec) {
        var elt;
        return "string" == typeof spec ? ((elt = document.createElement("div")).className = spec + " CodeMirror-guttermarker-subtle", 
        elt) : spec.cloneNode(!0);
    }
    function updateFoldInfo(cm, from, to) {
        var opts = cm.state.foldGutter.options, cur = from, minSize = cm.foldOption(opts, "minFoldSize"), func = cm.foldOption(opts, "rangeFinder");
        cm.eachLine(from, to, function(line) {
            var pos, mark = null;
            isFolded(cm, cur) ? mark = marker(opts.indicatorFolded) : (pos = Pos(cur, 0), 
            (pos = func && func(cm, pos)) && pos.to.line - pos.from.line >= minSize && (mark = marker(opts.indicatorOpen))), 
            cm.setGutterMarker(line, opts.gutter, mark), ++cur;
        });
    }
    function updateInViewport(cm) {
        var vp = cm.getViewport(), state = cm.state.foldGutter;
        state && (cm.operation(function() {
            updateFoldInfo(cm, vp.from, vp.to);
        }), state.from = vp.from, state.to = vp.to);
    }
    function onGutterClick(cm, line, gutter) {
        var state = cm.state.foldGutter;
        !state || gutter == (gutter = state.options).gutter && ((state = isFolded(cm, line)) ? state.clear() : cm.foldCode(Pos(line, 0), gutter.rangeFinder));
    }
    function onChange(cm) {
        var opts, state = cm.state.foldGutter;
        state && (opts = state.options, state.from = state.to = 0, clearTimeout(state.changeUpdate), 
        state.changeUpdate = setTimeout(function() {
            updateInViewport(cm);
        }, opts.foldOnChangeTimeSpan || 600));
    }
    function onViewportChange(cm) {
        var opts, state = cm.state.foldGutter;
        state && (opts = state.options, clearTimeout(state.changeUpdate), state.changeUpdate = setTimeout(function() {
            var vp = cm.getViewport();
            state.from == state.to || 20 < vp.from - state.to || 20 < state.from - vp.to ? updateInViewport(cm) : cm.operation(function() {
                vp.from < state.from && (updateFoldInfo(cm, vp.from, state.from), 
                state.from = vp.from), vp.to > state.to && (updateFoldInfo(cm, state.to, vp.to), 
                state.to = vp.to);
            });
        }, opts.updateViewportTimeSpan || 400));
    }
    function onFold(cm, from) {
        var state = cm.state.foldGutter;
        !state || (from = from.line) >= state.from && from < state.to && updateFoldInfo(cm, from, from + 1);
    }
}), !function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function lineIndent(cm, lineNo) {
        var text = cm.getLine(lineNo), spaceTo = text.search(/\S/);
        return -1 == spaceTo || /\bcomment\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))) ? -1 : CodeMirror.countColumn(text, null, cm.getOption("tabSize"));
    }
    CodeMirror.registerHelper("fold", "indent", function(cm, start) {
        var myIndent = lineIndent(cm, start.line);
        if (!(myIndent < 0)) {
            for (var lastLineInFold = null, i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {
                var indent = lineIndent(cm, i);
                if (-1 != indent) {
                    if (!(myIndent < indent)) break;
                    lastLineInFold = i;
                }
            }
            return lastLineInFold ? {
                from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),
                to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)
            } : void 0;
        }
    });
}), !function(a, b) {
    "use strict";
    "function" == typeof define && define.amd ? define([ "jquery" ], b) : "object" == typeof exports ? module.exports = b(require("jquery")) : a.bootbox = b(a.jQuery);
}(this, function a(b, c) {
    "use strict";
    function e(a, c, d) {
        a.stopPropagation(), a.preventDefault(), b.isFunction(d) && !1 === d(a) || c.modal("hide");
    }
    function g(a, c) {
        var d = 0;
        b.each(a, function(a, b) {
            c(a, b, d++);
        });
    }
    function h(a) {
        var c, d;
        if ("object" != typeof a) throw new Error("Please supply an object of options");
        if (a.message) return (a = b.extend({}, o, a)).buttons || (a.buttons = {}), 
        a.backdrop = !!a.backdrop && "static", c = a.buttons, d = function(a) {
            var b, c = 0;
            for (b in a) c++;
            return c;
        }(c), g(c, function(a, e, f) {
            if (b.isFunction(e) && (e = c[a] = {
                callback: e
            }), "object" !== b.type(e)) throw new Error("button with key " + a + " must be an object");
            e.label || (e.label = a), e.className || (e.className = d <= 2 && f === d - 1 ? "btn-primary" : "btn-default");
        }), a;
        throw new Error("Please specify a message");
    }
    function j(a, c, d) {
        return b.extend(!0, {}, a, function(a, b) {
            var c = a.length, d = {};
            if (c < 1 || 2 < c) throw new Error("Invalid argument length");
            return 2 === c || "string" == typeof a[0] ? (d[b[0]] = a[0], d[b[1]] = a[1]) : d = a[0], 
            d;
        }(c, d));
    }
    function k(a, b, c, d) {
        return m(j({
            className: "bootbox-" + a,
            buttons: l.apply(null, b)
        }, d, c), b);
    }
    function l() {
        for (var a = {}, b = 0, c = arguments.length; b < c; b++) {
            var e = arguments[b], f = e.toLowerCase(), e = e.toUpperCase();
            a[f] = {
                label: function(a) {
                    var b = q[o.locale];
                    return (b || q.en)[a];
                }(e)
            };
        }
        return a;
    }
    function m(a, b) {
        var d = {};
        return g(b, function(a, b) {
            d[b] = !0;
        }), g(a.buttons, function(a) {
            if (d[a] === c) throw new Error("button key " + a + " is not allowed (options are " + b.join("\n") + ")");
        }), a;
    }
    var n = {
        dialog: "<div class='bootbox modal' tabindex='-1' role='dialog'><div class='modal-dialog'><div class='modal-content'><div class='modal-body'><div class='bootbox-body'></div></div></div></div></div>",
        header: "<div class='modal-header'><h4 class='modal-title'></h4></div>",
        footer: "<div class='modal-footer'></div>",
        closeButton: "<button type='button' class='bootbox-close-button close' data-dismiss='modal' aria-hidden='true'>&times;</button>",
        form: "<form class='bootbox-form'></form>",
        inputs: {
            text: "<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text />",
            textarea: "<textarea class='bootbox-input bootbox-input-textarea form-control'></textarea>",
            email: "<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' />",
            select: "<select class='bootbox-input bootbox-input-select form-control'></select>",
            checkbox: "<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' /></label></div>",
            date: "<input class='bootbox-input bootbox-input-date form-control' autocomplete=off type='date' />",
            time: "<input class='bootbox-input bootbox-input-time form-control' autocomplete=off type='time' />",
            number: "<input class='bootbox-input bootbox-input-number form-control' autocomplete=off type='number' />",
            password: "<input class='bootbox-input bootbox-input-password form-control' autocomplete='off' type='password' />"
        }
    }, o = {
        locale: "en",
        backdrop: !0,
        animate: !0,
        className: null,
        closeButton: !0,
        show: !0,
        container: "body"
    }, p = {
        alert: function() {
            var a = k("alert", [ "ok" ], [ "message", "callback" ], arguments);
            if (a.callback && !b.isFunction(a.callback)) throw new Error("alert requires callback property to be a function when provided");
            return a.buttons.ok.callback = a.onEscape = function() {
                return !b.isFunction(a.callback) || a.callback();
            }, p.dialog(a);
        },
        confirm: function() {
            var a = k("confirm", [ "cancel", "confirm" ], [ "message", "callback" ], arguments);
            if (a.buttons.cancel.callback = a.onEscape = function() {
                return a.callback(!1);
            }, a.buttons.confirm.callback = function() {
                return a.callback(!0);
            }, b.isFunction(a.callback)) return p.dialog(a);
            throw new Error("confirm requires a callback");
        },
        prompt: function() {
            var e, h, f = b(n.form), a = m(j({
                className: "bootbox-prompt",
                buttons: l("cancel", "confirm"),
                value: "",
                inputType: "text"
            }, arguments, [ "title", "callback" ]), [ "cancel", "confirm" ]), i = a.show === c || a.show, q = document.createElement("input");
            if (q.setAttribute("type", a.inputType), [ "date", "time", "number" ][a.inputType] && (a.inputType = q.type), 
            a.message = f, a.buttons.cancel.callback = a.onEscape = function() {
                return a.callback(null);
            }, a.buttons.confirm.callback = function() {
                switch (a.inputType) {
                  case "text":
                  case "textarea":
                  case "email":
                  case "select":
                  case "date":
                  case "time":
                  case "number":
                  case "password":
                    c = h.val();
                    break;

                  case "checkbox":
                    var d = h.find("input:checked"), c = [];
                    g(d, function(a, d) {
                        c.push(b(d).val());
                    });
                }
                return a.callback(c);
            }, a.show = !1, !a.title) throw new Error("prompt requires a title");
            if (!b.isFunction(a.callback)) throw new Error("prompt requires a callback");
            if (!n.inputs[a.inputType]) throw new Error("invalid prompt type");
            switch (h = b(n.inputs[a.inputType]), a.inputType) {
              case "text":
              case "textarea":
              case "email":
              case "date":
              case "time":
              case "number":
              case "password":
                h.val(a.value);
                break;

              case "select":
                var k, r = {};
                if (!(k = a.inputOptions || []).length) throw new Error("prompt with select requires options");
                g(k, function(a, d) {
                    var e = h;
                    if (d.value === c || d.text === c) throw new Error("given options in wrong format");
                    d.group && (r[d.group] || (r[d.group] = b("<optgroup/>").attr("label", d.group)), 
                    e = r[d.group]), e.append("<option value='" + d.value + "'>" + d.text + "</option>");
                }), g(r, function(a, b) {
                    h.append(b);
                }), h.val(a.value);
                break;

              case "checkbox":
                var s = b.isArray(a.value) ? a.value : [ a.value ];
                if (!(k = a.inputOptions || []).length) throw new Error("prompt with checkbox requires options");
                if (!k[0].value || !k[0].text) throw new Error("given options in wrong format");
                h = b("<div/>"), g(k, function(c, d) {
                    var e = b(n.inputs[a.inputType]);
                    e.find("input").attr("value", d.value), e.find("label").append(d.text), 
                    g(s, function(a, b) {
                        b === d.value && e.find("input").prop("checked", !0);
                    }), h.append(e);
                });
            }
            return a.placeholder && h.attr("placeholder", a.placeholder), a.pattern && h.attr("pattern", a.pattern), 
            f.append(h), f.on("submit", function(a) {
                a.preventDefault(), e.find(".btn-primary").click();
            }), (e = p.dialog(a)).off("shown.bs.modal"), e.on("shown.bs.modal", function() {
                h.focus();
            }), !0 === i && e.modal("show"), e;
        },
        dialog: function(a) {
            a = h(a);
            var c = b(n.dialog), d = c.find(".modal-body"), f = a.buttons, i = "", j = {
                onEscape: a.onEscape
            };
            return g(f, function(a, b) {
                i += "<button data-bb-handler='" + a + "' type='button' class='btn " + b.className + "'>" + b.label + "</button>", 
                j[a] = b.callback;
            }), d.find(".bootbox-body").html(a.message), !0 === a.animate && c.addClass("fade"), 
            a.className && c.addClass(a.className), a.title && d.before(n.header), 
            a.closeButton && (f = b(n.closeButton), a.title ? c.find(".modal-header").prepend(f) : f.css("margin-top", "-10px").prependTo(d)), 
            a.title && c.find(".modal-title").html(a.title), i.length && (d.after(n.footer), 
            c.find(".modal-footer").html(i)), c.on("hidden.bs.modal", function(a) {
                a.target === this && c.remove();
            }), c.on("shown.bs.modal", function() {
                c.find(".btn-primary:first").focus();
            }), c.on("escape.close.bb", function(a) {
                j.onEscape && e(a, c, j.onEscape);
            }), c.on("click", ".modal-footer button", function(a) {
                var d = b(this).data("bb-handler");
                e(a, c, j[d]);
            }), c.on("click", ".bootbox-close-button", function(a) {
                e(a, c, j.onEscape);
            }), c.on("keyup", function(a) {
                27 === a.which && c.trigger("escape.close.bb");
            }), b(a.container).append(c), c.modal({
                backdrop: a.backdrop,
                keyboard: !1,
                show: !1
            }), a.show && c.modal("show"), c;
        },
        setDefaults: function() {
            var a = {};
            2 === arguments.length ? a[arguments[0]] = arguments[1] : a = arguments[0], 
            b.extend(o, a);
        },
        hideAll: function() {
            b(".bootbox").modal("hide");
        }
    }, q = {
        br: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Sim"
        },
        da: {
            OK: "OK",
            CANCEL: "Annuller",
            CONFIRM: "Accepter"
        },
        de: {
            OK: "OK",
            CANCEL: "Abbrechen",
            CONFIRM: "Akzeptieren"
        },
        en: {
            OK: "OK",
            CANCEL: "Cancel",
            CONFIRM: "OK"
        },
        es: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Aceptar"
        },
        fi: {
            OK: "OK",
            CANCEL: "Peruuta",
            CONFIRM: "OK"
        },
        fr: {
            OK: "OK",
            CANCEL: "Annuler",
            CONFIRM: "D'accord"
        },
        he: {
            OK: "",
            CANCEL: "",
            CONFIRM: ""
        },
        it: {
            OK: "OK",
            CANCEL: "Annulla",
            CONFIRM: "Conferma"
        },
        lt: {
            OK: "Gerai",
            CANCEL: "Ataukti",
            CONFIRM: "Patvirtinti"
        },
        lv: {
            OK: "Labi",
            CANCEL: "Atcelt",
            CONFIRM: "Apstiprint"
        },
        nl: {
            OK: "OK",
            CANCEL: "Annuleren",
            CONFIRM: "Accepteren"
        },
        no: {
            OK: "OK",
            CANCEL: "Avbryt",
            CONFIRM: "OK"
        },
        pl: {
            OK: "OK",
            CANCEL: "Anuluj",
            CONFIRM: "Potwierd"
        },
        ru: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        },
        sv: {
            OK: "OK",
            CANCEL: "Avbryt",
            CONFIRM: "OK"
        },
        tr: {
            OK: "Tamam",
            CANCEL: "ptal",
            CONFIRM: "Onayla"
        },
        zh_CN: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        },
        zh_TW: {
            OK: "OK",
            CANCEL: "",
            CONFIRM: ""
        }
    };
    return p.init = function(c) {
        return a(c || b);
    }, p;
}), "undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");

!function(a) {
    "use strict";
    a.fn.emulateTransitionEnd = function(b) {
        var c = !1, d = this;
        a(this).one(a.support.transition.end, function() {
            c = !0;
        });
        return setTimeout(function() {
            c || a(d).trigger(a.support.transition.end);
        }, b), this;
    }, a(function() {
        a.support.transition = function() {
            var c, a = document.createElement("bootstrap"), b = {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd otransitionend",
                transition: "transitionend"
            };
            for (c in b) if (void 0 !== a.style[c]) return {
                end: b[c]
            };
            return !1;
        }();
    });
}(jQuery), function(a) {
    "use strict";
    function c(c) {
        a(c).on("click", b, this.close);
    }
    var b = '[data-dismiss="alert"]', d = (c.prototype.close = function(b) {
        function c() {
            f.trigger("closed.bs.alert").remove();
        }
        var d = a(this), e = d.attr("data-target"), f = (e || (e = (e = d.attr("href")) && e.replace(/.*(?=#[^\s]*$)/, "")), 
        a(e));
        b && b.preventDefault(), (f = f.length ? f : d.hasClass("alert") ? d : d.parent()).trigger(b = a.Event("close.bs.alert")), 
        b.isDefaultPrevented() || (f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one(a.support.transition.end, c).emulateTransitionEnd(150) : c());
    }, a.fn.alert);
    a.fn.alert = function(b) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.alert");
            e || d.data("bs.alert", e = new c(this)), "string" == typeof b && e[b].call(d);
        });
    }, a.fn.alert.Constructor = c, a.fn.alert.noConflict = function() {
        return a.fn.alert = d, this;
    }, a(document).on("click.bs.alert.data-api", b, c.prototype.close);
}(jQuery), function(a) {
    "use strict";
    function b(c, d) {
        this.$element = a(c), this.options = a.extend({}, b.DEFAULTS, d), this.isLoading = !1;
    }
    b.DEFAULTS = {
        loadingText: "loading..."
    }, b.prototype.setState = function(b) {
        var c = "disabled", d = this.$element, e = d.is("input") ? "val" : "html", f = d.data();
        b += "Text", f.resetText || d.data("resetText", d[e]()), d[e](f[b] || this.options[b]), 
        setTimeout(a.proxy(function() {
            "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, 
            d.removeClass(c).removeAttr(c));
        }, this), 0);
    }, b.prototype.toggle = function() {
        var c, a = !0, b = this.$element.closest('[data-toggle="buttons"]');
        b.length && ("radio" == (c = this.$element.find("input")).prop("type") && (c.prop("checked") && this.$element.hasClass("active") ? a = !1 : b.find(".active").removeClass("active")), 
        a && c.prop("checked", !this.$element.hasClass("active")).trigger("change")), 
        a && this.$element.toggleClass("active");
    };
    var c = a.fn.button;
    a.fn.button = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.button");
            e || d.data("bs.button", e = new b(this, "object" == typeof c && c)), 
            "toggle" == c ? e.toggle() : c && e.setState(c);
        });
    }, a.fn.button.Constructor = b, a.fn.button.noConflict = function() {
        return a.fn.button = c, this;
    }, a(document).on("click.bs.button.data-api", "[data-toggle^=button]", function(b) {
        var c = a(b.target);
        (c = c.hasClass("btn") ? c : c.closest(".btn")).button("toggle"), b.preventDefault();
    });
}(jQuery), function(a) {
    "use strict";
    function b(b, c) {
        this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), 
        this.options = c, this.paused = this.sliding = this.interval = this.$active = this.$items = null, 
        "hover" == this.options.pause && this.$element.on("mouseenter", a.proxy(this.pause, this)).on("mouseleave", a.proxy(this.cycle, this));
    }
    b.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0
    }, b.prototype.cycle = function(b) {
        return b || (this.paused = !1), this.interval && clearInterval(this.interval), 
        this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), 
        this;
    }, b.prototype.getActiveIndex = function() {
        return this.$active = this.$element.find(".item.active"), this.$items = this.$active.parent().children(), 
        this.$items.index(this.$active);
    }, b.prototype.to = function(b) {
        var c = this, d = this.getActiveIndex();
        return b > this.$items.length - 1 || b < 0 ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function() {
            c.to(b);
        }) : d == b ? this.pause().cycle() : this.slide(d < b ? "next" : "prev", a(this.$items[b]));
    }, b.prototype.pause = function(b) {
        return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), 
        this.cycle(!0)), this.interval = clearInterval(this.interval), this;
    }, b.prototype.next = function() {
        return this.sliding ? void 0 : this.slide("next");
    }, b.prototype.prev = function() {
        return this.sliding ? void 0 : this.slide("prev");
    }, b.prototype.slide = function(b, c) {
        var d = this.$element.find(".item.active"), e = c || d[b](), c = this.interval, g = "next" == b ? "left" : "right", h = "next" == b ? "first" : "last", i = this;
        if (!e.length) {
            if (!this.options.wrap) return;
            e = this.$element.find(".item")[h]();
        }
        return e.hasClass("active") ? this.sliding = !1 : (h = a.Event("slide.bs.carousel", {
            relatedTarget: e[0],
            direction: g
        }), this.$element.trigger(h), h.isDefaultPrevented() ? void 0 : (this.sliding = !0, 
        c && this.pause(), this.$indicators.length && (this.$indicators.find(".active").removeClass("active"), 
        this.$element.one("slid.bs.carousel", function() {
            var b = a(i.$indicators.children()[i.getActiveIndex()]);
            b && b.addClass("active");
        })), a.support.transition && this.$element.hasClass("slide") ? (e.addClass(b), 
        e[0].offsetWidth, d.addClass(g), e.addClass(g), d.one(a.support.transition.end, function() {
            e.removeClass([ b, g ].join(" ")).addClass("active"), d.removeClass([ "active", g ].join(" ")), 
            i.sliding = !1, setTimeout(function() {
                i.$element.trigger("slid.bs.carousel");
            }, 0);
        }).emulateTransitionEnd(1e3 * d.css("transition-duration").slice(0, -1))) : (d.removeClass("active"), 
        e.addClass("active"), this.sliding = !1, this.$element.trigger("slid.bs.carousel")), 
        c && this.cycle(), this));
    };
    var c = a.fn.carousel;
    a.fn.carousel = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.carousel"), f = a.extend({}, b.DEFAULTS, d.data(), "object" == typeof c && c), g = "string" == typeof c ? c : f.slide;
            e || d.data("bs.carousel", e = new b(this, f)), "number" == typeof c ? e.to(c) : g ? e[g]() : f.interval && e.pause().cycle();
        });
    }, a.fn.carousel.Constructor = b, a.fn.carousel.noConflict = function() {
        return a.fn.carousel = c, this;
    }, a(document).on("click.bs.carousel.data-api", "[data-slide], [data-slide-to]", function(b) {
        var d = a(this), c = a(d.attr("data-target") || (c = d.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, "")), f = a.extend({}, c.data(), d.data());
        d.attr("data-slide-to") && (f.interval = !1), c.carousel(f), (f = d.attr("data-slide-to")) && c.data("bs.carousel").to(f), 
        b.preventDefault();
    }), a(window).on("load", function() {
        a('[data-ride="carousel"]').each(function() {
            var b = a(this);
            b.carousel(b.data());
        });
    });
}(jQuery), function(a) {
    "use strict";
    function b(c, d) {
        this.$element = a(c), this.options = a.extend({}, b.DEFAULTS, d), this.transitioning = null, 
        this.options.parent && (this.$parent = a(this.options.parent)), this.options.toggle && this.toggle();
    }
    b.DEFAULTS = {
        toggle: !0
    }, b.prototype.dimension = function() {
        return this.$element.hasClass("width") ? "width" : "height";
    }, b.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var b = a.Event("show.bs.collapse");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                b = this.$parent && this.$parent.find("> .panel > .in");
                if (b && b.length) {
                    var d = b.data("bs.collapse");
                    if (d && d.transitioning) return;
                    b.collapse("hide"), d || b.data("bs.collapse", null);
                }
                var e = this.dimension(), d = (this.$element.removeClass("collapse").addClass("collapsing")[e](0), 
                this.transitioning = 1, function() {
                    this.$element.removeClass("collapsing").addClass("collapse in")[e]("auto"), 
                    this.transitioning = 0, this.$element.trigger("shown.bs.collapse");
                });
                if (!a.support.transition) return d.call(this);
                b = a.camelCase([ "scroll", e ].join("-"));
                this.$element.one(a.support.transition.end, a.proxy(d, this)).emulateTransitionEnd(350)[e](this.$element[0][b]);
            }
        }
    }, b.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var d, b = a.Event("hide.bs.collapse");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) return b = this.dimension(), 
            this.$element[b](this.$element[b]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse").removeClass("in"), 
            this.transitioning = 1, d = function() {
                this.transitioning = 0, this.$element.trigger("hidden.bs.collapse").removeClass("collapsing").addClass("collapse");
            }, a.support.transition ? void this.$element[b](0).one(a.support.transition.end, a.proxy(d, this)).emulateTransitionEnd(350) : d.call(this);
        }
    }, b.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    var c = a.fn.collapse;
    a.fn.collapse = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.collapse"), f = a.extend({}, b.DEFAULTS, d.data(), "object" == typeof c && c);
            !e && f.toggle && "show" == c && (c = !c), e || d.data("bs.collapse", e = new b(this, f)), 
            "string" == typeof c && e[c]();
        });
    }, a.fn.collapse.Constructor = b, a.fn.collapse.noConflict = function() {
        return a.fn.collapse = c, this;
    }, a(document).on("click.bs.collapse.data-api", "[data-toggle=collapse]", function(b) {
        var d = a(this), b = d.attr("data-target") || b.preventDefault() || (b = d.attr("href")) && b.replace(/.*(?=#[^\s]+$)/, ""), b = a(b), g = b.data("bs.collapse"), h = g ? "toggle" : d.data(), i = d.attr("data-parent"), j = i && a(i);
        g && g.transitioning || (j && j.find('[data-toggle=collapse][data-parent="' + i + '"]').not(d).addClass("collapsed"), 
        d[b.hasClass("in") ? "addClass" : "removeClass"]("collapsed")), b.collapse(h);
    });
}(jQuery), function(a) {
    "use strict";
    function b(b) {
        a(".dropdown-backdrop").remove(), a(e).each(function() {
            var d = c(a(this)), e = {
                relatedTarget: this
            };
            d.hasClass("open") && (d.trigger(b = a.Event("hide.bs.dropdown", e)), 
            b.isDefaultPrevented() || d.removeClass("open").trigger("hidden.bs.dropdown", e));
        });
    }
    function c(b) {
        var c = b.attr("data-target"), c = (c = c ? c : (c = b.attr("href")) && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, "")) && a(c);
        return c && c.length ? c : b.parent();
    }
    function f(b) {
        a(b).on("click.bs.dropdown", this.toggle);
    }
    var e = "[data-toggle=dropdown]", g = (f.prototype.toggle = function(d) {
        var e = a(this);
        if (!e.is(".disabled, :disabled")) {
            var f = c(e), g = f.hasClass("open");
            if (b(), !g) {
                "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click", b);
                g = {
                    relatedTarget: this
                };
                if (f.trigger(d = a.Event("show.bs.dropdown", g)), d.isDefaultPrevented()) return;
                f.toggleClass("open").trigger("shown.bs.dropdown", g), e.focus();
            }
            return !1;
        }
    }, f.prototype.keydown = function(b) {
        if (/(38|40|27)/.test(b.keyCode)) {
            var d = a(this);
            if (b.preventDefault(), b.stopPropagation(), !d.is(".disabled, :disabled")) {
                var f = c(d), g = f.hasClass("open");
                if (!g || 27 == b.keyCode) return 27 == b.which && f.find(e).focus(), 
                d.click();
                g = " li:not(.divider):visible a", d = f.find("[role=menu]" + g + ", [role=listbox]" + g);
                d.length && (f = d.index(d.filter(":focus")), 38 == b.keyCode && 0 < f && f--, 
                40 == b.keyCode && f < d.length - 1 && f++, d.eq(f = ~f ? f : 0).focus());
            }
        }
    }, a.fn.dropdown);
    a.fn.dropdown = function(b) {
        return this.each(function() {
            var c = a(this), d = c.data("bs.dropdown");
            d || c.data("bs.dropdown", d = new f(this)), "string" == typeof b && d[b].call(c);
        });
    }, a.fn.dropdown.Constructor = f, a.fn.dropdown.noConflict = function() {
        return a.fn.dropdown = g, this;
    }, a(document).on("click.bs.dropdown.data-api", b).on("click.bs.dropdown.data-api", ".dropdown form", function(a) {
        a.stopPropagation();
    }).on("click.bs.dropdown.data-api", e, f.prototype.toggle).on("keydown.bs.dropdown.data-api", e + ", [role=menu], [role=listbox]", f.prototype.keydown);
}(jQuery), function(a) {
    "use strict";
    function b(b, c) {
        this.options = c, this.$element = a(b), this.$backdrop = this.isShown = null, 
        this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function() {
            this.$element.trigger("loaded.bs.modal");
        }, this));
    }
    b.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, b.prototype.toggle = function(a) {
        return this[this.isShown ? "hide" : "show"](a);
    }, b.prototype.show = function(b) {
        var c = this, d = a.Event("show.bs.modal", {
            relatedTarget: b
        });
        this.$element.trigger(d), this.isShown || d.isDefaultPrevented() || (this.isShown = !0, 
        this.escape(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), 
        this.backdrop(function() {
            var d = a.support.transition && c.$element.hasClass("fade"), e = (c.$element.parent().length || c.$element.appendTo(document.body), 
            c.$element.show().scrollTop(0), d && c.$element[0].offsetWidth, c.$element.addClass("in").attr("aria-hidden", !1), 
            c.enforceFocus(), a.Event("shown.bs.modal", {
                relatedTarget: b
            }));
            d ? c.$element.find(".modal-dialog").one(a.support.transition.end, function() {
                c.$element.focus().trigger(e);
            }).emulateTransitionEnd(300) : c.$element.focus().trigger(e);
        }));
    }, b.prototype.hide = function(b) {
        b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), 
        this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), 
        a(document).off("focusin.bs.modal"), this.$element.removeClass("in").attr("aria-hidden", !0).off("click.dismiss.bs.modal"), 
        a.support.transition && this.$element.hasClass("fade") ? this.$element.one(a.support.transition.end, a.proxy(this.hideModal, this)).emulateTransitionEnd(300) : this.hideModal());
    }, b.prototype.enforceFocus = function() {
        a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function(a) {
            this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.focus();
        }, this));
    }, b.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keyup.dismiss.bs.modal", a.proxy(function(a) {
            27 == a.which && this.hide();
        }, this)) : this.isShown || this.$element.off("keyup.dismiss.bs.modal");
    }, b.prototype.hideModal = function() {
        var a = this;
        this.$element.hide(), this.backdrop(function() {
            a.removeBackdrop(), a.$element.trigger("hidden.bs.modal");
        });
    }, b.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
    }, b.prototype.backdrop = function(b) {
        var d, c = this.$element.hasClass("fade") ? "fade" : "";
        this.isShown && this.options.backdrop ? (d = a.support.transition && c, 
        this.$backdrop = a('<div class="modal-backdrop ' + c + '" />').appendTo(document.body), 
        this.$element.on("click.dismiss.bs.modal", a.proxy(function(a) {
            a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this));
        }, this)), d && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), 
        b && (d ? this.$backdrop.one(a.support.transition.end, b).emulateTransitionEnd(150) : b())) : !this.isShown && this.$backdrop ? (this.$backdrop.removeClass("in"), 
        a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one(a.support.transition.end, b).emulateTransitionEnd(150) : b()) : b && b();
    };
    var c = a.fn.modal;
    a.fn.modal = function(c, d) {
        return this.each(function() {
            var e = a(this), f = e.data("bs.modal"), g = a.extend({}, b.DEFAULTS, e.data(), "object" == typeof c && c);
            f || e.data("bs.modal", f = new b(this, g)), "string" == typeof c ? f[c](d) : g.show && f.show(d);
        });
    }, a.fn.modal.Constructor = b, a.fn.modal.noConflict = function() {
        return a.fn.modal = c, this;
    }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(b) {
        var c = a(this), d = c.attr("href"), e = a(c.attr("data-target") || d && d.replace(/.*(?=#[^\s]+$)/, "")), d = e.data("bs.modal") ? "toggle" : a.extend({
            remote: !/#/.test(d) && d
        }, e.data(), c.data());
        c.is("a") && b.preventDefault(), e.modal(d, this).one("hide", function() {
            c.is(":visible") && c.focus();
        });
    }), a(document).on("show.bs.modal", ".modal", function() {
        a(document.body).addClass("modal-open");
    }).on("hidden.bs.modal", ".modal", function() {
        a(document.body).removeClass("modal-open");
    });
}(jQuery), function(a) {
    "use strict";
    function b(a, b) {
        this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null, 
        this.init("tooltip", a, b);
    }
    b.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1
    }, b.prototype.init = function(b, c, d) {
        this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d);
        for (var e = this.options.trigger.split(" "), f = e.length; f--; ) {
            var i, g = e[f];
            "click" == g ? this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this)) : "manual" != g && (i = "hover" == g ? "mouseleave" : "focusout", 
            this.$element.on(("hover" == g ? "mouseenter" : "focusin") + "." + this.type, this.options.selector, a.proxy(this.enter, this)), 
            this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this)));
        }
        this.options.selector ? this._options = a.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    }, b.prototype.getDefaults = function() {
        return b.DEFAULTS;
    }, b.prototype.getOptions = function(b) {
        return (b = a.extend({}, this.getDefaults(), this.$element.data(), b)).delay && "number" == typeof b.delay && (b.delay = {
            show: b.delay,
            hide: b.delay
        }), b;
    }, b.prototype.getDelegateOptions = function() {
        var b = {}, c = this.getDefaults();
        return this._options && a.each(this._options, function(a, d) {
            c[a] != d && (b[a] = d);
        }), b;
    }, b.prototype.enter = function(b) {
        var c = b instanceof this.constructor ? b : a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type);
        return clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function() {
            "in" == c.hoverState && c.show();
        }, c.options.delay.show)) : c.show();
    }, b.prototype.leave = function(b) {
        var c = b instanceof this.constructor ? b : a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type);
        return clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function() {
            "out" == c.hoverState && c.hide();
        }, c.options.delay.hide)) : c.hide();
    }, b.prototype.show = function() {
        var c, f, i, j, l, n, g, e, o, m, b = a.Event("show.bs." + this.type);
        this.hasContent() && this.enabled && (this.$element.trigger(b), b.isDefaultPrevented() || (b = (c = this).tip(), 
        this.setContent(), this.options.animation && b.addClass("fade"), e = "function" == typeof this.options.placement ? this.options.placement.call(this, b[0], this.$element[0]) : this.options.placement, 
        (g = (f = /\s?auto?\s?/i).test(e)) && (e = e.replace(f, "") || "top"), b.detach().css({
            top: 0,
            left: 0,
            display: "block"
        }).addClass(e), this.options.container ? b.appendTo(this.options.container) : b.insertAfter(this.$element), 
        f = this.getPosition(), i = b[0].offsetWidth, j = b[0].offsetHeight, g && (g = this.$element.parent(), 
        l = e, m = document.documentElement.scrollTop || document.body.scrollTop, 
        n = "body" == this.options.container ? window.innerWidth : g.outerWidth(), 
        o = "body" == this.options.container ? window.innerHeight : g.outerHeight(), 
        g = "body" == this.options.container ? 0 : g.offset().left, e = "bottom" == e && f.top + f.height + j - m > o ? "top" : "top" == e && f.top - m - j < 0 ? "bottom" : "right" == e && f.right + i > n ? "left" : "left" == e && f.left - i < g ? "right" : e, 
        b.removeClass(l).addClass(e)), o = this.getCalculatedOffset(e, f, i, j), 
        this.applyPlacement(o, e), this.hoverState = null, m = function() {
            c.$element.trigger("shown.bs." + c.type);
        }, a.support.transition && this.$tip.hasClass("fade") ? b.one(a.support.transition.end, m).emulateTransitionEnd(150) : m()));
    }, b.prototype.applyPlacement = function(b, c) {
        var d, e = this.tip(), f = e[0].offsetWidth, g = e[0].offsetHeight, h = parseInt(e.css("margin-top"), 10), i = parseInt(e.css("margin-left"), 10), h = (isNaN(h) && (h = 0), 
        isNaN(i) && (i = 0), b.top = b.top + h, b.left = b.left + i, a.offset.setOffset(e[0], a.extend({
            using: function(a) {
                e.css({
                    top: Math.round(a.top),
                    left: Math.round(a.left)
                });
            }
        }, b), 0), e.addClass("in"), e[0].offsetWidth), i = e[0].offsetHeight;
        "top" == c && i != g && (d = !0, b.top = b.top + g - i), /bottom|top/.test(c) ? (b.left < (c = 0) && (c = -2 * b.left, 
        b.left = 0, e.offset(b), h = e[0].offsetWidth, i = e[0].offsetHeight), this.replaceArrow(c - f + h, h, "left")) : this.replaceArrow(i - g, i, "top"), 
        d && e.offset(b);
    }, b.prototype.replaceArrow = function(a, b, c) {
        this.arrow().css(c, a ? 50 * (1 - a / b) + "%" : "");
    }, b.prototype.setContent = function() {
        var a = this.tip(), b = this.getTitle();
        a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right");
    }, b.prototype.hide = function() {
        function b() {
            "in" != c.hoverState && d.detach(), c.$element.trigger("hidden.bs." + c.type);
        }
        var c = this, d = this.tip(), e = a.Event("hide.bs." + this.type);
        return this.$element.trigger(e), e.isDefaultPrevented() ? void 0 : (d.removeClass("in"), 
        a.support.transition && this.$tip.hasClass("fade") ? d.one(a.support.transition.end, b).emulateTransitionEnd(150) : b(), 
        this.hoverState = null, this);
    }, b.prototype.fixTitle = function() {
        var a = this.$element;
        !a.attr("title") && "string" == typeof a.attr("data-original-title") || a.attr("data-original-title", a.attr("title") || "").attr("title", "");
    }, b.prototype.hasContent = function() {
        return this.getTitle();
    }, b.prototype.getPosition = function() {
        var b = this.$element[0];
        return a.extend({}, "function" == typeof b.getBoundingClientRect ? b.getBoundingClientRect() : {
            width: b.offsetWidth,
            height: b.offsetHeight
        }, this.$element.offset());
    }, b.prototype.getCalculatedOffset = function(a, b, c, d) {
        return "bottom" == a ? {
            top: b.top + b.height,
            left: b.left + b.width / 2 - c / 2
        } : "top" == a ? {
            top: b.top - d,
            left: b.left + b.width / 2 - c / 2
        } : "left" == a ? {
            top: b.top + b.height / 2 - d / 2,
            left: b.left - c
        } : {
            top: b.top + b.height / 2 - d / 2,
            left: b.left + b.width
        };
    }, b.prototype.getTitle = function() {
        var b = this.$element, c = this.options;
        return b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title);
    }, b.prototype.tip = function() {
        return this.$tip = this.$tip || a(this.options.template);
    }, b.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    }, b.prototype.validate = function() {
        this.$element[0].parentNode || (this.hide(), this.$element = null, this.options = null);
    }, b.prototype.enable = function() {
        this.enabled = !0;
    }, b.prototype.disable = function() {
        this.enabled = !1;
    }, b.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    }, b.prototype.toggle = function(b) {
        b = b ? a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type) : this;
        b.tip().hasClass("in") ? b.leave(b) : b.enter(b);
    }, b.prototype.destroy = function() {
        clearTimeout(this.timeout), this.hide().$element.off("." + this.type).removeData("bs." + this.type);
    };
    var c = a.fn.tooltip;
    a.fn.tooltip = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.tooltip");
            !e && "destroy" == c || (e || d.data("bs.tooltip", e = new b(this, "object" == typeof c && c)), 
            "string" == typeof c && e[c]());
        });
    }, a.fn.tooltip.Constructor = b, a.fn.tooltip.noConflict = function() {
        return a.fn.tooltip = c, this;
    };
}(jQuery), function(a) {
    "use strict";
    function b(a, b) {
        this.init("popover", a, b);
    }
    if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");
    b.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), ((b.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype)).constructor = b).prototype.getDefaults = function() {
        return b.DEFAULTS;
    }, b.prototype.setContent = function() {
        var a = this.tip(), b = this.getTitle(), c = this.getContent();
        a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content")[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), 
        a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide();
    }, b.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    }, b.prototype.getContent = function() {
        var a = this.$element, b = this.options;
        return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content);
    }, b.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    }, b.prototype.tip = function() {
        return this.$tip || (this.$tip = a(this.options.template)), this.$tip;
    };
    var c = a.fn.popover;
    a.fn.popover = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.popover");
            !e && "destroy" == c || (e || d.data("bs.popover", e = new b(this, "object" == typeof c && c)), 
            "string" == typeof c && e[c]());
        });
    }, a.fn.popover.Constructor = b, a.fn.popover.noConflict = function() {
        return a.fn.popover = c, this;
    };
}(jQuery), function(a) {
    "use strict";
    function b(c, d) {
        var f = a.proxy(this.process, this);
        this.$element = a(a(c).is("body") ? window : c), this.$body = a("body"), 
        this.$scrollElement = this.$element.on("scroll.bs.scroll-spy.data-api", f), 
        this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || (f = a(c).attr("href")) && f.replace(/.*(?=#[^\s]+$)/, "") || "") + " .nav li > a", 
        this.offsets = a([]), this.targets = a([]), this.activeTarget = null, this.refresh(), 
        this.process();
    }
    b.DEFAULTS = {
        offset: 10
    }, b.prototype.refresh = function() {
        var b = this.$element[0] == window ? "offset" : "position", c = (this.offsets = a([]), 
        this.targets = a([]), this);
        this.$body.find(this.selector).map(function() {
            var d = a(this), d = d.data("target") || d.attr("href"), f = /^#./.test(d) && a(d);
            return f && f.length && f.is(":visible") ? [ [ f[b]().top + (!a.isWindow(c.$scrollElement.get(0)) && c.$scrollElement.scrollTop()), d ] ] : null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            c.offsets.push(this[0]), c.targets.push(this[1]);
        });
    }, b.prototype.process = function() {
        var a, b = this.$scrollElement.scrollTop() + this.options.offset, d = (this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight) - this.$scrollElement.height(), e = this.offsets, f = this.targets, g = this.activeTarget;
        if (d <= b) return g != (a = f.last()[0]) && this.activate(a);
        if (g && b <= e[0]) return g != (a = f[0]) && this.activate(a);
        for (a = e.length; a--; ) g != f[a] && b >= e[a] && (!e[a + 1] || b <= e[a + 1]) && this.activate(f[a]);
    }, b.prototype.activate = function(b) {
        this.activeTarget = b, a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
        b = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]', 
        b = a(b).parents("li").addClass("active");
        (b = b.parent(".dropdown-menu").length ? b.closest("li.dropdown").addClass("active") : b).trigger("activate.bs.scrollspy");
    };
    var c = a.fn.scrollspy;
    a.fn.scrollspy = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.scrollspy");
            e || d.data("bs.scrollspy", e = new b(this, "object" == typeof c && c)), 
            "string" == typeof c && e[c]();
        });
    }, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function() {
        return a.fn.scrollspy = c, this;
    }, a(window).on("load", function() {
        a('[data-spy="scroll"]').each(function() {
            var b = a(this);
            b.scrollspy(b.data());
        });
    });
}(jQuery), function(a) {
    "use strict";
    function b(b) {
        this.element = a(b);
    }
    b.prototype.show = function() {
        var e, f, b = this.element, c = b.closest("ul:not(.dropdown-menu)"), d = b.data("target");
        d || (d = (d = b.attr("href")) && d.replace(/.*(?=#[^\s]*$)/, "")), b.parent("li").hasClass("active") || (e = c.find(".active:last a")[0], 
        f = a.Event("show.bs.tab", {
            relatedTarget: e
        }), b.trigger(f), f.isDefaultPrevented() || (f = a(d), this.activate(b.parent("li"), c), 
        this.activate(f, f.parent(), function() {
            b.trigger({
                type: "shown.bs.tab",
                relatedTarget: e
            });
        })));
    }, b.prototype.activate = function(b, c, d) {
        function e() {
            f.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"), 
            b.addClass("active"), g ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), 
            b.parent(".dropdown-menu") && b.closest("li.dropdown").addClass("active"), 
            d && d();
        }
        var f = c.find("> .active"), g = d && a.support.transition && f.hasClass("fade");
        g ? f.one(a.support.transition.end, e).emulateTransitionEnd(150) : e(), 
        f.removeClass("in");
    };
    var c = a.fn.tab;
    a.fn.tab = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.tab");
            e || d.data("bs.tab", e = new b(this)), "string" == typeof c && e[c]();
        });
    }, a.fn.tab.Constructor = b, a.fn.tab.noConflict = function() {
        return a.fn.tab = c, this;
    }, a(document).on("click.bs.tab.data-api", '[data-toggle="tab"], [data-toggle="pill"]', function(b) {
        b.preventDefault(), a(this).tab("show");
    });
}(jQuery), function(a) {
    "use strict";
    function b(c, d) {
        this.options = a.extend({}, b.DEFAULTS, d), this.$window = a(window).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), 
        this.$element = a(c), this.affixed = this.unpin = this.pinnedOffset = null, 
        this.checkPosition();
    }
    b.RESET = "affix affix-top affix-bottom", b.DEFAULTS = {
        offset: 0
    }, b.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(b.RESET).addClass("affix");
        var a = this.$window.scrollTop(), c = this.$element.offset();
        return this.pinnedOffset = c.top - a;
    }, b.prototype.checkPositionWithEventLoop = function() {
        setTimeout(a.proxy(this.checkPosition, this), 1);
    }, b.prototype.checkPosition = function() {
        var c, g, h, f, e, d;
        this.$element.is(":visible") && (c = a(document).height(), d = this.$window.scrollTop(), 
        e = this.$element.offset(), g = (f = this.options.offset).top, h = f.bottom, 
        "top" == this.affixed && (e.top += d), "object" != typeof f && (h = g = f), 
        "function" == typeof g && (g = f.top(this.$element)), "function" == typeof h && (h = f.bottom(this.$element)), 
        f = !(null != this.unpin && d + this.unpin <= e.top) && (null != h && e.top + this.$element.height() >= c - h ? "bottom" : null != g && d <= g && "top"), 
        this.affixed !== f && (this.unpin && this.$element.css("top", ""), d = a.Event((e = "affix" + (f ? "-" + f : "")) + ".bs.affix"), 
        this.$element.trigger(d), d.isDefaultPrevented() || (this.affixed = f, this.unpin = "bottom" == f ? this.getPinnedOffset() : null, 
        this.$element.removeClass(b.RESET).addClass(e).trigger(a.Event(e.replace("affix", "affixed"))), 
        "bottom" == f && this.$element.offset({
            top: c - h - this.$element.height()
        }))));
    };
    var c = a.fn.affix;
    a.fn.affix = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.affix");
            e || d.data("bs.affix", e = new b(this, "object" == typeof c && c)), 
            "string" == typeof c && e[c]();
        });
    }, a.fn.affix.Constructor = b, a.fn.affix.noConflict = function() {
        return a.fn.affix = c, this;
    }, a(window).on("load", function() {
        a('[data-spy="affix"]').each(function() {
            var b = a(this), c = b.data();
            c.offset = c.offset || {}, c.offsetBottom && (c.offset.bottom = c.offsetBottom), 
            c.offsetTop && (c.offset.top = c.offsetTop), b.affix(c);
        });
    });
}(jQuery), !function($) {
    "use strict";
    function ContextMenu(element, options) {
        this.$element = $(element), this.before = options.before || this.before, 
        this.onItem = options.onItem || this.onItem, this.scopes = options.scopes || null, 
        options.target && this.$element.data("target", options.target), this.listen();
    }
    ContextMenu.prototype = {
        constructor: ContextMenu,
        show: function(e) {
            var $menu, tp, relatedTarget = {
                relatedTarget: this
            };
            if (!this.isDisabled() && (this.closemenu(), this.before.call(this, e, $(e.currentTarget)))) return ($menu = this.getMenu()).trigger($.Event("show.bs.context", relatedTarget)), 
            tp = this.getPosition(e, $menu), $menu.attr("style", "").css(tp).addClass("open").on("click.context.data-api", "li:not(.divider)", $.proxy(this.onItem, this, $(e.currentTarget))).trigger("shown.bs.context", relatedTarget), 
            $("html").on("click.context.data-api", $menu.selector, $.proxy(this.closemenu, this)), 
            !1;
        },
        closemenu: function(e) {
            var relatedTarget, $menu = this.getMenu();
            if ($menu.hasClass("open")) return $menu.trigger($.Event("hide.bs.context", relatedTarget = {
                relatedTarget: this
            })), $menu.removeClass("open").off("click.context.data-api", "li:not(.divider)").trigger("hidden.bs.context", relatedTarget), 
            $("html").off("click.context.data-api", $menu.selector), !1;
        },
        before: function(e) {
            return !0;
        },
        onItem: function(e) {
            return !0;
        },
        listen: function() {
            this.$element.on("contextmenu.context.data-api", this.scopes, $.proxy(this.show, this)), 
            $("html").on("click.context.data-api", $.proxy(this.closemenu, this));
        },
        destroy: function() {
            this.$element.off(".context.data-api").removeData("context"), $("html").off(".context.data-api");
        },
        isDisabled: function() {
            return this.$element.hasClass(".disabled") || this.$element.attr("disabled");
        },
        getMenu: function() {
            var selector = (selector = this.$element.data("target")) || (selector = this.$element.attr("href")) && selector.replace(/.*(?=#[^\s]*$)/, ""), $menu = $(selector);
            return $menu && $menu.length ? $menu : this.$element.find(selector);
        },
        getPosition: function(e, $menu) {
            var mouseX = e.clientX, e = e.clientY, boundsX = $(window).width(), boundsY = $(window).height(), menuWidth = $menu.find(".dropdown-menu").outerWidth(), menuHeight = $menu.find(".dropdown-menu").outerHeight(), boundsY = boundsY < e + menuHeight ? {
                top: e - menuHeight + $(window).scrollTop()
            } : {
                top: e + $(window).scrollTop()
            }, menuHeight = boundsX < mouseX + menuWidth && 0 < mouseX - menuWidth ? {
                left: mouseX - menuWidth + $(window).scrollLeft()
            } : {
                left: mouseX + $(window).scrollLeft()
            }, e = $menu.offsetParent().offset();
            return menuHeight.left = menuHeight.left - e.left, boundsY.top = boundsY.top - e.top, 
            $.extend({
                position: "absolute",
                "z-index": 9999
            }, boundsY, menuHeight);
        }
    }, $.fn.contextmenu = function(option, e) {
        return this.each(function() {
            var $this = $(this), data = $this.data("context");
            data || $this.data("context", data = new ContextMenu($this, "object" == typeof option && option)), 
            "string" == typeof option && data[option].call(data, e);
        });
    }, $.fn.contextmenu.Constructor = ContextMenu, $(document).on("contextmenu.context.data-api", '[data-toggle="context"]', function(e) {
        $(this).contextmenu("show", e), e.preventDefault();
    });
}(jQuery), !function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define([ "exports" ], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).Dropbox = {});
}(this, function(e) {
    "use strict";
    function t(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function r(e, t) {
        for (var r = 0; t.length > r; r++) {
            var s = t[r];
            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), 
            Object.defineProperty(e, s.key, s);
        }
    }
    function s(e, t, s) {
        t && r(e.prototype, t), s && r(e, s);
    }
    function i(e) {
        return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e);
        })(e);
    }
    function n(e, t) {
        return (n = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e;
        })(e, t);
    }
    function a() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
            !0;
        } catch (e) {
            return !1;
        }
    }
    function o(e, t, r) {
        return (o = a() ? Reflect.construct : function(e, t, r) {
            var s = [ null ], t = (s.push.apply(s, t), new (Function.bind.apply(e, s))());
            return r && n(t, r.prototype), t;
        }).apply(null, arguments);
    }
    function u(e) {
        var t = "function" == typeof Map ? new Map() : void 0;
        return function(e) {
            if (null === e || -1 === Function.toString.call(e).indexOf("[native code]")) return e;
            if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t) {
                if (t.has(e)) return t.get(e);
                t.set(e, r);
            }
            function r() {
                return o(e, arguments, i(this).constructor);
            }
            return r.prototype = Object.create(e.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), n(r, e);
        }(e);
    }
    var p = "app", l = "user", f = "team", m = "dropboxapi.com", h = "dropbox.com", d = {
        api: "api",
        notify: "bolt",
        content: "api-content"
    }, _ = {};
    function g(e) {
        e = "000".concat(e.charCodeAt(0).toString(16)).slice(-4);
        return "\\u".concat(e);
    }
    _.accountSetProfilePhoto = function(e) {
        return this.request("account/set_profile_photo", e, "user", "api", "rpc", "account_info.write");
    }, _.authTokenFromOauth1 = function(e) {
        return this.request("auth/token/from_oauth1", e, "app", "api", "rpc", null);
    }, _.authTokenRevoke = function() {
        return this.request("auth/token/revoke", null, "user", "api", "rpc", null);
    }, _.checkApp = function(e) {
        return this.request("check/app", e, "app", "api", "rpc", null);
    }, _.checkUser = function(e) {
        return this.request("check/user", e, "user", "api", "rpc", "account_info.read");
    }, _.contactsDeleteManualContacts = function() {
        return this.request("contacts/delete_manual_contacts", null, "user", "api", "rpc", "contacts.write");
    }, _.contactsDeleteManualContactsBatch = function(e) {
        return this.request("contacts/delete_manual_contacts_batch", e, "user", "api", "rpc", "contacts.write");
    }, _.filePropertiesPropertiesAdd = function(e) {
        return this.request("file_properties/properties/add", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filePropertiesPropertiesOverwrite = function(e) {
        return this.request("file_properties/properties/overwrite", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filePropertiesPropertiesRemove = function(e) {
        return this.request("file_properties/properties/remove", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filePropertiesPropertiesSearch = function(e) {
        return this.request("file_properties/properties/search", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filePropertiesPropertiesSearchContinue = function(e) {
        return this.request("file_properties/properties/search/continue", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filePropertiesPropertiesUpdate = function(e) {
        return this.request("file_properties/properties/update", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filePropertiesTemplatesAddForTeam = function(e) {
        return this.request("file_properties/templates/add_for_team", e, "team", "api", "rpc", "files.team_metadata.write");
    }, _.filePropertiesTemplatesAddForUser = function(e) {
        return this.request("file_properties/templates/add_for_user", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filePropertiesTemplatesGetForTeam = function(e) {
        return this.request("file_properties/templates/get_for_team", e, "team", "api", "rpc", "files.team_metadata.write");
    }, _.filePropertiesTemplatesGetForUser = function(e) {
        return this.request("file_properties/templates/get_for_user", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filePropertiesTemplatesListForTeam = function() {
        return this.request("file_properties/templates/list_for_team", null, "team", "api", "rpc", "files.team_metadata.write");
    }, _.filePropertiesTemplatesListForUser = function() {
        return this.request("file_properties/templates/list_for_user", null, "user", "api", "rpc", "files.metadata.read");
    }, _.filePropertiesTemplatesRemoveForTeam = function(e) {
        return this.request("file_properties/templates/remove_for_team", e, "team", "api", "rpc", "files.team_metadata.write");
    }, _.filePropertiesTemplatesRemoveForUser = function(e) {
        return this.request("file_properties/templates/remove_for_user", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filePropertiesTemplatesUpdateForTeam = function(e) {
        return this.request("file_properties/templates/update_for_team", e, "team", "api", "rpc", "files.team_metadata.write");
    }, _.filePropertiesTemplatesUpdateForUser = function(e) {
        return this.request("file_properties/templates/update_for_user", e, "user", "api", "rpc", "files.metadata.write");
    }, _.fileRequestsCount = function() {
        return this.request("file_requests/count", null, "user", "api", "rpc", "file_requests.read");
    }, _.fileRequestsCreate = function(e) {
        return this.request("file_requests/create", e, "user", "api", "rpc", "file_requests.write");
    }, _.fileRequestsDelete = function(e) {
        return this.request("file_requests/delete", e, "user", "api", "rpc", "file_requests.write");
    }, _.fileRequestsDeleteAllClosed = function() {
        return this.request("file_requests/delete_all_closed", null, "user", "api", "rpc", "file_requests.write");
    }, _.fileRequestsGet = function(e) {
        return this.request("file_requests/get", e, "user", "api", "rpc", "file_requests.read");
    }, _.fileRequestsListV2 = function(e) {
        return this.request("file_requests/list_v2", e, "user", "api", "rpc", "file_requests.read");
    }, _.fileRequestsList = function() {
        return this.request("file_requests/list", null, "user", "api", "rpc", "file_requests.read");
    }, _.fileRequestsListContinue = function(e) {
        return this.request("file_requests/list/continue", e, "user", "api", "rpc", "file_requests.read");
    }, _.fileRequestsUpdate = function(e) {
        return this.request("file_requests/update", e, "user", "api", "rpc", "file_requests.write");
    }, _.filesAlphaGetMetadata = function(e) {
        return this.request("files/alpha/get_metadata", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesAlphaUpload = function(e) {
        return this.request("files/alpha/upload", e, "user", "content", "upload", "files.content.write");
    }, _.filesCopyV2 = function(e) {
        return this.request("files/copy_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCopy = function(e) {
        return this.request("files/copy", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCopyBatchV2 = function(e) {
        return this.request("files/copy_batch_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCopyBatch = function(e) {
        return this.request("files/copy_batch", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCopyBatchCheckV2 = function(e) {
        return this.request("files/copy_batch/check_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCopyBatchCheck = function(e) {
        return this.request("files/copy_batch/check", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCopyReferenceGet = function(e) {
        return this.request("files/copy_reference/get", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCopyReferenceSave = function(e) {
        return this.request("files/copy_reference/save", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCreateFolderV2 = function(e) {
        return this.request("files/create_folder_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCreateFolder = function(e) {
        return this.request("files/create_folder", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCreateFolderBatch = function(e) {
        return this.request("files/create_folder_batch", e, "user", "api", "rpc", "files.content.write");
    }, _.filesCreateFolderBatchCheck = function(e) {
        return this.request("files/create_folder_batch/check", e, "user", "api", "rpc", "files.content.write");
    }, _.filesDeleteV2 = function(e) {
        return this.request("files/delete_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesDelete = function(e) {
        return this.request("files/delete", e, "user", "api", "rpc", "files.content.write");
    }, _.filesDeleteBatch = function(e) {
        return this.request("files/delete_batch", e, "user", "api", "rpc", "files.content.write");
    }, _.filesDeleteBatchCheck = function(e) {
        return this.request("files/delete_batch/check", e, "user", "api", "rpc", "files.content.write");
    }, _.filesDownload = function(e) {
        return this.request("files/download", e, "user", "content", "download", "files.content.read");
    }, _.filesDownloadZip = function(e) {
        return this.request("files/download_zip", e, "user", "content", "download", "files.content.read");
    }, _.filesExport = function(e) {
        return this.request("files/export", e, "user", "content", "download", "files.content.read");
    }, _.filesGetFileLockBatch = function(e) {
        return this.request("files/get_file_lock_batch", e, "user", "api", "rpc", "files.content.read");
    }, _.filesGetMetadata = function(e) {
        return this.request("files/get_metadata", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesGetPreview = function(e) {
        return this.request("files/get_preview", e, "user", "content", "download", "files.content.read");
    }, _.filesGetTemporaryLink = function(e) {
        return this.request("files/get_temporary_link", e, "user", "api", "rpc", "files.content.read");
    }, _.filesGetTemporaryUploadLink = function(e) {
        return this.request("files/get_temporary_upload_link", e, "user", "api", "rpc", "files.content.write");
    }, _.filesGetThumbnail = function(e) {
        return this.request("files/get_thumbnail", e, "user", "content", "download", "files.content.read");
    }, _.filesGetThumbnailV2 = function(e) {
        return this.request("files/get_thumbnail_v2", e, "app, user", "content", "download", "files.content.read");
    }, _.filesGetThumbnailBatch = function(e) {
        return this.request("files/get_thumbnail_batch", e, "user", "content", "rpc", "files.content.read");
    }, _.filesListFolder = function(e) {
        return this.request("files/list_folder", e, "app, user", "api", "rpc", "files.metadata.read");
    }, _.filesListFolderContinue = function(e) {
        return this.request("files/list_folder/continue", e, "app, user", "api", "rpc", "files.metadata.read");
    }, _.filesListFolderGetLatestCursor = function(e) {
        return this.request("files/list_folder/get_latest_cursor", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesListFolderLongpoll = function(e) {
        return this.request("files/list_folder/longpoll", e, "noauth", "notify", "rpc", "files.metadata.read");
    }, _.filesListRevisions = function(e) {
        return this.request("files/list_revisions", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesLockFileBatch = function(e) {
        return this.request("files/lock_file_batch", e, "user", "api", "rpc", "files.content.write");
    }, _.filesMoveV2 = function(e) {
        return this.request("files/move_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesMove = function(e) {
        return this.request("files/move", e, "user", "api", "rpc", "files.content.write");
    }, _.filesMoveBatchV2 = function(e) {
        return this.request("files/move_batch_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesMoveBatch = function(e) {
        return this.request("files/move_batch", e, "user", "api", "rpc", "files.content.write");
    }, _.filesMoveBatchCheckV2 = function(e) {
        return this.request("files/move_batch/check_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesMoveBatchCheck = function(e) {
        return this.request("files/move_batch/check", e, "user", "api", "rpc", "files.content.write");
    }, _.filesPaperCreate = function(e) {
        return this.request("files/paper/create", e, "user", "api", "upload", "files.content.write");
    }, _.filesPaperUpdate = function(e) {
        return this.request("files/paper/update", e, "user", "api", "upload", "files.content.write");
    }, _.filesPermanentlyDelete = function(e) {
        return this.request("files/permanently_delete", e, "user", "api", "rpc", "files.permanent_delete");
    }, _.filesPropertiesAdd = function(e) {
        return this.request("files/properties/add", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filesPropertiesOverwrite = function(e) {
        return this.request("files/properties/overwrite", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filesPropertiesRemove = function(e) {
        return this.request("files/properties/remove", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filesPropertiesTemplateGet = function(e) {
        return this.request("files/properties/template/get", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesPropertiesTemplateList = function() {
        return this.request("files/properties/template/list", null, "user", "api", "rpc", "files.metadata.read");
    }, _.filesPropertiesUpdate = function(e) {
        return this.request("files/properties/update", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filesRestore = function(e) {
        return this.request("files/restore", e, "user", "api", "rpc", "files.content.write");
    }, _.filesSaveUrl = function(e) {
        return this.request("files/save_url", e, "user", "api", "rpc", "files.content.write");
    }, _.filesSaveUrlCheckJobStatus = function(e) {
        return this.request("files/save_url/check_job_status", e, "user", "api", "rpc", "files.content.write");
    }, _.filesSearch = function(e) {
        return this.request("files/search", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesSearchV2 = function(e) {
        return this.request("files/search_v2", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesSearchContinueV2 = function(e) {
        return this.request("files/search/continue_v2", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesTagsAdd = function(e) {
        return this.request("files/tags/add", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filesTagsGet = function(e) {
        return this.request("files/tags/get", e, "user", "api", "rpc", "files.metadata.read");
    }, _.filesTagsRemove = function(e) {
        return this.request("files/tags/remove", e, "user", "api", "rpc", "files.metadata.write");
    }, _.filesUnlockFileBatch = function(e) {
        return this.request("files/unlock_file_batch", e, "user", "api", "rpc", "files.content.write");
    }, _.filesUpload = function(e) {
        return this.request("files/upload", e, "user", "content", "upload", "files.content.write");
    }, _.filesUploadSessionAppendV2 = function(e) {
        return this.request("files/upload_session/append_v2", e, "user", "content", "upload", "files.content.write");
    }, _.filesUploadSessionAppend = function(e) {
        return this.request("files/upload_session/append", e, "user", "content", "upload", "files.content.write");
    }, _.filesUploadSessionFinish = function(e) {
        return this.request("files/upload_session/finish", e, "user", "content", "upload", "files.content.write");
    }, _.filesUploadSessionFinishBatch = function(e) {
        return this.request("files/upload_session/finish_batch", e, "user", "api", "rpc", "files.content.write");
    }, _.filesUploadSessionFinishBatchV2 = function(e) {
        return this.request("files/upload_session/finish_batch_v2", e, "user", "api", "rpc", "files.content.write");
    }, _.filesUploadSessionFinishBatchCheck = function(e) {
        return this.request("files/upload_session/finish_batch/check", e, "user", "api", "rpc", "files.content.write");
    }, _.filesUploadSessionStart = function(e) {
        return this.request("files/upload_session/start", e, "user", "content", "upload", "files.content.write");
    }, _.filesUploadSessionStartBatch = function(e) {
        return this.request("files/upload_session/start_batch", e, "user", "api", "rpc", "files.content.write");
    }, _.paperDocsArchive = function(e) {
        return this.request("paper/docs/archive", e, "user", "api", "rpc", "files.content.write");
    }, _.paperDocsCreate = function(e) {
        return this.request("paper/docs/create", e, "user", "api", "upload", "files.content.write");
    }, _.paperDocsDownload = function(e) {
        return this.request("paper/docs/download", e, "user", "api", "download", "files.content.read");
    }, _.paperDocsFolderUsersList = function(e) {
        return this.request("paper/docs/folder_users/list", e, "user", "api", "rpc", "sharing.read");
    }, _.paperDocsFolderUsersListContinue = function(e) {
        return this.request("paper/docs/folder_users/list/continue", e, "user", "api", "rpc", "sharing.read");
    }, _.paperDocsGetFolderInfo = function(e) {
        return this.request("paper/docs/get_folder_info", e, "user", "api", "rpc", "sharing.read");
    }, _.paperDocsList = function(e) {
        return this.request("paper/docs/list", e, "user", "api", "rpc", "files.metadata.read");
    }, _.paperDocsListContinue = function(e) {
        return this.request("paper/docs/list/continue", e, "user", "api", "rpc", "files.metadata.read");
    }, _.paperDocsPermanentlyDelete = function(e) {
        return this.request("paper/docs/permanently_delete", e, "user", "api", "rpc", "files.permanent_delete");
    }, _.paperDocsSharingPolicyGet = function(e) {
        return this.request("paper/docs/sharing_policy/get", e, "user", "api", "rpc", "sharing.read");
    }, _.paperDocsSharingPolicySet = function(e) {
        return this.request("paper/docs/sharing_policy/set", e, "user", "api", "rpc", "sharing.write");
    }, _.paperDocsUpdate = function(e) {
        return this.request("paper/docs/update", e, "user", "api", "upload", "files.content.write");
    }, _.paperDocsUsersAdd = function(e) {
        return this.request("paper/docs/users/add", e, "user", "api", "rpc", "sharing.write");
    }, _.paperDocsUsersList = function(e) {
        return this.request("paper/docs/users/list", e, "user", "api", "rpc", "sharing.read");
    }, _.paperDocsUsersListContinue = function(e) {
        return this.request("paper/docs/users/list/continue", e, "user", "api", "rpc", "sharing.read");
    }, _.paperDocsUsersRemove = function(e) {
        return this.request("paper/docs/users/remove", e, "user", "api", "rpc", "sharing.write");
    }, _.paperFoldersCreate = function(e) {
        return this.request("paper/folders/create", e, "user", "api", "rpc", "files.content.write");
    }, _.sharingAddFileMember = function(e) {
        return this.request("sharing/add_file_member", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingAddFolderMember = function(e) {
        return this.request("sharing/add_folder_member", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingCheckJobStatus = function(e) {
        return this.request("sharing/check_job_status", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingCheckRemoveMemberJobStatus = function(e) {
        return this.request("sharing/check_remove_member_job_status", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingCheckShareJobStatus = function(e) {
        return this.request("sharing/check_share_job_status", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingCreateSharedLink = function(e) {
        return this.request("sharing/create_shared_link", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingCreateSharedLinkWithSettings = function(e) {
        return this.request("sharing/create_shared_link_with_settings", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingGetFileMetadata = function(e) {
        return this.request("sharing/get_file_metadata", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingGetFileMetadataBatch = function(e) {
        return this.request("sharing/get_file_metadata/batch", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingGetFolderMetadata = function(e) {
        return this.request("sharing/get_folder_metadata", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingGetSharedLinkFile = function(e) {
        return this.request("sharing/get_shared_link_file", e, "user", "content", "download", "sharing.read");
    }, _.sharingGetSharedLinkMetadata = function(e) {
        return this.request("sharing/get_shared_link_metadata", e, "app, user", "api", "rpc", "sharing.read");
    }, _.sharingGetSharedLinks = function(e) {
        return this.request("sharing/get_shared_links", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListFileMembers = function(e) {
        return this.request("sharing/list_file_members", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListFileMembersBatch = function(e) {
        return this.request("sharing/list_file_members/batch", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListFileMembersContinue = function(e) {
        return this.request("sharing/list_file_members/continue", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListFolderMembers = function(e) {
        return this.request("sharing/list_folder_members", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListFolderMembersContinue = function(e) {
        return this.request("sharing/list_folder_members/continue", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListFolders = function(e) {
        return this.request("sharing/list_folders", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListFoldersContinue = function(e) {
        return this.request("sharing/list_folders/continue", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListMountableFolders = function(e) {
        return this.request("sharing/list_mountable_folders", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListMountableFoldersContinue = function(e) {
        return this.request("sharing/list_mountable_folders/continue", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListReceivedFiles = function(e) {
        return this.request("sharing/list_received_files", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListReceivedFilesContinue = function(e) {
        return this.request("sharing/list_received_files/continue", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingListSharedLinks = function(e) {
        return this.request("sharing/list_shared_links", e, "user", "api", "rpc", "sharing.read");
    }, _.sharingModifySharedLinkSettings = function(e) {
        return this.request("sharing/modify_shared_link_settings", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingMountFolder = function(e) {
        return this.request("sharing/mount_folder", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingRelinquishFileMembership = function(e) {
        return this.request("sharing/relinquish_file_membership", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingRelinquishFolderMembership = function(e) {
        return this.request("sharing/relinquish_folder_membership", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingRemoveFileMember = function(e) {
        return this.request("sharing/remove_file_member", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingRemoveFileMember2 = function(e) {
        return this.request("sharing/remove_file_member_2", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingRemoveFolderMember = function(e) {
        return this.request("sharing/remove_folder_member", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingRevokeSharedLink = function(e) {
        return this.request("sharing/revoke_shared_link", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingSetAccessInheritance = function(e) {
        return this.request("sharing/set_access_inheritance", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingShareFolder = function(e) {
        return this.request("sharing/share_folder", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingTransferFolder = function(e) {
        return this.request("sharing/transfer_folder", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingUnmountFolder = function(e) {
        return this.request("sharing/unmount_folder", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingUnshareFile = function(e) {
        return this.request("sharing/unshare_file", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingUnshareFolder = function(e) {
        return this.request("sharing/unshare_folder", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingUpdateFileMember = function(e) {
        return this.request("sharing/update_file_member", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingUpdateFolderMember = function(e) {
        return this.request("sharing/update_folder_member", e, "user", "api", "rpc", "sharing.write");
    }, _.sharingUpdateFolderPolicy = function(e) {
        return this.request("sharing/update_folder_policy", e, "user", "api", "rpc", "sharing.write");
    }, _.teamDevicesListMemberDevices = function(e) {
        return this.request("team/devices/list_member_devices", e, "team", "api", "rpc", "sessions.list");
    }, _.teamDevicesListMembersDevices = function(e) {
        return this.request("team/devices/list_members_devices", e, "team", "api", "rpc", "sessions.list");
    }, _.teamDevicesListTeamDevices = function(e) {
        return this.request("team/devices/list_team_devices", e, "team", "api", "rpc", "sessions.list");
    }, _.teamDevicesRevokeDeviceSession = function(e) {
        return this.request("team/devices/revoke_device_session", e, "team", "api", "rpc", "sessions.modify");
    }, _.teamDevicesRevokeDeviceSessionBatch = function(e) {
        return this.request("team/devices/revoke_device_session_batch", e, "team", "api", "rpc", "sessions.modify");
    }, _.teamFeaturesGetValues = function(e) {
        return this.request("team/features/get_values", e, "team", "api", "rpc", "team_info.read");
    }, _.teamGetInfo = function() {
        return this.request("team/get_info", null, "team", "api", "rpc", "team_info.read");
    }, _.teamGroupsCreate = function(e) {
        return this.request("team/groups/create", e, "team", "api", "rpc", "groups.write");
    }, _.teamGroupsDelete = function(e) {
        return this.request("team/groups/delete", e, "team", "api", "rpc", "groups.write");
    }, _.teamGroupsGetInfo = function(e) {
        return this.request("team/groups/get_info", e, "team", "api", "rpc", "groups.read");
    }, _.teamGroupsJobStatusGet = function(e) {
        return this.request("team/groups/job_status/get", e, "team", "api", "rpc", "groups.write");
    }, _.teamGroupsList = function(e) {
        return this.request("team/groups/list", e, "team", "api", "rpc", "groups.read");
    }, _.teamGroupsListContinue = function(e) {
        return this.request("team/groups/list/continue", e, "team", "api", "rpc", "groups.read");
    }, _.teamGroupsMembersAdd = function(e) {
        return this.request("team/groups/members/add", e, "team", "api", "rpc", "groups.write");
    }, _.teamGroupsMembersList = function(e) {
        return this.request("team/groups/members/list", e, "team", "api", "rpc", "groups.read");
    }, _.teamGroupsMembersListContinue = function(e) {
        return this.request("team/groups/members/list/continue", e, "team", "api", "rpc", "groups.read");
    }, _.teamGroupsMembersRemove = function(e) {
        return this.request("team/groups/members/remove", e, "team", "api", "rpc", "groups.write");
    }, _.teamGroupsMembersSetAccessType = function(e) {
        return this.request("team/groups/members/set_access_type", e, "team", "api", "rpc", "groups.write");
    }, _.teamGroupsUpdate = function(e) {
        return this.request("team/groups/update", e, "team", "api", "rpc", "groups.write");
    }, _.teamLegalHoldsCreatePolicy = function(e) {
        return this.request("team/legal_holds/create_policy", e, "team", "api", "rpc", "team_data.governance.write");
    }, _.teamLegalHoldsGetPolicy = function(e) {
        return this.request("team/legal_holds/get_policy", e, "team", "api", "rpc", "team_data.governance.write");
    }, _.teamLegalHoldsListHeldRevisions = function(e) {
        return this.request("team/legal_holds/list_held_revisions", e, "team", "api", "rpc", "team_data.governance.write");
    }, _.teamLegalHoldsListHeldRevisionsContinue = function(e) {
        return this.request("team/legal_holds/list_held_revisions_continue", e, "team", "api", "rpc", "team_data.governance.write");
    }, _.teamLegalHoldsListPolicies = function(e) {
        return this.request("team/legal_holds/list_policies", e, "team", "api", "rpc", "team_data.governance.write");
    }, _.teamLegalHoldsReleasePolicy = function(e) {
        return this.request("team/legal_holds/release_policy", e, "team", "api", "rpc", "team_data.governance.write");
    }, _.teamLegalHoldsUpdatePolicy = function(e) {
        return this.request("team/legal_holds/update_policy", e, "team", "api", "rpc", "team_data.governance.write");
    }, _.teamLinkedAppsListMemberLinkedApps = function(e) {
        return this.request("team/linked_apps/list_member_linked_apps", e, "team", "api", "rpc", "sessions.list");
    }, _.teamLinkedAppsListMembersLinkedApps = function(e) {
        return this.request("team/linked_apps/list_members_linked_apps", e, "team", "api", "rpc", "sessions.list");
    }, _.teamLinkedAppsListTeamLinkedApps = function(e) {
        return this.request("team/linked_apps/list_team_linked_apps", e, "team", "api", "rpc", "sessions.list");
    }, _.teamLinkedAppsRevokeLinkedApp = function(e) {
        return this.request("team/linked_apps/revoke_linked_app", e, "team", "api", "rpc", "sessions.modify");
    }, _.teamLinkedAppsRevokeLinkedAppBatch = function(e) {
        return this.request("team/linked_apps/revoke_linked_app_batch", e, "team", "api", "rpc", "sessions.modify");
    }, _.teamMemberSpaceLimitsExcludedUsersAdd = function(e) {
        return this.request("team/member_space_limits/excluded_users/add", e, "team", "api", "rpc", "members.write");
    }, _.teamMemberSpaceLimitsExcludedUsersList = function(e) {
        return this.request("team/member_space_limits/excluded_users/list", e, "team", "api", "rpc", "members.read");
    }, _.teamMemberSpaceLimitsExcludedUsersListContinue = function(e) {
        return this.request("team/member_space_limits/excluded_users/list/continue", e, "team", "api", "rpc", "members.read");
    }, _.teamMemberSpaceLimitsExcludedUsersRemove = function(e) {
        return this.request("team/member_space_limits/excluded_users/remove", e, "team", "api", "rpc", "members.write");
    }, _.teamMemberSpaceLimitsGetCustomQuota = function(e) {
        return this.request("team/member_space_limits/get_custom_quota", e, "team", "api", "rpc", "members.read");
    }, _.teamMemberSpaceLimitsRemoveCustomQuota = function(e) {
        return this.request("team/member_space_limits/remove_custom_quota", e, "team", "api", "rpc", "members.write");
    }, _.teamMemberSpaceLimitsSetCustomQuota = function(e) {
        return this.request("team/member_space_limits/set_custom_quota", e, "team", "api", "rpc", "members.read");
    }, _.teamMembersAddV2 = function(e) {
        return this.request("team/members/add_v2", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersAdd = function(e) {
        return this.request("team/members/add", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersAddJobStatusGetV2 = function(e) {
        return this.request("team/members/add/job_status/get_v2", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersAddJobStatusGet = function(e) {
        return this.request("team/members/add/job_status/get", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersDeleteProfilePhotoV2 = function(e) {
        return this.request("team/members/delete_profile_photo_v2", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersDeleteProfilePhoto = function(e) {
        return this.request("team/members/delete_profile_photo", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersGetAvailableTeamMemberRoles = function() {
        return this.request("team/members/get_available_team_member_roles", null, "team", "api", "rpc", "members.read");
    }, _.teamMembersGetInfoV2 = function(e) {
        return this.request("team/members/get_info_v2", e, "team", "api", "rpc", "members.read");
    }, _.teamMembersGetInfo = function(e) {
        return this.request("team/members/get_info", e, "team", "api", "rpc", "members.read");
    }, _.teamMembersListV2 = function(e) {
        return this.request("team/members/list_v2", e, "team", "api", "rpc", "members.read");
    }, _.teamMembersList = function(e) {
        return this.request("team/members/list", e, "team", "api", "rpc", "members.read");
    }, _.teamMembersListContinueV2 = function(e) {
        return this.request("team/members/list/continue_v2", e, "team", "api", "rpc", "members.read");
    }, _.teamMembersListContinue = function(e) {
        return this.request("team/members/list/continue", e, "team", "api", "rpc", "members.read");
    }, _.teamMembersMoveFormerMemberFiles = function(e) {
        return this.request("team/members/move_former_member_files", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersMoveFormerMemberFilesJobStatusCheck = function(e) {
        return this.request("team/members/move_former_member_files/job_status/check", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersRecover = function(e) {
        return this.request("team/members/recover", e, "team", "api", "rpc", "members.delete");
    }, _.teamMembersRemove = function(e) {
        return this.request("team/members/remove", e, "team", "api", "rpc", "members.delete");
    }, _.teamMembersRemoveJobStatusGet = function(e) {
        return this.request("team/members/remove/job_status/get", e, "team", "api", "rpc", "members.delete");
    }, _.teamMembersSecondaryEmailsAdd = function(e) {
        return this.request("team/members/secondary_emails/add", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSecondaryEmailsDelete = function(e) {
        return this.request("team/members/secondary_emails/delete", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSecondaryEmailsResendVerificationEmails = function(e) {
        return this.request("team/members/secondary_emails/resend_verification_emails", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSendWelcomeEmail = function(e) {
        return this.request("team/members/send_welcome_email", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSetAdminPermissionsV2 = function(e) {
        return this.request("team/members/set_admin_permissions_v2", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSetAdminPermissions = function(e) {
        return this.request("team/members/set_admin_permissions", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSetProfileV2 = function(e) {
        return this.request("team/members/set_profile_v2", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSetProfile = function(e) {
        return this.request("team/members/set_profile", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSetProfilePhotoV2 = function(e) {
        return this.request("team/members/set_profile_photo_v2", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSetProfilePhoto = function(e) {
        return this.request("team/members/set_profile_photo", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersSuspend = function(e) {
        return this.request("team/members/suspend", e, "team", "api", "rpc", "members.write");
    }, _.teamMembersUnsuspend = function(e) {
        return this.request("team/members/unsuspend", e, "team", "api", "rpc", "members.write");
    }, _.teamNamespacesList = function(e) {
        return this.request("team/namespaces/list", e, "team", "api", "rpc", "team_data.member");
    }, _.teamNamespacesListContinue = function(e) {
        return this.request("team/namespaces/list/continue", e, "team", "api", "rpc", "team_data.member");
    }, _.teamPropertiesTemplateAdd = function(e) {
        return this.request("team/properties/template/add", e, "team", "api", "rpc", "files.team_metadata.write");
    }, _.teamPropertiesTemplateGet = function(e) {
        return this.request("team/properties/template/get", e, "team", "api", "rpc", "files.team_metadata.write");
    }, _.teamPropertiesTemplateList = function() {
        return this.request("team/properties/template/list", null, "team", "api", "rpc", "files.team_metadata.write");
    }, _.teamPropertiesTemplateUpdate = function(e) {
        return this.request("team/properties/template/update", e, "team", "api", "rpc", "files.team_metadata.write");
    }, _.teamReportsGetActivity = function(e) {
        return this.request("team/reports/get_activity", e, "team", "api", "rpc", "team_info.read");
    }, _.teamReportsGetDevices = function(e) {
        return this.request("team/reports/get_devices", e, "team", "api", "rpc", "team_info.read");
    }, _.teamReportsGetMembership = function(e) {
        return this.request("team/reports/get_membership", e, "team", "api", "rpc", "team_info.read");
    }, _.teamReportsGetStorage = function(e) {
        return this.request("team/reports/get_storage", e, "team", "api", "rpc", "team_info.read");
    }, _.teamTeamFolderActivate = function(e) {
        return this.request("team/team_folder/activate", e, "team", "api", "rpc", "team_data.content.write");
    }, _.teamTeamFolderArchive = function(e) {
        return this.request("team/team_folder/archive", e, "team", "api", "rpc", "team_data.content.write");
    }, _.teamTeamFolderArchiveCheck = function(e) {
        return this.request("team/team_folder/archive/check", e, "team", "api", "rpc", "team_data.content.write");
    }, _.teamTeamFolderCreate = function(e) {
        return this.request("team/team_folder/create", e, "team", "api", "rpc", "team_data.content.write");
    }, _.teamTeamFolderGetInfo = function(e) {
        return this.request("team/team_folder/get_info", e, "team", "api", "rpc", "team_data.content.read");
    }, _.teamTeamFolderList = function(e) {
        return this.request("team/team_folder/list", e, "team", "api", "rpc", "team_data.content.read");
    }, _.teamTeamFolderListContinue = function(e) {
        return this.request("team/team_folder/list/continue", e, "team", "api", "rpc", "team_data.content.read");
    }, _.teamTeamFolderPermanentlyDelete = function(e) {
        return this.request("team/team_folder/permanently_delete", e, "team", "api", "rpc", "team_data.content.write");
    }, _.teamTeamFolderRename = function(e) {
        return this.request("team/team_folder/rename", e, "team", "api", "rpc", "team_data.content.write");
    }, _.teamTeamFolderUpdateSyncSettings = function(e) {
        return this.request("team/team_folder/update_sync_settings", e, "team", "api", "rpc", "team_data.content.write");
    }, _.teamTokenGetAuthenticatedAdmin = function() {
        return this.request("team/token/get_authenticated_admin", null, "team", "api", "rpc", "team_info.read");
    }, _.teamLogGetEvents = function(e) {
        return this.request("team_log/get_events", e, "team", "api", "rpc", "events.read");
    }, _.teamLogGetEventsContinue = function(e) {
        return this.request("team_log/get_events/continue", e, "team", "api", "rpc", "events.read");
    }, _.usersFeaturesGetValues = function(e) {
        return this.request("users/features/get_values", e, "user", "api", "rpc", "account_info.read");
    }, _.usersGetAccount = function(e) {
        return this.request("users/get_account", e, "user", "api", "rpc", "sharing.read");
    }, _.usersGetAccountBatch = function(e) {
        return this.request("users/get_account_batch", e, "user", "api", "rpc", "sharing.read");
    }, _.usersGetCurrentAccount = function() {
        return this.request("users/get_current_account", null, "user", "api", "rpc", "account_info.read");
    }, _.usersGetSpaceUsage = function() {
        return this.request("users/get_space_usage", null, "user", "api", "rpc", "account_info.read");
    };
    function q(e) {
        var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : m, r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : ".";
        return (r ? (t !== m && void 0 !== d[e] && (e = d[e], r = "-"), "https://".concat(e).concat(r)) : "https://").concat(t, "/2/");
    }
    function v() {
        var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : m, t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : ".", r = "api";
        return e !== m && (r = d[r], t = "-"), "https://".concat(r).concat(t).concat(e, "/oauth2/token");
    }
    function w(e) {
        return JSON.stringify(e).replace(/[\u007f-\uffff]/g, g);
    }
    function y() {
        return "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope || "undefined" == typeof module || "undefined" != typeof window;
    }
    function A() {
        return "undefined" != typeof window;
    }
    function S() {
        return "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope;
    }
    function C(e) {
        return e.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }
    function R(r, s, i) {
        t(this, R), this.status = r, this.headers = s, this.result = i;
    }
    var T, L, M, P = function(e) {
        !function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && n(e, t);
        }(u, e);
        r = u, s = a();
        var r, s, o = function() {
            var n, t = i(r);
            return function(e, t) {
                return !t || "object" != typeof t && "function" != typeof t ? function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e;
                }(e) : t;
            }(this, s ? (n = i(this).constructor, Reflect.construct(t, arguments, n)) : t.apply(this, arguments));
        };
        function u(e, r, s) {
            var i;
            return t(this, u), (i = o.call(this, "Response failed with a ".concat(e, " code"))).name = "DropboxResponseError", 
            i.status = e, i.headers = r, i.error = s, i;
        }
        return u;
    }(u(Error));
    function F(e) {
        return e.text().then(function(t) {
            var r;
            try {
                r = JSON.parse(t);
            } catch (e) {
                r = t;
            }
            throw new P(e.status, e.headers, r);
        });
    }
    function D(e) {
        return e.ok ? e.text().then(function(t) {
            var r;
            try {
                r = JSON.parse(t);
            } catch (e) {
                r = t;
            }
            return new R(e.status, e.headers, r);
        }) : F(e);
    }
    var G = [ "legacy", "offline", "online" ], U = [ "code", "token" ], x = [ "none", "user", "team" ], E = function() {
        function e(r) {
            t(this, e), r = r || {}, L = A() ? (T = window.fetch.bind(window), window.crypto || window.msCrypto) : S() ? (T = self.fetch.bind(self), 
            self.crypto) : (T = require("node-fetch"), require("crypto")), M = "undefined" == typeof TextEncoder ? require("util").TextEncoder : TextEncoder, 
            this.fetch = r.fetch || T, this.accessToken = r.accessToken, this.accessTokenExpiresAt = r.accessTokenExpiresAt, 
            this.refreshToken = r.refreshToken, this.clientId = r.clientId, this.clientSecret = r.clientSecret, 
            this.domain = r.domain, this.domainDelimiter = r.domainDelimiter, this.customHeaders = r.customHeaders, 
            this.dataOnBody = r.dataOnBody;
        }
        return s(e, [ {
            key: "setAccessToken",
            value: function(e) {
                this.accessToken = e;
            }
        }, {
            key: "getAccessToken",
            value: function() {
                return this.accessToken;
            }
        }, {
            key: "setClientId",
            value: function(e) {
                this.clientId = e;
            }
        }, {
            key: "getClientId",
            value: function() {
                return this.clientId;
            }
        }, {
            key: "setClientSecret",
            value: function(e) {
                this.clientSecret = e;
            }
        }, {
            key: "getClientSecret",
            value: function() {
                return this.clientSecret;
            }
        }, {
            key: "getRefreshToken",
            value: function() {
                return this.refreshToken;
            }
        }, {
            key: "setRefreshToken",
            value: function(e) {
                this.refreshToken = e;
            }
        }, {
            key: "getAccessTokenExpiresAt",
            value: function() {
                return this.accessTokenExpiresAt;
            }
        }, {
            key: "setAccessTokenExpiresAt",
            value: function(e) {
                this.accessTokenExpiresAt = e;
            }
        }, {
            key: "setCodeVerifier",
            value: function(e) {
                this.codeVerifier = e;
            }
        }, {
            key: "getCodeVerifier",
            value: function() {
                return this.codeVerifier;
            }
        }, {
            key: "generateCodeChallenge",
            value: function() {
                var e, t = this, r = new M().encode(this.codeVerifier);
                return A() || S() ? L.subtle.digest("SHA-256", r).then(function(r) {
                    r = btoa(String.fromCharCode.apply(null, new Uint8Array(r)));
                    e = C(r).substr(0, 128), t.codeChallenge = e;
                }) : (e = C(L.createHash("sha256").update(r).digest()), this.codeChallenge = e, 
                Promise.resolve());
            }
        }, {
            key: "generatePKCECodes",
            value: function() {
                var t;
                return t = (A() || S() ? (t = new Uint8Array(128), t = L.getRandomValues(t), 
                C(btoa(t))) : C(L.randomBytes(128))).substr(0, 128), this.codeVerifier = t, 
                this.generateCodeChallenge();
            }
        }, {
            key: "getAuthenticationUrl",
            value: function(e, t) {
                var r, s = this, i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "token", n = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null, a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : null, o = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : "none", u = 6 < arguments.length && void 0 !== arguments[6] && arguments[6], c = this.getClientId(), p = function() {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : h;
                    return e !== h && (e = "meta-".concat(e)), "https://".concat(e, "/oauth2/authorize");
                }(this.domain);
                if (!c) throw Error("A client id is required. You can set the client id using .setClientId().");
                if ("code" !== i && !e) throw Error("A redirect uri is required.");
                if (!U.includes(i)) throw Error("Authorization type must be code or token");
                if (n && !G.includes(n)) throw Error("Token Access Type must be legacy, offline, or online");
                if (a && !(a instanceof Array)) throw Error("Scope must be an array of strings");
                if (x.includes(o)) return r = "".concat(p, "code" === i ? "?response_type=code&client_id=" : "?response_type=token&client_id=").concat(c), 
                e && (r += "&redirect_uri=".concat(e)), t && (r += "&state=".concat(t)), 
                n && (r += "&token_access_type=".concat(n)), a && (r += "&scope=".concat(a.join(" "))), 
                "none" !== o && (r += "&include_granted_scopes=".concat(o)), u ? this.generatePKCECodes().then(function() {
                    return r = (r += "&code_challenge_method=S256") + "&code_challenge=".concat(s.codeChallenge);
                }) : Promise.resolve(r);
                throw Error("includeGrantedScopes must be none, user, or team");
            }
        }, {
            key: "getAccessTokenFromCode",
            value: function(e, t) {
                var r = this.getClientId(), s = this.getClientSecret();
                if (!r) throw Error("A client id is required. You can set the client id using .setClientId().");
                var i = v(this.domain, this.domainDelimiter), i = (i = (i += "?grant_type=authorization_code") + "&code=".concat(t)) + "&client_id=".concat(r);
                if (s) i += "&client_secret=".concat(s); else {
                    if (!this.codeVerifier) throw Error("You must use PKCE when generating the authorization URL to not include a client secret");
                    i += "&code_verifier=".concat(this.codeVerifier);
                }
                return e && (i += "&redirect_uri=".concat(e)), this.fetch(i, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded"
                    }
                }).then(D);
            }
        }, {
            key: "checkAndRefreshAccessToken",
            value: function() {
                var e = this.getRefreshToken() && this.getClientId(), t = !this.getAccessTokenExpiresAt() || new Date(Date.now() + 3e5) >= this.getAccessTokenExpiresAt(), r = !this.getAccessToken();
                return (t || r) && e ? this.refreshAccessToken() : Promise.resolve();
            }
        }, {
            key: "refreshAccessToken",
            value: function() {
                var i, n, a, e = this, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null, r = this.getClientId(), s = this.getClientSecret();
                if (!r) throw Error("A client id is required. You can set the client id using .setClientId().");
                if (!t || t instanceof Array) return i = v(this.domain, this.domainDelimiter), 
                n = {
                    headers: {
                        "Content-Type": "application/json"
                    },
                    method: "POST"
                }, this.dataOnBody ? (a = {
                    grant_type: "refresh_token",
                    client_id: r,
                    refresh_token: this.getRefreshToken()
                }, s && (a.client_secret = s), t && (a.scope = t.join(" ")), n.body = a) : (i = (i += "?grant_type=refresh_token&refresh_token=".concat(this.getRefreshToken())) + "&client_id=".concat(r), 
                s && (i += "&client_secret=".concat(s)), t && (i += "&scope=".concat(t.join(" ")))), 
                this.fetch(i, n).then(D).then(function(t) {
                    e.setAccessToken(t.result.access_token), e.setAccessTokenExpiresAt(function(e) {
                        return new Date(Date.now() + 1e3 * e);
                    }(t.result.expires_in));
                });
                throw Error("Scope must be an array of strings");
            }
        } ]), e;
    }(), B = "undefined" == typeof btoa ? function(e) {
        return Buffer.from(e).toString("base64");
    } : btoa;
    e.Dropbox = function() {
        function e(r) {
            t(this, e), this.auth = (r = r || {}).auth ? r.auth : new E(r), this.fetch = r.fetch || this.auth.fetch, 
            this.selectUser = r.selectUser, this.selectAdmin = r.selectAdmin, this.pathRoot = r.pathRoot, 
            this.domain = r.domain || this.auth.domain, this.domainDelimiter = r.domainDelimiter || this.auth.domainDelimiter, 
            this.customHeaders = r.customHeaders || this.auth.customHeaders, Object.assign(this, _);
        }
        return s(e, [ {
            key: "request",
            value: function(e, t, r, s, i) {
                switch (i) {
                  case "rpc":
                    return this.rpcRequest(e, t, r, s);

                  case "download":
                    return this.downloadRequest(e, t, r, s);

                  case "upload":
                    return this.uploadRequest(e, t, r, s);

                  default:
                    throw Error("Invalid request style: ".concat(i));
                }
            }
        }, {
            key: "rpcRequest",
            value: function(e, t, r, s) {
                var i = this;
                return this.auth.checkAndRefreshAccessToken().then(function() {
                    var e = {
                        method: "POST",
                        body: t ? JSON.stringify(t) : null,
                        headers: {}
                    };
                    return t && (e.headers["Content-Type"] = "application/json"), 
                    i.setAuthHeaders(r, e), i.setCommonHeaders(e), e;
                }).then(function(t) {
                    return i.fetch(q(s, i.domain, i.domainDelimiter) + e, t);
                }).then(D);
            }
        }, {
            key: "downloadRequest",
            value: function(e, t, r, s) {
                var i = this;
                return this.auth.checkAndRefreshAccessToken().then(function() {
                    var e = {
                        method: "POST",
                        headers: {
                            "Dropbox-API-Arg": w(t)
                        }
                    };
                    return i.setAuthHeaders(r, e), i.setCommonHeaders(e), e;
                }).then(function(t) {
                    return i.fetch(q(s, i.domain, i.domainDelimiter) + e, t);
                }).then(function(e) {
                    return e.ok ? new Promise(function(t) {
                        y() ? e.blob().then(function(e) {
                            return t(e);
                        }) : e.buffer().then(function(e) {
                            return t(e);
                        });
                    }).then(function(t) {
                        var r = JSON.parse(e.headers.get("dropbox-api-result"));
                        return y() ? r.fileBlob = t : r.fileBinary = t, new R(e.status, e.headers, r);
                    }) : F(e);
                });
            }
        }, {
            key: "uploadRequest",
            value: function(e, t, r, s) {
                var i = this;
                return this.auth.checkAndRefreshAccessToken().then(function() {
                    var e = t.contents, e = (delete t.contents, {
                        body: e,
                        method: "POST",
                        headers: {
                            "Content-Type": "application/octet-stream",
                            "Dropbox-API-Arg": w(t)
                        }
                    });
                    return i.setAuthHeaders(r, e), i.setCommonHeaders(e), e;
                }).then(function(t) {
                    return i.fetch(q(s, i.domain, i.domainDelimiter) + e, t);
                }).then(D);
            }
        }, {
            key: "setAuthHeaders",
            value: function(e, t) {
                var r, s;
                switch (1 < e.split(",").length && ((r = e.replace(" ", "").split(",")).includes(l) && this.auth.getAccessToken() ? e = l : r.includes(f) && this.auth.getAccessToken() ? e = f : r.includes(p) && (e = p)), 
                e) {
                  case p:
                    this.auth.clientId && this.auth.clientSecret && (s = B("".concat(this.auth.clientId, ":").concat(this.auth.clientSecret)), 
                    t.headers.Authorization = "Basic ".concat(s));
                    break;

                  case f:
                  case l:
                    this.auth.getAccessToken() && (t.headers.Authorization = "Bearer ".concat(this.auth.getAccessToken()));
                    break;

                  case "noauth":
                  case "cookie":
                    break;

                  default:
                    throw Error("Unhandled auth type: ".concat(e));
                }
            }
        }, {
            key: "setCommonHeaders",
            value: function(e) {
                var t = this;
                this.selectUser && (e.headers["Dropbox-API-Select-User"] = this.selectUser), 
                this.selectAdmin && (e.headers["Dropbox-API-Select-Admin"] = this.selectAdmin), 
                this.pathRoot && (e.headers["Dropbox-API-Path-Root"] = this.pathRoot), 
                this.customHeaders && Object.keys(this.customHeaders).forEach(function(r) {
                    e.headers[r] = t.customHeaders[r];
                });
            }
        } ]), e;
    }(), e.DropboxAuth = E, e.DropboxResponse = R, e.DropboxResponseError = P, Object.defineProperty(e, "__esModule", {
        value: !0
    });
}), !function(q, u, c) {
    function v(a, b, g) {
        a.addEventListener ? a.addEventListener(b, g, !1) : a.attachEvent("on" + b, g);
    }
    function z(a) {
        var b;
        return "keypress" == a.type ? (b = String.fromCharCode(a.which), a.shiftKey ? b : b.toLowerCase()) : n[a.which] || r[a.which] || String.fromCharCode(a.which).toLowerCase();
    }
    function w(a) {
        return "shift" == a || "ctrl" == a || "alt" == a || "meta" == a;
    }
    function A(a, b) {
        for (var d = [], e = "+" === (e = a) ? [ "+" ] : (e = e.replace(/\+{2}/g, "+plus")).split("+"), g = 0; g < e.length; ++g) {
            var m = e[g];
            B[m] && (m = B[m]), b && "keypress" != b && C[m] && (m = C[m], d.push("shift")), 
            w(m) && d.push(m);
        }
        if (e = m, !(g = b)) {
            if (!p) for (var c in p = {}, n) 95 < c && c < 112 || n.hasOwnProperty(c) && (p[n[c]] = c);
            g = p[e] ? "keydown" : "keypress";
        }
        return {
            key: m,
            modifiers: d,
            action: g = "keypress" == g && d.length ? "keydown" : g
        };
    }
    function d(a) {
        function b(a) {
            a = a || {};
            var l, b = !1;
            for (l in p) a[l] ? b = !0 : p[l] = 0;
            b || (x = !1);
        }
        function g(a, b, t, f, g, d) {
            var l, E = [], h = t.type;
            if (!k._callbacks[a]) return [];
            for ("keyup" == h && w(a) && (b = [ a ]), l = 0; l < k._callbacks[a].length; ++l) {
                var e, c = k._callbacks[a][l];
                !f && c.seq && p[c.seq] != c.level || h != c.action || ((e = "keypress" == h && !t.metaKey && !t.ctrlKey) || (e = c.modifiers, 
                e = b.sort().join(",") === e.sort().join(",")), e && (e = f && c.seq == f && c.level == d, 
                (!f && c.combo == g || e) && k._callbacks[a].splice(l, 1), E.push(c)));
            }
            return E;
        }
        function c(a, b, c, f) {
            k.stopCallback(b, b.target || b.srcElement, c, f) || !1 !== a(b, c) || (b.preventDefault ? b.preventDefault() : b.returnValue = !1, 
            b.stopPropagation ? b.stopPropagation() : b.cancelBubble = !0);
        }
        function e(a) {
            "number" != typeof a.which && (a.which = a.keyCode);
            var b = z(a);
            b && ("keyup" == a.type && y === b ? y = !1 : k.handleKey(b, function(a) {
                var b = [];
                return a.shiftKey && b.push("shift"), a.altKey && b.push("alt"), 
                a.ctrlKey && b.push("ctrl"), a.metaKey && b.push("meta"), b;
            }(a), a));
        }
        function m(a, g, t, f) {
            function l(g) {
                c(t, g, a), "keyup" !== f && (y = z(g)), setTimeout(b, 10);
            }
            for (var d = p[a] = 0; d < g.length; ++d) {
                var e = d + 1 === g.length ? l : function(c) {
                    return function() {
                        x = c, ++p[a], clearTimeout(q), q = setTimeout(b, 1e3);
                    };
                }(f || A(g[d + 1]).action);
                n(g[d], e, f, a, d);
            }
        }
        function n(a, b, c, f, d) {
            k._directMap[a + ":" + c] = b;
            var e = (a = a.replace(/\s+/g, " ")).split(" ");
            1 < e.length ? m(a, e, b, c) : (c = A(a, c), k._callbacks[c.key] = k._callbacks[c.key] || [], 
            g(c.key, c.modifiers, {
                type: c.action
            }, f, a, d), k._callbacks[c.key][f ? "unshift" : "push"]({
                callback: b,
                modifiers: c.modifiers,
                action: c.action,
                seq: f,
                level: d,
                combo: a
            }));
        }
        var k = this;
        if (a = a || u, !(k instanceof d)) return new d(a);
        k.target = a, k._callbacks = {}, k._directMap = {};
        var q, p = {}, y = !1, r = !1, x = !1;
        k._handleKey = function(a, d, e) {
            for (var f = g(a, d, e), k = 0, l = !(d = {}), h = 0; h < f.length; ++h) f[h].seq && (k = Math.max(k, f[h].level));
            for (h = 0; h < f.length; ++h) f[h].seq ? f[h].level == k && (l = !0, 
            d[f[h].seq] = 1, c(f[h].callback, e, f[h].combo, f[h].seq)) : l || c(f[h].callback, e, f[h].combo);
            f = "keypress" == e.type && r, e.type != x || w(a) || f || b(d), r = l && "keydown" == e.type;
        }, k._bindMultiple = function(a, b, c) {
            for (var d = 0; d < a.length; ++d) n(a[d], b, c);
        }, v(a, "keypress", e), v(a, "keydown", e), v(a, "keyup", e);
    }
    if (q) {
        var p, n = {
            8: "backspace",
            9: "tab",
            13: "enter",
            16: "shift",
            17: "ctrl",
            18: "alt",
            20: "capslock",
            27: "esc",
            32: "space",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            45: "ins",
            46: "del",
            91: "meta",
            93: "meta",
            224: "meta"
        }, r = {
            106: "*",
            107: "+",
            109: "-",
            110: ".",
            111: "/",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'"
        }, C = {
            "~": "`",
            "!": "1",
            "@": "2",
            "#": "3",
            $: "4",
            "%": "5",
            "^": "6",
            "&": "7",
            "*": "8",
            "(": "9",
            ")": "0",
            _: "-",
            "+": "=",
            ":": ";",
            '"': "'",
            "<": ",",
            ">": ".",
            "?": "/",
            "|": "\\"
        }, B = {
            option: "alt",
            command: "meta",
            return: "enter",
            escape: "esc",
            plus: "+",
            mod: /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
        };
        for (c = 1; c < 20; ++c) n[111 + c] = "f" + c;
        for (c = 0; c <= 9; ++c) n[c + 96] = c.toString();
        d.prototype.bind = function(a, b, c) {
            return a = a instanceof Array ? a : [ a ], this._bindMultiple.call(this, a, b, c), 
            this;
        }, d.prototype.unbind = function(a, b) {
            return this.bind.call(this, a, function() {}, b);
        }, d.prototype.trigger = function(a, b) {
            return this._directMap[a + ":" + b] && this._directMap[a + ":" + b]({}, a), 
            this;
        }, d.prototype.reset = function() {
            return this._callbacks = {}, this._directMap = {}, this;
        }, d.prototype.stopCallback = function(a, b) {
            var c;
            return !(-1 < (" " + b.className + " ").indexOf(" mousetrap ") || function D(a, b) {
                return null !== a && a !== u && (a === b || D(a.parentNode, b));
            }(b, this.target)) && ("composedPath" in a && "function" == typeof a.composedPath && ((c = a.composedPath()[0]) !== a.target && (b = c)), 
            "INPUT" == b.tagName || "SELECT" == b.tagName || "TEXTAREA" == b.tagName || b.isContentEditable);
        }, d.prototype.handleKey = function() {
            return this._handleKey.apply(this, arguments);
        }, d.addKeycodes = function(a) {
            for (var b in a) a.hasOwnProperty(b) && (n[b] = a[b]);
            p = null;
        }, (d.init = function() {
            var b, a = d(u);
            for (b in a) "_" !== b.charAt(0) && (d[b] = function(b) {
                return function() {
                    return a[b].apply(a, arguments);
                };
            }(b));
        })(), q.Mousetrap = d, "undefined" != typeof module && module.exports && (module.exports = d), 
        "function" == typeof define && define.amd && define(function() {
            return d;
        });
    }
}("undefined" != typeof window ? window : null, "undefined" != typeof window ? document : null);

var Typo = function(dictionary, affData, wordsData, settings) {
    if (this.platform = (settings = settings || {}).platform || "chrome", this.dictionary = null, 
    this.rules = {}, this.dictionaryTable = {}, this.compoundRules = [], this.compoundRuleCodes = {}, 
    this.replacementTable = [], this.flags = settings.flags || {}, dictionary) {
        this.dictionary = dictionary, wordsData = "chrome" == this.platform ? (affData = affData || this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + dictionary + "/" + dictionary + ".aff")), 
        wordsData || this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + dictionary + "/" + dictionary + ".dic"))) : (settings = settings.dictionaryPath || "", 
        affData = affData || this._readFile(settings + "/" + dictionary + "/" + dictionary + ".aff"), 
        wordsData || this._readFile(settings + "/" + dictionary + "/" + dictionary + ".dic")), 
        this.rules = this._parseAFF(affData), this.compoundRuleCodes = {};
        for (var i = 0, _len = this.compoundRules.length; i < _len; i++) for (var rule = this.compoundRules[i], j = 0, _jlen = rule.length; j < _jlen; j++) this.compoundRuleCodes[rule[j]] = [];
        for (i in "ONLYINCOMPOUND" in this.flags && (this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = []), 
        this.dictionaryTable = this._parseDIC(wordsData), this.compoundRuleCodes) 0 == this.compoundRuleCodes[i].length && delete this.compoundRuleCodes[i];
        for (i = 0, _len = this.compoundRules.length; i < _len; i++) {
            for (var ruleText = this.compoundRules[i], expressionText = "", j = 0, _jlen = ruleText.length; j < _jlen; j++) {
                var character = ruleText[j];
                character in this.compoundRuleCodes ? expressionText += "(" + this.compoundRuleCodes[character].join("|") + ")" : expressionText += character;
            }
            this.compoundRules[i] = new RegExp(expressionText, "i");
        }
    }
    return this;
}, fs, mkdirp, trash, getDirName, gui, updater, win, getDirName;

function IDEViewModel() {
    function __normalizePath(path) {
        return path = path.replace(/\\/g, "/");
    }
    function CSIDEProject(projectData) {
        var self = this, name = ko.observable(projectData.name || (getLastDirName(projectData.path) ? getLastDirName(projectData.path) : "Untitled")), path = ko.observable().extend({
            normalizePaths: ""
        }), scenes = (path(projectData.path), ko.observableArray([])), issues = ko.observableArray([]), console_logs = ko.observableArray([]).extend({
            rateLimit: {
                timeout: 100
            },
            callFunc: {
                func: function() {
                    setTimeout(function() {
                        var ul = $("#cs-console > ul")[0];
                        ul && (ul.scrollTop = ul.scrollHeight);
                    }, 100);
                }
            }
        }), unreadLogs = ko.observable(0), consoleOpen = ko.observable(!1), source = projectData.source, expanded = ko.observable(!1 !== projectData.expanded), locked = ko.observable(!1), readOnly = ko.observable(projectData.readOnly || !1), editing = ko.observable(!1), invalidName = ko.observable(!1);
        self.getName = ko.computed(function() {
            return name();
        }, this), self.getPath = ko.computed(function() {
            return path();
        }, this), self.getScenes = scenes, self.getIssues = ko.computed(function() {
            return issues();
        }, this), self.consoleOpen = ko.computed(function() {
            return consoleOpen();
        }, this), self.getLogs = ko.computed(function() {
            return console_logs();
        }, this), self.getUnreadLogCount = ko.computed(function() {
            return unreadLogs();
        }, this), self.issueCount = ko.computed(function() {
            return issues().length;
        }, this), self.getSource = function() {
            return source;
        }, self.isExpanded = ko.computed(function() {
            return expanded();
        }, this), self.isLocked = ko.computed(function() {
            return locked();
        }, this), self.isReadOnly = ko.computed(function() {
            return readOnly();
        }, this), self.beingEdited = ko.computed(function() {
            return editing();
        }, this), self.nameInvalid = ko.computed(function() {
            return invalidName();
        }, this), self.isDirty = ko.computed(function() {
            for (var i = 0; i < scenes().length; i++) {
                if (scenes()[i].isDirty()) return !0;
                if (i === scenes().length - 1) return !1;
            }
        }), self.getWordCount = function(exclCommandLines, selected) {
            exclCommandLines = exclCommandLines || !1;
            for (var wordCount = 0, i = 0; i < scenes().length; i++) wordCount += scenes()[i].getWordCount(exclCommandLines, selected);
            return wordCount;
        }, self.getCharCount = function(selected) {
            for (var charCount = 0, i = 0; i < scenes().length; i++) charCount += scenes()[i].getCharCount(selected);
            return charCount;
        }, self.logToConsole = function(log, type, meta) {
            "boolean" != typeof log && "number" != typeof log && "string" != typeof log || ("string" != typeof type && (type = ""), 
            999 < console_logs().length && console_logs.shift(), meta ? "string" == typeof meta.scene && "number" == typeof meta.line ? console_logs.push({
                value: log,
                type: type || "null",
                scene: meta.scene || "",
                line: meta.line || ""
            }) : (console.log(typeof meta.scene, typeof meta.line), console_logs.push({
                value: "Error: attempt to log bad meta data logged to project console!",
                type: "cm-error"
            })) : console_logs.push({
                value: log,
                type: type || "null"
            }), consoleOpen() || "system" == type || unreadLogs(unreadLogs() < 8 ? unreadLogs() + 1 : "9+"));
        }, self.toggleConsole = function(force) {
            return consoleOpen("boolean" == typeof force ? force : !consoleOpen()), 
            consoleOpen() && unreadLogs(0), consoleOpen();
        }, self.clearConsole = function() {
            console_logs.removeAll();
        }, self.dismissAllIssues = function() {
            for (var issueBuffer = [], issueList = issues(), o = 0; o < issueList.length; o++) issueBuffer.push(issueList[o]);
            for (var i = 0; i < issueBuffer.length; i++) issueBuffer[i].dismiss();
            __selectTab("game");
        }, self.setExpand = function(boole, event) {
            "boolean" != typeof boole ? expanded() ? expanded(!1) : expanded(!0) : expanded(boole);
        }, self.nameInterface = ko.pureComputed({
            read: function() {
                return name();
            },
            write: function(newValue) {
                validName(newValue, !0, function(valid, errMsg) {
                    invalidName(!valid), valid ? name(newValue) : console.log(errMsg);
                });
            },
            owner: this
        }), self.rename = function(data, event) {
            if (!readOnly() && ("keyup" != event.type || 13 == event.keyCode || 27 == event.keyCode)) {
                if ("dblclick" != event.type) return invalidName() && editing() ? void 0 : (editing(!1), 
                void __updatePersistenceList());
                editing(!0), setTimeout(function() {
                    $(event.target).focus().select();
                }, 10);
            }
        }, self.run = function() {
            locked() || (locked(!0), self.isDirty() ? bootbox.confirm("This project has unsaved changes, these will not appear in the test run, do you wish to continue?", function(result) {
                result && __runProject(self);
            }) : __runProject(self), setTimeout(function() {
                locked(!1);
            }, 5e3));
        }, self.openFolder = function() {
            __openFolder(path());
        }, self.close = function() {
            var project;
            (project = self).isDirty() ? bootbox.confirm("This project has unsaved scenes, are you sure you wish to close it?", function(result) {
                result && (project === selectedProject() && (selectedProject() == activeProject() && activeProject(null), 
                selectedScene(""), editor.setValue(""), __getTab("game").href("")), 
                projects.remove(project), __updatePersistenceList());
            }) : (project === selectedProject() && (selectedProject() == activeProject() && activeProject(null), 
            selectedScene(""), editor.setValue(""), __getTab("game").href("")), 
            projects.remove(project), __updatePersistenceList());
        }, self.select = function() {
            for (var i = 0; i < scenes().length; i++) if (scenes()[i].select()) return !0;
            return !1;
        }, self.save = function(cb) {
            "function" != typeof cb && (cb = function() {});
            var failed = !1, count = scenes().length;
            scenes().forEach(function(scene, index) {
                failed || scene.save(null, null, function(err) {
                    if (err) return failed = !0, cb(err);
                    0 == --count && cb(null);
                });
            });
        }, self.addNewScene = function(project, event) {
            readOnly() || (event && event.stopPropagation(), function(project, name) {
                "object" == typeof project && !function generateName(newName) {
                    sceneExists(newName, project, function(exists) {
                        var newScene;
                        exists ? (exists = newName.substring(newName.lastIndexOf("_") + 1, newName.length), 
                        exists = isNaN(exists) ? 0 : parseInt(exists) + 1, generateName("untitled_" + exists)) : (exists = project.getPath() + newName + ".txt", 
                        newScene = new CSIDEScene({
                            path: exists,
                            source: platform,
                            readOnly: project.isReadOnly()
                        }), project.addScene(newScene), newScene.save(null, null, function(err) {
                            err ? bootbox.alert(err.message) : newScene.load(function(err, scene) {
                                err || scene.select();
                            });
                        }));
                    });
                }(name || "untitled");
            }(self));
        }, self.addScene = function(scene) {
            scene.getProject() !== self && !1 !== scene.getProject() || scenes.push(scene);
        }, self.removeScene = function(scene) {
            -1 !== scenes().lastIndexOf(scene) && (scenes.remove(scene), scenes().length < 1 && projects.remove(self));
        }, self.closeScene = function(scene) {
            function closeScene() {
                selectedScene() == scene && (selectedScene(null), editor.setValue("")), 
                self.removeScene(scene), __updatePersistenceList();
            }
            scene.isDirty() ? bootbox.confirm("This scene has unsaved changes, are you sure you wish to close it?", function(result) {
                result && closeScene();
            }) : closeScene();
        }, self.exportScenes = function() {
            fh.selectFolder(function(newPath) {
                newPath && bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any files with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>", function(result) {
                    result && __copyProjectTo(path(), newPath, function(err) {
                        err ? notification("Error", err.message, {
                            type: "error"
                        }) : notification("Game Exported Successfully", "All scenes exported successfully to " + newPath, {
                            type: "success",
                            buttons: [ {
                                addClass: "btn",
                                text: "Show Folder",
                                onClick: function(note) {
                                    __openFolder(newPath), note.close();
                                }
                            } ]
                        }).setTimeout(1e4);
                    });
                });
            });
        }, self.compile = function() {
            fh.selectFolder(function(newPath) {
                newPath && bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any file with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>", function(result) {
                    var project, path;
                    result && (path = newPath, __shortCompile(project = self, function(err, allScenes) {
                        fh.readFile("compile_head.txt", function(err, headContents) {
                            fh.readFile("compile_tail.txt", function(err, tailContents) {
                                fh.writeFile(path + project.getName() + ".html", headContents + "<script>allScenes = " + JSON.stringify(allScenes) + "<\/script>" + tailContents, function(err) {
                                    if (err) throw new Error("Export failed!");
                                    err = [ {
                                        addClass: "btn",
                                        text: "Show Folder",
                                        onClick: function(note) {
                                            __openFolder(path), note.close();
                                        }
                                    } ];
                                    notification("Game Exported Successfully", project.getName(), {
                                        type: "success",
                                        buttons: err
                                    }).setTimeout(1e4);
                                });
                            });
                        });
                    }));
                });
            });
        }, self.test = function(test) {
            !function __testProject(project, test) {
                if ("random" != test && "quick" != test) return void alert("Error: no such test as " + test + "test!");
                if (void 0 === project || "" === project) return void alert("Error: no project given to " + test + "test!");
                var path = "node_modules/cside-choicescript/" + test + "test.html";
                activeProject(project);
                "web-dropbox" === platform ? (project.test_win = window.open(path, "Quicktest", "toolbar=0,location=0,status=0,menubar=0,scrollbars,resizable,width=500,height=400"), 
                project.test_win.addEventListener("beforeunload", function(event) {
                    project.test_win = null;
                }), setTimeout(function() {
                    project.test_win.title = test.toUpperCase() + "TEST - " + project.getName();
                }, 200)) : project.test_win ? (project.test_win.close(), project.test_win = null, 
                __testProject(project, test)) : nw.Window.open(path, {
                    focus: !0,
                    width: 500,
                    height: 500,
                    title: ""
                }, function(test_win) {
                    (project.test_win = test_win).on("closed", function() {
                        project.test_win.hide(), project.test_win.close(!0), project.test_win = null;
                    });
                });
            }(self, test);
        }, self.openAllScenes = function() {
            var projectPath;
            projectPath = self.getPath(), fh.readDir(projectPath, function(err, filepaths) {
                !function(err, filepaths) {
                    err ? console.log(err) : __openScenes(filepaths.filter(function(filepath) {
                        return ".txt" === getFileExtension(filepath) && !filepath.match(CONST_IMG_PREFIX);
                    }, !1).map(function(filepath) {
                        return projectPath + filepath;
                    }));
                }(err, filepaths);
            });
        }, self.reloadAllScenes = function() {
            for (var i = 0; i < scenes().length; i++) scenes()[i].load();
        }, self.logIssue = function(err, scene) {
            var lineNum = "number" == typeof err.lineNumber ? err.lineNumber - 1 : null, issue = new csideIssue({
                project: self,
                scene: scene,
                desc: err.message,
                lineNum: lineNum
            }), scene = (issues.push(issue), [ {
                addClass: "btn btn-danger",
                text: "Show",
                onClick: function(note) {
                    note.close(), issue.getLineNum() && issue.show(), selectedProject() != self && self.select(), 
                    __selectTab("issues");
                }
            } ]);
            notification("New Issue", "New issue with project " + name(), {
                type: "error",
                buttons: scene
            }).setTimeout(5e3);
        }, self.removeIssue = function(issue) {
            issues.remove(issue);
        };
    }
    function CSIDEScene(sceneData) {
        function renameSceneFile(newName) {
            var newPath;
            invalidName() || (saving(!0), newPath = self.getProject().getPath() + newName + ".txt", 
            fh.renameFile(path(), newPath, function(err) {
                !function(err) {
                    saving(!1), err ? bootbox.alert(err) : (fileStats.mtime ? fileStats.mtime = new Date() : fileStats.modifiedAt = new Date(), 
                    path(newPath), name(newName), __updatePersistenceList());
                }(err);
            }));
        }
        var self = this, path = ko.observable("").extend({
            normalizePaths: ""
        }), name = (path(sceneData.path), ko.observable("").extend({
            lowerCase: ""
        })), isImportant = (name(getSceneName(path())), name().toUpperCase().match(reservedSceneNames)), source = sceneData.source || platform, loaded = ko.observable(!1), locked = ko.observable(!1), readOnly = ko.observable(sceneData.readOnly || !1), dirty = ko.observable(!1), editing = ko.observable(!1), colouring = ko.observable(!1), saving = ko.observable(!1), inErrState = ko.observable(!1), errStateMsg = ko.observable(""), cmDoc = CodeMirror.Doc(sceneData.contents || "", "choicescript"), charCount = ko.observable(sceneData.contents ? sceneData.contents.length : 0), wordCount = ko.observable(0), cursor = ko.observable({
            line: 0,
            ch: 0
        }), selectedChars = ko.observable(0), history = cmDoc.getHistory(), fileStats = sceneData.stats || {
            mtime: new Date()
        }, markColour = ko.observable(sceneData.color || (isImportant ? "rgb(119, 151, 236)" : "rgb(119, 119, 119)")), issues = ko.observableArray([]), invalidName = ko.observable(!1), nameErrMsg = ko.observable();
        self.isLocked = ko.computed(function() {
            var curScene;
            return !!locked() || !(!(curScene = cside.getSelectedScene()) || !curScene.beingEdited() || curScene == self);
        }, this), self.getName = ko.computed(function() {
            return name();
        }, this), self.getPath = ko.computed(function() {
            return path();
        }, this), self.hasLoaded = ko.computed(function() {
            return loaded();
        }, this), self.isSaving = ko.computed(function() {
            return saving();
        }, this), self.isDirty = ko.computed(function() {
            return dirty();
        }, this), self.isReadOnly = ko.computed(function() {
            return readOnly();
        }, this), self.beingEdited = ko.computed(function() {
            return editing();
        }, this), self.isSelected = ko.computed(function() {
            return this === selectedScene();
        }, this), self.beingColoured = ko.computed(function() {
            return colouring();
        }, this), self.getSource = function() {
            return source;
        }, self.getProject = function() {
            for (var projectPath = getProjectPath(path()), n = 0; n < projects().length; n++) if (projects()[n].getPath() === projectPath) return projects()[n];
            return null;
        }, self.getText = function() {
            return cmDoc.getValue();
        }, self.getMarkColour = ko.computed(function() {
            return markColour();
        }, this), self.getLineHandle = function(lineNum) {
            return cmDoc.getLineHandle(lineNum);
        }, self.getLineNumber = function(lineHandle) {
            return cmDoc.getLineNumber(lineHandle);
        }, self.nameInvalid = ko.computed(function() {
            return invalidName();
        }, this), self.getNameErrorMsg = ko.computed(function() {
            return nameErrMsg();
        }, this), self.getIssues = ko.computed(function() {
            return issues();
        }, this), self.getContents = function() {
            return cmDoc.getValue();
        }, self.getErrStateMsg = ko.computed(function() {
            return errStateMsg() + " - click here to close";
        }, this), self.getErrState = ko.computed(function() {
            return inErrState();
        }, this), self.getCharCountString = function() {
            return 0 < selectedChars() ? selectedChars() + " (" + charCount() + ")" : charCount();
        }, self.getCharCount = function(selected) {
            return (selected ? selectedChars : charCount)();
        }, self.getCursorString = function() {
            return "Ln " + (cursor().line + 1) + ", Col " + cursor().ch;
        }, self.getWordCountString = function() {
            var suffix = editor.getOption("exclude_cmd_lines") ? " [excl. cmds]" : " [inc. cmds]";
            return 0 < selectedChars() ? __wordCount(cmDoc.getSelection(), editor.getOption("exclude_cmd_lines")) + (" (" + wordCount()) + ") " + suffix : wordCount() + suffix;
        }, self.getWordCount = function(exclCommandLines, selected) {
            return __wordCount(selected ? cmDoc.getSelection() : cmDoc.getValue(), exclCommandLines);
        }, self.getState = ko.computed(function() {
            return saving() ? "fa fa-spinner fa-spin" : loaded() ? inErrState() ? "fa fa-exclamation-triangle scene-unsaved" : readOnly() ? "fa fa-lock" : dirty() ? "fa fa-save scene-unsaved" : "fa fa-save scene-saved" : "fa fa-ban";
        }), self.setText = function(value) {
            readOnly() || "string" == typeof value && cmDoc.setValue(value);
        };
        function saveScene(callback) {
            var data = cmDoc.getValue();
            fh.writeFile(path(), data, function(err) {
                !function(err) {
                    err ? console.log(err) : (dirty(!1), cmDoc.markClean(), fileStats.mtime ? fileStats.mtime = new Date() : fileStats.modifiedAt = new Date());
                    saving(!1), "function" == typeof callback && callback(err);
                }(err);
            });
        }
        self.nameInterface = ko.pureComputed({
            read: function() {
                return name();
            },
            write: function(newValue) {
                validName(newValue, !1, function(valid, errMsg) {
                    invalidName(!valid), valid || nameErrMsg(errMsg);
                });
            },
            owner: this
        }), self.rename = function(data, event) {
            var newName;
            inErrState() || !loaded() || saving() || readOnly() || "keyup" == event.type && 13 != event.keyCode && 27 != event.keyCode || ("dblclick" != event.type && "click" != event.type ? invalidName() && editing() ? $(event.target).fadeOut("fast").fadeIn("fast").focus() : ((newName = event.target.value.trim()) != name() && sceneExists(newName, self.getProject(), function(exists) {
                exists ? (notification("Failed to Rename Scene", "Scene '" + event.target.value.toLowerCase() + "' already exists in this Project", {
                    type: "error"
                }), event.target.value = name()) : renameSceneFile(newName);
            }), editing(!1)) : isImportant ? notification("", "Reserved scene cannot be renamed", {
                type: "error",
                layout: "bottomLeft"
            }) : self.isLocked() || (editing(!0), setTimeout(function() {
                $(event.target).focus().select();
            }, 10)));
        }, self.recolour = function(data, event) {
            if (("mouseleave" !== event.type || colouring()) && !self.isLocked()) {
                if ("string" == typeof data && data != markColour()) {
                    event = new RegExp("(" + validSceneColours().join("|").replace(/\(/g, "\\(").replace(/\)/g, "\\)") + ")");
                    if (!data.match(event)) return void console.log("Scene Recolour Error: Invalid colour");
                    markColour(data), __updatePersistenceList();
                }
                colouring(!colouring());
            }
        }, self.focusLine = function(lineNum, noArrow) {
            self !== selectedScene() && self.select(), noArrow || (editor.clearGutter("arrow-gutter"), 
            editor.setGutterMarker(lineNum, "arrow-gutter", document.createTextNode(""))), 
            editor.scrollIntoView({
                line: lineNum,
                ch: 0
            }, 20);
        }, self.addIssue = function(issue) {
            var lh;
            if (issues.push(issue), "number" == typeof issue.getLineNum()) return (lh = cmDoc.getLineHandle(issue.getLineNum())) ? (cmDoc.addLineClass(lh, "background", "CodeMirror-error-background"), 
            CodeMirror.on(lh, "delete", function(lineHandle, change) {
                issues.remove(issue);
            }), lh) : null;
        }, self.removeIssue = function(issue) {
            "number" == typeof issue.getLineNum() && cmDoc.removeLineClass(issue.getLineNum(), "background", "CodeMirror-error-background"), 
            issues.remove(issue);
        }, self.load = function(callback) {
            function finishLoading(err, data) {
                err ? (inErrState(!0), errStateMsg(err.message), console.log(errStateMsg()), 
                callback(err)) : (inErrState(!1), cmDoc.setValue(data), cmDoc.markClean(), 
                cmDoc.clearHistory(), dirty(!1), __updatePersistenceList()), loaded(!0), 
                saving(!1), void 0 !== callback && callback(err, self);
            }
            saving() || (loaded(!1), saving(!0), "function" != typeof callback && (callback = function(err) {
                err && console.log(err.message);
            }), fh.stat(path(), function(err, newfileStats) {
                err ? finishLoading(err) : (fileStats = newfileStats, fh.readFile(path(), function(err, data) {
                    err ? finishLoading(err) : finishLoading(err, data);
                }));
            }));
        }, self.save = function(scene, event, callback) {
            var lastModifiedAt;
            event && event.stopPropagation(), !dirty() && loaded() || inErrState() || saving() || locked() || readOnly() ? "function" == typeof callback && callback(null) : (saving(!0), 
            lastModifiedAt = fileStats.mtime || fileStats.modifiedAt, fh.stat(path(), function(err, newfileStats) {
                !err || 404 != err.code && "ENOENT" != err.code ? err ? (console.log(err), 
                saving(!1), bootbox.alert("<h3>Warning</h3><p>Unable to save <b>" + name() + "</b> of <b>" + self.getProject().getName() + "</b>: " + err.message + ".</p> \t\t\t\t\t\t<p>Check your internet connection.</p>")) : function(newfileStats) {
                    (newfileStats.mtime || newfileStats.modifiedAt).getTime() > lastModifiedAt.getTime() + 1e3 ? bootbox.dialog({
                        message: "'" + name() + ".txt' of <b>" + self.getProject().getName() + "</b> appears to have been modified by another program or process \t\t\t\t\t\tsince it was last saved. Are you sure you wish to save it?",
                        title: "Conflict Warning",
                        buttons: {
                            cancel: {
                                label: "Cancel",
                                callback: function() {
                                    saving(!1);
                                }
                            },
                            reload: {
                                label: "Reload",
                                callback: function() {
                                    saving(!1), self.load(function(err, scene) {
                                        err || scene.select();
                                    });
                                }
                            },
                            yes: {
                                label: "Save",
                                className: "btn-primary",
                                callback: function() {
                                    saveScene(callback);
                                }
                            }
                        },
                        onEscape: function() {
                            saving(!1);
                        }
                    }) : saveScene(callback);
                }(newfileStats) : saveScene(callback);
            }));
        }, self.select = function() {
            if (selectedScene() !== self) return !(inErrState() || !loaded() || saving() || self.isLocked()) && (editor.clearGutter("arrow-gutter"), 
            selectedScene(self), editor.swapDoc(cmDoc), self.getProject().isExpanded() || self.getProject().setExpand(!0), 
            editor.setOption("readOnly", readOnly()), !0);
        }, self.close = function() {
            self.getProject().closeScene(self);
        }, self.copyTo = function(targetProject) {
            var newPath;
            "object" != typeof targetProject || inErrState() || !loaded() || saving() || (targetProject.isReadOnly() ? notification("", "Cannot Move Scene to Read-Only Project", {
                type: "error",
                closeWith: [ "click" ]
            }) : (newPath = targetProject.getPath() + name() + ".txt", fh.copyFile(path(), newPath, function(err, fileStat) {
                !function(err) {
                    err ? (bootbox.alert(err.message), console.log(err)) : (err = new CSIDEScene({
                        path: newPath,
                        source: source,
                        contents: cmDoc.getValue()
                    }), targetProject.addScene(err), err.load());
                }(err);
            })));
        }, self.moveTo = function(targetProject) {
            var currentProject, newPath;
            "object" != typeof targetProject || inErrState() || !loaded() || saving() || readOnly() || (isImportant ? notification("", "Cannot Move Reserved Scene", {
                type: "error",
                closeWith: [ "click" ]
            }) : targetProject.isReadOnly() ? notification("", "Cannot Move Scene to Read-Only Project", {
                type: "error",
                closeWith: [ "click" ]
            }) : (currentProject = self.getProject(), targetProject !== currentProject && (newPath = targetProject.getPath() + name() + ".txt", 
            fh.renameFile(path(), newPath, function(err) {
                !function(err) {
                    err ? (bootbox.alert(err.message), console.log(err)) : (currentProject.removeScene(self), 
                    path(newPath), targetProject.addScene(self), __updatePersistenceList());
                }(err);
            }))));
        }, self.del = function() {
            inErrState() || !loaded() || saving() || (isImportant ? notification("", "Cannot Delete Reserved Scene", {
                type: "error",
                closeWith: [ "click" ]
            }) : readOnly() ? notification("", "Cannot Delete Read-Only Scene", {
                type: "error",
                closeWith: [ "click" ]
            }) : bootbox.confirm("<h3>Confirm</h3><p>Are you sure you want to permanently delete '" + name() + ".txt'?</p><p style='font-size:12px;'>" + path() + "<p>", function(result) {
                result && fh.deleteFile(path(), function(err) {
                    err ? bootbox.alert(err.message) : self.close();
                });
            }));
        }, CodeMirror.on(cmDoc, "beforeChange", function(cm, change) {
            saving() && loaded() && (change.cancel(), "undo" != change.origin && "redo" != change.origin || cmDoc.setHistory(history));
        }), CodeMirror.on(cmDoc, "change", function(cm, change) {
            saving() || (cmDoc.isClean() ? dirty(!1) : dirty(!0)), history = cmDoc.getHistory(), 
            charCount(charCount() - change.removed.join("\n").length + change.text.join("\n").length), 
            editor.getOption("word_count") && wordCount(__wordCount(cmDoc.getValue(), editor.getOption("exclude_cmd_lines")));
        }), CodeMirror.on(cmDoc, "cursorActivity", function(cm) {
            cursor(cmDoc.getCursor()), selectedChars(cmDoc.getSelection().length);
        });
    }
    function csideIssue(issueData) {
        var self = this, scene = issueData.scene || null, project = issueData.project || null;
        if (null === project) return null;
        var desc = issueData.desc || "No description available", lineHandle = null, lineNum = "number" == typeof issueData.lineNum && -1 < issueData.lineNum ? issueData.lineNum : null, issueData = new Date(), date = issueData.getDate() + "/" + (issueData.getMonth() + 1) + "/" + issueData.getFullYear(), time = issueData.getHours() + ":" + issueData.getMinutes();
        self.getScene = function() {
            return scene;
        }, self.getDesc = function() {
            return desc;
        }, self.getDate = function() {
            return date;
        }, self.getTime = function() {
            return time;
        }, self.getLineNum = function() {
            return lineHandle ? lineHandle.lineNo() : lineNum;
        }, self.dismiss = function() {
            project.removeIssue(self), scene && scene.removeIssue(self);
        }, self.show = function() {
            scene && (scene.select(), "number" == typeof self.getLineNum() && scene.focusLine(self.getLineNum(), !0));
        }, scene && (issueData = scene.addIssue(self)) && (lineHandle = issueData);
    }
    function CSIDESetting(settingData) {
        var options, setting = this, value = ko.observable(settingData.value), id = (value.extend({
            notify: "always"
        }), settingData.id), name = settingData.name, selectedOption = 0, type = settingData.type || "binary", cat = settingData.cat || "app", desc = ko.observable(settingData.desc || ""), visible = ko.observable(!0);
        options = "binary" === type ? [ {
            desc: "on",
            value: !0
        }, {
            desc: "off",
            value: !1
        } ] : settingData.options, setting.getValue = ko.computed(function() {
            return value();
        }, this), setting.getId = function() {
            return id;
        }, setting.getName = function() {
            return name;
        }, setting.getType = function() {
            return type;
        }, setting.getCat = function() {
            return cat;
        }, setting.getOptions = function() {
            return options;
        }, setting.getSelectedOptionId = function() {
            for (var i = 0; i < options.length; i++) if (value() == options[i].value) return i;
            return null;
        }, setting.getDesc = ko.computed(function() {
            return desc();
        }, this), setting.isVisible = ko.computed(function() {
            return visible();
        }, this), setting.setDesc = function(val) {
            desc(val);
        }, setting.apply = settingData.apply, setting.toggle = function(option, evt) {
            "binary" != type ? value(option.value) : selectedOption + 1 == options.length ? value(options[selectedOption = 0].value) : value(options[selectedOption += 1].value);
        }, setting.setValue = function(newVal) {
            value(newVal);
        }, setting.setVisibility = function(newVal) {
            "boolean" == typeof newVal && visible(newVal);
        }, value.subscribe(function(option) {
            config.settings[cat][id] = value(), setting.apply(value()), __updateConfig();
        }), setting.extAPI = {
            getName: setting.getName,
            getType: setting.getType,
            getDesc: setting.getDesc,
            getValue: setting.getValue,
            value: value,
            toggle: setting.toggle,
            getOptions: setting.getOptions,
            isVisible: setting.isVisible
        };
    }
    ko.extenders.normalizePaths = function(target, option) {
        return target.subscribe(function(path) {
            target(__normalizePath(path));
        }), target;
    }, ko.extenders.lowerCase = function(target, option) {
        return target.subscribe(function(val) {
            target(val.toLowerCase());
        }), target;
    }, ko.extenders.callFunc = function(target, option) {
        return target.subscribe(function() {
            option.func();
        }), target;
    };
    var nw_version, updating, autoSaveFn, autoUpdateCheckFn, autoSuggestFn, CSIDE_version, platform, self = this, CONST_IMG_PREFIX = (usingNode ? (CSIDE_version = gui.App.manifest.version, 
    nw_version = process.versions["node-webkit"], "mac_os" === (platform = "darwin" === process.platform ? "mac_os" : process.platform) ? process.execPath.substring(0, process.execPath.lastIndexOf("/") + 1) : process.execPath.substring(0, process.execPath.lastIndexOf("\\") + 1), 
    updating = !1, autoSuggestFn = autoUpdateCheckFn = autoSaveFn = null, self.isUpdating = function() {
        return updating;
    }) : (CSIDE_version = "Dropbox Alpha", platform = "web-dropbox"), "csideimg_"), user = {
        name: usingNode ? require("username").sync() : "Dropbox User",
        path: "/"
    }, projectMenuOptions = (user.name = user.name.charAt(0).toUpperCase() + user.name.slice(1), 
    ko.observableArray([ new menuOption("Add new scene", function(menu) {
        menu.getTarget().addNewScene();
    }), new menuOption("Open all scenes", function(menu) {
        menu.getTarget().openAllScenes();
    }), new menuOption("Reload all scenes", function(menu) {
        menu.getTarget().reloadAllScenes();
    }), new menuOption("Review", function(menu) {}, [ new menuOption("Word count", function(menu) {
        cside.showWordCount(menu.getTarget());
    }) ]), new menuOption("Export", function(menu) {}, [ new menuOption("All scenes to folder", function(menu) {
        menu.getTarget().exportScenes();
    }) ]), new menuOption("Open folder in " + ("mac_os" === platform ? "Finder" : "Explorer"), function(menu) {
        menu.getTarget().openFolder();
    }), new menuOption("Show/hide project", function(menu) {
        menu.getTarget().setExpand();
    }), new menuOption("Close project", function(menu) {
        menu.getTarget().close();
    }) ])), sceneMenuOptions = ko.observableArray([ new menuOption("Edit", function(menu) {}, [ new menuOption("Convert all spaces to tabs", function(menu) {
        __normalizeSceneIndentation(menu.getTarget(), "tabs");
    }), new menuOption("Convert all tabs to spaces", function(menu) {
        __normalizeSceneIndentation(menu.getTarget(), "spaces");
    }) ]), new menuOption("Review", function(menu) {}, [ new menuOption("Word count", function(menu) {
        cside.showWordCount(menu.getTarget());
    }) ]), new menuOption("Reload", function(menu) {
        menu.getTarget().load(function(err, scene) {
            err || selectedScene() !== menu.getTarget() || scene.select();
        });
    }), new menuOption("Close", function(menu) {
        menu.getTarget().close();
    }), new menuOption("Delete file", function(menu) {
        menu.getTarget().del();
    }) ]), projects = (usingNode && (sceneMenuOptions.push(new menuOption("Export", function(menu) {}, [ new menuOption("Copy file to folder", function(menu) {
        var scene = menu.getTarget();
        fh.selectFolder(function(newPath) {
            newPath && bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any file with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>", function(result) {
                result && fh.copyFile(scene.getPath(), newPath + scene.getName() + ".txt", function(err, data) {
                    err ? notification("Export Failed", err.message, {
                        type: "error"
                    }) : (err = [ {
                        addClass: "btn",
                        text: "Show Folder",
                        onClick: function(note) {
                            __openFolder(newPath), note.close();
                        }
                    } ], notification("Export Succesful", "Copied " + scene.getName() + " to " + newPath, {
                        type: "success",
                        buttons: err
                    }).setTimeout(3e3));
                });
            });
        });
    }), new menuOption("Print file", function(menu) {
        nw.Window.open("file://" + menu.getTarget().getPath(), {
            focus: !0,
            width: 800,
            height: 600
        }, function(win) {
            win.window.print();
        });
    }) ])), projectMenuOptions.splice(4, 0, new menuOption("Import", function(menu) {}, [ new menuOption("Image (as scene)", function(menu) {
        menu.getTarget().isReadOnly() || fh.selectImage(function(path) {
            path && !function(project, path) {
                var image = new Image();
                image.onload = function() {
                    var canvas = document.createElement("canvas"), fileExt = getFileExtension(path), imgSceneName = (CONST_IMG_PREFIX + getLastDirName(path).replace(fileExt, "")).replace(/\s/g, "_").toLowerCase(), scenePath = project.getPath() + imgSceneName + ".txt";
                    canvas.width = this.naturalWidth, canvas.height = this.naturalHeight, 
                    canvas.width <= 0 && canvas.height <= 0 ? notification("Image Import Failed", path, {
                        type: "error"
                    }) : (canvas.getContext("2d").drawImage(image, 0, 0), sceneExists(imgSceneName, project, function(exists) {
                        var newScene;
                        exists ? bootbox.prompt({
                            title: "That Image Already Exists - Copy & Paste Code Below",
                            value: "*gosub_scene " + imgSceneName,
                            callback: function(result) {}
                        }) : (newScene = new CSIDEScene({
                            path: scenePath,
                            source: platform
                        }), exists = canvas.toDataURL(), newScene.setText("*comment ENCODED IMAGE FILE - DO NOT EDIT\n*comment source: " + path + "\n*comment usage: *gosub_scene " + newScene.getName() + "\n*image " + exists + "\n*return"), 
                        newScene.save(null, null, function(err) {
                            err ? bootbox.alert(err.message) : (notification("Image Import Successful", "", {
                                type: "success"
                            }), bootbox.prompt({
                                title: "Copy & Paste Code Below",
                                value: "*gosub_scene " + newScene.getName(),
                                callback: function(result) {}
                            }));
                        }));
                    }));
                }, image.onabort = image.onerror = function() {
                    notification("Image Import Failed", path, {
                        type: "error"
                    });
                }, image.src = "file://" + path;
            }(menu.getTarget(), path);
        });
    }) ])), projectMenuOptions.splice(6, 0, new menuOption("Test Project", function(menu) {}, [ new menuOption("Quicktest", function(menu) {
        menu.getTarget().test("quick");
    }), new menuOption("Randomtest", function(menu) {
        "web-dropbox" != platform ? menu.getTarget().test("random") : bootbox.alert("<h3>Apologies...</h3><p>But due to technical limitations randomtest can only be run in the Desktop version of the Choicescript IDE.</p></h3>");
    }) ])), projectMenuOptions()[5].getSubMenuOptions().push(new menuOption("Compiled game", function(menu) {
        menu.getTarget().compile();
    }))), ko.observableArray([])), selectedScene = ko.observable(null), selectedProject = ko.computed(function() {
        return selectedScene() ? selectedScene().getProject() : null;
    });
    if (self.getSelectedProject = ko.computed(function() {
        return selectedProject();
    }, this), "mac_os" === platform) {
        var nativeMenuBar = new nw.Menu({
            type: "menubar"
        });
        "darwin" === process.platform && nativeMenuBar.createMacBuiltin("CSIDE"), 
        win.menu = nativeMenuBar, !function() {
            for (var projectMenu = new nw.Menu(), options = (projectMenu.getTarget = selectedProject, 
            projectMenuOptions()), i = 0; i < options.length; i++) if (options[i].getSubMenuOptions()) {
                for (var subMenu = new nw.Menu(), o = 0; o < options[i].getSubMenuOptions().length; o++) subMenu.append(new nw.MenuItem({
                    label: options[i].getSubMenuOptions()[o].getLabel(),
                    click: options[i].getSubMenuOptions()[o].doAction.bind(null, projectMenu)
                }));
                projectMenu.append(new nw.MenuItem({
                    label: options[i].getLabel(),
                    click: options[i].doAction.bind(null, projectMenu),
                    submenu: subMenu
                }));
            } else projectMenu.append(new nw.MenuItem({
                label: options[i].getLabel(),
                click: options[i].doAction.bind(null, projectMenu)
            }));
            var index = "mac_os" === platform ? 3 : 1;
            win.menu.insert(new nw.MenuItem({
                label: "Project",
                submenu: projectMenu
            }), index);
        }();
        for (var sceneMenu = new nw.Menu(), options = (sceneMenu.getTarget = selectedScene, 
        sceneMenuOptions()), i = 0; i < options.length; i++) if (options[i].getSubMenuOptions()) {
            for (var subMenu = new nw.Menu(), o = 0; o < options[i].getSubMenuOptions().length; o++) subMenu.append(new nw.MenuItem({
                label: options[i].getSubMenuOptions()[o].getLabel(),
                click: options[i].getSubMenuOptions()[o].doAction.bind(null, sceneMenu)
            }));
            sceneMenu.append(new nw.MenuItem({
                label: options[i].getLabel(),
                click: options[i].doAction.bind(null, sceneMenu),
                submenu: subMenu
            }));
        } else sceneMenu.append(new nw.MenuItem({
            label: options[i].getLabel(),
            click: options[i].doAction.bind(null, sceneMenu)
        }));
        nativeMenuBar = "mac_os" === platform ? 4 : 2;
        win.menu.insert(new nw.MenuItem({
            label: "Scene",
            submenu: sceneMenu
        }), nativeMenuBar), "mac_os" != platform ? nw.Window.get().menu = win.menu : (ko.extenders.updateMenuBarStates = function(target, option) {
            return target.subscribe(function(scene) {
                var b = !!scene, scene = "mac_os" === platform ? 3 : 1, sceneIndex = "mac_os" === platform ? 4 : 2;
                win.menu = nw.Window.get().menu;
                for (var index = scene; index <= sceneIndex; index++) for (var item = 0; item < win.menu.items[index].submenu.items.length; item++) win.menu.items[index].submenu.items[item].enabled = b;
                nw.Window.get().menu = win.menu;
            }), target;
        }, selectedScene.extend({
            updateMenuBarStates: ""
        }), selectedScene.valueHasMutated());
    }
    var config, autoFormatMap = {
        "...": "",
        "--": ""
    }, reservedSceneNames = "(STARTUP|CHOICESCRIPT_STATS)", validSceneColours = ko.observableArray([ "rgb(125, 186, 125)", "rgb(172, 209, 240)", "rgb(228, 144, 150)", "rgb(237, 216, 161)", "rgb(161, 165, 237)", "rgb(224, 161, 237)", "rgb(163, 163, 163)", "rgb(230, 230, 230)" ]), validSceneColours = ko.observableArray([ "rgb(114, 195, 116)", "rgb(119, 151, 236)", "rgb(217, 83, 79)", "rgb(165, 147, 122)", "rgb(255, 141, 43)", "rgb(224, 121, 245)", "rgb(0, 168, 195)", "rgb(119, 119, 119)" ]), uiColour = ko.observable().extend({
        notify: "always"
    }), activeProject = (uiColour("90,90,90"), ko.observable(!1), ko.observable("")), projects = ko.observableArray([]), wordCountOn = ko.observable(!0), defaultConfig = {
        settings: {
            editor: {
                tabtype: "spaces",
                smartindent: !0,
                tabsize: "4",
                linewrap: !0,
                fontsize: "12px",
                fontfamily: "'Courier New', Courier, monospace",
                spell_dic: "en_US",
                theme: "cs-dark",
                "night-mode": !1,
                spellcheck: 1,
                autosuggest: !1,
                autoformat: !0,
                "word-count": 2,
                "visible-tabs": !1,
                "selection-match": !1
            },
            app: {
                persist: !0,
                autosave: !0,
                cmdhelp: !1,
                "update-channel": "stable",
                "ui-colour": "90,90,90",
                "project-path": "default"
            }
        },
        justUpdated: !1,
        openProjects: [],
        userDictionary: {},
        tabs: [ "game", "issues", "settings", "help", "dictionary" ]
    };
    usingNode && defaultConfig.tabs.push("examples"), config = defaultConfig;
    try {
        for (var item in storedConfig = JSON.parse(localStorage.getItem("CSIDE_appConfig"))) config[item] = storedConfig[item];
    } catch (err) {
        bootbox.alert("Sorry, there was a problem parsing your configuration settings.<br> \t\tThey have been repaired and reset to the defaults.<br><br> \t\t<b>Error:</b> " + err.message), 
        localStorage.setItem("CSIDE_appConfig", JSON.stringify(defaultConfig)), 
        config = defaultConfig;
    }
    var db, keymap, userDictionary = {}, fh = {
        writeFile: function(path, data, callback) {
            "web-dropbox" === platform ? db.filesUpload({
                path: path,
                contents: data,
                mode: {
                    ".tag": "overwrite"
                },
                autorename: !1
            }).then(function(response) {
                callback(null);
            }).catch(function(err) {
                callback(normalizeError(err));
            }) : mkdirp(getDirName(path), function(err) {
                err ? callback(normalizeError(err)) : fs.writeFile(path, data, {
                    encoding: "utf8"
                }, function(err) {
                    callback(normalizeError(err));
                });
            });
        },
        getDropboxImageUrl: function(path, callback) {
            if ("web-dropbox" !== platform) throw new Error("getDropboxImageUrl is a Dropbox only method!");
            db.filesDownload({
                path: path
            }).then(function(response) {
                try {
                    var url = window.URL.createObjectURL(response.result.fileBlob);
                    callback(null, url);
                } catch (err) {
                    callback(normalizeError(err));
                }
            }).catch(function(err) {
                callback(normalizeError(err));
            });
        },
        readFile: function(path, callback) {
            "web-dropbox" === platform ? db.filesDownload({
                path: path
            }).then(function(fileData) {
                var reader = new FileReader();
                reader.addEventListener("loadend", function() {
                    reader.result ? callback(null, new TextDecoder("utf-8").decode(reader.result)) : callback({});
                }), reader.readAsArrayBuffer(fileData.result.fileBlob);
            }).catch(function(err) {
                callback(normalizeError(err));
            }) : fs.readFile(path, {
                encoding: "utf8"
            }, function(err, data) {
                callback(normalizeError(err), data);
            });
        },
        copyFile: function(oldPath, newPath, callback) {
            "web-dropbox" === platform ? db.filesCopy({
                from_path: oldPath,
                to_path: newPath
            }).then(function(response) {
                callback(null);
            }).catch(function(err) {
                callback(normalizeError(err));
            }) : fs.readFile(oldPath, {
                encoding: "utf8"
            }, function(err, data) {
                err ? callback(normalizeError(err)) : fs.writeFile(newPath, data, function(err) {
                    callback(normalizeError(err));
                });
            });
        },
        renameFile: function(oldPath, newPath, callback) {
            "web-dropbox" === platform ? db.filesMove({
                from_path: oldPath,
                to_path: newPath
            }).then(function(response) {
                callback(null);
            }).catch(function(err) {
                callback(normalizeError(err));
            }) : fs.rename(oldPath, newPath, function(err) {
                callback(normalizeError(err));
            });
        },
        deleteFile: function(path, callback) {
            "web-dropbox" === platform ? db.filesDelete({
                path: path
            }).then(function(response) {
                callback(null);
            }).catch(function(err) {
                callback(normalizeError(err));
            }) : trash([ path ], function(err) {
                callback(normalizeError(err));
            });
        },
        readDir: function(path, callback, dbMetaData) {
            "web-dropbox" === platform ? db.filesListFolder({
                path: path = "/" == path ? "" : path
            }).then(function(response) {
                callback(null, void 0 !== dbMetaData && 1 == dbMetaData ? response.result.entries.map(function(item) {
                    return item.path = item.path_lower, item.isFolder = "folder" == item[".tag"], 
                    item;
                }) : response.result.entries.map(function(item) {
                    return getLastDirName(item.path_lower);
                }));
            }).catch(function(err) {
                callback(normalizeError(err));
            }) : fs.readdir(path, function(err, filePathArray) {
                callback(normalizeError(err), filePathArray);
            });
        },
        makeDir: function(path, callback) {
            "web-dropbox" === platform ? ("/" == path.slice(-1, path.length) && (path = path.slice(0, -1)), 
            db.filesCreateFolder({
                path: path
            }).then(function(response) {
                callback(null);
            }).catch(function(error) {
                err && 403 == err.status && (delete err.status, err.code = "EEXIST"), 
                callback(normalizeError(err));
            })) : mkdirp(path, function(err) {
                callback(normalizeError(err));
            });
        },
        stat: function(path, callback) {
            "web-dropbox" === platform ? db.filesGetMetadata({
                path: path
            }).then(function(response) {
                callback(null, {
                    mtime: new Date(response.client_modified)
                });
            }).catch(function(err) {
                callback(normalizeError(err));
            }) : fs.stat(path, function(err, fileStats) {
                callback(normalizeError(err), fileStats);
            });
        },
        selectFolder: function(callback) {
            var chooser;
            "web-dropbox" === platform ? fileBrowser.selectFolders(function(selection) {
                0 < selection.length ? callback(selection[0].path + "/") : callback(null);
            }) : ((chooser = $("#selectFolder")).off().change(function(evt) {
                callback($(this).val() + "/"), $(this).val("");
            }), setTimeout(function() {
                chooser.trigger("click");
            }, 200));
        },
        selectImage: function(callback) {
            var chooser;
            "web-dropbox" === platform ? bootbox.alert("TODO: Image scene import not yet implemented on the web-version.") : ((chooser = $("#getImagePaths")).off().change(function(evt) {
                callback($(this).val()), $(this).val("");
            }), setTimeout(function() {
                chooser.trigger("click");
            }, 200));
        },
        selectFiles: function(callback, options) {
            var extensions, chooser;
            options = options || {}, usingNode ? (extensions = options.extensions || [ ".txt", ".log" ], 
            (chooser = $("#getFilePaths")).attr("accept", extensions.join(",")), 
            chooser.off().change(function(evt) {
                var selection = $(this).val().split(";");
                1 === selection.length && "" === selection[0] && callback(null), 
                $(this).val(""), callback(selection);
            }), chooser.trigger("click")) : fileBrowser.open(function(selection) {
                selection.length < 1 && callback(null), selection = selection.filter(function(file) {
                    return !file.isFolder();
                }).map(function(file) {
                    return file.path;
                }), callback(selection);
            }, options);
        }
    }, normalizeError = function(err) {
        if (!err) return null;
        if (void 0 === err.message) try {
            err.message = JSON.parse(err.responseText).error;
        } catch (e) {
            err.message = "Unable to get an error description";
        }
        switch (void 0 === err.code && (err.code = err.status || "Unknown Error Code"), 
        void 0 !== err.code && 409 == err.code && ("not_found" == err.error.error[err.error.error[".tag"]][".tag"] && (err.code = 404), 
        err.message = "Dropbox: " + err.error.error_summary), err.code) {
          case "not_found":
          case "ENOENT":
          case 404:
            err.code = 404;
        }
        return err;
    }, notification = function(title, message, options) {
        (options = options || {}).theme = "bootstrap-v3", options.layout = options.layout || "bottomRight", 
        options.type = options.type || "alert", options.timeout = !1 !== options.timeout && (options.timeout || 5e3), 
        options.closeWith = !1 !== options.closeWith && (options.closeWith || [ "click" ]), 
        options.buttons = options.buttons || null, options.buttons && (options.buttons = options.buttons.map(function(btn) {
            return Noty.button(btn.text, btn.addClass, function(note) {
                btn.onClick(note);
            });
        })), options.text = "<h5>" + title + "</h5>\t\t\t\t\t <p>" + message + "</p>", 
        options.progress && (options.text += "<progress value='0' max='100'></progress>");
        var n = new Noty(options);
        return options.progress && (n.setProgress = function(val) {
            $(n.barDom).find(".noty_body").find("progress").val(val);
        }), n.show(), n;
    }, dropboxAuthorised = (self.notification = function(title, message, options) {
        notification(title, message, options);
    }, "web-dropbox" == platform && (utils.parseQueryString(window.location.hash).access_token ? db = new Dropbox.Dropbox({
        accessToken: utils.parseQueryString(window.location.hash).access_token
    }) : (db = new Dropbox.Dropbox({
        clientId: "hnzfrguwoejpwbj"
    })).auth.getAuthenticationUrl(window.location).then(authUrl => {
        window.location = authUrl;
    }), db.usersGetCurrentAccount().then(function(acc) {
        user.name = acc.name.display_name;
    }).catch(function(err) {})), window.db = db, ko.observable(!1)), typo = new Typo("", "", "", {
        platform: "any"
    }), editor = (self.dbAuth = ko.computed(function() {
        return dropboxAuthorised();
    }, this), self.getProjects = projects, self.getSelectedScene = ko.computed(function() {
        return selectedScene();
    }, this), self.getActiveProject = ko.computed(function() {
        return activeProject();
    }, this), self.getValidSceneColours = ko.computed(function() {
        return validSceneColours();
    }, this), self.getPlatform = function() {
        return platform;
    }, self.wordCountOn = ko.computed(function() {
        return wordCountOn();
    }), self.getUIColour = function(delta) {
        delta = delta || 0, config.settings.app["night-mode"] && (delta -= 30);
        for (var val, rgb = uiColour().split(","), i = 0; i < rgb.length; i++) (val = parseInt(rgb[i]) + delta) < 0 ? val = 0 : 255 < val && (val = 255), 
        rgb[i] = val;
        return "rgb(" + rgb.join(",") + ")";
    }, self.selectTab = function(tab) {
        for (var tabs = self.tabs(), i = 0; i < tabs.length; i++) if (tab === tabs[i].id) {
            __selectTab(tab);
            break;
        }
    }, self.readFile = function(url, callback) {
        fh.readFile(url, callback);
    }, self.selectScene = function(scene) {
        scene.select();
    }, self.getDropboxImageUrl = function(url, callback) {
        fh.getDropboxImageUrl(url, callback);
    }, self.selectFileClick = function(file, event) {
        var aProject = activeProject(), nProject = file.getProject(), nProject = aProject !== nProject ? nProject : aProject;
        file.isSelected() ? file.viewInEditor() : 1 !== nProject.getEditors().length || event.shiftKey ? self.openNewEditor(file, function(ed) {
            ed && file.viewInEditor();
        }) : (nProject.getEditors()[0].setFile(file), file.viewInEditor());
    }, self.session = {
        save: function(cb) {
            var failed = !1, count = projects().length;
            count < 1 ? cb(null) : projects().forEach(function(project, index) {
                project.save(function(err) {
                    if (err) return failed ? void 0 : (failed = !0, cb(err));
                    0 == --count && cb(null);
                });
            });
        },
        isDirty: ko.computed(function() {
            for (var i = 0; i < projects().length; i++) if (projects()[i].isDirty()) return !0;
            return !1;
        })
    }, self.session.win = function() {
        var fullScreen = ko.observable(!0);
        return {
            isFullscreen: ko.computed(function() {
                return fullScreen();
            }, this),
            toggleMaximize: function() {
                fullScreen() ? win.restore() : "mac_os" === platform ? win.enterFullscreen() : win.maximize(), 
                fullScreen(!fullScreen());
            }
        };
    }(), keymap = "mac_os" == platform || "web-dropbox" == platform && "MacIntel" == window.navigator.platform ? {
        "Cmd-S": function(ed) {
            selectedScene().save();
        },
        "Cmd-W": function(ed) {
            selectedScene().close();
        },
        "Cmd-N": function(ed) {
            selectedProject().addNewScene();
        },
        "Cmd-Q": function(ed) {
            usingNode && win.close();
        },
        "Shift-Cmd-S": function(ed) {
            selectedProject().save();
        },
        "Shift-Cmd-W": function(ed) {
            selectedProject().close();
        },
        "Shift-Cmd-N": function(ed) {
            self.createProject();
        },
        "Shift-Cmd-,": function(ed) {
            self.scenePanel();
        },
        "Shift-Cmd-.": function(ed) {
            self.tabPanel();
        },
        "Shift-Cmd-=": function(ed) {
            var fontSizeSetting = settings.byId("editor", "fontsize"), optionId = fontSizeSetting.getSelectedOptionId();
            "number" == typeof optionId && optionId < fontSizeSetting.getOptions().length - 1 && fontSizeSetting.toggle(fontSizeSetting.getOptions()[optionId + 1]);
        },
        "Shift-Cmd--": function(ed) {
            var fontSizeSetting = settings.byId("editor", "fontsize"), optionId = fontSizeSetting.getSelectedOptionId();
            "number" == typeof optionId && 0 < optionId && fontSizeSetting.toggle(fontSizeSetting.getOptions()[optionId - 1]);
        },
        "Shift-Cmd-O": function(ed) {
            selectedProject().openAllScenes();
        },
        "Shift-Tab": function(ed) {
            ed.indentSelection("subtract");
        },
        "Cmd-O": function(ed) {
            self.openFileBrowser();
        },
        "Cmd-D": function(ed) {
            insertTextTags("${", "}");
        },
        "Cmd-B": function(ed) {
            insertTextTags("[b]", "[/b]");
        },
        "Cmd-I": function(ed) {
            insertTextTags("[i]", "[/i]");
        },
        "Cmd-/": function(ed) {
            insertTextTags("*comment ", "", !0);
        },
        "Cmd-T": function(ed) {
            selectedProject().test("quick");
        },
        "Shift-Cmd-T": function(ed) {
            selectedProject().test("random");
        },
        "Shift-Cmd-Enter": function(ed) {
            selectedProject().run();
        },
        "Shift-Cmd-C": function(ed) {
            selectedProject().toggleConsole() && $("#cs-console > input").focus();
        },
        "Cmd-Alt-Down": function(ed) {
            self.moveSelection("down");
        },
        "Cmd-Alt-Up": function(ed) {
            self.moveSelection("up");
        },
        "Shift-Cmd-K": function(ed) {
            ed.execCommand("deleteLine");
        },
        "Shift-Cmd-D": function(ed) {
            ed.execCommand("duplicateLine");
        },
        F11: function(ed) {
            ed.setOption("fullScreen", !ed.getOption("fullScreen"));
        },
        Esc: function(ed) {
            ed.setOption("fullScreen", !ed.getOption("fullScreen"));
        },
        "Cmd-Alt-PageUp": function(ed) {
            __cycleSceneSelection(!0);
        },
        "Cmd-Alt-PageDown": function(ed) {
            __cycleSceneSelection(!1);
        }
    } : {
        "Ctrl-S": function(ed) {
            selectedScene().save();
        },
        "Ctrl-W": function(ed) {
            selectedScene().close();
        },
        "Ctrl-N": function(ed) {
            selectedProject().addNewScene();
        },
        "Ctrl-O": function(ed) {
            self.openFileBrowser();
        },
        "Shift-Ctrl-O": function(ed) {
            selectedProject().openAllScenes();
        },
        "Shift-Ctrl-S": function(ed) {
            selectedProject().save();
        },
        "Shift-Ctrl-W": function(ed) {
            selectedProject().close();
        },
        "Shift-Ctrl-N": function(ed) {
            self.createProject();
        },
        "Shift-Ctrl-,": function(ed) {
            self.scenePanel();
        },
        "Shift-Ctrl-.": function(ed) {
            self.tabPanel();
        },
        "Shift-Ctrl-=": function(ed) {
            var fontSizeSetting = settings.byId("editor", "fontsize"), optionId = fontSizeSetting.getSelectedOptionId();
            "number" == typeof optionId && optionId < fontSizeSetting.getOptions().length - 1 && fontSizeSetting.toggle(fontSizeSetting.getOptions()[optionId + 1]);
        },
        "Shift-Ctrl--": function(ed) {
            var fontSizeSetting = settings.byId("editor", "fontsize"), optionId = fontSizeSetting.getSelectedOptionId();
            "number" == typeof optionId && 0 < optionId && fontSizeSetting.toggle(fontSizeSetting.getOptions()[optionId - 1]);
        },
        "Shift-Ctrl-Q": function(ed) {
            usingNode && win.close();
        },
        "Shift-Tab": function(ed) {
            ed.indentSelection("subtract");
        },
        "Ctrl-D": function(ed) {
            insertTextTags("${", "}");
        },
        "Ctrl-B": function(ed) {
            insertTextTags("[b]", "[/b]");
        },
        "Ctrl-I": function(ed) {
            insertTextTags("[i]", "[/i]");
        },
        "Ctrl-/": function(ed) {
            insertTextTags("*comment ", "", !0);
        },
        "Ctrl-T": function(ed) {
            selectedProject().test("quick");
        },
        "Shift-Ctrl-T": function(ed) {
            selectedProject().test("random");
        },
        "Shift-Ctrl-Enter": function(ed) {
            selectedProject().run();
        },
        "Shift-Ctrl-C": function(ed) {
            selectedProject().toggleConsole() && $("#cs-console > input").focus();
        },
        "Shift-Ctrl-Down": function(ed) {
            self.moveSelection("down");
        },
        "Shift-Ctrl-Up": function(ed) {
            self.moveSelection("up");
        },
        "Shift-Ctrl-K": function(ed) {
            ed.execCommand("deleteLine");
        },
        "Shift-Ctrl-D": function(ed) {
            ed.execCommand("duplicateLine");
        },
        F11: function(ed) {
            ed.setOption("fullScreen", !ed.getOption("fullScreen"));
        },
        Esc: function(ed) {
            ed.setOption("fullScreen", !ed.getOption("fullScreen"));
        },
        "Ctrl-PageUp": function(ed) {
            __cycleSceneSelection(!0);
        },
        "Ctrl-PageDown": function(ed) {
            __cycleSceneSelection(!1);
        }
    }, CodeMirror.fromTextArea(document.getElementById("code-textarea"), {
        mode: {
            name: "choicescript",
            version: 2,
            singleLineStringErrors: !1
        },
        lineNumbers: !0,
        lineWrapping: !0,
        tabSize: 4,
        indentUnit: 4,
        indentWithTabs: !0,
        matchBrackets: !0,
        extraKeys: keymap,
        foldGutter: !0,
        historyEventDelay: 500,
        gutters: [ "arrow-gutter", "CodeMirror-linenumbers", "CodeMirror-foldgutter" ],
        highlightSelectionMatches: {
            style: "matchhighlight",
            minChars: 2,
            delay: 200,
            wordsOnly: !1,
            annotateScrollbar: !1,
            showToken: !1,
            trim: !0
        }
    })), insertTextTags = (self.moveSelection = function(direction) {
        if ("up" === direction || "down" === direction) for (var selections = editor.listSelections(), i = 0; i < selections.length; i++) {
            var top = selections[i].from(), bottom = selections[i].to(), alpha = "down" === direction ? 1 : -1;
            if (void 0 === editor.getLine(top.line + alpha) || void 0 === editor.getLine(bottom.line + alpha)) return;
            0 === bottom.ch && (bottom.line--, bottom.ch = editor.getLine(bottom.line).length);
            var storeLine = "down" === direction ? editor.getLine(bottom.line + alpha) : editor.getLine(top.line + alpha), movingLines = editor.getRange({
                line: top.line,
                ch: 0
            }, {
                line: bottom.line,
                ch: editor.getLine(bottom.line).length
            });
            editor.replaceRange(movingLines, {
                line: top.line + alpha,
                ch: 0
            }, {
                line: bottom.line + alpha,
                ch: editor.getLine(bottom.line + alpha).length
            }), "down" === direction ? editor.replaceRange(storeLine, {
                line: top.line,
                ch: 0
            }, {
                line: top.line,
                ch: editor.getLine(top.line).length
            }) : editor.replaceRange(storeLine, {
                line: bottom.line,
                ch: 0
            }, {
                line: bottom.line,
                ch: editor.getLine(bottom.line).length
            }), editor.setSelection({
                line: top.line + alpha,
                ch: 0
            }, {
                line: bottom.line + alpha,
                ch: editor.getLine(bottom.line + alpha).length
            });
        }
    }, editor.addOverlay(function() {
        var word = new RegExp(/(?=[\"\'])?([A-Za-z\u00C0-\u00FF\u0100-\u017F]+'[A-Za-z\u00C0-\u00FF\u0100-\u017F]+|[A-Za-z\u00C0-\u00FF\u0100-\u017F]{2,}|[AaI]'?)(?=[\s\.,:;\?'\-\!\"])/g), cmd = new RegExp(/\*[A-Za-z_]+\b/);
        new RegExp(/\{.*\}/g);
        return {
            token: function(stream) {
                if (0 === stream.pos) {
                    var indentation = /^( +|\t+)/.exec(stream.string);
                    if (indentation) return stream.pos += indentation[0].length, 
                    editor.options.visibleTabs ? "visible-indentation" : "null";
                }
                cmd.lastIndex = stream.pos;
                indentation = cmd.exec(stream.string);
                if (indentation && indentation.index == stream.pos) {
                    if (2 !== editor.options.spellcheck) return stream.pos += indentation[0].length || 1, 
                    "cmd";
                    stream.skipToEnd();
                }
                word.lastIndex = stream.pos;
                indentation = word.exec(stream.string);
                if (indentation && indentation.index == stream.pos) return stream.pos += indentation[0].length || 1, 
                style = cside.spellCheck(indentation[0]) ? "null" : "spell-error";
                indentation ? stream.pos++ : stream.skipToEnd();
            }
        };
    }()), editor.on("dragover", function(cm, e) {
        $(".CodeMirror-cursors .CodeMirror-cursor").css("visibility", "visible");
        e = {
            left: e.x,
            top: e.y
        }, e = editor.coordsChar(e);
        editor.setCursor(e);
    }), editor.on("dragstart", function(cm, e) {
        e.dataTransfer.setData("Text", editor.getSelection());
    }), editor.on("renderLine", function(cm, line, elt) {
        var charWidth = editor.defaultCharWidth(), line = CodeMirror.countColumn(line.text, null, cm.getOption("tabSize")) * charWidth, cm = 8 * editor.options.tabSize, charWidth = line / cm, line = cm * charWidth;
        elt.style.paddingLeft = line + "px", elt.style.textIndent = "-" + line / (1 + charWidth) + "px";
    }), editor.on("inputRead", function(cm, change) {
        var tok, replacement;
        1 == change.text.length && (editor.getOption("autoformat") && "formattable" == (tok = cm.getTokenAt(change.from)).type && void 0 !== (replacement = autoFormatMap[tok.string]) && (cm.changeGeneration(!0), 
        cm.replaceRange(replacement, {
            line: change.from.line,
            ch: tok.start
        }, {
            line: change.from.line,
            ch: tok.end
        })), editor.getOption("autosuggest") && change.text[0].match(/\w$/) && (autoSuggestFn && clearTimeout(autoSuggestFn), 
        autoSuggestFn = setTimeout(function() {
            CodeMirror.showHint(cm, null, {
                completeSingle: !1,
                extraKeys: {
                    Enter: function() {
                        return !1;
                    }
                }
            });
        }, 150)));
    }), editor.refresh(), editor.forceSyntaxRedraw = function() {
        editor.setOption("mode", "choicescript");
    }, CodeMirror.commands.duplicateLine = function(cm) {
        var cur = cm.getCursor(), cur = (cur = cm.getLine(cur.line).trim()).replace(/^\t+/, "");
        CodeMirror.commands.goLineEnd(cm), CodeMirror.commands.newlineAndIndent(cm), 
        cm.replaceSelection(cur);
    }, function(tagStart, tagEnd, allowSpecialLines) {
        var cursorLoc = "around";
        if (text = editor.getSelection()) {
            for (var line, whitespace, text = text.split("\n"), i = 0; i < text.length; i++) "" === (line = text[i]) || !allowSpecialLines && (line.match(/^\s*\*[A-Za-z_]+\b/) || line.match(/^\s*#/)) || (line = (line = (whitespace = line.match(/^\s+/g)) ? line.replace(/^\s+/g, "") : line).substring(0, tagStart.length) === tagStart && line.substring(line.length - tagEnd.length, line.length) === tagEnd ? line.substring(tagStart.length, line.length - tagEnd.length) : tagStart + line + tagEnd, 
            text[i] = (whitespace || "") + line);
            text = text.join("\n");
        } else text = tagStart + tagEnd, cursorLoc = "start";
        editor.replaceSelection(text, cursorLoc), "start" === cursorLoc && editor.setCursor(editor.getCursor().line, editor.getCursor().ch + tagStart.length);
    }), __csideTabs = {
        game: {
            id: "game",
            title: "Game",
            showTitle: !0,
            iconClass: "fa fa-cube",
            href: ko.observable(""),
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: ko.computed(function() {
                return activeProject() ? activeProject().getName() : "Run a Project";
            }, this)
        },
        issues: {
            id: "issues",
            title: "Issues",
            showTitle: !0,
            iconClass: "fa fa-exclamation-triangle",
            href: "",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: ko.computed(function() {
                return selectedProject() ? "Issues with " + selectedProject().getName() : "Select a Project";
            }, this)
        },
        settings: {
            id: "settings",
            title: "Settings",
            showTitle: !1,
            iconClass: "fa fa-cog",
            href: "",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: ""
        },
        help: {
            id: "help",
            title: "Help & Information",
            showTitle: !0,
            iconClass: "fa fa-question-circle",
            href: "help/index.html",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: "Help & Information"
        },
        dictionary: {
            id: "dictionary",
            title: "User Dictionary",
            showTitle: !0,
            iconClass: "fa fa-book",
            href: "",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: "User Dictionary"
        },
        examples: {
            id: "examples",
            title: "Example Projects & Templates",
            showTitle: !0,
            iconClass: "fa fa-lightbulb-o",
            href: "",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: "Example Projects & Templates"
        }
    };
    function __cycleSceneSelection(direction) {
        var currentScene, sceneList;
        cside.getSelectedProject() && (currentScene = cside.getSelectedScene(), 
        sceneList = cside.getSelectedProject().getScenes(), currentScene && -1 < (currentScene = sceneList.indexOf(cside.getSelectedScene())) && (direction ? 0 < currentScene ? sceneList[--currentScene] : sceneList[sceneList.length - 1] : currentScene < sceneList.length - 1 ? sceneList[++currentScene] : sceneList[0]).select());
    }
    function __getTab(id) {
        for (var tabs = self.tabs(), i = 0; i < tabs.length; i++) if (id === tabs[i].id) return tabs[i];
        return null;
    }
    function __getCSIDEHelp() {
        for (var i = 0; i < frames.length; i++) if (frames[i].csideHelp) return frames[i].csideHelp;
        return null;
    }
    self.tabs = ko.observableArray([]), self.tabs.subscribe(function(tabList) {
        for (var i = 0; i < tabList.length; i++) tabList[i] || tabList.splice(i, 1);
    }), usingNode && (self.cs_examples = [ {
        title: "Interactive CSIDE Tutorial",
        desc: "A great starting point tutorial - developed by Vendetta. Useful for those new to both Choicescript and the Choicescript IDE.",
        path: "cs_examples/CSIDE Tutorial/"
    }, {
        title: "ChoiceScript Basics Tutorial",
        desc: "A simple tutorial template by FairyGodfeather. This example project is designed to get you started with handling name, gender and relationship stats in your ChoiceScript games. A great starting point for any new project!",
        path: "cs_examples/Basics Tutorial/"
    }, {
        title: "Pronouns with Gender-Neutral Options Template",
        desc: 'A template for including gender neutral pronouns in your game (they/them), created by Lynnea Glasser. This includes a variable system to make sure your verbs and pronouns will match ("They go on ahead"/"She goes on ahead").',
        path: "cs_examples/GNO Pronoun Template/"
    }, {
        title: "Editor Theme Configuration Template",
        desc: "An example script that customizes the custom editor theme.",
        path: "cs_examples/Theme Template/"
    } ], self.runExample = function(data) {
        __runProject(new CSIDEProject({
            path: data.path
        }));
    }, self.cloneExample = function(data) {
        self.createProject("", function(err, project) {
            err ? notification("Error", err.message, {
                type: "error"
            }) : __copyProjectTo(data.path, project.getPath(), function(err) {
                err ? notification("Error", err.message, {
                    type: "error"
                }) : (project.openAllScenes(), notification("Import Successful", data.title + " imported to " + project.getPath(), {
                    type: "success"
                }));
            });
        }, !0);
    });
    var settings = {
        editor: ko.observableArray([ new CSIDESetting({
            id: "smartindent",
            name: "Smart Indentation",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Automatically indent (or dedent) the cursor after flow-control commands",
            apply: function(val) {
                val ? editor.setOption("smartIndent", !0) : editor.setOption("smartIndent", !1);
            }
        }), new CSIDESetting({
            id: "linewrap",
            name: "Line Wrapping",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Wrap lines that exceed the editor's width (no horizontal scrolling)",
            apply: function(val) {
                val ? (editor.setOption("lineWrapping", !0), editor.on("renderLine", function(cm, line, elt) {
                    line = CodeMirror.countColumn(line.text, null, cm.getOption("tabSize")) * editor.defaultCharWidth(), 
                    cm = 8 * editor.options.tabSize, line /= cm, cm *= line;
                    elt.style.paddingLeft = cm + "px", elt.style.textIndent = "-" + cm / (1 + line) + "px";
                })) : (delete editor._handlers.renderLine, editor.setOption("lineWrapping", !1)), 
                editor.refresh();
            }
        }), new CSIDESetting({
            id: "autosuggest",
            name: "Auto Suggest",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Prompt quick-complete word suggestions as you type",
            apply: function(val) {
                editor.setOption("autosuggest", val);
            }
        }), new CSIDESetting({
            id: "autoformat",
            name: "Auto Format",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Automatically replace certain character combinations with their formatted equivalents",
            apply: function(val) {
                editor.setOption("autoformat", val);
            }
        }), new CSIDESetting({
            id: "selection-match",
            name: "Selection Match",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Highlight matching instances of selected text",
            apply: function(val) {
                editor.setOption("highlightSelectionMatches", val), editor.forceSyntaxRedraw();
            }
        }), new CSIDESetting({
            id: "visible-tabs",
            name: "Visible Indentation",
            value: !1,
            type: "binary",
            cat: "editor",
            desc: "Provides a visible representation of the indentation level in the editor window",
            apply: function(val) {
                editor.setOption("visibleTabs", val), editor.forceSyntaxRedraw();
            }
        }), new CSIDESetting({
            id: "spellcheck",
            name: "Spell Check",
            value: 2,
            type: "variable",
            cat: "editor",
            options: [ {
                desc: "Exclude cmd lines",
                value: 2
            }, {
                desc: "Include cmd lines",
                value: 1
            }, {
                desc: "Off",
                value: 0
            } ],
            desc: "Underline any mispelt words in the active scene text",
            apply: function(val) {
                editor.setOption("spellcheck", val), editor.forceSyntaxRedraw();
            }
        }), new CSIDESetting({
            id: "spell_dic",
            name: "Spell Check Dictionary",
            value: "en_US",
            type: "variable",
            cat: "editor",
            options: [ {
                desc: "US",
                value: "en_US"
            }, {
                desc: "GB",
                value: "en_GB"
            } ],
            desc: "The dictionary to spellcheck against",
            apply: function(val) {
                typo = new Typo(val, typo._readFile("lib/typo/dictionaries/" + val + "/" + val + ".aff"), typo._readFile("lib/typo/dictionaries/" + val + "/" + val + ".dic"), {
                    platform: "any"
                }), editor.forceSyntaxRedraw();
            }
        }), new CSIDESetting({
            id: "word-count",
            name: "Word Count",
            value: 2,
            type: "variable",
            cat: "editor",
            desc: "Display the current scene's word and character counts at the bottom of the editor window",
            options: [ {
                desc: "Exclude cmd lines",
                value: 2
            }, {
                desc: "Include cmd lines",
                value: 1
            }, {
                desc: "Off",
                value: 0
            } ],
            apply: function(val) {
                wordCountOn(0 < val), editor.setOption("word_count", 0 < val), editor.setOption("exclude_cmd_lines", 1 < val);
            }
        }), new CSIDESetting({
            id: "tabtype",
            name: "Tab Type",
            value: "tabs",
            type: "variable",
            cat: "editor",
            desc: "Sets the indentation unit (used by smart indent)",
            options: [ {
                desc: "Tabs",
                value: "tabs"
            }, {
                desc: "Spaces",
                value: "spaces"
            } ],
            apply: function(val) {
                "spaces" == val ? (editor.setOption("indentWithTabs", !1), keymap.Tab = function(cm) {
                    var spaces;
                    cm.somethingSelected() ? cm.indentSelection("add") : (spaces = Array(cm.getOption("indentUnit") + 1).join(" "), 
                    cm.replaceSelection(spaces));
                }) : (editor.setOption("indentWithTabs", !0), keymap.Tab = function() {
                    editor.execCommand("defaultTab");
                });
            }
        }), new CSIDESetting({
            id: "tabsize",
            name: "Tab/Indent Block Size",
            value: "4",
            type: "dropdown",
            cat: "editor",
            options: [ {
                desc: "2",
                value: "2"
            }, {
                desc: "3",
                value: "3"
            }, {
                desc: "4",
                value: "4"
            }, {
                desc: "5",
                value: "5"
            }, {
                desc: "6",
                value: "6"
            }, {
                desc: "7",
                value: "7"
            }, {
                desc: "8",
                value: "8"
            } ],
            desc: "The number of spaces to indent by, or the visual size of tabs (used by smart indent)",
            apply: function(val) {
                val = parseInt(val, 10);
                editor.setOption("indentUnit", val), editor.setOption("tabSize", val);
            }
        }), new CSIDESetting({
            id: "fontsize",
            name: "Font Size (px)",
            value: "12px",
            type: "variable",
            cat: "editor",
            options: [ {
                desc: "10",
                value: "10px"
            }, {
                desc: "12",
                value: "12px"
            }, {
                desc: "14",
                value: "14px"
            }, {
                desc: "16",
                value: "16px"
            } ],
            desc: "The size of the font in the editor window",
            apply: function(val) {
                $("#editor-wrap").css("font-size", val), editor.refresh();
            }
        }), new CSIDESetting({
            id: "fontfamily",
            name: "Font Family",
            value: "'Century Gothic', AppleGothic, Arial, Helvetica, sans-serif",
            type: "dropdown",
            cat: "editor",
            options: [ {
                desc: "Mono",
                value: "'Courier New', Courier, monospace"
            }, {
                desc: "Sans-Serif",
                value: "Arial, Helvetica, sans-serif"
            }, {
                desc: "Serif",
                value: "'Times New Roman', Times, serif"
            }, {
                desc: "Gothic",
                value: "'Century Gothic', AppleGothic, Arial, Helvetica, sans-serif"
            } ],
            desc: "The font family used in the editor window",
            apply: function(val) {
                $("#editor-wrap").css("font-family", val), editor.refresh();
            }
        }), new CSIDESetting({
            id: "theme",
            name: "Editor Theme",
            value: "cs-light",
            type: "dropdown",
            cat: "editor",
            options: [ {
                desc: "Dark",
                value: "cs-dark"
            }, {
                desc: "Dichromatic",
                value: "cs-dichromatic"
            }, {
                desc: "Light",
                value: "cs-light"
            }, {
                desc: "Custom",
                value: "cs-custom"
            } ],
            desc: "Sets the colour and style of the editor window and its text",
            apply: function(val) {
                var storedCSS;
                "cs-custom" == (val = [ "cs-dark", "cs-light", "cs-dichromatic", "cs-custom" ].includes(val) ? val : "cs-light") && (storedCSS = localStorage.getItem("CSIDE_userCSS"), 
                document.getElementById("user-theme").innerHTML = storedCSS), editor.setOption("theme", val), 
                $("#code-footer, #cs-console").removeClass().addClass("CodeMirror cm-s-" + val);
            }
        }) ]),
        app: ko.observableArray([ new CSIDESetting({
            id: "version",
            name: "Version: " + CSIDE_version,
            value: "",
            type: "variable",
            options: [],
            desc: "",
            apply: function(val) {}
        }), new CSIDESetting({
            id: "autosave",
            name: "Autosave Scenes & Projects",
            value: !1,
            type: "binary",
            desc: "Save all unsaved changes automatically (every 5 minutes)",
            apply: function(val) {
                void 0 !== autoSaveFn && autoSaveFn && clearInterval(autoSaveFn), 
                val && (autoSaveFn = setInterval(function() {
                    self.session.save(function(err) {
                        err && bootbox.alert("<h3>Save Error</h3>" + err.message);
                    });
                }, 3e5));
            }
        }), new CSIDESetting({
            id: "persist",
            name: "Persistent Session",
            value: !1,
            type: "binary",
            desc: "Retain open scenes & project data between sessions",
            apply: function(val) {}
        }), new CSIDESetting({
            id: "cmdhelp",
            name: "Command Help (prompts & links)",
            value: !1,
            type: "binary",
            desc: "Commands in the editor window will link to their appropriate choicescriptdev.wikia page when double-clicked",
            apply: function(val) {
                val ? $(".CodeMirror").off().on("mouseover", ".cm-builtin, .cm-keyword", function() {
                    $(this).css("cursor", "pointer"), $(this).attr("title", "Double-Click for help with this command");
                }).on("mouseout", ".cm-builtin, .cm-keyword", function() {
                    $(this).css("cursor", ""), $(this).removeAttr("title");
                }).on("dblclick", ".cm-builtin, .cm-keyword", function(e) {
                    e.preventDefault(), e.stopPropagation();
                    var e = $(this).parent().children(":first-child").text().trim(), commandName = e.match(/^\*[\w_]+/);
                    commandName && (e = "http://www.choicescriptdev.wikia.com/" + (commandName = commandName[0].substring(1, e.length)), 
                    usingNode ? gui.Shell.openExternal(e) : window.open(e));
                }) : $(".CodeMirror").off();
            }
        }), new CSIDESetting({
            id: "night-mode",
            name: "Night Mode",
            value: !1,
            type: "binary",
            desc: "Toggle between a light and dark application interface",
            apply: function(val) {
                var help = __getCSIDEHelp();
                val ? ($("body").addClass("night"), help && $(help.document.body).addClass("night")) : ($("body").removeClass("night"), 
                help && $(help.document.body).removeClass("night")), uiColour(uiColour());
            }
        }), new CSIDESetting({
            id: "project-path",
            name: "Project Folder",
            value: "default",
            type: "custom",
            options: [ {
                desc: "Select",
                value: "select"
            }, {
                desc: "Default",
                value: "default"
            } ],
            desc: "",
            apply: function(val) {
                var userDir, self = this;
                "default" == val ? (usingNode && (userDir = process.env["win32" == process.platform ? "USERPROFILE" : "HOME"]), 
                userDir = usingNode ? userDir + "/Documents/Choicescript Projects/" : "/Choicescript Projects/", 
                self.setDesc(userDir), user.path = userDir) : "select" == val ? (fh.selectFolder(function(path) {
                    path && (path = __normalizePath(path), self.setValue(path), 
                    self.setDesc(path), user.path = path, config.settings[self.getCat()][self.getId()] = path, 
                    __updateConfig());
                }), self.setValue(user.path), config.settings[self.getCat()][self.getId()] = user.path, 
                __updateConfig()) : (self.setDesc(val), user.path = val);
            }
        }), new CSIDESetting({
            id: "update-channel",
            name: "Update Channel",
            value: "stable",
            type: "variable",
            options: [ {
                desc: "Stable",
                value: "stable"
            }, {
                desc: "Latest",
                value: "latest"
            }, {
                desc: "Development",
                value: "development"
            }, {
                desc: "None",
                value: "none"
            } ],
            desc: "Speed and stability of the updates CSIDE will receive",
            apply: function(channel) {
                var autoUpdate, self = this;
                "web-dropbox" == platform ? self.setVisibility(!1) : (void 0 !== autoUpdateCheckFn && autoUpdateCheckFn && clearInterval(autoUpdateCheckFn), 
                "none" != channel && usingNode && (autoUpdate = function() {
                    var n;
                    self.prompt && !self.prompt.closed || (n = notification("", "<i aria-hidden=true class='fa fa-refresh fa-spin'></i> Checking for updates...", {
                        closeWith: !1,
                        timeout: !1
                    }), updater.checkForUpdates({
                        cside: CSIDE_version,
                        nw: nw_version
                    }, channel, function(err, update) {
                        n.close(), err ? notification("Connection Error", "Failed to obtain update data from server. " + err.message, {
                            type: "error"
                        }) : update && (self.prompt = function(channel, update) {
                            var buttons = [ {
                                addClass: "btn",
                                text: "Download",
                                onClick: function(note) {
                                    note.close(), function(channel) {
                                        var status, eventHandlers;
                                        updating || (status = notification("Downloading Update", "Do not close the program", {
                                            progress: !0,
                                            closeWith: !1,
                                            timeout: !1
                                        }), eventHandlers = {
                                            progress: function(val) {
                                                isNaN(val) || status.setProgress(val);
                                            },
                                            error: function(title, msg) {
                                                notification(title, msg, {
                                                    type: "error"
                                                });
                                            }
                                        }, updating = !0, updater.update(channel, eventHandlers, function(err) {
                                            status.close(), updating = !1, err ? (notification("Update Failed", err.message, {
                                                type: "error",
                                                timeout: 1e4
                                            }), updater.restore(function(err) {
                                                err ? notification("Warning - Rollback failed: Package Corrupt", err.message, {
                                                    type: "error",
                                                    timeout: 1e4
                                                }) : notification("Rollback Succesful", "The previous app package has been restored");
                                            })) : (config.justUpdated = !0, __updateConfig(), 
                                            notification("Update Complete", "Please restart the application.", {
                                                closeWith: !1,
                                                timeout: !1,
                                                type: "success"
                                            }));
                                        }));
                                    }(channel);
                                }
                            }, {
                                addClass: "btn",
                                text: "Cancel",
                                onClick: function(note) {
                                    note.close();
                                }
                            } ];
                            return notification("Update Available on " + (channel.charAt(0).toUpperCase() + channel.slice(1)), update.desc, {
                                closeWith: !1,
                                timeout: !1,
                                buttons: buttons,
                                type: "development" === channel ? "warning" : "alert"
                            });
                        }(channel, update));
                    }));
                }, autoUpdateCheckFn = setInterval(autoUpdate, 36e5), autoUpdate()));
            }
        }), new CSIDESetting({
            id: "ui-colour",
            name: "Colour Scheme",
            value: "rgb(90, 90, 90)",
            type: "variable",
            desc: "",
            options: [ {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(90, 90, 90)'></div>",
                value: "granite"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(175, 93, 111)'></div>",
                value: "garnet"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(147, 122, 175)'></div>",
                value: "amethyst"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(107, 166, 125)'></div>",
                value: "emerald"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(94,104,121)'></div>",
                value: "slate"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(129,127,122)'></div>",
                value: "sandstone"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(51, 164, 164)'></div>",
                value: "jade"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(76,91,152)'></div>",
                value: "sapphire"
            } ],
            apply: function(val) {
                var colour;
                switch (val) {
                  case "granite":
                    colour = "90,90,90";
                    break;

                  case "amethyst":
                    colour = "147,122,175";
                    break;

                  case "garnet":
                    colour = "175,93,111";
                    break;

                  case "emerald":
                    colour = "60,100,80";
                    break;

                  case "slate":
                    colour = "94,104,121";
                    break;

                  case "sandstone":
                    colour = "129,127,122";
                    break;

                  case "jade":
                    colour = "51,164,164";
                    break;

                  case "sapphire":
                    colour = "76,91,152";
                    break;

                  default:
                    colour = "90,90,90";
                }
                uiColour(colour);
            }
        }) ]),
        byId: function(settingType, id) {
            if (void 0 !== settings[settingType]) for (var i = 0; i < settings[settingType]().length; i++) if (settings[settingType]()[i].getId() == id) return settings[settingType]()[i];
            return null;
        },
        asObject: function(settingType) {
            if (void 0 !== settings[settingType]) {
                for (var arr = settings[settingType](), obj = {}, i = 0; i < arr.length; i++) obj[arr[i].getId()] = arr[i].getValue();
                return obj;
            }
            console.log("Invalid settings type passed to settings.asObject function.");
        }
    }, consoleCmdBuf = (self.getEditorSettings = ko.computed(function() {
        return settings.editor().map(function(setting) {
            return setting.extAPI;
        });
    }), self.getAppSettings = ko.computed(function() {
        return settings.app().map(function(setting) {
            return setting.extAPI;
        });
    }), self.scenePanel = function(action) {
        var sidebarLeft;
        $("#page-content-wrapper").is(":animated") || $("#sidebar").is(":animated") || (sidebarLeft = $("#sidebar").css("left"), 
        parseInt(sidebarLeft.slice(0, sidebarLeft.length - 2)) < 0 ? ($("#page-content-wrapper").animate({
            left: 230
        }, 300, function() {
            editor.refresh();
        }), $("#sidebar").animate({
            left: 0
        }, 300, function() {
            editor.refresh();
        })) : ($("#page-content-wrapper").animate({
            left: 0
        }, 300, function() {
            editor.refresh();
        }), $("#sidebar").animate({
            left: -230
        }, 300, function() {
            editor.refresh();
        })));
    }, []), consoleCmdBufPtr = 0;
    ko.observable(0);
    function __openScenes(paths, selectLast) {
        for (var lastIndex = selectLast ? paths.length - 1 : paths.length, i = 0; i < lastIndex; i++) {
            var ext = getFileExtension(paths[i]);
            switch (ext) {
              case ".txt":
                __openScene(paths[i], function() {});
                break;

              case ".log":
                __openLogFile(paths[i], function() {});
                break;

              default:
                return void bootbox.alert("<h3>Error</h3>Attempting to open an unsupported file type: " + ext + ". Please report this.");
            }
        }
        if (selectLast) switch (getFileExtension(paths[lastIndex])) {
          case ".txt":
            __openScene(paths[lastIndex], function(err, scene) {
                err || scene.select();
            });
            break;

          case ".log":
            __openLogFile(paths[lastIndex], function() {});
            break;

          default:
            bootbox.alert("<h3>Error</h3>Attempting to open an unsupported file type: " + ext + ". Please report this.");
        }
    }
    function __promptForString(callback, title, placeholder) {
        bootbox.prompt({
            title: title || "Please enter text",
            value: placeholder || "",
            callback: function(str) {
                callback("string" != typeof str ? "" : function(str) {
                    return str = (str = str.trim()).replace(/\s{2,}/g, " ");
                }(str));
            }
        });
    }
    function __addProject(project) {
        project instanceof CSIDEProject ? projects.unshift(project) : bootbox.alert("Error: Unable to add non-CSIDE Project.");
    }
    function __openLogFile(path, callback) {
        nw.Window.open("file://" + path, {
            focus: !0,
            width: 800,
            height: 600
        }, callback);
    }
    function __openScene(sceneDataOrPath, callback) {
        if ("string" != typeof sceneDataOrPath) throw new Error("Error: Bad sceneData or scenePath - cannot be resolved into scene.");
        var sceneDataOrPath = new CSIDEScene({
            path: sceneDataOrPath,
            source: platform
        }), sceneProjectPath = getProjectPath(sceneDataOrPath.getPath()), sceneProject = function(projectPath) {
            for (var i = 0; i < projects().length; i++) {
                if (projects()[i].getPath() === projectPath) return projects()[i];
                if (i === projects().length - 1) return !1;
            }
        }(sceneProjectPath);
        if (sceneProject) {
            if (function(sceneName, project) {
                for (var scenes = project.getScenes(), i = 0; i < scenes.length; i++) {
                    if (scenes[i].getName() === sceneName) return scenes[i];
                    if (i === scenes.length - 1) return;
                }
            }(sceneDataOrPath.getName(), sceneProject)) return void sceneDataOrPath.select();
        } else __addProject(sceneProject = new CSIDEProject({
            path: sceneProjectPath,
            source: platform
        }));
        sceneProject.addScene(sceneDataOrPath), sceneDataOrPath.load(callback);
    }
    function getSceneName(scenePath) {
        scenePath = getLastDirName(scenePath);
        return scenePath.substring(0, scenePath.length - 4);
    }
    function getLastDirName(path) {
        var divider;
        return divider = -1 != (path = ("/" == path.charAt(path.length - 1) || "\\" == path.charAt(path.length - 1)) && 2 < path.length ? path.substring(0, path.length - 1) : path).lastIndexOf("/") ? "/" : "\\", 
        path.substring(path.lastIndexOf(divider) + 1, path.length);
    }
    function getFileExtension(scenePath) {
        return scenePath.substring(scenePath.lastIndexOf("."), scenePath.length);
    }
    function getProjectPath(scenePath) {
        return scenePath.substring(0, scenePath.lastIndexOf("/") + 1);
    }
    function validName(name, allowSpaces, callback) {
        var err, valid = !1;
        !name || "" === name || /^\s*$/.test(name) ? err = "Name required" : (name.match(/^[\w-\s]+$/) || !allowSpaces) && (name.match(/^[\w-]+$/) || allowSpaces) ? name.toUpperCase().match(reservedSceneNames) ? err = "That name is reserved" : valid = !0 : err = "Name contains invalid characters.", 
        callback(valid, err);
    }
    function __wordCount(string, exclCommandLines) {
        var wordCount = 0;
        return wordCount = 1 === (wordCount = ((exclCommandLines = exclCommandLines || !1) ? ((exclCommandLines = string.replace(/\*.+$/gm, "")).replace(/^\s+|\s+$/g, "").split(/\s+/).length, 
        exclCommandLines) : string).replace(/^\s+|\s+$/g, "").split(/\s+/).length) && "" === string ? 0 : wordCount;
    }
    function __copyProjectTo(oldPath, newPath, callback) {
        fh.readDir(oldPath, function(err, filenames) {
            if (err) callback(err); else for (var count = (filenames = filenames.filter(function(file) {
                return ".txt" === getFileExtension(file);
            })).length, i = 0; i < filenames.length; i++) fh.copyFile(oldPath + filenames[i], newPath + filenames[i], function(err, data) {
                err ? callback(err) : 0 == --count && callback(null);
            });
        });
    }
    function __openFolder(path) {
        usingNode ? gui.Shell.openItem(path) : fileBrowser.open(path, function(selection) {
            selection.length < 1 || __openScenes(selection = selection.filter(function(file) {
                return !file.isFolder();
            }).map(function(file) {
                return file.path;
            }), !0);
        });
    }
    function sceneExists(sceneName, project, callback) {
        project = project.getPath() + sceneName + ".txt";
        fh.stat(project, function(err, stat) {
            err && 404 == err.code || "undefined" !== stat.isRemoved && 1 == stat.isRemoved ? callback(!1) : callback(!0);
        });
    }
    function __normalizeSceneIndentation(scene, indentUnit) {
        var tabSize = settings.asObject("editor").tabsize, lines = (indentUnit = indentUnit || settings.asObject("editor").tabtype, 
        scene.getText().split("\n"));
        if ("spaces" == indentUnit) {
            for (var i = 0; i < lines.length; i++) if (oldIndent = lines[i].match(/^\t+/)) {
                for (var newIndent = "", c = 0; c < oldIndent[0].length * tabSize; c++) newIndent += " ";
                lines[i] = lines[i].replace(/^\t+/, newIndent);
            }
        } else {
            if ("tabs" != indentUnit) throw new Error("Scene Normalization: Bad indent unit: " + indentUnit);
            for (var oldIndent, i = 0; i < lines.length; i++) if (oldIndent = lines[i].match(/^\s+/)) {
                for (newIndent = "", c = 0; c < oldIndent[0].length / tabSize; c++) newIndent += "\t";
                lines[i] = lines[i].replace(/^\s+/, newIndent);
            }
        }
        scene.setText(lines.join("\n"));
    }
    function __selectTab(id) {
        $("#tabs").tabs("option", "active", $("#" + id).index() - 1);
    }
    function __runProject(project) {
        __shortCompile(project, function(err, allScenes) {
            err ? (bootbox.alert("<h3>Compilation Error</h3>" + err.message), console.log(err)) : (cside.allScenes = allScenes, 
            notification("Running", project.getName(), {
                timeout: 2e3
            }), activeProject(project), err = __getTab("game"), allScenes = (allScenes = "run_index.html?restart=true") || err.href(), 
            err.href(""), err.href(allScenes), cside.tabPanel("open"), __selectTab("game"));
        });
    }
    self.consoleInput = function(data, evt) {
        if (evt) {
            var element = evt.originalEvent.target, input = element.value;
            if (38 === evt.keyCode) {
                if (consoleCmdBuf.length <= 0) return;
                --consoleCmdBufPtr < 0 && (consoleCmdBufPtr = consoleCmdBuf.length - 1), 
                element.value = consoleCmdBuf[consoleCmdBufPtr];
            } else if (40 === evt.keyCode) {
                if (consoleCmdBuf.length <= 0) return;
                ++consoleCmdBufPtr > consoleCmdBuf.length - 1 && (consoleCmdBufPtr = 0), 
                element.value = consoleCmdBuf[consoleCmdBufPtr];
            }
            if (input && 13 === evt.keyCode) {
                9 < consoleCmdBuf.length && consoleCmdBuf.shift(), consoleCmdBuf.push(input), 
                consoleCmdBufPtr = consoleCmdBuf.length, selectedProject().logToConsole(input, "*" == input.substring(0, 1) ? "cm-builtin" : "cm-variable");
                var toks, stack, result, evt = document.getElementById("game-tab-frame").contentWindow || document.getElementById("#game-tab-frame");
                if (void 0 === evt || void 0 === evt.stats) selectedProject().logToConsole("Error: no choicescript game running", "cm-error"); else if (selectedProject() != activeProject()) selectedProject().logToConsole("Error: this project is not the one running", "cm-error"); else try {
                    input.match(/^\*/) ? (toks = input.match(/^\*(?:set|temp|rand|achieve|restart|goto|goto_scene)/)) || (toks = input.match(/^\*(console_)?(clear|track|untrack|track_all_off|track_all_on|track_list|help)/)) ? (input = 1 < toks.length && "console_" !== toks[1] ? "*console_" + input.substring(1, input.length) : input).match(/^\*goto/) ? input.match(/^\*goto\s+/) ? (input = input.replace(/^\*goto\s+/, ""), 
                    evt.stats.scene.CSIDEConsole_goto(input)) : (input = input.replace(/^\*goto_scene\s+/, ""), 
                    evt.stats.scene.CSIDEConsole_goto_scene(input)) : evt.stats.scene.runCommand(input) || selectedProject().logToConsole("Error: an unknown error occured whilst attempting to execute that command", "cm-error") : selectedProject().logToConsole("Error: invalid console command", "cm-error") : (stack = evt.stats.scene.tokenizeExpr(input), 
                    result = "string" == typeof (result = evt.stats.scene.evaluateExpr(stack)) ? '"' + result + '"' : result || "false", 
                    selectedProject().logToConsole(result, "output"));
                } catch (e) {
                    e.message = e.message.replace(/line [0-9]+ of\s\w+: /, ""), 
                    selectedProject().logToConsole("Error: " + e.message, "cm-error");
                }
                element.value = "";
            }
        }
    }, self.tabPanel = function(action) {
        if (!$(".left-wrap").is(":animated") && !$(".right-wrap").is(":animated")) {
            var ele, isOpen = !0;
            if (60 < 100 * (ele = $(".left-wrap")).width() / ele.offsetParent().width() && (isOpen = !1), 
            "close" == action && isOpen || !action && isOpen) $(".right-wrap").animate({
                right: "-50%"
            }, 500, function() {
                editor.refresh();
            }), $(".left-wrap").animate({
                width: "100%"
            }, 500, function() {
                editor.refresh();
            }), $("#expand-collapse-bar").addClass("collapsed"); else {
                if (("open" != action || isOpen) && (action || isOpen)) return isOpen;
                $(".left-wrap").animate({
                    width: "50%"
                }, 500, function() {
                    editor.refresh();
                }), $(".right-wrap").animate({
                    right: "0%"
                }, 500, function() {
                    editor.refresh();
                }), $("#expand-collapse-bar").removeClass("collapsed");
            }
        }
    }, self.openScene = function(path, callback) {
        __openScene(path, callback);
    }, self.openLogFile = function(path, callback) {
        getFileExtension(path) && __openLogFile(path, callback);
    }, self.openFileBrowser = function() {
        fh.selectFiles(function(selection) {
            selection && 1 <= selection.length && __openScenes(selection, !0);
        });
    }, self.spellCheck = function(word) {
        return !editor.options.spellcheck || (typo.check(word) || userDictionary.check(word.toLowerCase()) || word.match(/^\d+$/));
    }, userDictionary = {
        persistentList: {},
        persistentListArray: ko.observableArray([]),
        sessionList: {},
        validateWord: function(word) {
            return word.match(/^([A-Za-z\u00C0-\u00FF\u0100-\u017F]+'[A-Za-z\u00C0-\u00FF\u0100-\u017F]+|[A-Za-z\u00C0-\u00FF\u0100-\u017F]{2,}|[AaI]'?)$/);
        },
        add: function(word, list) {
            return !!userDictionary.validateWord(word) && (word = word.toLowerCase(), 
            userDictionary[list + "List"][word] || (userDictionary[list + "List"][word] = !0, 
            userDictionary.update(list), "persistent" == list && userDictionary.persistentListArray.push(word)), 
            !0);
        },
        remove: function(word, list) {
            userDictionary[list + "List"] && delete userDictionary[list + "List"][word], 
            userDictionary.update(list), userDictionary.persistentListArray.remove(word);
        },
        removeAll: function() {
            userDictionary.persistentList = {}, userDictionary.persistentListArray.removeAll();
        },
        check: function(word) {
            var pList = this.persistentList;
            return !(!this.sessionList[word] && !pList[word]);
        },
        load: function() {
            try {
                for (var i in userDictionary.persistentList = JSON.parse(localStorage.getItem("userDictionary")) || {}, 
                userDictionary.persistentList) userDictionary.persistentList.hasOwnProperty(i.toLowerCase()) && userDictionary.persistentListArray.push(i.toLowerCase());
            } catch (err) {
                err ? userDictionary.update() : bootbox.alert("Sorry, there was a problem loading or parsing your user dictionary data.<br>If you're seeing this message frequently please file a bug report.");
            }
        },
        update: function(list) {
            void 0 !== list && "persistent" != list || (list = JSON.stringify(userDictionary.persistentList, null, "\t"), 
            localStorage.setItem("userDictionary", list)), editor.forceSyntaxRedraw();
        },
        sanitize: function() {
            for (var arr = Object.keys(userDictionary.persistentList), i = 0; i < arr.length; i++) {
                if (arr[i] !== arr[i].toLowerCase()) throw new Error("Error: Entry should be lowercase: " + arr[i]);
                if (!userDictionary.validateWord(arr[i])) throw new Error("Error: Invalid entry (not a word): " + arr[i]);
                if (!0 !== userDictionary.persistentList[arr[i]]) throw new Error("Error: Entry value should be 'true' for: " + arr[i]);
            }
        },
        import: function() {
            var path;
            fh.selectFiles(function(selection) {
                !selection || selection.length < 1 || (path = selection[0], 1 < selection.length || ".json" != getFileExtension(path) ? bootbox.alert("<h3>Error</h3>Please select a single valid JSON file.") : bootbox.confirm("Are you sure you wish to import this dictionary?<br>All words from the current dictionary will be lost.", function(result) {
                    result && fh.readFile(path, function(err, data) {
                        if (err) notification("Failed to Read Dictionary", path, {
                            type: "error"
                        }); else try {
                            userDictionary.persistentList = JSON.parse(data), userDictionary.sanitize(), 
                            userDictionary.update(), userDictionary.removeAll(), 
                            userDictionary.load(), notification("Dictionary Import Succesful", path, {
                                type: "success"
                            });
                        } catch (e) {
                            throw notification("Dictionary Import Failed", path, {
                                type: "error"
                            }), e;
                        }
                    });
                }));
            }, {
                extensions: [ ".json" ]
            });
        },
        export: function() {
            var path;
            fh.selectFolder(function(url) {
                url && __promptForString(function(filename) {
                    filename && validName(filename, !1, function(valid, err) {
                        valid ? (path = url + filename + ".json", fh.stat(path, function(err, stats) {
                            err && 404 === err.code ? fh.writeFile(path, localStorage.userDictionary, function(err) {
                                err || notification("Dictionary Export Successful", path, {
                                    type: "success",
                                    buttons: [ {
                                        addClass: "btn",
                                        text: "Show Folder",
                                        onClick: function(note) {
                                            __openFolder(getDirName(path)), note.close();
                                        }
                                    } ]
                                });
                            }) : notification("Export Failed: File already exists", path, {
                                type: "error"
                            });
                        })) : notification("Export Failed: Naming error", err, {
                            type: "error"
                        });
                    });
                }, "Filename for Exported Dictionary", "CSIDE_Dictionary");
            });
        }
    }, self.importDictionary = userDictionary.import, self.exportDictionary = userDictionary.export, 
    self.clearDictionary = function() {
        bootbox.confirm("Are you sure you wish to remove all words from the user dictionary?", function(result) {
            result && (userDictionary.removeAll(), userDictionary.update());
        });
    }, self.dictWord = ko.observable(""), self.addToDictionary = function(obj, e) {
        "click" != e.type && ("keyup" != e.type || 13 != e.keyCode) || userDictionary.add(self.dictWord(), "persistent") || bootbox.alert("<h3>Error</h3>Unable to add to user dictionary: not a word!");
    }, self.removeFromDictionary = function(word) {
        userDictionary.persistentList.hasOwnProperty(word) && userDictionary.remove(word, "persistent");
    }, self.getDictionaryArray = ko.computed(function() {
        var query = self.dictWord().toLowerCase();
        return ("" == query ? userDictionary.persistentListArray() : userDictionary.persistentListArray().filter(function(word) {
            return word.startsWith(query);
        })).sort();
    }, this), self.init = function() {
        if (usingNode || (user.name = "dropbox-user"), config.settings.app.persist) {
            for (var i = 0; i < config.openProjects.length; i++) {
                var thisProjectData, project = new CSIDEProject(thisProjectData = config.openProjects[i]);
                __addProject(project);
                for (var n = 0; n < thisProjectData.openScenes.length; n++) {
                    var scene = new CSIDEScene(thisProjectData.openScenes[n]);
                    project.addScene(scene), scene.load();
                }
            }
            if (config.tabs.length === __csideTabs.length) for (var e = 0; e < config.tabs.length; e++) self.tabs.push(__csideTabs[config.tabs[e]]); else for (var tab in __csideTabs) self.tabs.push(__csideTabs[tab]);
        } else for (var tab in __csideTabs) self.tabs.push(__csideTabs[tab]);
        for (var scope = settings.editor(), i = 0; i < scope.length; i++) {
            var val = (void 0 !== config.settings.editor[scope[i].getId()] ? config : defaultConfig).settings.editor[scope[i].getId()];
            scope[i].setValue(val);
        }
        for (scope = settings.app(), i = 0; i < scope.length; i++) {
            val = (void 0 !== config.settings.app[scope[i].getId()] ? config : defaultConfig).settings.app[scope[i].getId()];
            scope[i].setValue(val);
        }
        try {
            userDictionary.sanitize(), userDictionary.load();
        } catch (err) {
            bootbox.alert("Sorry, there was a problem loading or parsing your user dictionary data.<br>If you're seeing this message frequently please file a bug report.");
        }
        __selectTab("help"), !config.justUpdated && void 0 !== config.justUpdated || (config.justUpdated = !1, 
        __updateConfig(), setTimeout(function() {
            notification("Updated to v" + CSIDE_version, "A full list of changes can be found under 'Changelog' in the help and information tab.", {
                buttons: [ {
                    addClass: "btn",
                    text: "Show Changelog",
                    onClick: function(note) {
                        var csideHelp = __getCSIDEHelp();
                        csideHelp && (csideHelp.breadcrumbs = [ {
                            url: "home.html",
                            title: "Home"
                        }, {
                            url: "changelog.md",
                            title: "Changelog"
                        } ], csideHelp.history = [ "home.html", "changelog.md" ], 
                        csideHelp.drawPage("changelog.md")), note.close();
                    }
                } ]
            }).setTimeout(5e3);
        }, 1e4));
    }, self.slideUpAndOut = function(elem) {
        $(elem).parent().find("ul").remove(), $(elem).animate({
            minHeight: 0,
            height: 0,
            padding: 0
        }, 400, function() {
            $(elem).remove();
        });
    }, self.slideDownAndIn = function(elem) {
        $(elem).hide().slideDown(400);
    }, self.fadeIn = function(elem) {
        $(elem).hide().fadeIn("fast");
    }, self.fadeOutAndUp = function(elem) {
        $(elem).animate({
            opacity: 0,
            height: 0,
            padding: 0
        }, 400, function() {
            $(elem).remove();
        });
    }, self.showWordCount = function(sceneOrProject) {
        sceneOrProject.getWordCount(), sceneOrProject.getWordCount(!0), sceneOrProject.getCharCount();
        var type = sceneOrProject.constructor.name.substring("CSIDE".length, sceneOrProject.constructor.name.length), selectedTitle = "Scene" == type ? "Currently Selected Text (this scene)" : "Currently Selected Text (in all scenes)", type = type + " - " + sceneOrProject.getName(), msg = "<h5>Word Count</h5> \t\t    Including command lines: " + sceneOrProject.getWordCount() + "<br>Excluding command lines: " + sceneOrProject.getWordCount(!0), msg = (msg += "<br>Characters: " + sceneOrProject.getCharCount()) + ("<br><br><h5>" + selectedTitle + "</h5> \t\t\t\tWords including command lines: " + sceneOrProject.getWordCount(!1, !0) + "<br>Words excluding command lines: " + sceneOrProject.getWordCount(!0, !0) + "<br>Characters: " + sceneOrProject.getCharCount(!0)) + "<br><br>Please note that these figures are only approximations.<br>Project word counts only include those of open scenes.";
        bootbox.alert({
            message: msg,
            title: type
        });
    };
    self.createProject = function(projectName, cb, blank) {
        function __create(projectName) {
            validName(projectName, !0, function(valid, err) {
                var callback;
                valid ? (valid = user.path + projectName, callback = function(exists) {
                    exists ? notification("Project Naming Error", "A Project with that name already exists in the project directory", {
                        type: "error"
                    }) : function(projectName, cb, blank) {
                        blank = blank || !1, function(cpf_cb) {
                            var projectPath = user.path + (projectName + "/");
                            fh.makeDir(projectPath, function(err) {
                                err && "EEXIST" == err.code ? (bootbox.alert("Error: That Project folder could not be created because it already exists."), 
                                cpf_cb(!0)) : err ? (bootbox.alert("Error: Unable to create the project folder, check your permissions."), 
                                cpf_cb(!0)) : cpf_cb(!1, projectPath);
                            });
                        }(function(err, projectPath) {
                            err && cb(err);
                            var project = new CSIDEProject({
                                name: projectName,
                                path: projectPath,
                                source: platform
                            }), err = (__addProject(project), "*title " + projectName + "\n*author " + user.name + "\n*comment your code goes here\n*finish");
                            (blank ? [] : [ new CSIDEScene({
                                path: projectPath + "choicescript_stats.txt",
                                contents: "",
                                source: platform
                            }), new CSIDEScene({
                                path: projectPath + "startup.txt",
                                contents: err,
                                source: platform
                            }) ]).forEach(function(scene, index) {
                                scene.save(null, null, function(err) {
                                    err ? bootbox.alert(err.message) : (project.addScene(scene), 
                                    scene.load(function(err, scene) {
                                        err || scene.select();
                                    }));
                                });
                            }), cb(null, project);
                        });
                    }(projectName, cb, blank);
                }, fh.stat(valid, function(err, stat) {
                    err && 404 == err.code || "undefined" !== stat.isRemoved && 1 == stat.isRemoved ? callback(!1) : callback(!0);
                })) : notification("Project Naming Error", err, {
                    type: "error"
                });
            });
        }
        blank = blank || !1, "function" != typeof cb && (cb = function(err, project) {
            err || notification("Project created", project.getPath(), {
                type: "success",
                layout: "bottomRight"
            });
        }), "string" != typeof projectName || "" == projectName ? __promptForString(function(str) {
            str && __create(str);
        }, "Name of Project?") : __create(projectName);
    };
    function __shortCompile(project, cb, transpile) {
        var statusBox = notification("Compiling... ", project.getName(), {
            closeWith: !1,
            timeout: !1
        }), allScenes = {}, failed = !1, projectPath = project.getPath();
        fh.readDir(projectPath, function(err, fileNames) {
            var count;
            return err || (count = (fileNames = fileNames.filter(function(fileName) {
                return ".txt" === getFileExtension(fileName);
            })).length, fileNames.forEach(function(fileName, index) {
                fh.readFile(projectPath + fileName, function(err, data) {
                    if (!failed) return err ? (failed = !0, statusBox.close(), 404 == err.code && (err = new Error("File not found: " + fileName)), 
                    cb(err)) : (err = function(fileName, data) {
                        var scene = new Scene(), fileName = getSceneName(fileName);
                        try {
                            scene.loadLines(data);
                        } catch (err) {
                            return statusBox.close(), new Error(err.message + " - " + fileName + ".txt");
                        }
                        if (transpile) {
                            for (var changes = [], lineNum = 0; lineNum < scene.lines.length; lineNum++) {
                                var command = /^\s*\*(\w+)(.*)/.exec(scene.lines[lineNum]);
                                if (command && cse[command[1]]) {
                                    for (var block_size = 1; scene.getIndent(scene.lines[lineNum + block_size]) > scene.getIndent(scene.lines[lineNum]); ) block_size++;
                                    changes.push({
                                        targetLine: lineNum,
                                        targetLength: block_size,
                                        change: cse[command[1]].transpile(scene, command[2], lineNum, block_size)
                                    });
                                }
                            }
                            for (var c = 0; c < changes.length; c++) Array.prototype.splice.apply(scene.lines, [ changes[c].targetLine, changes[c].targetLength ].concat(changes[c].change));
                        }
                        return allScenes[fileName] = {}, allScenes[fileName].crc = scene.temps.choice_crc, 
                        allScenes[fileName].labels = scene.labels, allScenes[fileName].lines = scene.lines, 
                        !1;
                    }(fileName, data)) ? (statusBox.close(), cb(err)) : void (0 == --count && (statusBox.close(), 
                    cb(null, allScenes)));
                });
            }), failed) ? (statusBox.close(), cb(err)) : void 0;
        });
    }
    var fileBrowser, cse = {
        getFreeLabelName: function(scene, prefix) {
            for (var i = 0; i < prefix && void 0 !== scene.labels[prefix + "_" + i]; i++);
            return prefix + "_" + i;
        },
        while: {
            transpile: function(scene, expr, line, block_size) {
                var lines = [], label = cse.getFreeLabelName(scene, "while_loop");
                return lines.push("*label " + label), lines.push("*if" + expr), 
                (lines = lines.concat(scene.lines.slice(line + 1, line + block_size))).push("\t*goto " + label), 
                lines;
            }
        }
    };
    function __updateConfig() {
        var newConfig = JSON.stringify(config, null, "\t");
        localStorage.setItem("CSIDE_appConfig", newConfig);
    }
    function __updatePersistenceList() {
        config.openProjects = [], config.tabs = [];
        for (var i = 0; i < projects().length; i++) {
            for (var thisScene, thisProject = {
                path: projects()[i].getPath(),
                source: projects()[i].getSource(),
                name: projects()[i].getName(),
                expanded: projects()[i].isExpanded(),
                openScenes: []
            }, n = 0; n < projects()[i].getScenes().length; n++) thisScene = {
                path: projects()[i].getScenes()[n].getPath(),
                source: projects()[i].getScenes()[n].getSource(),
                color: projects()[i].getScenes()[n].getMarkColour()
            }, thisProject.openScenes.push(thisScene);
            config.openProjects.unshift(thisProject);
        }
        for (var e = 0; e < self.tabs().length; e++) config.tabs[e] = self.tabs()[e].id;
        __updateConfig();
    }
    self.updatePersistenceList = function() {
        __updatePersistenceList();
    }, self.makeSortable = function(data) {
        __makeSortable(data);
    }, self.dragSceneEvent = function(arg, event, ui) {
        var targetProject, movingScene;
        function execute(action) {
            sceneExists(arg.item.getName(), targetProject, function(exists) {
                exists ? ($(ui.sender).sortable("cancel"), arg.cancelDrop = !0, 
                bootbox.alert("This project already has a scene by that name.")) : action();
            });
        }
        console.log(arg, arg.item, arg.targetParent, arg.targetParent(), event, ui, ui.target), 
        console.log(), arg.sourceParent != arg.targetParent && (targetProject = ko.dataFor(event.target), 
        movingScene = arg.item, arg.cancelDrop = !0, bootbox.dialog({
            message: "Would you like to <b>move</b> or <b>copy</b> this scene to this project?",
            title: "What would you like to do?",
            buttons: {
                copy: {
                    label: "Copy",
                    className: "btn-primary",
                    callback: function() {
                        execute(function() {
                            movingScene.copyTo(targetProject);
                        });
                    }
                },
                move: {
                    label: "Move",
                    callback: function() {
                        execute(function() {
                            movingScene.moveTo(targetProject);
                        });
                    }
                },
                cancel: {
                    label: "Cancel",
                    callback: function() {}
                }
            }
        }));
    }, ko.bindingHandlers.bindIframe = {
        init: function(element, valueAccessor) {
            function bindIframe() {
                try {
                    var iframeInit = element.contentWindow.initChildFrame, iframedoc = element.contentDocument.body;
                } catch (e) {}
                iframeInit ? iframeInit(ko, valueAccessor()) : iframedoc && ko.applyBindings(valueAccessor(), iframedoc);
            }
            bindIframe(), ko.utils.registerEventHandler(element, "load", bindIframe);
        }
    }, ko.bindingHandlers.enableTextInput = {
        init: function(element, valueAccessor) {
            $(element).prop("readOnly", !0);
        },
        update: function(element, valueAccessor) {
            $(element).prop("readOnly", !ko.utils.unwrapObservable(valueAccessor()));
        }
    }, ko.bindingHandlers.fadeVisible = {
        init: function(element, valueAccessor) {
            valueAccessor = valueAccessor();
            $(element).toggle(ko.utils.unwrapObservable(valueAccessor));
        },
        update: function(element, valueAccessor) {
            valueAccessor = valueAccessor();
            ko.utils.unwrapObservable(valueAccessor) ? $(element).show().animate({
                opacity: 1
            }, 250) : $(element).animate({
                opacity: 0
            }, 250, function() {
                $(this).hide();
            });
        }
    }, ko.bindingHandlers.fadeAndSlideVisible = {
        init: function(element, valueAccessor) {
            valueAccessor = valueAccessor();
            $(element).toggle(ko.unwrap(valueAccessor));
        },
        update: function(element, valueAccessor) {
            valueAccessor = valueAccessor();
            ko.unwrap(valueAccessor) ? $(element).slideDown(500).animate({
                opacity: 1
            }, {
                queue: !1,
                duration: 350
            }) : $(element).slideUp(500).animate({
                opacity: 0
            }, {
                queue: !1,
                duration: 350
            });
        }
    }, ko.bindingHandlers.initFiles = {
        init: function(element, valueAccessor) {
            $(element).draggable({
                cursor: "move",
                cursorAt: {
                    left: 5,
                    top: 5
                },
                scroll: !0,
                start: function(event, ui) {
                    ui.helper.appendTo($("body"));
                },
                helper: function() {
                    var newElement = $("<div></div>");
                    return newElement.addClass("helper"), newElement.text($("folder.selected").length), 
                    $(newElement);
                }
            });
        },
        update: function(element, valueAccessor, allBindings) {}
    }, ko.bindingHandlers.initFolders = {
        init: function(element, valueAccessor) {
            $(element).droppable({
                accept: ".file, .folder-ul",
                over: function(event, ui) {
                    $(this).css("background-color", "#F7F7E1");
                },
                out: function(event, ui) {
                    $(this).css("background-color", "");
                },
                drop: function(event, ui) {
                    $(this).delay(100).fadeOut().fadeIn("slow");
                    var targetFolder = $(this);
                    $(".folder-selected").each(function() {
                        moveDropboxItem($(this), targetFolder);
                    });
                }
            }).draggable({
                cursor: "move",
                cursorAt: {
                    left: 5,
                    top: 5
                },
                scroll: !0,
                start: function(event, ui) {
                    ui.helper.appendTo($("body"));
                },
                helper: function() {
                    var newElement = $("<div></div>");
                    return newElement.addClass("helper"), $(newElement);
                }
            });
        },
        update: function(element, valueAccessor, allBindings) {}
    };
    {
        function fileBrowser() {
            var shiftPressed = !1, ctrlPressed = !1, self = ($(document).keydown(function(e) {
                17 == e.keyCode && (e.preventDefault(), ctrlPressed = !0), 16 == e.keyCode && (e.preventDefault(), 
                shiftPressed = !0);
            }), $(document).keyup(function(e) {
                17 == e.keyCode && (e.preventDefault(), ctrlPressed = !1), 16 == e.keyCode && (e.preventDefault(), 
                shiftPressed = !1);
            }), this), visible = ko.observable(!1), loading = ko.observable(!1), curPath = ko.observable(""), buttonText = ko.observable("Open"), browserTitle = ko.observable("Open scenes"), stateDesc = ko.observable(""), error = ko.observable(!1);
            function fileFolderItem(data) {
                var parsedDate, thisFileFolder = this;
                thisFileFolder.is_folder = "folder" == data[".tag"] || data.isFolder || data.is_folder, 
                thisFileFolder.name = data.name, thisFileFolder.path = data.path, 
                thisFileFolder.icon = data.icon || (data.isFolder ? "fa fa-folder-o fa-lg" : "fa fa-file-o fa-lg"), 
                thisFileFolder.selected = ko.observable(!1), thisFileFolder.index = data.listIndex, 
                thisFileFolder.select = function(data, event, forcedValue, skipKeyCheck) {
                    if (!skipKeyCheck) {
                        var selectedList = self.selection(), fullList = self.filesAndFolders();
                        if (!ctrlPressed && !shiftPressed && 0 < selectedList.length) {
                            for (var s in selectedList) fullList[selectedList[s].index].selected(!1);
                            self.selection([]);
                        } else if (shiftPressed) {
                            selectedList.sort(function(a, b) {
                                return a.index - b.index;
                            });
                            var topToBottom = !1;
                            if (self.selection() < 1) for (var i = 0; i < thisFileFolder.index; i++) fullList[i].select({}, {}, !0, !0); else {
                                for (i = 0; i < thisFileFolder.index; i++) if (fullList[i].selected()) {
                                    topToBottom = !0;
                                    break;
                                }
                                if (topToBottom) for (i = selectedList[0].index; i < thisFileFolder.index; i++) fullList[i].selected() || fullList[i].select({}, {}, !0, !0); else for (i = selectedList[selectedList.length - 1].index; i > thisFileFolder.index; i--) fullList[i].selected() || fullList[i].select({}, {}, !0, !0);
                            }
                        }
                    }
                    forcedValue ? thisFileFolder.selected(forcedValue) : thisFileFolder.selected() ? thisFileFolder.selected(!1) : thisFileFolder.selected(!0), 
                    self.selection.push(thisFileFolder);
                }, data.isFolder ? thisFileFolder.open = function() {
                    self.redraw(thisFileFolder.path);
                } : thisFileFolder.open = function() {
                    "function" == typeof self.callback ? (self.selection = ko.observableArray([ thisFileFolder ]), 
                    self.executeTask()) : self.close();
                }, thisFileFolder.dateModified = data.modifiedAt || "", "" != thisFileFolder.dateModified && ((parsedDate = {}).day = data.modifiedAt.getDate(), 
                parsedDate.month = data.modifiedAt.getMonth(), parsedDate.year = data.modifiedAt.getFullYear(), 
                parsedDate.hours = data.modifiedAt.getHours(), parsedDate.mins = data.modifiedAt.getMinutes(), 
                parsedDate.mins.toString().length < 2 && (parsedDate.mins = "0" + parsedDate.mins.toString()), 
                thisFileFolder.dateModified = " - last modified at " + parsedDate.day + "/" + parsedDate.month + "/" + parsedDate.year + " at " + parsedDate.hours + ":" + parsedDate.mins), 
                thisFileFolder.isFolder = function() {
                    return thisFileFolder.is_folder;
                };
            }
            self.getButtonText = ko.computed(function() {
                return buttonText();
            }, this), self.getBrowserTitle = ko.computed(function() {
                return browserTitle() + ": " + curPath();
            }, this), self.isVisible = ko.computed(function() {
                return visible();
            }, this), self.isLoading = ko.computed(function() {
                return loading();
            }, this), self.getStateDesc = ko.computed(function() {
                return stateDesc();
            }, this), self.hasErrored = ko.computed(function() {
                return error();
            }, this), self.path = ko.computed(function() {
                return curPath();
            }, this), self.selectingFolder = !1, self.filesAndFolders = ko.observableArray([]), 
            self.selection = ko.observableArray([]), this.cancel = function() {
                "function" == typeof self.callback && self.callback([]), self.close();
            }, this.close = function() {
                var s, selectedList = self.selection(), fullList = self.filesAndFolders();
                for (s in selectedList) fullList[selectedList[s].index].selected(!1);
                self.selection([]), self.callback = null, self.selectingFolder = !1, 
                self.extensions = [ ".txt", ".log" ], visible(!1);
            }, this.open = function(path, callback, options) {
                "function" == typeof path && (options = callback, callback = path, 
                path = ""), self.selectingFolder ? (buttonText("Select"), browserTitle("Select a Folder")) : options && options.extensions ? (self.extensions = options.extensions, 
                buttonText("Open"), browserTitle("Select " + self.extensions.join(", "))) : (self.extensions = [ ".txt", ".log" ], 
                buttonText("Open"), browserTitle("Open scenes")), self.callback = callback, 
                path = path || curPath(), self.redraw(path), visible(!0);
            }, this.redraw = function(path) {
                stateDesc("Connecting..."), loading(!0), error(!1), curPath(path), 
                self.filesAndFolders([]), self.selection([]);
                var position = 0;
                fh.readDir(path, function(err, listStats) {
                    if (err) error(!0), stateDesc("Failed to connect. Please check your internet connection."); else {
                        "/" != curPath() && "" != curPath() && ((err = curPath().split("/")).pop(), 
                        err = err.join("/"), self.filesAndFolders.push(new fileFolderItem({
                            name: "Up a level",
                            path: err,
                            isFolder: !0,
                            icon: "fa fa-level-up fa-lg",
                            listIndex: position
                        })), position++);
                        for (var i = 0; i < listStats.length; i++) !listStats[i].isFolder && self.extensions.indexOf(getFileExtension(listStats[i].path)) < 0 || (listStats[i].listIndex = position, 
                        self.selectingFolder && !listStats[i].isFolder || (position++, 
                        self.filesAndFolders.push(new fileFolderItem(listStats[i]))));
                    }
                    loading(!1);
                }, !0);
            }, this.selectFolders = function(callback) {
                self.selectingFolder = !0, self.open("", callback);
            }, this.executeTask = function() {
                !self.selectingFolder && 1 == self.selection().length && self.selection()[0].isFolder() ? self.selection()[0].open() : (self.callback(self.selection()), 
                self.close());
            };
        }
        usingNode;
    }
    function contextMenu(newTarget, newOptions) {
        var target = newTarget, options = newOptions;
        this.getTitle = function() {
            return title;
        }, this.getOptions = ko.computed(function() {
            return options();
        }, this), this.getTarget = function() {
            return target;
        };
    }
    function menuOption(newLabel, newAction, newSubMenu) {
        var label = newLabel, newLabel = newAction, subMenu = newSubMenu;
        this.getLabel = function() {
            return label;
        }, this.getSubMenuOptions = function() {
            return subMenu;
        }, this.doAction = newLabel;
    }
    usingNode || (fileBrowser = new fileBrowser(), ko.applyBindings(fileBrowser, $("#file-browser-canvas")[0]), 
    self.webFileBrowserClosed = ko.computed(function() {
        return !fileBrowser.isVisible();
    }));
    var toolbarMenus, fileMenuOptions = ko.observableArray([ new menuOption("Open Scene", function(menu) {
        menu.getTarget().open();
    }) ]), folderMenuOptions = ko.observableArray([ new menuOption("Open Folder", function(menu) {
        menu.getTarget().open();
    }) ]);
    function toolbarMenu(data) {
        var menu = this, title = ko.observable(data.title || ""), expanded = ko.observable(!1);
        menu.isActive = data.active || !0, menu.getTarget = data.target, menu.doAction = function(option) {
            expanded(!1), option.doAction(menu);
        }, menu.isExpanded = ko.computed(function() {
            return expanded();
        }, this), menu.toggle = function(force) {
            "boolean" == typeof force ? expanded(force) : expanded() ? expanded(!1) : expanded(!0);
        }, menu.getTitle = title(), menu.getOptions = ko.computed(function() {
            return data.options();
        }, this);
    }
    "mac_os" !== platform && (toolbarMenus = ko.observableArray([ new toolbarMenu({
        title: "<span title='Project' class='fa fa-folder-open-o '>",
        active: self.getSelectedProject,
        options: ko.computed(function() {
            return new contextMenu(selectedProject(), projectMenuOptions).getOptions();
        }, this),
        target: ko.computed(function() {
            return selectedProject();
        }, this)
    }), new toolbarMenu({
        title: "<span title='Scene' class='fa fa-file-text-o'>",
        active: self.getSelectedScene,
        options: ko.computed(function() {
            return new contextMenu(selectedScene(), sceneMenuOptions).getOptions();
        }, this),
        target: ko.computed(function() {
            return selectedScene();
        }, this)
    }) ]), self.getToolbarMenus = ko.computed(function() {
        return toolbarMenus();
    }, this));
    nativeMenuBar = new function() {
        this.isReady = function() {
            return !0;
        };
        var menu = ko.observable();
        this.getContextMenu = ko.computed(function() {
            return menu();
        }, this), $(function() {
            function Menu(cutLabel, copyLabel, pasteLabel) {
                require("nw.gui");
                var menu = new nw.Menu(), cutLabel = new nw.MenuItem({
                    label: cutLabel || "Cut",
                    click: function() {
                        document.execCommand("cut");
                    }
                }), copyLabel = new nw.MenuItem({
                    label: copyLabel || "Copy",
                    click: function() {
                        document.execCommand("copy");
                    }
                }), paste = new nw.MenuItem({
                    label: pasteLabel || "Paste",
                    click: function() {
                        document.execCommand("paste");
                    }
                }), indent = new nw.MenuItem({
                    label: pasteLabel || "Indent",
                    click: function() {
                        editor.execCommand("indentMore");
                    }
                }), pasteLabel = new nw.MenuItem({
                    label: pasteLabel || "Dedent",
                    click: function() {
                        editor.execCommand("indentLess");
                    }
                }), select = new nw.MenuItem({
                    label: "Select all",
                    click: function() {
                        editor.execCommand("selectAll");
                    }
                }), comment = new nw.MenuItem({
                    label: "Toggle block comment",
                    click: function() {
                        insertTextTags("*comment ", "", !0);
                    }
                }), dblLinebreak = new nw.MenuItem({
                    label: "Insert double line break",
                    click: function() {
                        var cur = editor.getCursor();
                        cur && ((cur = editor.getLine(cur.line)) && (cur = cur.match(/^\s+/)) ? editor.replaceSelection("\n" + cur + "*line_break\n" + cur + "*line_break\n" + cur, "end") : editor.replaceSelection("\n*line_break\n*line_break\n", "end")), 
                        editor.focus();
                    }
                });
                return menu.append(cutLabel), menu.append(copyLabel), menu.append(paste), 
                menu.append(indent), menu.append(pasteLabel), menu.append(select), 
                menu.append(dblLinebreak), menu.append(comment), menu;
            }
            usingNode && ($(".CodeMirror-scroll").on("contextmenu", function(e) {
                e.preventDefault();
            }), $("body").on("contextmenu", ".CodeMirror-code", function(e) {
                var menu = new Menu();
                e.preventDefault(), menu.popup(e.originalEvent.x, e.originalEvent.y);
            }));
        }), $(function() {
            $("#sidebar").contextmenu({
                target: "#context-menu",
                scopes: ".project-header",
                before: function(event, element) {
                    element = ko.dataFor(element.parent().get(0));
                    return menu(new contextMenu(element, projectMenuOptions)), !0;
                }
            }), $("#main-project-wrap").contextmenu({
                target: "#context-menu",
                scopes: ".scene",
                before: function(event, element) {
                    element = ko.dataFor(element.get(0));
                    return !(element.getErrState() || !element.hasLoaded() || element.isSaving() || element.isLocked()) && (menu(new contextMenu(element, sceneMenuOptions)), 
                    !0);
                }
            }), $("#file-browser-ul").contextmenu({
                target: "#context-menu",
                scopes: ".file",
                before: function(event, element) {
                    element = ko.dataFor(element.get(0));
                    return element.isFolder() ? menu(new contextMenu(element, folderMenuOptions)) : menu(new contextMenu(element, fileMenuOptions)), 
                    !0;
                }
            }), $(".CodeMirror-code").contextmenu({
                target: "#context-menu",
                scopes: ".cm-spell-error",
                before: function(e, element) {
                    var menuElement, word, menuOptions;
                    if (!typo.working) return typo.working = !0, menuElement = this.getMenu()[0], 
                    menu(new contextMenu(null, ko.observableArray([ new menuOption("Working...", function() {}) ]))), 
                    e = editor.coordsChar({
                        left: e.originalEvent.x,
                        top: e.originalEvent.y
                    }), editor.setCursor(e), e = editor.findWordAt(e), editor.setSelection(e.anchor, e.head), 
                    word = element.text(), menuOptions = ko.observableArray([]), 
                    typo.suggest(word, 5, function(suggestions) {
                        suggestions.length < 1 && menuOptions.push(new menuOption("No suggestions for " + word, function(menu) {}));
                        for (var i = 0; i < suggestions.length; i++) !function(i) {
                            var thisSuggestion = suggestions[i];
                            menuOptions.push(new menuOption(thisSuggestion, function(menu) {
                                var undo;
                                undo = !1, editor.replaceSelection(thisSuggestion), 
                                undo && editor.getDoc().undo(), editor.focus(), 
                                editor.focus();
                            }));
                        }(i);
                        menuOptions.push(new menuOption("Ignore '" + word + "' this session", function() {
                            userDictionary.add(word, "session"), editor.focus();
                        })), menuOptions.push(new menuOption("Add '" + word + "' to user dictionary", function() {
                            userDictionary.add(word, "persistent"), editor.focus();
                        })), typo.working = !1, menu(new contextMenu(null, menuOptions)), 
                        window.innerHeight - menuElement.offsetTop < 25 * menuOptions().length && (menuElement.style.top = menuElement.style.top.slice(0, menuElement.style.top.length - 2) - 18 * menuOptions().length + "px");
                    }), !0;
                }
            });
        });
    }();
    ko.applyBindings(nativeMenuBar, $("#context-menu")[0]);
}

function Scene(name, stats, nav, options) {
    stats = stats || {}, this.name = name = name || "", this.stats = stats, this.temps = {
        choice_reuse: "allow",
        choice_user_restored: !1,
        _choiceEnds: {}
    }, this.nav = nav, this.debugMode = (options = options || {}).debugMode || !1, 
    this.secondaryMode = options.secondaryMode, this.saveSlot = options.saveSlot || "", 
    this.lines = [], this.lineNum = 0, this.rollbackLineCoverage(), this.finished = !1, 
    this.labels = {}, this.indent = 0, this.prevLine = "empty", this.screenEmpty = !0, 
    this.initialCommands = !0, this.stats.sceneName = name, (this.stats.scene = this).target = null, 
    this.accumulatedParagraph = [];
}

function SceneNavigator(sceneList) {
    this.setSceneList(sceneList), this.startingStats = {};
}

function callIos(scheme, path) {
    if (_global.isIosApp) {
        if ("undefined" != typeof webkit && webkit.messageHandlers) return webkit.messageHandlers.choicescript.postMessage([ scheme, path ]);
        path = path ? encodeURIComponent(path).replace(/[!~*')(]/g, function(match) {
            return "%" + match.charCodeAt(0).toString(16);
        }) : "", setTimeout(function() {
            var iframe = document.createElement("IFRAME");
            iframe.setAttribute("src", scheme + "://" + path), iframe.setAttribute("style", "display:none"), 
            document.documentElement.appendChild(iframe), iframe.parentNode.removeChild(iframe);
        }, 0);
    }
}

function safeCall(obj, fn) {
    if (fn) {
        var isHeadless = "undefined" == typeof window, debug = !isHeadless && window.debug;
        if (isIE || isHeadless) "undefined" != typeof MSApp ? obj ? MSApp.execUnsafeLocalFunction(function() {
            fn.call(obj);
        }) : MSApp.execUnsafeLocalFunction(fn) : obj ? fn.call(obj) : fn.call(); else try {
            obj ? fn.call(obj) : fn.call();
        } catch (e) {
            if (e.message ? window.onerror(e.message, e.fileName, e.lineNumber, e.stack) : e.stack ? window.onerror(e.stack, e.fileName, e.lineNumber, e.stack) : window.onerror(toJson(e, "\n")), 
            window.console && (window.console.error(e), e.message && window.console.error("Message: " + e.message), 
            e.stack && window.console.error("Stack: " + e.stack)), debug) throw e;
        }
    }
}

function safeCallback(callback) {
    return function() {
        safeCall(null, callback);
    };
}

function safeTimeout(fn, time) {
    setTimeout(function() {
        safeCall(null, fn);
    }, time);
}

function isDefined(x) {
    return void 0 !== x;
}

function jsonStringifyAscii(obj) {
    return JSON.stringify(obj).replace(/(.)/g, function(x) {
        var code = x.charCodeAt(0);
        if (127 < code || code < 32) {
            var outCode = code.toString(16);
            switch (outCode.length) {
              case 4:
                return "\\u" + outCode;

              case 3:
                return "\\u0" + outCode;

              case 2:
                return "\\u00" + outCode;

              case 1:
                return "\\u000" + outCode;

              default:
                return x;
            }
        }
        return x;
    });
}

function toJson(obj, standardized) {
    if ("undefined" != typeof JSON && JSON.stringify) return jsonStringifyAscii(obj);
    switch (typeof obj) {
      case "object":
        if (obj) {
            var prop, list = [];
            if (obj instanceof Array) {
                for (var i = 0; i < obj.length; i++) list.push(toJson(obj[i], standardized));
                return "[" + list.join(",") + "]";
            }
            for (prop in obj) "scene" != prop && (standardized || !/^[a-zA-Z][a-zA-Z_0-9]\w+$/.test(prop) || /\b(abstract|boolean|break|byte|case|catch|char|class|comment|const|continue|debugger|default|delete|do|double|else|enum|export|extends|false|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|label|long|native|new|null|package|private|protected|public|return|short|static|super|switch|synchronized|this|throws|transient|true|try|typeof|var|void|volatile|while|with)\b/.test(prop) ? list.push('"' + prop + '":' + toJson(obj[prop], standardized)) : list.push(prop + ":" + toJson(obj[prop], standardized)));
            return "{" + list.join(",") + "}";
        }
        return "null";

      case "string":
        return '"' + obj.replace(/(.)/g, function(x) {
            if ("'" == x || '"' == x || "\\" == x) return "\\" + x;
            var code = x.charCodeAt(0);
            if (127 < code || code < 32) {
                var outCode = code.toString(16);
                switch (outCode.length) {
                  case 4:
                    return "\\u" + outCode;

                  case 3:
                    return "\\u0" + outCode;

                  case 2:
                    return "\\u00" + outCode;

                  case 1:
                    return "\\u000" + outCode;

                  default:
                    return x;
                }
            }
            return x;
        }) + '"';

      case "number":
      case "boolean":
        return String(obj);

      case "function":
        return "badfunction";

      case "undefined":
        return "undefined";

      default:
        throw new Error("invalid type: " + typeof obj);
    }
}

Typo.prototype = {
    load: function(obj) {
        for (var i in obj) this[i] = obj[i];
        return this;
    },
    _readFile: function(path, charset) {
        charset = charset || "ISO8859-1";
        var req = new XMLHttpRequest();
        return req.open("GET", path, !1), req.overrideMimeType && req.overrideMimeType("text/plain; charset=" + charset), 
        req.send(null), req.responseText;
    },
    _parseAFF: function(data) {
        for (var rules = {}, lines = (data = this._removeAffixComments(data)).split("\n"), i = 0, _len = lines.length; i < _len; i++) {
            var definitionParts = (line = lines[i]).split(/\s+/), ruleType = definitionParts[0];
            if ("PFX" == ruleType || "SFX" == ruleType) {
                for (var ruleCode = definitionParts[1], combineable = definitionParts[2], entries = [], j = i + 1, _jlen = i + 1 + (numEntries = parseInt(definitionParts[3], 10)); j < _jlen; j++) {
                    var charactersToRemove = (lineParts = (line = lines[j]).split(/\s+/))[2], additionParts = lineParts[3].split("/"), charactersToAdd = additionParts[0], additionParts = ("0" === charactersToAdd && (charactersToAdd = ""), 
                    this.parseRuleCodes(additionParts[1])), regexToMatch = lineParts[4], entry = {};
                    entry.add = charactersToAdd, 0 < additionParts.length && (entry.continuationClasses = additionParts), 
                    "." !== regexToMatch && (entry.match = "SFX" === ruleType ? new RegExp(regexToMatch + "$") : new RegExp("^" + regexToMatch)), 
                    "0" != charactersToRemove && (entry.remove = "SFX" === ruleType ? new RegExp(charactersToRemove + "$") : charactersToRemove), 
                    entries.push(entry);
                }
                rules[ruleCode] = {
                    type: ruleType,
                    combineable: "Y" == combineable,
                    entries: entries
                }, i += numEntries;
            } else if ("COMPOUNDRULE" === ruleType) {
                for (var numEntries, j = i + 1, _jlen = i + 1 + (numEntries = parseInt(definitionParts[1], 10)); j < _jlen; j++) {
                    var line, lineParts = (line = lines[j]).split(/\s+/);
                    this.compoundRules.push(lineParts[1]);
                }
                i += numEntries;
            } else "REP" === ruleType ? 3 === (lineParts = line.split(/\s+/)).length && this.replacementTable.push([ lineParts[1], lineParts[2] ]) : this.flags[ruleType] = definitionParts[1];
        }
        return rules;
    },
    _removeAffixComments: function(data) {
        return data = (data = (data = (data = data.replace(/#.*$/gm, "")).replace(/^\s\s*/m, "").replace(/\s\s*$/m, "")).replace(/\n{2,}/g, "\n")).replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    },
    _parseDIC: function(data) {
        var lines = (data = this._removeDicComments(data)).split("\n"), dictionaryTable = {};
        function addWord(word, rules) {
            word in dictionaryTable && "object" == typeof dictionaryTable[word] || (dictionaryTable[word] = []), 
            dictionaryTable[word].push(rules);
        }
        for (var i = 1, _len = lines.length; i < _len; i++) {
            var parts = lines[i].split("/", 2), word = parts[0];
            if (1 < parts.length) {
                var ruleCodesArray = this.parseRuleCodes(parts[1]);
                "NEEDAFFIX" in this.flags && -1 != ruleCodesArray.indexOf(this.flags.NEEDAFFIX) || addWord(word, ruleCodesArray);
                for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
                    var code = ruleCodesArray[j], rule = this.rules[code];
                    if (rule) for (var newWords = this._applyRule(word, rule), ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                        var newWord = newWords[ii];
                        if (addWord(newWord, []), rule.combineable) for (var k = j + 1; k < _jlen; k++) {
                            var combineCode = ruleCodesArray[k], combineCode = this.rules[combineCode];
                            if (combineCode && combineCode.combineable && rule.type != combineCode.type) for (var otherNewWords = this._applyRule(newWord, combineCode), iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) addWord(otherNewWords[iii], []);
                        }
                    }
                    code in this.compoundRuleCodes && this.compoundRuleCodes[code].push(word);
                }
            } else addWord(word, []);
        }
        return dictionaryTable;
    },
    _removeDicComments: function(data) {
        return data = data.replace(/^\t.*$/gm, "");
    },
    parseRuleCodes: function(textCodes) {
        if (textCodes) {
            if (!("FLAG" in this.flags)) return textCodes.split("");
            if ("long" !== this.flags.FLAG) return "num" === this.flags.FLAG ? textCode.split(",") : void 0;
            for (var flags = [], i = 0, _len = textCodes.length; i < _len; i += 2) flags.push(textCodes.substr(i, 2));
            return flags;
        }
        return [];
    },
    _applyRule: function(word, rule) {
        for (var entries = rule.entries, newWords = [], i = 0, _len = entries.length; i < _len; i++) {
            var entry = entries[i];
            if (!entry.match || word.match(entry.match)) {
                var newWord = word;
                if (entry.remove && (newWord = newWord.replace(entry.remove, "")), 
                "SFX" === rule.type ? newWord += entry.add : newWord = entry.add + newWord, 
                newWords.push(newWord), "continuationClasses" in entry) for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {
                    var continuationRule = this.rules[entry.continuationClasses[j]];
                    continuationRule && (newWords = newWords.concat(this._applyRule(newWord, continuationRule)));
                }
            }
        }
        return newWords;
    },
    check: function(aWord) {
        aWord = aWord.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        if (this.checkExact(aWord)) return !0;
        if (aWord.toUpperCase() === aWord) {
            var capitalizedWord = aWord[0] + aWord.substring(1).toLowerCase();
            if (this.hasFlag(capitalizedWord, "KEEPCASE")) return !1;
            if (this.checkExact(capitalizedWord)) return !0;
        }
        capitalizedWord = aWord.toLowerCase();
        if (capitalizedWord !== aWord) {
            if (this.hasFlag(capitalizedWord, "KEEPCASE")) return !1;
            if (this.checkExact(capitalizedWord)) return !0;
        }
        return !1;
    },
    checkExact: function(word) {
        var ruleCodes = this.dictionaryTable[word];
        if (void 0 === ruleCodes) {
            if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) for (var i = 0, _len = this.compoundRules.length; i < _len; i++) if (word.match(this.compoundRules[i])) return !0;
        } else for (i = 0, _len = ruleCodes.length; i < _len; i++) if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) return !0;
        return !1;
    },
    hasFlag: function(word, flag, wordFlags) {
        if (flag in this.flags && ((wordFlags = void 0 === wordFlags ? Array.prototype.concat.apply([], this.dictionaryTable[word]) : wordFlags) && -1 !== wordFlags.indexOf(this.flags[flag]))) return !0;
        return !1;
    },
    alphabet: "",
    suggest: function(word, limit, callback) {
        if (limit = limit || 5, this.check(word)) callback([]); else {
            for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {
                var replacementEntry = this.replacementTable[i];
                if (-1 !== word.indexOf(replacementEntry[0])) {
                    replacementEntry = word.replace(replacementEntry[0], replacementEntry[1]);
                    if (this.check(replacementEntry)) return void callback([ replacementEntry ]);
                }
            }
            var self = this;
            self.alphabet = "abcdefghijklmnopqrstuvwxyz", !function(word, callback) {
                edits1([ word ], function(ed1) {
                    edits1(ed1, function(ed2) {
                        for (var corrections = known(ed1).concat(known(ed2)), weighted_corrections = {}, i = 0, _len = corrections.length; i < _len; i++) corrections[i] in weighted_corrections ? weighted_corrections[corrections[i]] += 1 : weighted_corrections[corrections[i]] = 1;
                        var sorted_corrections = [];
                        for (i in weighted_corrections) sorted_corrections.push([ i, weighted_corrections[i] ]);
                        sorted_corrections.sort(function(a, b) {
                            return a[1] < b[1] ? -1 : 1;
                        }).reverse();
                        for (var rv = [], i = 0, _len = Math.min(limit, sorted_corrections.length); i < _len; i++) self.hasFlag(sorted_corrections[i][0], "NOSUGGEST") || rv.push(sorted_corrections[i][0]);
                        callback(rv);
                    });
                });
            }(word, function(rv) {
                callback(rv);
            });
        }
        function edits1(words, callback) {
            for (var rv = [], workers = [], workersCompleted = [], i = 0; i < 4; ++i) {
                var worker = new Worker("lib/typo/wordprocessor.js");
                worker.addEventListener("message", function(index) {
                    return function(e) {
                        rv = rv.concat(e.data), workersCompleted[index] = !0, this.terminate();
                        for (var i = 0; i < 4; ++i) if (!workersCompleted[i]) return;
                        callback(rv);
                    };
                }(i)), workers.push(worker), workersCompleted.push(!1);
            }
            for (var sliceSize = words.length / 4, i = 0; i < 4; ++i) 3 != i ? workers[i].postMessage(words.slice(sliceSize * i, sliceSize * (i + 1))) : workers[i].postMessage(words.slice(sliceSize * i));
        }
        function known(words) {
            for (var rv = [], i = 0; i < words.length; i++) self.check(words[i]) && rv.push(words[i]);
            return rv;
        }
    }
}, !function(n) {
    var v = this || (0, eval)("this"), y = v.document, L = v.navigator, r = v.jQuery, D = v.JSON;
    !function(n) {
        "function" == typeof require && "object" == typeof exports && "object" == typeof module ? n(module.exports || exports, require) : "function" == typeof define && define.amd ? define([ "exports", "require" ], n) : n(v.ko = {});
    }(function(M, N) {
        function H(a, d) {
            return (null === a || typeof a in Q) && a === d;
        }
        function R(a, d) {
            var c;
            return function() {
                c = c || setTimeout(function() {
                    c = n, a();
                }, d);
            };
        }
        function S(a, d) {
            var c;
            return function() {
                clearTimeout(c), c = setTimeout(a, d);
            };
        }
        function I(b, d, c, e) {
            a.d[b] = {
                init: function(b, h, k, g, m) {
                    var l, s;
                    return a.s(function() {
                        var g = a.a.c(h()), k = !c != !g, z = !s;
                        (z || d || k !== l) && (z && a.Y.la() && (s = a.a.ia(a.f.childNodes(b), !0)), 
                        k ? (z || a.f.T(b, a.a.ia(s)), a.Ca(e ? e(m, g) : m, b)) : a.f.ja(b), 
                        l = k);
                    }, null, {
                        o: b
                    }), {
                        controlsDescendantBindings: !0
                    };
                }
            }, a.h.ha[b] = !1, a.f.Q[b] = !0;
        }
        var h, k, g, a = void 0 !== M ? M : {};
        function b(a, b) {
            for (var c in a) a.hasOwnProperty(c) && b(c, a[c]);
        }
        function d(a, b) {
            if (b) for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
            return a;
        }
        function c(a, b) {
            return a.__proto__ = b, a;
        }
        a.b = function(b, d) {
            for (var c = b.split("."), e = a, f = 0; f < c.length - 1; f++) e = e[c[f]];
            e[c[c.length - 1]] = d;
        }, a.A = function(a, d, c) {
            a[d] = c;
        }, a.version = "3.2.0", a.b("version", a.version), a.a = (M = {
            __proto__: []
        } instanceof Array, h = {}, (f = {})[L && /Firefox\/2/i.test(L.userAgent) ? "KeyboardEvent" : "UIEvents"] = [ "keyup", "keydown", "keypress" ], 
        f.MouseEvents = "click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" "), 
        b(f, function(a, b) {
            if (b.length) for (var c = 0, d = b.length; c < d; c++) h[b[c]] = a;
        }), k = {
            propertychange: !0
        }, g = y && function() {
            for (var a = 3, b = y.createElement("div"), c = b.getElementsByTagName("i"); b.innerHTML = "\x3c!--[if gt IE " + ++a + "]><i></i><![endif]--\x3e", 
            c[0]; );
            return 4 < a ? a : n;
        }(), {
            vb: [ "authenticity_token", /^__RequestVerificationToken(_.*)?$/ ],
            u: function(a, b) {
                for (var c = 0, d = a.length; c < d; c++) b(a[c], c);
            },
            m: function(a, b) {
                if ("function" == typeof Array.prototype.indexOf) return Array.prototype.indexOf.call(a, b);
                for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return c;
                return -1;
            },
            qb: function(a, b, c) {
                for (var d = 0, g = a.length; d < g; d++) if (b.call(c, a[d], d)) return a[d];
                return null;
            },
            ua: function(m, b) {
                b = a.a.m(m, b);
                0 < b ? m.splice(b, 1) : 0 === b && m.shift();
            },
            rb: function(m) {
                for (var b = [], c = 0, d = (m = m || []).length; c < d; c++) a.a.m(b, m[c]) < 0 && b.push(m[c]);
                return b;
            },
            Da: function(a, b) {
                for (var c = [], d = 0, g = (a = a || []).length; d < g; d++) c.push(b(a[d], d));
                return c;
            },
            ta: function(a, b) {
                for (var c = [], d = 0, g = (a = a || []).length; d < g; d++) b(a[d], d) && c.push(a[d]);
                return c;
            },
            ga: function(a, b) {
                if (b instanceof Array) a.push.apply(a, b); else for (var c = 0, d = b.length; c < d; c++) a.push(b[c]);
                return a;
            },
            ea: function(b, c, d) {
                var g = a.a.m(a.a.Xa(b), c);
                g < 0 ? d && b.push(c) : d || b.splice(g, 1);
            },
            xa: M,
            extend: d,
            za: c,
            Aa: M ? c : d,
            G: b,
            na: function(a, b) {
                if (!a) return a;
                var d, c = {};
                for (d in a) a.hasOwnProperty(d) && (c[d] = b(a[d], d, a));
                return c;
            },
            Ka: function(b) {
                for (;b.firstChild; ) a.removeNode(b.firstChild);
            },
            oc: function(b) {
                b = a.a.S(b);
                for (var c = y.createElement("div"), d = 0, g = b.length; d < g; d++) c.appendChild(a.R(b[d]));
                return c;
            },
            ia: function(b, c) {
                for (var d = 0, g = b.length, e = []; d < g; d++) {
                    var f = b[d].cloneNode(!0);
                    e.push(c ? a.R(f) : f);
                }
                return e;
            },
            T: function(b, c) {
                if (a.a.Ka(b), c) for (var d = 0, g = c.length; d < g; d++) b.appendChild(c[d]);
            },
            Lb: function(b, c) {
                var d = b.nodeType ? [ b ] : b;
                if (0 < d.length) {
                    for (var g = d[0], e = g.parentNode, f = 0, h = c.length; f < h; f++) e.insertBefore(c[f], g);
                    for (f = 0, h = d.length; f < h; f++) a.removeNode(d[f]);
                }
            },
            ka: function(a, b) {
                if (a.length) {
                    for (b = 8 === b.nodeType && b.parentNode || b; a.length && a[0].parentNode !== b; ) a.shift();
                    if (1 < a.length) {
                        var c = a[0], d = a[a.length - 1];
                        for (a.length = 0; c !== d; ) if (a.push(c), !(c = c.nextSibling)) return;
                        a.push(d);
                    }
                }
                return a;
            },
            Nb: function(a, b) {
                g < 7 ? a.setAttribute("selected", b) : a.selected = b;
            },
            cb: function(a) {
                return null === a || a === n ? "" : a.trim ? a.trim() : a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
            },
            uc: function(a, b) {
                return !(b.length > (a = a || "").length) && a.substring(0, b.length) === b;
            },
            cc: function(a, b) {
                if (a === b) return !0;
                if (11 === a.nodeType) return !1;
                if (b.contains) return b.contains(3 === a.nodeType ? a.parentNode : a);
                if (b.compareDocumentPosition) return 16 == (16 & b.compareDocumentPosition(a));
                for (;a && a != b; ) a = a.parentNode;
                return !!a;
            },
            Ja: function(b) {
                return a.a.cc(b, b.ownerDocument.documentElement);
            },
            ob: function(b) {
                return !!a.a.qb(b, a.a.Ja);
            },
            t: function(a) {
                return a && a.tagName && a.tagName.toLowerCase();
            },
            n: function(b, c, d) {
                var e = g && k[c];
                if (!e && r) r(b).bind(c, d); else if (e || "function" != typeof b.addEventListener) {
                    if (void 0 === b.attachEvent) throw Error("Browser doesn't support addEventListener or attachEvent");
                    function f(a) {
                        d.call(b, a);
                    }
                    var h = "on" + c;
                    b.attachEvent(h, f), a.a.w.da(b, function() {
                        b.detachEvent(h, f);
                    });
                } else b.addEventListener(c, d, !1);
            },
            oa: function(b, c) {
                if (!b || !b.nodeType) throw Error("element must be a DOM node when calling triggerEvent");
                var d = !("input" !== a.a.t(b) || !b.type || "click" != c.toLowerCase()) && ("checkbox" == (d = b.type) || "radio" == d);
                if (r && !d) r(b).trigger(c); else if ("function" == typeof y.createEvent) {
                    if ("function" != typeof b.dispatchEvent) throw Error("The supplied element doesn't support dispatchEvent");
                    (d = y.createEvent(h[c] || "HTMLEvents")).initEvent(c, !0, !0, v, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, b), 
                    b.dispatchEvent(d);
                } else if (d && b.click) b.click(); else {
                    if (void 0 === b.fireEvent) throw Error("Browser doesn't support triggering events");
                    b.fireEvent("on" + c);
                }
            },
            c: function(b) {
                return a.C(b) ? b() : b;
            },
            Xa: function(b) {
                return a.C(b) ? b.v() : b;
            },
            Ba: function(b, c, d) {
                var g, e;
                c && (e = b.className.match(g = /\S+/g) || [], a.a.u(c.match(g), function(b) {
                    a.a.ea(e, b, d);
                }), b.className = e.join(" "));
            },
            bb: function(b, c) {
                var c = a.a.c(c), g = (null !== c && c !== n || (c = ""), a.f.firstChild(b));
                !g || 3 != g.nodeType || a.f.nextSibling(g) ? a.f.T(b, [ b.ownerDocument.createTextNode(c) ]) : g.data = c, 
                a.a.fc(b);
            },
            Mb: function(a, b) {
                if (a.name = b, g <= 7) try {
                    a.mergeAttributes(y.createElement("<input name='" + a.name + "'/>"), !1);
                } catch (c) {}
            },
            fc: function(a) {
                9 <= g && ((a = 1 == a.nodeType ? a : a.parentNode).style && (a.style.zoom = a.style.zoom));
            },
            dc: function(a) {
                var b;
                g && (b = a.style.width, a.style.width = 0, a.style.width = b);
            },
            sc: function(b, c) {
                b = a.a.c(b), c = a.a.c(c);
                for (var d = [], g = b; g <= c; g++) d.push(g);
                return d;
            },
            S: function(a) {
                for (var b = [], c = 0, d = a.length; c < d; c++) b.push(a[c]);
                return b;
            },
            xc: 6 === g,
            yc: 7 === g,
            L: g,
            xb: function(b, c) {
                for (var d = a.a.S(b.getElementsByTagName("input")).concat(a.a.S(b.getElementsByTagName("textarea"))), g = "string" == typeof c ? function(a) {
                    return a.name === c;
                } : function(a) {
                    return c.test(a.name);
                }, e = [], f = d.length - 1; 0 <= f; f--) g(d[f]) && e.push(d[f]);
                return e;
            },
            pc: function(b) {
                return "string" == typeof b && (b = a.a.cb(b)) ? D && D.parse ? D.parse(b) : new Function("return " + b)() : null;
            },
            eb: function(b, c, d) {
                if (D && D.stringify) return D.stringify(a.a.c(b), c, d);
                throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
            },
            qc: function(c, d, g) {
                var e = (g = g || {}).params || {}, f = g.includeFields || this.vb, h = c;
                if ("object" == typeof c && "form" === a.a.t(c)) for (var h = c.action, k = f.length - 1; 0 <= k; k--) for (var t = a.a.xb(c, f[k]), E = t.length - 1; 0 <= E; E--) e[t[E].name] = t[E].value;
                d = a.a.c(d);
                var n, x = y.createElement("form");
                for (n in x.style.display = "none", x.action = h, x.method = "post", 
                d) c = y.createElement("input"), c.type = "hidden", c.name = n, 
                c.value = a.a.eb(a.a.c(d[n])), x.appendChild(c);
                b(e, function(a, b) {
                    var c = y.createElement("input");
                    c.type = "hidden", c.name = a, c.value = b, x.appendChild(c);
                }), y.body.appendChild(x), g.submitter ? g.submitter(x) : x.submit(), 
                setTimeout(function() {
                    x.parentNode.removeChild(x);
                }, 0);
            }
        }), a.b("utils", a.a), a.b("utils.arrayForEach", a.a.u), a.b("utils.arrayFirst", a.a.qb), 
        a.b("utils.arrayFilter", a.a.ta), a.b("utils.arrayGetDistinctValues", a.a.rb), 
        a.b("utils.arrayIndexOf", a.a.m), a.b("utils.arrayMap", a.a.Da), a.b("utils.arrayPushAll", a.a.ga), 
        a.b("utils.arrayRemoveItem", a.a.ua), a.b("utils.extend", a.a.extend), a.b("utils.fieldsIncludedWithJsonPost", a.a.vb), 
        a.b("utils.getFormFields", a.a.xb), a.b("utils.peekObservable", a.a.Xa), 
        a.b("utils.postJson", a.a.qc), a.b("utils.parseJson", a.a.pc), a.b("utils.registerEventHandler", a.a.n), 
        a.b("utils.stringifyJson", a.a.eb), a.b("utils.range", a.a.sc), a.b("utils.toggleDomNodeCssClass", a.a.Ba), 
        a.b("utils.triggerEvent", a.a.oa), a.b("utils.unwrapObservable", a.a.c), 
        a.b("utils.objectForEach", a.a.G), a.b("utils.addOrRemoveItem", a.a.ea), 
        a.b("unwrap", a.a.c), Function.prototype.bind || (Function.prototype.bind = function(a) {
            var d = this, c = Array.prototype.slice.call(arguments);
            return a = c.shift(), function() {
                return d.apply(a, c.concat(Array.prototype.slice.call(arguments)));
            };
        }), a.a.e = new function() {
            function a(b, h) {
                var k = b[c];
                if (!k || "null" === k || !e[k]) {
                    if (!h) return n;
                    k = b[c] = "ko" + d++, e[k] = {};
                }
                return e[k];
            }
            var d = 0, c = "__ko__" + new Date().getTime(), e = {};
            return {
                get: function(c, d) {
                    c = a(c, !1);
                    return c === n ? n : c[d];
                },
                set: function(c, d, e) {
                    e === n && a(c, !1) === n || (a(c, !0)[d] = e);
                },
                clear: function(a) {
                    var b = a[c];
                    return !!b && (delete e[b], !(a[c] = null));
                },
                F: function() {
                    return d++ + c;
                }
            };
        }(), a.b("utils.domData", a.a.e), a.b("utils.domData.clear", a.a.e.clear), 
        a.a.w = new function() {
            function b(b, d) {
                var g = a.a.e.get(b, c);
                return g === n && d && a.a.e.set(b, c, g = []), g;
            }
            function d(c) {
                if (e = b(c, !1)) for (var e = e.slice(0), g = 0; g < e.length; g++) e[g](c);
                if (a.a.e.clear(c), a.a.w.cleanExternalData(c), f[c.nodeType]) for (e = c.firstChild; c = e; ) e = c.nextSibling, 
                8 === c.nodeType && d(c);
            }
            var c = a.a.e.F(), e = {
                1: !0,
                8: !0,
                9: !0
            }, f = {
                1: !0,
                9: !0
            };
            return {
                da: function(a, c) {
                    if ("function" != typeof c) throw Error("Callback must be a function");
                    b(a, !0).push(c);
                },
                Kb: function(d, e) {
                    var g = b(d, !1);
                    g && (a.a.ua(g, e), 0 == g.length && a.a.e.set(d, c, n));
                },
                R: function(b) {
                    if (e[b.nodeType] && (d(b), f[b.nodeType])) {
                        var c = [];
                        a.a.ga(c, b.getElementsByTagName("*"));
                        for (var g = 0, m = c.length; g < m; g++) d(c[g]);
                    }
                    return b;
                },
                removeNode: function(b) {
                    a.R(b), b.parentNode && b.parentNode.removeChild(b);
                },
                cleanExternalData: function(a) {
                    r && "function" == typeof r.cleanData && r.cleanData([ a ]);
                }
            };
        }(), a.R = a.a.w.R, a.removeNode = a.a.w.removeNode, a.b("cleanNode", a.R), 
        a.b("removeNode", a.removeNode), a.b("utils.domNodeDisposal", a.a.w), a.b("utils.domNodeDisposal.addDisposeCallback", a.a.w.da), 
        a.b("utils.domNodeDisposal.removeDisposeCallback", a.a.w.Kb), a.a.ba = function(b) {
            if (r) {
                if (r.parseHTML) d = r.parseHTML(b) || []; else if ((d = r.clean([ b ])) && d[0]) {
                    for (b = d[0]; b.parentNode && 11 !== b.parentNode.nodeType; ) b = b.parentNode;
                    b.parentNode && b.parentNode.removeChild(b);
                }
            } else {
                var c = a.a.cb(b).toLowerCase(), d = y.createElement("div");
                for (b = "ignored<div>" + (c = (c.match(/^<(thead|tbody|tfoot)/) ? [ 1, "<table>", "</table>" ] : !c.indexOf("<tr") && [ 2, "<table><tbody>", "</tbody></table>" ]) || (!c.indexOf("<td") || !c.indexOf("<th")) && [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ] || [ 0, "", "" ])[1] + b + c[2] + "</div>", 
                "function" == typeof v.innerShiv ? d.appendChild(v.innerShiv(b)) : d.innerHTML = b; c[0]--; ) d = d.lastChild;
                d = a.a.S(d.lastChild.childNodes);
            }
            return d;
        }, a.a.$a = function(b, d) {
            if (a.a.Ka(b), null !== (d = a.a.c(d)) && d !== n) if ("string" != typeof d && (d = d.toString()), 
            r) r(b).html(d); else for (var c = a.a.ba(d), e = 0; e < c.length; e++) b.appendChild(c[e]);
        }, a.b("utils.parseHtmlFragment", a.a.ba), a.b("utils.setHtml", a.a.$a), 
        a.D = function() {
            var d = {};
            return {
                Ua: function(a) {
                    if ("function" != typeof a) throw Error("You can only pass a function to ko.memoization.memoize()");
                    var b = (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1) + (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1);
                    return d[b] = a, "\x3c!--[ko_memo:" + b + "]--\x3e";
                },
                Rb: function(a, b) {
                    var f = d[a];
                    if (f === n) throw Error("Couldn't find any memo with ID " + a + ". Perhaps it's already been unmemoized.");
                    try {
                        return f.apply(null, b || []), !0;
                    } finally {
                        delete d[a];
                    }
                },
                Sb: function(c, d) {
                    var f = [];
                    !function b(c, d) {
                        if (c) if (8 == c.nodeType) null != (f = a.D.Gb(c.nodeValue)) && d.push({
                            bc: c,
                            mc: f
                        }); else if (1 == c.nodeType) for (var f = 0, h = c.childNodes, k = h.length; f < k; f++) b(h[f], d);
                    }(c, f);
                    for (var h = 0, k = f.length; h < k; h++) {
                        var g = f[h].bc, m = [ g ];
                        d && a.a.ga(m, d), a.D.Rb(f[h].mc, m), g.nodeValue = "", 
                        g.parentNode && g.parentNode.removeChild(g);
                    }
                },
                Gb: function(a) {
                    return (a = a.match(/^\[ko_memo\:(.*?)\]$/)) ? a[1] : null;
                }
            };
        }(), a.b("memoization", a.D), a.b("memoization.memoize", a.D.Ua), a.b("memoization.unmemoize", a.D.Rb), 
        a.b("memoization.parseMemoText", a.D.Gb), a.b("memoization.unmemoizeDomNodeAndDescendants", a.D.Sb), 
        a.La = {
            throttle: function(b, d) {
                b.throttleEvaluation = d;
                var c = null;
                return a.j({
                    read: b,
                    write: function(a) {
                        clearTimeout(c), c = setTimeout(function() {
                            b(a);
                        }, d);
                    }
                });
            },
            rateLimit: function(a, d) {
                var c, e, f;
                "number" == typeof d ? c = d : (c = d.timeout, e = d.method), f = "notifyWhenChangesStop" == e ? S : R, 
                a.Ta(function(a) {
                    return f(a, c);
                });
            },
            notify: function(a, d) {
                a.equalityComparer = "always" == d ? null : H;
            }
        };
        var Q = {
            undefined: 1,
            boolean: 1,
            number: 1,
            string: 1
        }, f = (a.b("extenders", a.La), a.Pb = function(b, d, c) {
            this.target = b, this.wa = d, this.ac = c, this.Cb = !1, a.A(this, "dispose", this.K);
        }, a.Pb.prototype.K = function() {
            this.Cb = !0, this.ac();
        }, a.P = function() {
            a.a.Aa(this, a.P.fn), this.M = {};
        }, {
            U: function(b, d, c) {
                var e = this, f = (c = c || "change", new a.Pb(e, d ? b.bind(d) : b, function() {
                    a.a.ua(e.M[c], f), e.nb && e.nb();
                }));
                return e.va && e.va(c), e.M[c] || (e.M[c] = []), e.M[c].push(f), 
                f;
            },
            notifySubscribers: function(b, d) {
                if (this.Ab(d = d || "change")) try {
                    a.k.Ea();
                    for (var f, c = this.M[d].slice(0), e = 0; f = c[e]; ++e) f.Cb || f.wa(b);
                } finally {
                    a.k.end();
                }
            },
            Ta: function(b) {
                var e, f, h, d = this, c = a.C(d), k = (d.qa || (d.qa = d.notifySubscribers, 
                d.notifySubscribers = function(a, b) {
                    b && "change" !== b ? "beforeChange" === b ? d.kb(a) : d.qa(a, b) : d.lb(a);
                }), b(function() {
                    c && h === d && (h = d()), e = !1, d.Pa(f, h) && d.qa(f = h);
                }));
                d.lb = function(a) {
                    e = !0, h = a, k();
                }, d.kb = function(a) {
                    e || (f = a, d.qa(a, "beforeChange"));
                };
            },
            Ab: function(a) {
                return this.M[a] && this.M[a].length;
            },
            yb: function() {
                var b = 0;
                return a.a.G(this.M, function(a, c) {
                    b += c.length;
                }), b;
            },
            Pa: function(a, d) {
                return !this.equalityComparer || !this.equalityComparer(a, d);
            },
            extend: function(b) {
                var d = this;
                return b && a.a.G(b, function(b, e) {
                    b = a.La[b];
                    "function" == typeof b && (d = b(d, e) || d);
                }), d;
            }
        }), F = (a.A(f, "subscribe", f.U), a.A(f, "extend", f.extend), a.A(f, "getSubscriptionsCount", f.yb), 
        a.a.xa && a.a.za(f, Function.prototype), a.P.fn = f, a.Db = function(a) {
            return null != a && "function" == typeof a.U && "function" == typeof a.notifySubscribers;
        }, a.b("subscribable", a.P), a.b("isSubscribable", a.Db), a.Y = a.k = function() {
            function b(a) {
                c.push(e), e = a;
            }
            function d() {
                e = c.pop();
            }
            var e, c = [], f = 0;
            return {
                Ea: b,
                end: d,
                Jb: function(b) {
                    if (e) {
                        if (!a.Db(b)) throw Error("Only subscribable things can act as dependencies");
                        e.wa(b, b.Vb || (b.Vb = ++f));
                    }
                },
                B: function(a, c, g) {
                    try {
                        return b(), a.apply(c, g || []);
                    } finally {
                        d();
                    }
                },
                la: function() {
                    if (e) return e.s.la();
                },
                ma: function() {
                    if (e) return e.ma;
                }
            };
        }(), a.b("computedContext", a.Y), a.b("computedContext.getDependenciesCount", a.Y.la), 
        a.b("computedContext.isInitial", a.Y.ma), a.b("computedContext.isSleeping", a.Y.zc), 
        a.p = function(b) {
            function d() {
                return 0 < arguments.length ? (d.Pa(c, arguments[0]) && (d.X(), 
                c = arguments[0], d.W()), this) : (a.k.Jb(d), c);
            }
            var c = b;
            return a.P.call(d), a.a.Aa(d, a.p.fn), d.v = function() {
                return c;
            }, d.W = function() {
                d.notifySubscribers(c);
            }, d.X = function() {
                d.notifySubscribers(c, "beforeChange");
            }, a.A(d, "peek", d.v), a.A(d, "valueHasMutated", d.W), a.A(d, "valueWillMutate", d.X), 
            d;
        }, a.p.fn = {
            equalityComparer: H
        }, a.p.rc = "__ko_proto__"), P = (a.p.fn[F] = a.p, a.a.xa && a.a.za(a.p.fn, a.P.fn), 
        a.Ma = function(b, d) {
            return null !== b && b !== n && b[F] !== n && (b[F] === d || a.Ma(b[F], d));
        }, a.C = function(b) {
            return a.Ma(b, a.p);
        }, a.Ra = function(b) {
            return !!("function" == typeof b && b[F] === a.p || "function" == typeof b && b[F] === a.j && b.hc);
        }, a.b("observable", a.p), a.b("isObservable", a.C), a.b("isWriteableObservable", a.Ra), 
        a.b("isWritableObservable", a.Ra), a.aa = function(b) {
            if ("object" == typeof (b = b || []) && "length" in b) return b = a.p(b), 
            a.a.Aa(b, a.aa.fn), b.extend({
                trackArrayChanges: !0
            });
            throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");
        }, a.aa.fn = {
            remove: function(b) {
                for (var d = this.v(), c = [], e = "function" != typeof b || a.C(b) ? function(a) {
                    return a === b;
                } : b, f = 0; f < d.length; f++) {
                    var h = d[f];
                    e(h) && (0 === c.length && this.X(), c.push(h), d.splice(f, 1), 
                    f--);
                }
                return c.length && this.W(), c;
            },
            removeAll: function(b) {
                var d, c;
                return b === n ? (c = (d = this.v()).slice(0), this.X(), d.splice(0, d.length), 
                this.W(), c) : b ? this.remove(function(c) {
                    return 0 <= a.a.m(b, c);
                }) : [];
            },
            destroy: function(b) {
                var d = this.v(), c = "function" != typeof b || a.C(b) ? function(a) {
                    return a === b;
                } : b;
                this.X();
                for (var e = d.length - 1; 0 <= e; e--) c(d[e]) && (d[e]._destroy = !0);
                this.W();
            },
            destroyAll: function(b) {
                return b === n ? this.destroy(function() {
                    return !0;
                }) : b ? this.destroy(function(d) {
                    return 0 <= a.a.m(b, d);
                }) : [];
            },
            indexOf: function(b) {
                var d = this();
                return a.a.m(d, b);
            },
            replace: function(a, d) {
                a = this.indexOf(a);
                0 <= a && (this.X(), this.v()[a] = d, this.W());
            }
        }, a.a.u("pop push reverse shift sort splice unshift".split(" "), function(b) {
            a.aa.fn[b] = function() {
                var a = this.v();
                return this.X(), this.sb(a, b, arguments), a = a[b].apply(a, arguments), 
                this.W(), a;
            };
        }), a.a.u([ "slice" ], function(b) {
            a.aa.fn[b] = function() {
                var a = this();
                return a[b].apply(a, arguments);
            };
        }), a.a.xa && a.a.za(a.aa.fn, a.p.fn), a.b("observableArray", a.aa), a.La.trackArrayChanges = function(b) {
            function d() {
                var d, g;
                c || (c = !0, d = b.notifySubscribers, b.notifySubscribers = function(a, b) {
                    return b && "change" !== b || ++f, d.apply(this, arguments);
                }, g = [].concat(b.v() || []), e = null, b.U(function(c) {
                    var d;
                    c = [].concat(c || []), b.Ab("arrayChange") && (d = e = !e || 1 < f ? a.a.Fa(g, c, {
                        sparse: !0
                    }) : e).length && b.notifySubscribers(d, "arrayChange"), g = c, 
                    e = null, f = 0;
                }));
            }
            var c, e, f, h;
            b.sb || (c = !1, e = null, f = 0, h = b.U, b.U = b.subscribe = function(a, b, c) {
                return "arrayChange" === c && d(), h.apply(this, arguments);
            }, b.sb = function(b, d, m) {
                function l(a, b, c) {
                    return s[s.length] = {
                        status: a,
                        value: b,
                        index: c
                    };
                }
                if (c && !f) {
                    var s = [], h = b.length, p = m.length, z = 0;
                    switch (d) {
                      case "push":
                        z = h;

                      case "unshift":
                        for (d = 0; d < p; d++) l("added", m[d], z + d);
                        break;

                      case "pop":
                        z = h - 1;

                      case "shift":
                        h && l("deleted", b[z], z);
                        break;

                      case "splice":
                        d = Math.min(Math.max(0, m[0] < 0 ? h + m[0] : m[0]), h);
                        for (var h = 1 === p ? h : Math.min(d + (m[1] || 0), h), p = d + p - 2, z = Math.max(h, p), u = [], t = [], E = 2; d < z; ++d, 
                        ++E) d < h && t.push(l("deleted", b[d], d)), d < p && u.push(l("added", m[E], d));
                        a.a.wb(t, u);
                        break;

                      default:
                        return;
                    }
                    e = s;
                }
            });
        }, a.s = a.j = function(b, d, c) {
            function e() {
                a.a.G(v, function(a, b) {
                    b.K();
                }), v = {};
            }
            function f() {
                e(), q = !(u = !(A = 0));
            }
            function h() {
                var a = g.throttleEvaluation;
                a && 0 <= a ? (clearTimeout(O), O = setTimeout(k, a)) : g.ib ? g.ib() : k();
            }
            function k(b) {
                if (p) {
                    if (E) throw Error("A 'pure' computed must not be called recursively");
                } else if (!u) {
                    if (J && J()) {
                        if (!z) return void r();
                    } else z = !1;
                    if (p = !0, x) try {
                        var c = {};
                        a.k.Ea({
                            wa: function(a, b) {
                                c[b] || (c[b] = 1, ++A);
                            },
                            s: g,
                            ma: n
                        }), A = 0, s = t.call(d);
                    } finally {
                        a.k.end(), p = !1;
                    } else try {
                        var e = v, l = A;
                        a.k.Ea({
                            wa: function(a, b) {
                                u || (l && e[b] ? (v[b] = e[b], ++A, delete e[b], 
                                --l) : v[b] || (v[b] = a.U(h), ++A));
                            },
                            s: g,
                            ma: E ? n : !A
                        }), v = {}, A = 0;
                        try {
                            var m = d ? t.call(d) : t();
                        } finally {
                            a.k.end(), l && a.a.G(e, function(a, b) {
                                b.K();
                            }), q = !1;
                        }
                        g.Pa(s, m) && (g.notifySubscribers(s, "beforeChange"), s = m, 
                        !0 !== b && g.notifySubscribers(s));
                    } finally {
                        p = !1;
                    }
                    A || r();
                }
            }
            function g() {
                if (0 < arguments.length) {
                    if ("function" != typeof G) throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
                    return G.apply(d, arguments), this;
                }
                return a.k.Jb(g), q && k(!0), s;
            }
            function m() {
                return q && !A && k(!0), s;
            }
            function l() {
                return q || 0 < A;
            }
            var s, q = !0, p = !1, z = !1, u = !1, t = b, E = !1, x = !1;
            if ("function" != typeof (t = t && "object" == typeof t ? (c = t).read : (c = c || {}, 
            t || c.read))) throw Error("Pass a function that returns the value of the ko.computed");
            var G = c.write, w = c.disposeWhenNodeIsRemoved || c.o || null, C = c.disposeWhen || c.Ia, J = C, r = f, v = {}, A = 0, O = null, y = (d = d || c.owner, 
            a.P.call(g), a.a.Aa(g, a.j.fn), g.v = m, g.la = function() {
                return A;
            }, g.hc = "function" == typeof c.write, g.K = function() {
                r();
            }, g.Z = l, g.Ta);
            return g.Ta = function(a) {
                y.call(g, a), g.ib = function() {
                    g.kb(s), q = !0, g.lb(g);
                };
            }, c.pure ? (x = E = !0, g.va = function() {
                x && k(!(x = !1));
            }, g.nb = function() {
                g.yb() || (e(), x = q = !0);
            }) : c.deferEvaluation && (g.va = function() {
                m(), delete g.va;
            }), a.A(g, "peek", g.v), a.A(g, "dispose", g.K), a.A(g, "isActive", g.Z), 
            a.A(g, "getDependenciesCount", g.la), w && (z = !0, w.nodeType && (J = function() {
                return !a.a.Ja(w) || C && C();
            })), x || c.deferEvaluation || k(), w && l() && w.nodeType && (r = function() {
                a.a.w.Kb(w, r), f();
            }, a.a.w.da(w, r)), g;
        }, a.jc = function(b) {
            return a.Ma(b, a.j);
        }, f = a.p.rc, a.j[f] = a.p, a.j.fn = {
            equalityComparer: H
        }, a.j.fn[f] = a.j, a.a.xa && a.a.za(a.j.fn, a.P.fn), a.b("dependentObservable", a.j), 
        a.b("computed", a.j), a.b("isComputed", a.jc), a.Ib = function(b, d) {
            return "function" == typeof b ? a.s(b, d, {
                pure: !0
            }) : ((b = a.a.extend({}, b)).pure = !0, a.s(b, d));
        }, a.b("pureComputed", a.Ib), !function() {
            function b(a, f, h) {
                var k;
                return h = h || new c(), "object" != typeof (a = f(a)) || null === a || a === n || a instanceof Date || a instanceof String || a instanceof Number || a instanceof Boolean ? a : (k = a instanceof Array ? [] : {}, 
                h.save(a, k), function(a, b) {
                    if (a instanceof Array) {
                        for (var c = 0; c < a.length; c++) b(c);
                        "function" == typeof a.toJSON && b("toJSON");
                    } else for (c in a) b(c);
                }(a, function(c) {
                    var d = f(a[c]);
                    switch (typeof d) {
                      case "boolean":
                      case "number":
                      case "string":
                      case "function":
                        k[c] = d;
                        break;

                      case "object":
                      case "undefined":
                        var l = h.get(d);
                        k[c] = l !== n ? l : b(d, f, h);
                    }
                }), k);
            }
            function c() {
                this.keys = [], this.hb = [];
            }
            a.Qb = function(c) {
                if (0 == arguments.length) throw Error("When calling ko.toJS, pass the object you want to convert.");
                return b(c, function(b) {
                    for (var c = 0; a.C(b) && c < 10; c++) b = b();
                    return b;
                });
            }, a.toJSON = function(b, c, d) {
                return b = a.Qb(b), a.a.eb(b, c, d);
            }, c.prototype = {
                save: function(b, c) {
                    var d = a.a.m(this.keys, b);
                    0 <= d ? this.hb[d] = c : (this.keys.push(b), this.hb.push(c));
                },
                get: function(b) {
                    return 0 <= (b = a.a.m(this.keys, b)) ? this.hb[b] : n;
                }
            };
        }(), a.b("toJS", a.Qb), a.b("toJSON", a.toJSON), a.i = {
            q: function(b) {
                switch (a.a.t(b)) {
                  case "option":
                    return !0 === b.__ko__hasDomDataOptionValue__ ? a.a.e.get(b, a.d.options.Va) : !(a.a.L <= 7) || b.getAttributeNode("value") && b.getAttributeNode("value").specified ? b.value : b.text;

                  case "select":
                    return 0 <= b.selectedIndex ? a.i.q(b.options[b.selectedIndex]) : n;

                  default:
                    return b.value;
                }
            },
            ca: function(b, d, c) {
                switch (a.a.t(b)) {
                  case "option":
                    "string" == typeof d ? (a.a.e.set(b, a.d.options.Va, n), "__ko__hasDomDataOptionValue__" in b && delete b.__ko__hasDomDataOptionValue__, 
                    b.value = d) : (a.a.e.set(b, a.d.options.Va, d), b.__ko__hasDomDataOptionValue__ = !0, 
                    b.value = "number" == typeof d ? d : "");
                    break;

                  case "select":
                    "" !== d && null !== d || (d = n);
                    for (var k, e = -1, f = 0, h = b.options.length; f < h; ++f) if ((k = a.i.q(b.options[f])) == d || "" == k && d === n) {
                        e = f;
                        break;
                    }
                    (c || 0 <= e || d === n && 1 < b.size) && (b.selectedIndex = e);
                    break;

                  default:
                    b.value = d = null !== d && d !== n ? d : "";
                }
            }
        }, a.b("selectExtensions", a.i), a.b("selectExtensions.readValue", a.i.q), 
        a.b("selectExtensions.writeValue", a.i.ca), a.h = function() {
            function b(b) {
                var s, k, c = [], d = (b = 123 === (b = a.a.cb(b)).charCodeAt(0) ? b.slice(1, -1) : b).match(e), p = 0;
                if (d) {
                    d.push(",");
                    for (var u, z = 0; u = d[z]; ++z) {
                        var t = u.charCodeAt(0);
                        if (44 === t) {
                            if (p <= 0) {
                                s && c.push(k ? {
                                    key: s,
                                    value: k.join("")
                                } : {
                                    unknown: s
                                }), s = k = p = 0;
                                continue;
                            }
                        } else if (58 === t) {
                            if (!k) continue;
                        } else if (47 === t && z && 1 < u.length) (t = d[z - 1].match(f)) && !h[t[0]] && ((d = (b = b.substr(b.indexOf(u) + 1)).match(e)).push(","), 
                        z = -1, u = "/"); else if (40 === t || 123 === t || 91 === t) ++p; else if (41 === t || 125 === t || 93 === t) --p; else if (!s && !k) {
                            s = 34 === t || 39 === t ? u.slice(1, -1) : u;
                            continue;
                        }
                        k ? k.push(u) : k = [ u ];
                    }
                }
                return c;
            }
            var d = [ "true", "false", "null", "undefined" ], c = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i, e = RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]", "g"), f = /[\])"'A-Za-z0-9_$]+$/, h = {
                in: 1,
                return: 1,
                typeof: 1
            }, k = {};
            return {
                ha: [],
                V: k,
                Wa: b,
                ya: function(g, m) {
                    function l(b, g) {
                        var m;
                        if (!z) {
                            var u = a.getBindingHandler(b);
                            if (u && u.preprocess && !(g = u.preprocess(g, b, l))) return;
                            (u = k[b]) && (m = g, u = m = !(0 <= a.a.m(d, m)) && (null !== (u = m.match(c)) && (u[1] ? "Object(" + u[1] + ")" + u[2] : m))), 
                            u && f.push("'" + b + "':function(_z){" + m + "=_z}");
                        }
                        e.push("'" + b + "':" + (g = h ? "function(){return " + g + " }" : g));
                    }
                    var e = [], f = [], h = (m = m || {}).valueAccessors, z = m.bindingParams, m = "string" == typeof g ? b(g) : g;
                    return a.a.u(m, function(a) {
                        l(a.key || a.unknown, a.value);
                    }), f.length && l("_ko_property_writers", "{" + f.join(",") + " }"), 
                    e.join(",");
                },
                lc: function(a, b) {
                    for (var c = 0; c < a.length; c++) if (a[c].key == b) return !0;
                    return !1;
                },
                pa: function(b, c, d, e, f) {
                    b && a.C(b) ? !a.Ra(b) || f && b.v() === e || b(e) : (b = c.get("_ko_property_writers")) && b[d] && b[d](e);
                }
            };
        }(), a.b("expressionRewriting", a.h), a.b("expressionRewriting.bindingRewriteValidators", a.h.ha), 
        a.b("expressionRewriting.parseObjectLiteral", a.h.Wa), a.b("expressionRewriting.preProcessBindings", a.h.ya), 
        a.b("expressionRewriting._twoWayBindings", a.h.V), a.b("jsonExpressionRewriting", a.h), 
        a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson", a.h.ya), 
        !function() {
            function b(a) {
                return 8 == a.nodeType && h.test(f ? a.text : a.nodeValue);
            }
            function d(a) {
                return 8 == a.nodeType && k.test(f ? a.text : a.nodeValue);
            }
            function c(a, c) {
                for (var g = a, e = 1, f = []; g = g.nextSibling; ) {
                    if (d(g) && 0 === --e) return f;
                    f.push(g), b(g) && e++;
                }
                if (c) return null;
                throw Error("Cannot find closing comment tag to match: " + a.nodeValue);
            }
            function e(a, b) {
                b = c(a, b);
                return b ? (0 < b.length ? b[b.length - 1] : a).nextSibling : null;
            }
            var f = y && "\x3c!--test--\x3e" === y.createComment("test").text, h = f ? /^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/, k = f ? /^\x3c!--\s*\/ko\s*--\x3e$/ : /^\s*\/ko\s*$/, g = {
                ul: !0,
                ol: !0
            };
            a.f = {
                Q: {},
                childNodes: function(a) {
                    return b(a) ? c(a) : a.childNodes;
                },
                ja: function(c) {
                    if (b(c)) for (var d = 0, g = (c = a.f.childNodes(c)).length; d < g; d++) a.removeNode(c[d]); else a.a.Ka(c);
                },
                T: function(c, d) {
                    if (b(c)) {
                        a.f.ja(c);
                        for (var g = c.nextSibling, e = 0, f = d.length; e < f; e++) g.parentNode.insertBefore(d[e], g);
                    } else a.a.T(c, d);
                },
                Hb: function(a, c) {
                    b(a) ? a.parentNode.insertBefore(c, a.nextSibling) : a.firstChild ? a.insertBefore(c, a.firstChild) : a.appendChild(c);
                },
                Bb: function(c, d, g) {
                    g ? b(c) ? c.parentNode.insertBefore(d, g.nextSibling) : g.nextSibling ? c.insertBefore(d, g.nextSibling) : c.appendChild(d) : a.f.Hb(c, d);
                },
                firstChild: function(a) {
                    return b(a) ? !a.nextSibling || d(a.nextSibling) ? null : a.nextSibling : a.firstChild;
                },
                nextSibling: function(a) {
                    return (a = b(a) ? e(a) : a).nextSibling && d(a.nextSibling) ? null : a.nextSibling;
                },
                gc: b,
                wc: function(a) {
                    return (a = (f ? a.text : a.nodeValue).match(h)) ? a[1] : null;
                },
                Fb: function(c) {
                    if (g[a.a.t(c)]) {
                        var l = c.firstChild;
                        if (l) do {
                            if (1 === l.nodeType) {
                                var k, f = l.firstChild, h = null;
                                if (f) do {} while (h ? h.push(f) : b(f) ? (k = e(f, !0)) ? f = k : h = [ f ] : d(f) && (h = [ f ]), 
                                f = f.nextSibling);
                                if (f = h) for (h = l.nextSibling, k = 0; k < f.length; k++) h ? c.insertBefore(f[k], h) : c.appendChild(f[k]);
                            }
                        } while (l = l.nextSibling);
                    }
                }
            };
        }(), a.b("virtualElements", a.f), a.b("virtualElements.allowedBindings", a.f.Q), 
        a.b("virtualElements.emptyNode", a.f.ja), a.b("virtualElements.insertAfter", a.f.Bb), 
        a.b("virtualElements.prepend", a.f.Hb), a.b("virtualElements.setDomNodeChildren", a.f.T), 
        a.J = function() {
            this.Yb = {};
        }, a.a.extend(a.J.prototype, {
            nodeHasBindings: function(b) {
                switch (b.nodeType) {
                  case 1:
                    return null != b.getAttribute("data-bind") || a.g.getComponentNameForNode(b);

                  case 8:
                    return a.f.gc(b);

                  default:
                    return !1;
                }
            },
            getBindings: function(b, d) {
                var c = (c = this.getBindingsString(b, d)) ? this.parseBindingsString(c, d, b) : null;
                return a.g.mb(c, b, d, !1);
            },
            getBindingAccessors: function(b, d) {
                var c = (c = this.getBindingsString(b, d)) ? this.parseBindingsString(c, d, b, {
                    valueAccessors: !0
                }) : null;
                return a.g.mb(c, b, d, !0);
            },
            getBindingsString: function(b) {
                switch (b.nodeType) {
                  case 1:
                    return b.getAttribute("data-bind");

                  case 8:
                    return a.f.wc(b);

                  default:
                    return null;
                }
            },
            parseBindingsString: function(b, d, c, e) {
                try {
                    var m, g, k, f = this.Yb, h = b + (e && e.valueAccessors || "");
                    return (k = f[h]) || (m = "with($context){with($data||{}){return{" + a.h.ya(b, e) + "}}}", 
                    g = new Function("$context", "$element", m), k = f[h] = g), 
                    k(d, c);
                } catch (l) {
                    throw l.message = "Unable to parse bindings.\nBindings value: " + b + "\nMessage: " + l.message, 
                    l;
                }
            }
        }), a.J.instance = new a.J(), a.b("bindingProvider", a.J), !function() {
            function b(a) {
                return function() {
                    return a;
                };
            }
            function d(a) {
                return a();
            }
            function c(b) {
                return a.a.na(a.k.B(b), function(a, c) {
                    return function() {
                        return b()[c];
                    };
                });
            }
            function e(d, g, e) {
                return "function" == typeof d ? c(d.bind(null, g, e)) : a.a.na(d, b);
            }
            function f(a, b) {
                return c(this.getBindings.bind(this, a, b));
            }
            function h(b, c, d) {
                var g, e = a.f.firstChild(c), l = a.J.instance, f = l.preprocessNode;
                if (f) {
                    for (;g = e; ) e = a.f.nextSibling(g), f.call(l, g);
                    e = a.f.firstChild(c);
                }
                for (;g = e; ) e = a.f.nextSibling(g), k(b, g, d);
            }
            function k(b, c, d) {
                var g = !0, e = 1 === c.nodeType;
                e && a.f.Fb(c), (g = e && d || a.J.instance.nodeHasBindings(c) ? m(c, null, b, d).shouldBindDescendants : g) && !s[a.a.t(c)] && h(b, c, !e);
            }
            function m(b, c, e, l) {
                var h, k, s, p, r, v, A, m = a.a.e.get(b, q);
                if (!c) {
                    if (m) throw Error("You cannot apply bindings multiple times to the same element.");
                    a.a.e.set(b, q, !0);
                }
                return !m && l && a.Ob(b, e), c && "function" != typeof c ? h = c : (k = a.J.instance, 
                s = k.getBindingAccessors || f, p = a.j(function() {
                    return (h = c ? c(e, b) : s.call(k, b, e)) && e.I && e.I(), 
                    h;
                }, null, {
                    o: b
                }), h && p.Z() || (p = null)), h && (v = p ? function(a) {
                    return function() {
                        return d(p()[a]);
                    };
                } : function(a) {
                    return h[a];
                }, (A = function() {
                    return a.a.na(p ? p() : h, d);
                }).get = function(a) {
                    return h[a] && v(a)();
                }, A.has = function(a) {
                    return a in h;
                }, l = function(b) {
                    var c = [], d = {}, g = [];
                    return a.a.G(b, function G(e) {
                        var l;
                        d[e] || ((l = a.getBindingHandler(e)) && (l.after && (g.push(e), 
                        a.a.u(l.after, function(c) {
                            if (b[c]) {
                                if (-1 !== a.a.m(g, c)) throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + g.join(", "));
                                G(c);
                            }
                        }), g.length--), c.push({
                            key: e,
                            zb: l
                        })), d[e] = !0);
                    }), c;
                }(h), a.a.u(l, function(c) {
                    var d = c.zb.init, g = c.zb.update, l = c.key;
                    if (8 === b.nodeType && !a.f.Q[l]) throw Error("The binding '" + l + "' cannot be used with virtual elements");
                    try {
                        "function" == typeof d && a.k.B(function() {
                            var a = d(b, v(l), A, e.$data, e);
                            if (a && a.controlsDescendantBindings) {
                                if (r !== n) throw Error("Multiple bindings (" + r + " and " + l + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                r = l;
                            }
                        }), "function" == typeof g && a.j(function() {
                            g(b, v(l), A, e.$data, e);
                        }, null, {
                            o: b
                        });
                    } catch (f) {
                        throw f.message = 'Unable to process binding "' + l + ": " + h[l] + '"\nMessage: ' + f.message, 
                        f;
                    }
                })), {
                    shouldBindDescendants: r === n
                };
            }
            function l(b) {
                return b && b instanceof a.N ? b : new a.N(b);
            }
            a.d = {};
            var s = {
                script: !0
            }, q = (a.getBindingHandler = function(b) {
                return a.d[b];
            }, a.N = function(b, c, d, g) {
                var f, e = this, l = "function" == typeof b && !a.C(b), m = a.j(function() {
                    var f = l ? b() : b, h = a.a.c(f);
                    return c ? (c.I && c.I(), a.a.extend(e, c), m && (e.I = m)) : (e.$parents = [], 
                    e.$root = h, e.ko = a), e.$rawData = f, e.$data = h, d && (e[d] = h), 
                    g && g(e, c, h), e.$data;
                }, null, {
                    Ia: function() {
                        return f && !a.a.ob(f);
                    },
                    o: !0
                });
                m.Z() && ((e.I = m).equalityComparer = null, f = [], m.Tb = function(b) {
                    f.push(b), a.a.w.da(b, function(b) {
                        a.a.ua(f, b), f.length || (m.K(), e.I = m = n);
                    });
                });
            }, a.N.prototype.createChildContext = function(b, c, d) {
                return new a.N(b, this, c, function(a, b) {
                    a.$parentContext = b, a.$parent = b.$data, a.$parents = (b.$parents || []).slice(0), 
                    a.$parents.unshift(a.$parent), d && d(a);
                });
            }, a.N.prototype.extend = function(b) {
                return new a.N(this.I || this.$data, this, null, function(c, d) {
                    c.$rawData = d.$rawData, a.a.extend(c, "function" == typeof b ? b() : b);
                });
            }, a.a.e.F()), p = a.a.e.F();
            a.Ob = function(b, c) {
                if (2 != arguments.length) return a.a.e.get(b, p);
                a.a.e.set(b, p, c), c.I && c.I.Tb(b);
            }, a.ra = function(b, c, d) {
                return 1 === b.nodeType && a.f.Fb(b), m(b, c, l(d), !0);
            }, a.Wb = function(b, c, d) {
                return d = l(d), a.ra(b, e(c, d, b), d);
            }, a.Ca = function(a, b) {
                1 !== b.nodeType && 8 !== b.nodeType || h(l(a), b, !0);
            }, a.pb = function(a, b) {
                if (!r && v.jQuery && (r = v.jQuery), b && 1 !== b.nodeType && 8 !== b.nodeType) throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
                b = b || v.document.body, k(l(a), b, !0);
            }, a.Ha = function(b) {
                switch (b.nodeType) {
                  case 1:
                  case 8:
                    var c = a.Ob(b);
                    if (c) return c;
                    if (b.parentNode) return a.Ha(b.parentNode);
                }
                return n;
            }, a.$b = function(b) {
                return (b = a.Ha(b)) ? b.$data : n;
            }, a.b("bindingHandlers", a.d), a.b("applyBindings", a.pb), a.b("applyBindingsToDescendants", a.Ca), 
            a.b("applyBindingAccessorsToNode", a.ra), a.b("applyBindingsToNode", a.Wb), 
            a.b("contextFor", a.Ha), a.b("dataFor", a.$b);
        }(), !function(b) {
            function d(d, g) {
                var l, e = f.hasOwnProperty(d) ? f[d] : b;
                e || (e = f[d] = new a.P(), c(d, function(a) {
                    h[d] = a, delete f[d], l ? e.notifySubscribers(a) : setTimeout(function() {
                        e.notifySubscribers(a);
                    }, 0);
                }), l = !0), e.U(g);
            }
            function c(a, b) {
                e("getConfig", [ a ], function(c) {
                    c ? e("loadComponent", [ a, c ], function(a) {
                        b(a);
                    }) : b(null);
                });
            }
            function e(c, d, f, l) {
                var h = (l = l || a.g.loaders.slice(0)).shift();
                if (h) {
                    var q = h[c];
                    if (q) {
                        var p = !1;
                        if (q.apply(h, d.concat(function(a) {
                            p ? f(null) : null !== a ? f(a) : e(c, d, f, l);
                        })) !== b && (p = !0, !h.suppressLoaderExceptions)) throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");
                    } else e(c, d, f, l);
                } else f(null);
            }
            var f = {}, h = {};
            a.g = {
                get: function(a, c) {
                    var e = h.hasOwnProperty(a) ? h[a] : b;
                    e ? setTimeout(function() {
                        c(e);
                    }, 0) : d(a, c);
                },
                tb: function(a) {
                    delete h[a];
                },
                jb: e
            }, a.g.loaders = [], a.b("components", a.g), a.b("components.get", a.g.get), 
            a.b("components.clearCachedDefinition", a.g.tb);
        }(), !function() {
            function b(b, c, d, e) {
                function h() {
                    0 == --u && e(k);
                }
                var k = {}, u = 2, t = d.template;
                d = d.viewModel, t ? f(c, t, function(c) {
                    a.g.jb("loadTemplate", [ b, c ], function(a) {
                        k.template = a, h();
                    });
                }) : h(), d ? f(c, d, function(c) {
                    a.g.jb("loadViewModel", [ b, c ], function(a) {
                        k[g] = a, h();
                    });
                }) : h();
            }
            function c(b) {
                switch (a.a.t(b)) {
                  case "script":
                    return a.a.ba(b.text);

                  case "textarea":
                    return a.a.ba(b.value);

                  case "template":
                    if (e(b.content)) return a.a.ia(b.content.childNodes);
                }
                return a.a.ia(b.childNodes);
            }
            function e(a) {
                return v.DocumentFragment ? a instanceof DocumentFragment : a && 11 === a.nodeType;
            }
            function f(a, b, c) {
                "string" == typeof b.require ? N || v.require ? (N || v.require)([ b.require ], c) : a("Uses require, but no AMD loader is present") : c(b);
            }
            function h(a) {
                return function(b) {
                    throw Error("Component '" + a + "': " + b);
                };
            }
            var k = {}, g = (a.g.register = function(b, c) {
                if (!c) throw Error("Invalid configuration for " + b);
                if (a.g.Qa(b)) throw Error("Component " + b + " is already registered");
                k[b] = c;
            }, a.g.Qa = function(a) {
                return a in k;
            }, a.g.vc = function(b) {
                delete k[b], a.g.tb(b);
            }, a.g.ub = {
                getConfig: function(a, b) {
                    b(k.hasOwnProperty(a) ? k[a] : null);
                },
                loadComponent: function(a, c, d) {
                    var e = h(a);
                    f(e, c, function(c) {
                        b(a, e, c, d);
                    });
                },
                loadTemplate: function(b, d, g) {
                    var f;
                    b = h(b), "string" == typeof d ? g(a.a.ba(d)) : d instanceof Array ? g(d) : e(d) ? g(a.a.S(d.childNodes)) : d.element ? (d = d.element, 
                    (v.HTMLElement ? d instanceof HTMLElement : d && d.tagName && 1 === d.nodeType) ? g(c(d)) : "string" == typeof d ? (f = y.getElementById(d)) ? g(c(f)) : b("Cannot find element with ID " + d) : b("Unknown element type: " + d)) : b("Unknown template value: " + d);
                },
                loadViewModel: function(a, b, c) {
                    !function d(a, b, c) {
                        var e;
                        "function" == typeof b ? c(function(a) {
                            return new b(a);
                        }) : "function" == typeof b[g] ? c(b[g]) : "instance" in b ? (e = b.instance, 
                        c(function() {
                            return e;
                        })) : "viewModel" in b ? d(a, b.viewModel, c) : a("Unknown viewModel value: " + b);
                    }(h(a), b, c);
                }
            }, "createViewModel");
            a.b("components.register", a.g.register), a.b("components.isRegistered", a.g.Qa), 
            a.b("components.unregister", a.g.vc), a.b("components.defaultLoader", a.g.ub), 
            a.g.loaders.push(a.g.ub), a.g.Ub = k;
        }(), !function() {
            function b(b, e) {
                var f = b.getAttribute("params");
                return f ? (f = d.parseBindingsString(f, e, b, {
                    valueAccessors: !0,
                    bindingParams: !0
                }), f = a.a.na(f, function(d) {
                    return a.s(d, null, {
                        o: b
                    });
                }), (e = a.a.na(f, function(d) {
                    return d.Z() ? a.s(function() {
                        return a.a.c(d());
                    }, null, {
                        o: b
                    }) : d.v();
                })).hasOwnProperty("$raw") || (e.$raw = f), e) : {
                    $raw: {}
                };
            }
            a.g.getComponentNameForNode = function(b) {
                return b = a.a.t(b), a.g.Qa(b) && b;
            }, a.g.mb = function(c, d, f, h) {
                if (1 === d.nodeType) {
                    var k = a.g.getComponentNameForNode(d);
                    if (k) {
                        if ((c = c || {}).component) throw Error('Cannot use the "component" binding on a custom element matching a component');
                        var g = {
                            name: k,
                            params: b(d, f)
                        };
                        c.component = h ? function() {
                            return g;
                        } : g;
                    }
                }
                return c;
            };
            var d = new a.J();
            a.a.L < 9 && (a.g.register = function(a) {
                return function(b) {
                    return y.createElement(b), a.apply(this, arguments);
                };
            }(a.g.register), y.createDocumentFragment = function(b) {
                return function() {
                    var h, d = b(), f = a.g.Ub;
                    for (h in f) f.hasOwnProperty(h) && d.createElement(h);
                    return d;
                };
            }(y.createDocumentFragment));
        }(), !function() {
            var b = 0;
            a.d.component = {
                init: function(d, c, e, f, h) {
                    function k() {
                        var a = g && g.dispose;
                        "function" == typeof a && a.call(g), m = null;
                    }
                    var g, m;
                    return a.a.w.da(d, k), a.s(function() {
                        var f, q, e = a.a.c(c());
                        if ("string" == typeof e ? f = e : (f = a.a.c(e.name), q = a.a.c(e.params)), 
                        !f) throw Error("No component name specified");
                        var p = m = ++b;
                        a.g.get(f, function(b) {
                            if (m === p) {
                                if (k(), !b) throw Error("Unknown component '" + f + "'");
                                if (!(c = b.template)) throw Error("Component '" + f + "' has no template");
                                c = a.a.ia(c), a.f.T(d, c);
                                var c = q, e = b.createViewModel;
                                b = e ? e.call(b, c, {
                                    element: d
                                }) : c, c = h.createChildContext(b), g = b, a.Ca(c, d);
                            }
                        });
                    }, null, {
                        o: d
                    }), {
                        controlsDescendantBindings: !0
                    };
                }
            }, a.f.Q.component = !0;
        }(), {
            class: "className",
            for: "htmlFor"
        }), K = (a.d.attr = {
            update: function(b, d) {
                d = a.a.c(d()) || {};
                a.a.G(d, function(c, d) {
                    var h = !1 === (d = a.a.c(d)) || null === d || d === n;
                    h && b.removeAttribute(c), a.a.L <= 8 && c in P ? (c = P[c], 
                    h ? b.removeAttribute(c) : b[c] = d) : h || b.setAttribute(c, d.toString()), 
                    "name" === c && a.a.Mb(b, h ? "" : d.toString());
                });
            }
        }, a.d.checked = {
            after: [ "value", "attr" ],
            init: function(b, d, c) {
                function e() {
                    var k, e = b.checked, f = s ? h() : e;
                    a.Y.ma() || g && !e || (k = a.k.B(d), m ? l !== f ? (e && (a.a.ea(k, f, !0), 
                    a.a.ea(k, l, !1)), l = f) : a.a.ea(k, f, e) : a.h.pa(k, c, "checked", f, !0));
                }
                var m, l, s, h = a.Ib(function() {
                    return c.has("checkedValue") ? a.a.c(c.get("checkedValue")) : c.has("value") ? a.a.c(c.get("value")) : b.value;
                }), k = "checkbox" == b.type, g = "radio" == b.type;
                (k || g) && (m = k && a.a.c(d()) instanceof Array, l = m ? h() : n, 
                s = g || m, g && !b.name && a.d.uniqueName.init(b, function() {
                    return !0;
                }), a.s(e, null, {
                    o: b
                }), a.a.n(b, "click", e), a.s(function() {
                    var c = a.a.c(d());
                    b.checked = m ? 0 <= a.a.m(c, h()) : k ? c : h() === c;
                }, null, {
                    o: b
                }));
            }
        }, a.h.V.checked = !0, a.d.checkedValue = {
            update: function(b, d) {
                b.value = a.a.c(d());
            }
        }, a.d.css = {
            update: function(b, d) {
                d = a.a.c(d());
                "object" == typeof d ? a.a.G(d, function(c, d) {
                    d = a.a.c(d), a.a.Ba(b, c, d);
                }) : (d = String(d || ""), a.a.Ba(b, b.__ko__cssValue, !1), b.__ko__cssValue = d, 
                a.a.Ba(b, d, !0));
            }
        }, a.d.enable = {
            update: function(b, d) {
                d = a.a.c(d());
                d && b.disabled ? b.removeAttribute("disabled") : d || b.disabled || (b.disabled = !0);
            }
        }, a.d.disable = {
            update: function(b, d) {
                a.d.enable.update(b, function() {
                    return !a.a.c(d());
                });
            }
        }, a.d.event = {
            init: function(b, d, c, e, f) {
                var h = d() || {};
                a.a.G(h, function(h) {
                    "string" == typeof h && a.a.n(b, h, function(b) {
                        var m, l = d()[h];
                        if (l) {
                            try {
                                var s = a.a.S(arguments);
                                e = f.$data, s.unshift(e), m = l.apply(e, s);
                            } finally {
                                !0 !== m && (b.preventDefault ? b.preventDefault() : b.returnValue = !1);
                            }
                            !1 === c.get(h + "Bubble") && (b.cancelBubble = !0, 
                            b.stopPropagation && b.stopPropagation());
                        }
                    });
                });
            }
        }, a.d.foreach = {
            Eb: function(b) {
                return function() {
                    var d = b(), c = a.a.Xa(d);
                    return c && "number" != typeof c.length ? (a.a.c(d), {
                        foreach: c.data,
                        as: c.as,
                        includeDestroyed: c.includeDestroyed,
                        afterAdd: c.afterAdd,
                        beforeRemove: c.beforeRemove,
                        afterRender: c.afterRender,
                        beforeMove: c.beforeMove,
                        afterMove: c.afterMove,
                        templateEngine: a.O.Oa
                    }) : {
                        foreach: d,
                        templateEngine: a.O.Oa
                    };
                };
            },
            init: function(b, d) {
                return a.d.template.init(b, a.d.foreach.Eb(d));
            },
            update: function(b, d, c, e, f) {
                return a.d.template.update(b, a.d.foreach.Eb(d), c, e, f);
            }
        }, a.h.ha.foreach = !1, a.f.Q.foreach = !0, a.d.hasfocus = {
            init: function(b, d, c) {
                function e(e) {
                    b.__ko_hasfocusUpdating = !0;
                    var f, g = b.ownerDocument;
                    if ("activeElement" in g) {
                        try {
                            f = g.activeElement;
                        } catch (h) {
                            f = g.body;
                        }
                        e = f === b;
                    }
                    g = d(), a.h.pa(g, c, "hasfocus", e, !0), b.__ko_hasfocusLastValue = e, 
                    b.__ko_hasfocusUpdating = !1;
                }
                var f = e.bind(null, !0), h = e.bind(null, !1);
                a.a.n(b, "focus", f), a.a.n(b, "focusin", f), a.a.n(b, "blur", h), 
                a.a.n(b, "focusout", h);
            },
            update: function(b, d) {
                d = !!a.a.c(d());
                b.__ko_hasfocusUpdating || b.__ko_hasfocusLastValue === d || (d ? b.focus() : b.blur(), 
                a.k.B(a.a.oa, null, [ b, d ? "focusin" : "focusout" ]));
            }
        }, a.h.V.hasfocus = !0, a.d.hasFocus = a.d.hasfocus, a.h.V.hasFocus = !0, 
        a.d.html = {
            init: function() {
                return {
                    controlsDescendantBindings: !0
                };
            },
            update: function(b, d) {
                a.a.$a(b, d());
            }
        }, I("if"), I("ifnot", !1, !0), I("with", !0, !1, function(a, d) {
            return a.createChildContext(d);
        }), {});
        a.d.options = {
            init: function(b) {
                if ("select" !== a.a.t(b)) throw Error("options binding applies only to SELECT elements");
                for (;0 < b.length; ) b.remove(0);
                return {
                    controlsDescendantBindings: !0
                };
            },
            update: function(b, d, c) {
                function e() {
                    return a.a.ta(b.options, function(a) {
                        return a.selected;
                    });
                }
                function f(a, b, c) {
                    var d = typeof b;
                    return "function" == d ? b(a) : "string" == d ? a[b] : c;
                }
                function h(c, d) {
                    var e;
                    s.length && (e = 0 <= a.a.m(s, a.i.q(d[0])), a.a.Nb(d[0], e), 
                    q && !e && a.k.B(a.a.oa, null, [ b, "change" ]));
                }
                var l, s, k = 0 != b.length && b.multiple ? b.scrollTop : null, g = a.a.c(d()), m = c.get("optionsIncludeDestroyed"), q = (d = {}, 
                s = b.multiple ? a.a.Da(e(), a.i.q) : 0 <= b.selectedIndex ? [ a.i.q(b.options[b.selectedIndex]) ] : [], 
                g && (void 0 === g.length && (g = [ g ]), l = a.a.ta(g, function(b) {
                    return m || b === n || null === b || !a.a.c(b._destroy);
                }), c.has("optionsCaption") && (null !== (g = a.a.c(c.get("optionsCaption"))) && g !== n && l.unshift(K))), 
                !1);
                d.beforeRemove = function(a) {
                    b.removeChild(a);
                }, g = h, c.has("optionsAfterRender") && (g = function(b, d) {
                    h(0, d), a.k.B(c.get("optionsAfterRender"), null, [ d[0], b !== K ? b : n ]);
                }), a.a.Za(b, l, function(d, e, g) {
                    return g.length && (s = g[0].selected ? [ a.i.q(g[0]) ] : [], 
                    q = !0), e = b.ownerDocument.createElement("option"), d === K ? (a.a.bb(e, c.get("optionsCaption")), 
                    a.i.ca(e, n)) : (g = f(d, c.get("optionsValue"), d), a.i.ca(e, a.a.c(g)), 
                    d = f(d, c.get("optionsText"), g), a.a.bb(e, d)), [ e ];
                }, d, g), a.k.B(function() {
                    c.get("valueAllowUnset") && c.has("value") ? a.i.ca(b, a.a.c(c.get("value")), !0) : (b.multiple ? s.length && e().length < s.length : s.length && 0 <= b.selectedIndex ? a.i.q(b.options[b.selectedIndex]) !== s[0] : s.length || 0 <= b.selectedIndex) && a.a.oa(b, "change");
                }), a.a.dc(b), k && 20 < Math.abs(k - b.scrollTop) && (b.scrollTop = k);
            }
        }, a.d.options.Va = a.a.e.F(), a.d.selectedOptions = {
            after: [ "options", "foreach" ],
            init: function(b, d, c) {
                a.a.n(b, "change", function() {
                    var e = d(), f = [];
                    a.a.u(b.getElementsByTagName("option"), function(b) {
                        b.selected && f.push(a.i.q(b));
                    }), a.h.pa(e, c, "selectedOptions", f);
                });
            },
            update: function(b, d) {
                if ("select" != a.a.t(b)) throw Error("values binding applies only to SELECT elements");
                var c = a.a.c(d());
                c && "number" == typeof c.length && a.a.u(b.getElementsByTagName("option"), function(b) {
                    var d = 0 <= a.a.m(c, a.i.q(b));
                    a.a.Nb(b, d);
                });
            }
        }, a.h.V.selectedOptions = !0, a.d.style = {
            update: function(b, d) {
                d = a.a.c(d() || {});
                a.a.G(d, function(c, d) {
                    d = a.a.c(d), b.style[c] = d = null !== d && d !== n && !1 !== d ? d : "";
                });
            }
        }, a.d.submit = {
            init: function(b, d, c, e, f) {
                if ("function" != typeof d()) throw Error("The value for a submit binding must be a function");
                a.a.n(b, "submit", function(a) {
                    var c, e = d();
                    try {
                        c = e.call(f.$data, b);
                    } finally {
                        !0 !== c && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
                    }
                });
            }
        }, a.d.text = {
            init: function() {
                return {
                    controlsDescendantBindings: !0
                };
            },
            update: function(b, d) {
                a.a.bb(b, d());
            }
        }, a.f.Q.text = !0, function() {
            var b, d, c, e, f, h, k, g, m;
            v && v.navigator && (b = function(a) {
                if (a) return parseFloat(a[1]);
            }, d = v.opera && v.opera.version && parseInt(v.opera.version()), c = v.navigator.userAgent, 
            e = b(c.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)), f = b(c.match(/Firefox\/([^ ]*)/))), 
            a.a.L < 10 && (h = a.a.e.F(), k = a.a.e.F(), g = function(b) {
                var c = this.activeElement;
                (c = c && a.a.e.get(c, k)) && c(b);
            }, m = function(b, c) {
                var d = b.ownerDocument;
                a.a.e.get(d, h) || (a.a.e.set(d, h, !0), a.a.n(d, "selectionchange", g)), 
                a.a.e.set(b, k, c);
            }), a.d.textInput = {
                init: function(b, c, g) {
                    function h(c, d) {
                        a.a.n(b, c, d);
                    }
                    function u() {
                        x || (v = b.value, x = setTimeout(t, 4));
                    }
                    function t() {
                        clearTimeout(x), v = x = n;
                        var d = b.value;
                        r !== d && (r = d, a.h.pa(c(), g, "textInput", d));
                    }
                    var x, v, r = b.value;
                    a.a.L < 10 ? (h("propertychange", function(a) {
                        "value" === a.propertyName && t();
                    }), 8 == a.a.L && (h("keyup", t), h("keydown", t)), 8 <= a.a.L && (m(b, t), 
                    h("dragend", u))) : (h("input", t), e < 5 && "textarea" === a.a.t(b) ? (h("keydown", u), 
                    h("paste", u), h("cut", u)) : d < 11 ? h("keydown", u) : f < 4 && (h("DOMAutoComplete", t), 
                    h("dragdrop", t), h("drop", t))), h("change", t), a.s(function k() {
                        var d = a.a.c(c());
                        null !== d && d !== n || (d = ""), v !== n && d === v ? setTimeout(k, 4) : b.value !== d && (r = d, 
                        b.value = d);
                    }, null, {
                        o: b
                    });
                }
            }, a.h.V.textInput = !0, a.d.textinput = {
                preprocess: function(a, b, c) {
                    c("textInput", a);
                }
            };
        }(), a.d.uniqueName = {
            init: function(b, d) {
                d() && (d = "ko_unique_" + ++a.d.uniqueName.Zb, a.a.Mb(b, d));
            }
        }, a.d.uniqueName.Zb = 0, a.d.value = {
            after: [ "options", "foreach" ],
            init: function(b, d, c) {
                var e, f, h, k, g, m;
                "input" != b.tagName.toLowerCase() || "checkbox" != b.type && "radio" != b.type ? (e = [ "change" ], 
                f = c.get("valueUpdate"), h = !1, k = null, f && (a.a.ga(e, f = "string" == typeof f ? [ f ] : f), 
                e = a.a.rb(e)), g = function() {
                    k = null, h = !1;
                    var e = d(), g = a.i.q(b);
                    a.h.pa(e, c, "value", g);
                }, !a.a.L || "input" != b.tagName.toLowerCase() || "text" != b.type || "off" == b.autocomplete || b.form && "off" == b.form.autocomplete || -1 != a.a.m(e, "propertychange") || (a.a.n(b, "propertychange", function() {
                    h = !0;
                }), a.a.n(b, "focus", function() {
                    h = !1;
                }), a.a.n(b, "blur", function() {
                    h && g();
                })), a.a.u(e, function(c) {
                    var d = g;
                    a.a.uc(c, "after") && (d = function() {
                        k = a.i.q(b), setTimeout(g, 0);
                    }, c = c.substring(5)), a.a.n(b, c, d);
                }), a.s(m = function() {
                    var f, e = a.a.c(d()), g = a.i.q(b);
                    null !== k && e === k ? setTimeout(m, 0) : e !== g && ("select" === a.a.t(b) ? (f = c.get("valueAllowUnset"), 
                    (g = function() {
                        a.i.ca(b, e, f);
                    })(), f || e === a.i.q(b) ? setTimeout(g, 0) : a.k.B(a.a.oa, null, [ b, "change" ])) : a.i.ca(b, e));
                }, null, {
                    o: b
                })) : a.ra(b, {
                    checkedValue: d
                });
            },
            update: function() {}
        }, a.h.V.value = !0, a.d.visible = {
            update: function(b, d) {
                var d = a.a.c(d()), e = "none" != b.style.display;
                d && !e ? b.style.display = "" : !d && e && (b.style.display = "none");
            }
        }, function(b) {
            a.d[b] = {
                init: function(d, c, e, f, h) {
                    return a.d.event.init.call(this, d, function() {
                        var a = {};
                        return a[b] = c(), a;
                    }, e, f, h);
                }
            };
        }("click"), a.H = function() {}, a.H.prototype.renderTemplateSource = function() {
            throw Error("Override renderTemplateSource");
        }, a.H.prototype.createJavaScriptEvaluatorBlock = function() {
            throw Error("Override createJavaScriptEvaluatorBlock");
        }, a.H.prototype.makeTemplateSource = function(b, d) {
            if ("string" == typeof b) {
                d = (d = d || y).getElementById(b);
                if (d) return new a.r.l(d);
                throw Error("Cannot find template with ID " + b);
            }
            if (1 == b.nodeType || 8 == b.nodeType) return new a.r.fa(b);
            throw Error("Unknown template type: " + b);
        }, a.H.prototype.renderTemplate = function(a, d, c, e) {
            return a = this.makeTemplateSource(a, e), this.renderTemplateSource(a, d, c);
        }, a.H.prototype.isTemplateRewritten = function(a, d) {
            return !1 === this.allowTemplateRewriting || this.makeTemplateSource(a, d).data("isRewritten");
        }, a.H.prototype.rewriteTemplate = function(a, d, c) {
            d = d((a = this.makeTemplateSource(a, c)).text()), a.text(d), a.data("isRewritten", !0);
        }, a.b("templateEngine", a.H), a.fb = function() {
            function b(b, c, d, k) {
                b = a.h.Wa(b);
                for (var g = a.h.ha, m = 0; m < b.length; m++) {
                    var l = b[m].key;
                    if (g.hasOwnProperty(l)) {
                        var s = g[l];
                        if ("function" == typeof s) {
                            if (l = s(b[m].value)) throw Error(l);
                        } else if (!s) throw Error("This template engine does not support the '" + l + "' binding within its templates");
                    }
                }
                return d = "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + a.h.ya(b, {
                    valueAccessors: !0
                }) + " } })()},'" + d.toLowerCase() + "')", k.createJavaScriptEvaluatorBlock(d) + c;
            }
            var d = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi, c = /\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;
            return {
                ec: function(b, c, d) {
                    c.isTemplateRewritten(b, d) || c.rewriteTemplate(b, function(b) {
                        return a.fb.nc(b, c);
                    }, d);
                },
                nc: function(a, f) {
                    return a.replace(d, function(a, c, d, e, l) {
                        return b(l, c, d, f);
                    }).replace(c, function(a, c) {
                        return b(c, "\x3c!-- ko --\x3e", "#comment", f);
                    });
                },
                Xb: function(b, c) {
                    return a.D.Ua(function(d, k) {
                        d = d.nextSibling;
                        d && d.nodeName.toLowerCase() === c && a.ra(d, b, k);
                    });
                }
            };
        }(), a.b("__tr_ambtns", a.fb.Xb), function() {
            a.r = {}, a.r.l = function(a) {
                this.l = a;
            }, a.r.l.prototype.text = function() {
                var b = "script" === (b = a.a.t(this.l)) ? "text" : "textarea" === b ? "value" : "innerHTML";
                if (0 == arguments.length) return this.l[b];
                var d = arguments[0];
                "innerHTML" === b ? a.a.$a(this.l, d) : this.l[b] = d;
            };
            var b = a.a.e.F() + "_", d = (a.r.l.prototype.data = function(c) {
                if (1 === arguments.length) return a.a.e.get(this.l, b + c);
                a.a.e.set(this.l, b + c, arguments[1]);
            }, a.a.e.F());
            a.r.fa = function(a) {
                this.l = a;
            }, a.r.fa.prototype = new a.r.l(), a.r.fa.prototype.text = function() {
                var b;
                if (0 == arguments.length) return (b = a.a.e.get(this.l, d) || {}).gb === n && b.Ga && (b.gb = b.Ga.innerHTML), 
                b.gb;
                a.a.e.set(this.l, d, {
                    gb: arguments[0]
                });
            }, a.r.l.prototype.nodes = function() {
                if (0 == arguments.length) return (a.a.e.get(this.l, d) || {}).Ga;
                a.a.e.set(this.l, d, {
                    Ga: arguments[0]
                });
            }, a.b("templateSources", a.r), a.b("templateSources.domElement", a.r.l), 
            a.b("templateSources.anonymousTemplate", a.r.fa);
        }(), function() {
            function b(b, c, d) {
                var e;
                for (c = a.f.nextSibling(c); b && (e = b) !== c; ) d(e, b = a.f.nextSibling(e));
            }
            function d(c, d) {
                if (c.length) {
                    var e = c[0], f = c[c.length - 1], h = e.parentNode, k = a.J.instance, n = k.preprocessNode;
                    if (n) {
                        if (b(e, f, function(a, b) {
                            var c = a.previousSibling, d = n.call(k, a);
                            d && (a === e && (e = d[0] || b), a === f && (f = d[d.length - 1] || c));
                        }), c.length = 0, !e) return;
                        e === f ? c.push(e) : (c.push(e, f), a.a.ka(c, h));
                    }
                    b(e, f, function(b) {
                        1 !== b.nodeType && 8 !== b.nodeType || a.pb(d, b);
                    }), b(e, f, function(b) {
                        1 !== b.nodeType && 8 !== b.nodeType || a.D.Sb(b, [ d ]);
                    }), a.a.ka(c, h);
                }
            }
            function c(a) {
                return a.nodeType ? a : 0 < a.length ? a[0] : null;
            }
            function e(b, e, f, k, q) {
                var p = (p = b && c(b)) && p.ownerDocument, n = (q = q || {}).templateEngine || h;
                if (a.fb.ec(f, n, p), "number" != typeof (f = n.renderTemplate(f, k, q, p)).length || 0 < f.length && "number" != typeof f[0].nodeType) throw Error("Template engine must return an array of DOM nodes");
                switch (p = !1, e) {
                  case "replaceChildren":
                    a.f.T(b, f), p = !0;
                    break;

                  case "replaceNode":
                    a.a.Lb(b, f), p = !0;
                    break;

                  case "ignoreTargetNode":
                    break;

                  default:
                    throw Error("Unknown renderMode: " + e);
                }
                return p && (d(f, k), q.afterRender && a.k.B(q.afterRender, null, [ f, k.$data ])), 
                f;
            }
            function f(b, c, d) {
                return a.C(b) ? b() : "function" == typeof b ? b(c, d) : b;
            }
            a.ab = function(b) {
                if (b != n && !(b instanceof a.H)) throw Error("templateEngine must inherit from ko.templateEngine");
                h = b;
            }, a.Ya = function(b, d, k, s, q) {
                if (((k = k || {}).templateEngine || h) == n) throw Error("Set a template engine before calling renderTemplate");
                var p;
                return q = q || "replaceChildren", s ? (p = c(s), a.j(function() {
                    var h = d && d instanceof a.N ? d : new a.N(a.a.c(d)), n = f(b, h.$data, h), h = e(s, q, n, h, k);
                    "replaceNode" == q && (p = c(s = h));
                }, null, {
                    Ia: function() {
                        return !p || !a.a.Ja(p);
                    },
                    o: p && "replaceNode" == q ? p.parentNode : p
                })) : a.D.Ua(function(c) {
                    a.Ya(b, d, k, c, "replaceNode");
                });
            }, a.tc = function(b, c, h, k, q) {
                function p(a, b) {
                    d(b, u), h.afterRender && h.afterRender(b, a);
                }
                function r(a, c) {
                    return u = q.createChildContext(a, h.as, function(a) {
                        a.$index = c;
                    }), e(null, "ignoreTargetNode", f(b, a, u), u, h);
                }
                var u;
                return a.j(function() {
                    var b = a.a.c(c) || [];
                    void 0 === b.length && (b = [ b ]), b = a.a.ta(b, function(b) {
                        return h.includeDestroyed || b === n || null === b || !a.a.c(b._destroy);
                    }), a.k.B(a.a.Za, null, [ k, b, r, h, p ]);
                }, null, {
                    o: k
                });
            };
            var h, k = a.a.e.F();
            a.d.template = {
                init: function(b, c) {
                    c = a.a.c(c());
                    return "string" == typeof c || c.name ? a.f.ja(b) : (c = a.f.childNodes(b), 
                    c = a.a.oc(c), new a.r.fa(b).nodes(c)), {
                        controlsDescendantBindings: !0
                    };
                },
                update: function(b, c, d, e, f) {
                    var r, h = c();
                    d = !0, e = null, "string" == typeof (c = a.a.c(h)) ? c = {} : (h = c.name, 
                    (d = "if" in c ? a.a.c(c.if) : d) && "ifnot" in c && (d = !a.a.c(c.ifnot)), 
                    r = a.a.c(c.data)), "foreach" in c ? e = a.tc(h || b, d && c.foreach || [], c, b, f) : d ? (f = "data" in c ? f.createChildContext(r, c.as) : f, 
                    e = a.Ya(h || b, f, c, b)) : a.f.ja(b), f = e, (r = a.a.e.get(b, k)) && "function" == typeof r.K && r.K(), 
                    a.a.e.set(b, k, f && f.Z() ? f : n);
                }
            }, a.h.ha.template = function(b) {
                return 1 == (b = a.h.Wa(b)).length && b[0].unknown || a.h.lc(b, "name") ? null : "This template engine does not support anonymous templates nested within its templates";
            }, a.f.Q.template = !0;
        }(), a.b("setTemplateEngine", a.ab), a.b("renderTemplate", a.Ya), a.a.wb = function(a, d, c) {
            if (a.length && d.length) for (var f, h, k, g, e = f = 0; (!c || e < c) && (k = a[f]); ++f) {
                for (h = 0; g = d[h]; ++h) if (k.value === g.value) {
                    k.moved = g.index, g.moved = k.index, d.splice(h, 1), e = h = 0;
                    break;
                }
                e += h;
            }
        }, a.a.Fa = function() {
            function b(b, c, e, f, h) {
                for (var q, t, v, x, k = Math.min, g = Math.max, m = [], n = b.length, p = c.length, r = p - n || 1, u = n + p + 1, l = 0; l <= n; l++) for (v = t, 
                m.push(t = []), x = k(p, l + r), q = g(0, l - 1); q <= x; q++) t[q] = q ? l ? b[l - 1] === c[q - 1] ? v[q - 1] : k(v[q] || u, t[q - 1] || u) + 1 : q + 1 : l + 1;
                for (k = [], g = [], r = [], l = n, q = p; l || q; ) p = m[l][q] - 1, 
                q && p === m[l][q - 1] ? g.push(k[k.length] = {
                    status: e,
                    value: c[--q],
                    index: q
                }) : l && p === m[l - 1][q] ? r.push(k[k.length] = {
                    status: f,
                    value: b[--l],
                    index: l
                }) : (--q, --l, h.sparse || k.push({
                    status: "retained",
                    value: c[q]
                }));
                return a.a.wb(g, r, 10 * n), k.reverse();
            }
            return function(a, c, e) {
                return e = "boolean" == typeof e ? {
                    dontLimitMoves: e
                } : e || {}, (a = a || []).length <= (c = c || []).length ? b(a, c, "added", "deleted", e) : b(c, a, "deleted", "added", e);
            };
        }(), a.b("utils.compareArrays", a.a.Fa), function() {
            var d = a.a.e.F();
            a.a.Za = function(c, e, f, h, k) {
                function g(b, d) {
                    w = s[d], t !== d && (y[b] = w), w.Na(t++), a.a.ka(w.$, c), 
                    r.push(w), x.push(w);
                }
                function m(b, c) {
                    if (b) for (var d = 0, e = c.length; d < e; d++) c[d] && a.a.u(c[d].$, function(a) {
                        b(a, d, c[d].sa);
                    });
                }
                e = e || [], h = h || {};
                var l = a.a.e.get(c, d) === n, s = a.a.e.get(c, d) || [], q = a.a.Da(s, function(a) {
                    return a.sa;
                }), p = a.a.Fa(q, e, h.dontLimitMoves), r = [], u = 0, t = 0, v = [], x = [];
                e = [];
                for (var w, B, D, y = [], q = [], C = 0; B = p[C]; C++) switch (D = B.moved, 
                B.status) {
                  case "deleted":
                    D === n && ((w = s[u]).j && w.j.K(), v.push.apply(v, a.a.ka(w.$, c)), 
                    h.beforeRemove && (e[C] = w, x.push(w))), u++;
                    break;

                  case "retained":
                    g(C, u++);
                    break;

                  case "added":
                    D !== n ? g(C, D) : (w = {
                        sa: B.value,
                        Na: a.p(t++)
                    }, r.push(w), x.push(w), l || (q[C] = w));
                }
                m(h.beforeMove, y), a.a.u(v, h.beforeRemove ? a.R : a.removeNode);
                for (var F, C = 0, l = a.f.firstChild(c); w = x[C]; C++) {
                    for (w.$ || a.a.extend(w, function(b, d, f, h, k) {
                        var g = [], m = a.j(function() {
                            var l = d(f, k, a.a.ka(g, b)) || [];
                            0 < g.length && (a.a.Lb(g, l), h && a.k.B(h, null, [ f, l, k ])), 
                            g.length = 0, a.a.ga(g, l);
                        }, null, {
                            o: b,
                            Ia: function() {
                                return !a.a.ob(g);
                            }
                        });
                        return {
                            $: g,
                            j: m.Z() ? m : n
                        };
                    }(c, f, w.sa, k, w.Na)), u = 0; p = w.$[u]; l = p.nextSibling, 
                    F = p, u++) p !== l && a.f.Bb(c, p, F);
                    !w.ic && k && (k(w.sa, w.$, w.Na), w.ic = !0);
                }
                m(h.beforeRemove, e), m(h.afterMove, y), m(h.afterAdd, q), a.a.e.set(c, d, r);
            };
        }(), a.b("utils.setDomNodeChildrenFromArrayMapping", a.a.Za), a.O = function() {
            this.allowTemplateRewriting = !1;
        }, a.O.prototype = new a.H(), a.O.prototype.renderTemplateSource = function(b) {
            var d = a.a.L < 9 || !b.nodes ? null : b.nodes();
            return d ? a.a.S(d.cloneNode(!0).childNodes) : (b = b.text(), a.a.ba(b));
        }, a.O.Oa = new a.O(), a.ab(a.O.Oa), a.b("nativeTemplateEngine", a.O), function() {
            a.Sa = function() {
                var a = this.kc = function() {
                    if (!r || !r.tmpl) return 0;
                    try {
                        if (0 <= r.tmpl.tag.tmpl.open.toString().indexOf("__")) return 2;
                    } catch (a) {}
                    return 1;
                }();
                this.renderTemplateSource = function(b, e, f) {
                    if (f = f || {}, a < 2) throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
                    var h = b.data("precompiled");
                    return h || (h = b.text() || "", h = r.template(null, "{{ko_with $item.koBindingContext}}" + h + "{{/ko_with}}"), 
                    b.data("precompiled", h)), b = [ e.$data ], e = r.extend({
                        koBindingContext: e
                    }, f.templateOptions), (e = r.tmpl(h, b, e)).appendTo(y.createElement("div")), 
                    r.fragments = {}, e;
                }, this.createJavaScriptEvaluatorBlock = function(a) {
                    return "{{ko_code ((function() { return " + a + " })()) }}";
                }, this.addTemplate = function(a, b) {
                    y.write("<script type='text/html' id='" + a + "'>" + b + "<\/script>");
                }, 0 < a && (r.tmpl.tag.ko_code = {
                    open: "__.push($1 || '');"
                }, r.tmpl.tag.ko_with = {
                    open: "with($1) {",
                    close: "} "
                });
            }, a.Sa.prototype = new a.H();
            var b = new a.Sa();
            0 < b.kc && a.ab(b), a.b("jqueryTmplTemplateEngine", a.Sa);
        }();
    });
}(), !function(a, b) {
    "use strict";
    "object" == typeof exports ? b(exports, require("jquery"), require("knockout"), require("jquery-ui")) : "function" == typeof define && define.amd ? define([ "exports", "jquery", "knockout", "jquery-ui" ], b) : b(a.kojqui = {}, a.jQuery, a.ko);
}(this, function(a, b, c) {
    "use strict";
    var e, g, h, d = function() {
        var a = function(a) {
            a = (a || "").match(/^(\d)\.(\d+)\..*$/);
            return a ? {
                major: parseInt(a[1], 10),
                minor: parseInt(a[2], 10)
            } : null;
        };
        return {
            jQuery: b && b.fn ? a(b.fn.jquery) : null,
            jQueryUI: b && b.ui ? a(b.ui.version) : null,
            knockout: c ? a(c.version) : null
        };
    }();
    if (!d.jQuery) throw new Error("jQuery must be loaded before knockout-jquery.");
    if (!d.jQueryUI) throw new Error("jQuery UI must be loaded before knockout-jquery.");
    if (!d.knockout) throw new Error("knockout must be loaded before knockout-jquery.");
    if (d.jQueryUI.major < 1 || 1 === d.jQueryUI.major && d.jQueryUI.minor < 8) throw new Error("This version of the jQuery UI library is not supported.");
    if (d.knockout.major < 2 || 2 === d.knockout.major && d.knockout.minor < 2) throw new Error("This version of the knockout library is not supported.");
    e = function() {
        var a = "__kojqui_options", d = function(a, b) {
            var d = {};
            return c.utils.arrayForEach(b, function(b) {
                void 0 !== a[b] && (d[b] = c.utils.unwrapObservable(a[b]));
            }), d;
        }, e = function(a, d, e) {
            c.isObservable(e.refreshOn) && c.computed({
                read: function() {
                    e.refreshOn(), b(d)[a]("refresh");
                },
                disposeWhenNodeIsRemoved: d
            });
        };
        return {
            create: function(f) {
                var g = f.name;
                b.fn[g] && (c.bindingHandlers[g] = {
                    init: function(h, i, j, k, l) {
                        var i = i(), o = d(i, f.options), p = d(i, f.events), n = arguments;
                        return c.utils.arrayForEach(c.bindingHandlers[g].preInitHandlers, function(a) {
                            a.apply(this, n);
                        }), c.applyBindingsToDescendants(l, h), c.utils.domData.set(h, a, o), 
                        b.each(p, function(a, b) {
                            p[a] = b.bind(k);
                        }), b(h)[g](c.utils.extend(o, p)), f.hasRefresh && e(g, h, i), 
                        c.isWriteableObservable(i.widget) && i.widget(b(h)), c.utils.domNodeDisposal.addDisposeCallback(h, function() {
                            b(h)[g]("destroy");
                        }), c.utils.arrayForEach(c.bindingHandlers[g].postInitHandlers, function(a) {
                            a.apply(this, n);
                        }), {
                            controlsDescendantBindings: !0
                        };
                    },
                    update: function(e, h) {
                        var h = h(), j = c.utils.domData.get(e, a), k = d(h, f.options);
                        b.each(k, function(a, c) {
                            c !== j[a] && b(e)[g]("option", a, k[a]);
                        }), c.utils.domData.set(e, a, k);
                    },
                    config: f,
                    preInitHandlers: [],
                    postInitHandlers: []
                }, f.preInit && c.bindingHandlers[g].preInitHandlers.push(f.preInit), 
                f.postInit && c.bindingHandlers[g].postInitHandlers.push(f.postInit));
            }
        };
    }(), function() {
        var g, h, i, a = 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? (g = [ "active", "animated", "autoHeight", "clearStyle", "collapsible", "disabled", "event", "fillSpace", "header", "icons", "navigation", "navigationFilter" ], 
        i = !(h = [ "change", "changestart", "create" ]), "accordionchange.accordion") : (g = [ "active", "animate", "collapsible", "disabled", "event", "header", "heightStyle", "icons" ], 
        h = [ "activate", "beforeActivate", "create" ], i = !0, "accordionactivate.accordion");
        e.create({
            name: "accordion",
            options: g,
            events: h,
            postInit: function(d, e) {
                var f = e();
                c.isWriteableObservable(f.active) && b(d).on(a, function() {
                    f.active(b(d).accordion("option", "active"));
                }), c.utils.domNodeDisposal.addDisposeCallback(d, function() {
                    b(d).off(".accordion");
                });
            },
            hasRefresh: i
        });
    }(), function() {
        var a = 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? [ "change", "close", "create", "focus", "open", "search", "select" ] : [ "change", "close", "create", "focus", "open", "response", "search", "select" ];
        e.create({
            name: "autocomplete",
            options: [ "appendTo", "autoFocus", "delay", "disabled", "minLength", "position", "source" ],
            events: a
        });
    }(), e.create({
        name: "button",
        options: [ "disabled", "icons", "label", "text" ],
        events: [ "create" ],
        hasRefresh: !0
    }), e.create({
        name: "buttonset",
        options: [ "items", "disabled" ],
        events: [ "create" ],
        hasRefresh: !0
    }), e.create({
        name: "datepicker",
        options: [ "altField", "altFormat", "appendText", "autoSize", "buttonImage", "buttonImageOnly", "buttonText", "calculateWeek", "changeMonth", "changeYear", "closeText", "constrainInput", "currentText", "dateFormat", "dayNames", "dayNamesMin", "dayNamesShort", "defaultDate", "duration", "firstDay", "gotoCurrent", "hideIfNoPrevNext", "isRTL", "maxDate", "minDate", "monthNames", "monthNamesShort", "navigationAsDateFormat", "nextText", "numberOfMonths", "prevText", "selectOtherMonths", "shortYearCutoff", "showAnim", "showButtonPanel", "showCurrentAtPos", "showMonthAfterYear", "showOn", "showOptions", "showOtherMonths", "showWeek", "stepMonths", "weekHeader", "yearRange", "yearSuffix", "beforeShow", "beforeShowDay", "onChangeMonthYear", "onClose", "onSelect" ],
        events: [],
        postInit: function(a, d) {
            var g, h, e = d(), d = c.utils.unwrapObservable(e.value);
            d && b(a).datepicker("setDate", d), c.isObservable(e.value) && (g = e.value.subscribe(function(c) {
                b(a).datepicker("setDate", c);
            }), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                g.dispose();
            })), c.isWriteableObservable(e.value) && (h = b(a).datepicker("option", "onSelect"), 
            b(a).datepicker("option", "onSelect", function(c) {
                var d = b(a).datepicker("option", "dateFormat"), d = b.datepicker.parseDate(d, c);
                e.value(d), "function" == typeof h && h.apply(this, Array.prototype.slice.call(arguments));
            }));
        }
    }), g = 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? [ "autoOpen", "buttons", "closeOnEscape", "closeText", "dialogClass", "disabled", "draggable", "height", "maxHeight", "maxWidth", "minHeight", "minWidth", "modal", "position", "resizable", "show", "stack", "title", "width", "zIndex" ] : 1 === d.jQueryUI.major && 9 === d.jQueryUI.minor ? [ "autoOpen", "buttons", "closeOnEscape", "closeText", "dialogClass", "draggable", "height", "hide", "maxHeight", "maxWidth", "minHeight", "minWidth", "modal", "position", "resizable", "show", "stack", "title", "width", "zIndex" ] : [ "appendTo", "autoOpen", "buttons", "closeOnEscape", "closeText", "dialogClass", "draggable", "height", "hide", "maxHeight", "maxWidth", "minHeight", "minWidth", "modal", "position", "resizable", "show", "title", "width" ], 
    h = [ "beforeClose", "create", "open", "focus", "dragStart", "drag", "dragStop", "resizeStart", "resize", "resizeStop", "close" ], 
    e.create({
        name: "dialog",
        options: g,
        events: h,
        preInit: function(a) {
            var b = document.createElement("DIV");
            b.style.display = "none", a.parentNode.insertBefore(b, a), c.utils.domNodeDisposal.addDisposeCallback(b, function() {
                c.removeNode(a);
            });
        },
        postInit: function(a, d) {
            var e = d();
            e.isOpen && c.computed({
                read: function() {
                    c.utils.unwrapObservable(e.isOpen) ? b(a).dialog("open") : b(a).dialog("close");
                },
                disposeWhenNodeIsRemoved: a
            }), c.isWriteableObservable(e.isOpen) && (b(a).on("dialogopen.dialog", function() {
                e.isOpen(!0);
            }), b(a).on("dialogclose.dialog", function() {
                e.isOpen(!1);
            })), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".dialog");
            });
        }
    }), e.create({
        name: "menu",
        options: [ "disabled", "icons", "menus", "position", "role" ],
        events: [ "blur", "create", "focus", "select" ],
        hasRefresh: !0
    }), function() {
        var a = 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? [ "disabled", "value" ] : [ "disabled", "max", "value" ];
        e.create({
            name: "progressbar",
            options: a,
            events: [ "change", "create", "complete" ]
        });
    }(), e.create({
        name: "slider",
        options: [ "animate", "disabled", "max", "min", "orientation", "range", "step", "value", "values" ],
        events: [ "create", "start", "slide", "change", "stop" ],
        postInit: function(a, d) {
            var e = d();
            c.isWriteableObservable(e.value) && b(a).on("slidechange.slider", function(c, d) {
                b(a).find(".ui-slider-handle")[0] === d.handle && e.value(d.value);
            }), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".slider");
            });
        }
    }), e.create({
        name: "spinner",
        options: [ "culture", "disabled", "icons", "incremental", "max", "min", "numberFormat", "page", "step" ],
        events: [ "create", "start", "spin", "stop", "change" ],
        postInit: function(a, d, e) {
            var f = d();
            f.value && c.computed({
                read: function() {
                    b(a).spinner("value", c.utils.unwrapObservable(f.value));
                },
                disposeWhenNodeIsRemoved: a
            }), c.isWriteableObservable(f.value) && (e().valueUpdate ? b(a).on("spin.spinner", function(a, b) {
                f.value(b.value);
            }) : b(a).on("spinchange.spinner", function() {
                f.value(b(a).spinner("value"));
            })), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".spinner");
            });
        }
    }), function() {
        var g, h, j, i = 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? (g = [ "ajaxOptions", "cache", "collapsible", "cookie", "disabled", "event", "fx", "idPrefix", "panelTemplate", "selected", "spinner", "tabTemplate" ], 
        j = function(a, d) {
            var e = d();
            c.isWriteableObservable(e.selected) && b(a).on("tabsshow.tabs", function(c, d) {
                b(a)[0] === c.target && e.selected(d.index);
            }), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".tabs");
            });
        }, !(h = [ "add", "create", "disable", "enable", "load", "remove", "select", "show" ])) : (g = [ "active", "collapsible", "disabled", "event", "heightStyle", "hide", "show" ], 
        h = [ "activate", "beforeActivate", "beforeLoad", "create", "load" ], j = function(a, d) {
            var e = d();
            c.isWriteableObservable(e.active) && b(a).on("tabsactivate.tabs", function(c, d) {
                b(a)[0] === c.target && e.active(d.newTab.index());
            }), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".tabs");
            });
        }, !0);
        e.create({
            name: "tabs",
            options: g,
            events: h,
            postInit: j,
            hasRefresh: i
        });
    }(), e.create({
        name: "tooltip",
        options: [ "content", "disabled", "hide", "items", "position", "show", "tooltipClass", "track" ],
        events: [ "create", "open", "close" ],
        postInit: function(a, d) {
            var e = d();
            e.isOpen && c.computed({
                read: function() {
                    c.utils.unwrapObservable(e.isOpen) ? b(a).tooltip("open") : b(a).tooltip("close");
                },
                disposeWhenNodeIsRemoved: a
            }), c.isWriteableObservable(e.isOpen) && (b(a).on("tooltipopen.tooltip", function() {
                e.isOpen(!0);
            }), b(a).on("tooltipclose.tooltip", function() {
                e.isOpen(!1);
            })), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".tooltip");
            });
        }
    }), a.bindingFactory = e, a.version = "1.0.0";
}), !function(a) {
    var b, c;
    "function" == typeof define && define.amd ? define([ "knockout", "jquery", "jquery-ui/ui/widgets/sortable", "jquery-ui/ui/widgets/draggable", "jquery-ui/ui/widgets/droppable" ], a) : "function" == typeof require && "object" == typeof exports && "object" == typeof module ? (b = require("knockout"), 
    c = require("jquery"), require("jquery-ui/ui/widgets/sortable"), require("jquery-ui/ui/widgets/draggable"), 
    require("jquery-ui/ui/widgets/droppable"), a(b, c)) : a(window.ko, window.jQuery);
}(function(a, b) {
    function m(b, d) {
        a.utils.arrayForEach(b, function(a) {
            1 === a.nodeType && (j(a, c, d), j(a, f, i(a.parentNode, e)));
        });
    }
    function n(b, c) {
        var d, e = {}, f = h(b()) || {};
        return f.data ? (e[c] = f.data, e.name = f.template) : e[c] = b(), a.utils.arrayForEach([ "afterAdd", "afterRender", "as", "beforeRemove", "includeDestroyed", "templateEngine", "templateOptions", "nodes" ], function(b) {
            f.hasOwnProperty(b) ? e[b] = f[b] : a.bindingHandlers.sortable.hasOwnProperty(b) && (e[b] = a.bindingHandlers.sortable[b]);
        }), "foreach" === c && (e.afterRender ? (d = e.afterRender, e.afterRender = function(a, b) {
            m.call(b, a, b), d.call(b, a, b);
        }) : e.afterRender = m), e;
    }
    function o(a, b) {
        var c = h(b);
        if (c) for (var d = 0; d < a; d++) c[d] && h(c[d]._destroy) && a++;
        return a;
    }
    var c = "ko_sortItem", d = "ko_sourceIndex", e = "ko_sortList", f = "ko_parentList", g = "ko_dragItem", h = a.utils.unwrapObservable, i = a.utils.domData.get, j = a.utils.domData.set, k = b.ui && b.ui.version, l = k && k.indexOf("1.6.") && k.indexOf("1.7.") && (k.indexOf("1.8.") || "1.8.24" === k);
    a.bindingHandlers.sortable = {
        init: function(k, m, q, r, s) {
            var t, u, v = b(k), w = h(m()) || {}, x = n(m, "foreach"), y = {}, z = (function(c, d) {
                d ? (d = document.getElementById(d)) && (d = new a.templateSources.domElement(d)).text(b.trim(d.text())) : b(c).contents().each(function() {
                    this && 1 !== this.nodeType && c.removeChild(this);
                });
            }(k, x.name), b.extend(!0, y, a.bindingHandlers.sortable), w.options && y.options && (a.utils.extend(y.options, w.options), 
            delete w.options), a.utils.extend(y, w), y.connectClass && (a.isObservable(y.allowDrop) || "function" == typeof y.allowDrop) ? a.computed({
                read: function() {
                    var b = h(y.allowDrop), b = "function" == typeof b ? b.call(this, x.foreach) : b;
                    a.utils.toggleDomNodeCssClass(k, y.connectClass, b);
                },
                disposeWhenNodeIsRemoved: k
            }, this) : a.utils.toggleDomNodeCssClass(k, y.connectClass, y.allowDrop), 
            a.bindingHandlers.template.init(k, function() {
                return x;
            }, q, r, s), t = y.options.start, u = y.options.update, y.options.helper || (y.options.helper = function(a, c) {
                return c.is("tr") && c.children().each(function() {
                    b(this).width(b(this).width());
                }), c;
            }), setTimeout(function() {
                var m, n = y.options.receive;
                v.sortable(a.utils.extend(y.options, {
                    start: function(b, c) {
                        var e = c.item[0];
                        j(e, d, a.utils.arrayIndexOf(c.item.parent().children(), e)), 
                        c.item.find("input:focus").change(), t && t.apply(this, arguments);
                    },
                    receive: function(a, b) {
                        "function" == typeof n && n.call(this, a, b), (m = i(b.item[0], g)) && (m.clone && (m = m.clone()), 
                        y.dragged && (m = y.dragged.call(this, m, a, b) || m));
                    },
                    update: function(g, k) {
                        var p, q, r, s, z, t = k.item[0], v = k.item.parent()[0], w = i(t, c) || m;
                        if (w || b(t).remove(), m = null, w && this === v || !l && b.contains(this, v)) {
                            if (v = i(t, f), q = i(t, d), p = i(t.parentNode, e), 
                            r = a.utils.arrayIndexOf(k.item.parent().children(), t), 
                            x.includeDestroyed || (q = o(q, v), r = o(r, p)), (y.beforeMove || y.afterMove) && (s = {
                                item: w,
                                sourceParent: v,
                                sourceParentNode: v && k.sender || t.parentNode,
                                sourceIndex: q,
                                targetParent: p,
                                targetIndex: r,
                                cancelDrop: !1
                            }, y.beforeMove && y.beforeMove.call(this, s, g, k)), 
                            v ? b(v !== p && k.sender || this).sortable("cancel") : b(t).remove(), 
                            s && s.cancelDrop) return;
                            y.hasOwnProperty("strategyMove") && !1 !== y.strategyMove ? 0 <= r && (v ? v !== p ? (v.splice(q, 1), 
                            p.splice(r, 0, w), j(t, c, null), k.item.remove()) : (z = h(v), 
                            v.valueWillMutate && v.valueWillMutate(), z.splice(q, 1), 
                            z.splice(r, 0, w), v.valueHasMutated && v.valueHasMutated()) : (p.splice(r, 0, w), 
                            j(t, c, null), k.item.remove())) : (0 <= r && (v && (v.splice(q, 1), 
                            a.processAllDeferredBindingUpdates && a.processAllDeferredBindingUpdates(), 
                            a.options && a.options.deferUpdates && a.tasks.runEarly()), 
                            p.splice(r, 0, w)), j(t, c, null)), a.processAllDeferredBindingUpdates && a.processAllDeferredBindingUpdates(), 
                            y.afterMove && y.afterMove.call(this, s, g, k);
                        }
                        u && u.apply(this, arguments);
                    },
                    connectWith: !!y.connectClass && "." + y.connectClass
                })), void 0 !== y.isEnabled && a.computed({
                    read: function() {
                        v.sortable(h(y.isEnabled) ? "enable" : "disable");
                    },
                    disposeWhenNodeIsRemoved: k
                });
            }, 0));
            return a.utils.domNodeDisposal.addDisposeCallback(k, function() {
                (v.data("ui-sortable") || v.data("sortable")) && v.sortable("destroy"), 
                a.utils.toggleDomNodeCssClass(k, y.connectClass, !1), clearTimeout(z);
            }), {
                controlsDescendantBindings: !0
            };
        },
        update: function(b, c, d, f, g) {
            var h = n(c, "foreach");
            j(b, e, h.foreach), a.bindingHandlers.template.update(b, function() {
                return h;
            }, d, f, g);
        },
        connectClass: "ko_container",
        allowDrop: !0,
        afterMove: null,
        beforeMove: null,
        options: {}
    }, a.bindingHandlers.draggable = {
        init: function(c, d, e, f, i) {
            var l = (k = h(d()) || {}).options || {}, m = a.utils.extend({}, a.bindingHandlers.draggable.options), o = n(d, "data"), d = k.connectClass || a.bindingHandlers.draggable.connectClass, q = (void 0 !== k.isEnabled ? k : a.bindingHandlers.draggable).isEnabled, k = "data" in k ? k.data : k;
            return j(c, g, k), a.utils.extend(m, l), m.connectToSortable = !!d && "." + d, 
            b(c).draggable(m), void 0 !== q && a.computed({
                read: function() {
                    b(c).draggable(h(q) ? "enable" : "disable");
                },
                disposeWhenNodeIsRemoved: c
            }), a.utils.domNodeDisposal.addDisposeCallback(c, function() {
                b(c).draggable("destroy");
            }), a.bindingHandlers.template.init(c, function() {
                return o;
            }, e, f, i);
        },
        update: function(b, c, d, e, f) {
            var g = n(c, "data");
            return a.bindingHandlers.template.update(b, function() {
                return g;
            }, d, e, f);
        },
        connectClass: a.bindingHandlers.sortable.connectClass,
        options: {
            helper: "clone"
        }
    }, a.bindingHandlers.droppable = {
        init: function(d, e, f, j, k) {
            var l = h(e()) || {}, m = l.options || {}, n = a.utils.extend({}, a.bindingHandlers.droppable.options), o = (void 0 !== l.isEnabled ? l : a.bindingHandlers.droppable).isEnabled;
            a.utils.extend(n, m), l = "data" in l ? l.data : e(), n.drop = function(a, b) {
                b = i(b.draggable[0], g) || i(b.draggable[0], c);
                l(b);
            }, b(d).droppable(n), void 0 !== o && a.computed({
                read: function() {
                    b(d).droppable(h(o) ? "enable" : "disable");
                },
                disposeWhenNodeIsRemoved: d
            }), a.utils.domNodeDisposal.addDisposeCallback(d, function() {
                b(d).droppable("destroy");
            });
        },
        options: {
            accept: "*"
        }
    };
}), "object" == typeof nw ? (window.usingNode = !0, fs = require("fs"), mkdirp = require("mkdirp"), 
trash = require("trash"), getDirName = require("path").dirname, gui = require("nw.gui"), 
updater = require("cside-updater"), win = gui.Window.get(), win.show(), process.on("uncaughtException", function(err) {
    var usefulDirIndex;
    bootbox.alert(err.message), console.log(err), usefulDirIndex = "mac_os" === cside.getPlatform() ? (usefulDirIndex = process.execPath.lastIndexOf("Choicescript IDE.app"), 
    process.execPath.substring(0, usefulDirIndex)) : process.execPath.slice(0, process.execPath.lastIndexOf("\\")) + "\\", 
    fs.writeFile(usefulDirIndex + "error-log.txt", err.message() + "\n", function(err) {
        if (err) throw err;
    });
})) : (window.usingNode = !1, getDirName = function(path) {
    return path.substring(0, path.lastIndexOf("/") + 1);
}, window.onbeforeunload = function(evt) {
    var msg;
    return cside.session.isDirty() && 0 !== cside.getProjects().length ? (msg = "Warning: You have unsaved changes.", 
    (evt = evt || window.event) && (evt.returnValue = msg), msg) : null;
}), window.cside = new IDEViewModel(), ko.applyBindings(cside, $(".main-wrap")[0]), 
cside.init(), "undefined" != typeof module && module.exports && (this["encoding-indexes"] = require("./encoding-indexes.js")["encoding-indexes"]), 
!function(global) {
    "use strict";
    function inRange(a, min, max) {
        return min <= a && a <= max;
    }
    var floor = Math.floor;
    function ToDictionary(o) {
        if (void 0 === o) return {};
        if (o === Object(o)) return o;
        throw TypeError("Could not convert argument to dictionary");
    }
    function isASCIIByte(a) {
        return 0 <= a && a <= 127;
    }
    var isASCIICodePoint = isASCIIByte;
    function Stream(tokens) {
        this.tokens = [].slice.call(tokens), this.tokens.reverse();
    }
    Stream.prototype = {
        endOfStream: function() {
            return !this.tokens.length;
        },
        read: function() {
            return this.tokens.length ? this.tokens.pop() : -1;
        },
        prepend: function(token) {
            if (Array.isArray(token)) for (var tokens = token; tokens.length; ) this.tokens.push(tokens.pop()); else this.tokens.push(token);
        },
        push: function(token) {
            if (Array.isArray(token)) for (var tokens = token; tokens.length; ) this.tokens.unshift(tokens.shift()); else this.tokens.unshift(token);
        }
    };
    function decoderError(fatal, opt_code_point) {
        if (fatal) throw TypeError("Decoder error");
        return opt_code_point || 65533;
    }
    function encoderError(code_point) {
        throw TypeError("The code point " + code_point + " could not be encoded.");
    }
    function getEncoding(label) {
        return label = String(label).trim().toLowerCase(), Object.prototype.hasOwnProperty.call(label_to_encoding, label) ? label_to_encoding[label] : null;
    }
    var shift_jis_index, big5_index_no_hkscs, encodings = [ {
        encodings: [ {
            labels: [ "unicode-1-1-utf-8", "utf-8", "utf8" ],
            name: "UTF-8"
        } ],
        heading: "The Encoding"
    }, {
        encodings: [ {
            labels: [ "866", "cp866", "csibm866", "ibm866" ],
            name: "IBM866"
        }, {
            labels: [ "csisolatin2", "iso-8859-2", "iso-ir-101", "iso8859-2", "iso88592", "iso_8859-2", "iso_8859-2:1987", "l2", "latin2" ],
            name: "ISO-8859-2"
        }, {
            labels: [ "csisolatin3", "iso-8859-3", "iso-ir-109", "iso8859-3", "iso88593", "iso_8859-3", "iso_8859-3:1988", "l3", "latin3" ],
            name: "ISO-8859-3"
        }, {
            labels: [ "csisolatin4", "iso-8859-4", "iso-ir-110", "iso8859-4", "iso88594", "iso_8859-4", "iso_8859-4:1988", "l4", "latin4" ],
            name: "ISO-8859-4"
        }, {
            labels: [ "csisolatincyrillic", "cyrillic", "iso-8859-5", "iso-ir-144", "iso8859-5", "iso88595", "iso_8859-5", "iso_8859-5:1988" ],
            name: "ISO-8859-5"
        }, {
            labels: [ "arabic", "asmo-708", "csiso88596e", "csiso88596i", "csisolatinarabic", "ecma-114", "iso-8859-6", "iso-8859-6-e", "iso-8859-6-i", "iso-ir-127", "iso8859-6", "iso88596", "iso_8859-6", "iso_8859-6:1987" ],
            name: "ISO-8859-6"
        }, {
            labels: [ "csisolatingreek", "ecma-118", "elot_928", "greek", "greek8", "iso-8859-7", "iso-ir-126", "iso8859-7", "iso88597", "iso_8859-7", "iso_8859-7:1987", "sun_eu_greek" ],
            name: "ISO-8859-7"
        }, {
            labels: [ "csiso88598e", "csisolatinhebrew", "hebrew", "iso-8859-8", "iso-8859-8-e", "iso-ir-138", "iso8859-8", "iso88598", "iso_8859-8", "iso_8859-8:1988", "visual" ],
            name: "ISO-8859-8"
        }, {
            labels: [ "csiso88598i", "iso-8859-8-i", "logical" ],
            name: "ISO-8859-8-I"
        }, {
            labels: [ "csisolatin6", "iso-8859-10", "iso-ir-157", "iso8859-10", "iso885910", "l6", "latin6" ],
            name: "ISO-8859-10"
        }, {
            labels: [ "iso-8859-13", "iso8859-13", "iso885913" ],
            name: "ISO-8859-13"
        }, {
            labels: [ "iso-8859-14", "iso8859-14", "iso885914" ],
            name: "ISO-8859-14"
        }, {
            labels: [ "csisolatin9", "iso-8859-15", "iso8859-15", "iso885915", "iso_8859-15", "l9" ],
            name: "ISO-8859-15"
        }, {
            labels: [ "iso-8859-16" ],
            name: "ISO-8859-16"
        }, {
            labels: [ "cskoi8r", "koi", "koi8", "koi8-r", "koi8_r" ],
            name: "KOI8-R"
        }, {
            labels: [ "koi8-ru", "koi8-u" ],
            name: "KOI8-U"
        }, {
            labels: [ "csmacintosh", "mac", "macintosh", "x-mac-roman" ],
            name: "macintosh"
        }, {
            labels: [ "dos-874", "iso-8859-11", "iso8859-11", "iso885911", "tis-620", "windows-874" ],
            name: "windows-874"
        }, {
            labels: [ "cp1250", "windows-1250", "x-cp1250" ],
            name: "windows-1250"
        }, {
            labels: [ "cp1251", "windows-1251", "x-cp1251" ],
            name: "windows-1251"
        }, {
            labels: [ "ansi_x3.4-1968", "ascii", "cp1252", "cp819", "csisolatin1", "ibm819", "iso-8859-1", "iso-ir-100", "iso8859-1", "iso88591", "iso_8859-1", "iso_8859-1:1987", "l1", "latin1", "us-ascii", "windows-1252", "x-cp1252" ],
            name: "windows-1252"
        }, {
            labels: [ "cp1253", "windows-1253", "x-cp1253" ],
            name: "windows-1253"
        }, {
            labels: [ "cp1254", "csisolatin5", "iso-8859-9", "iso-ir-148", "iso8859-9", "iso88599", "iso_8859-9", "iso_8859-9:1989", "l5", "latin5", "windows-1254", "x-cp1254" ],
            name: "windows-1254"
        }, {
            labels: [ "cp1255", "windows-1255", "x-cp1255" ],
            name: "windows-1255"
        }, {
            labels: [ "cp1256", "windows-1256", "x-cp1256" ],
            name: "windows-1256"
        }, {
            labels: [ "cp1257", "windows-1257", "x-cp1257" ],
            name: "windows-1257"
        }, {
            labels: [ "cp1258", "windows-1258", "x-cp1258" ],
            name: "windows-1258"
        }, {
            labels: [ "x-mac-cyrillic", "x-mac-ukrainian" ],
            name: "x-mac-cyrillic"
        } ],
        heading: "Legacy single-byte encodings"
    }, {
        encodings: [ {
            labels: [ "chinese", "csgb2312", "csiso58gb231280", "gb2312", "gb_2312", "gb_2312-80", "gbk", "iso-ir-58", "x-gbk" ],
            name: "GBK"
        }, {
            labels: [ "gb18030" ],
            name: "gb18030"
        } ],
        heading: "Legacy multi-byte Chinese (simplified) encodings"
    }, {
        encodings: [ {
            labels: [ "big5", "big5-hkscs", "cn-big5", "csbig5", "x-x-big5" ],
            name: "Big5"
        } ],
        heading: "Legacy multi-byte Chinese (traditional) encodings"
    }, {
        encodings: [ {
            labels: [ "cseucpkdfmtjapanese", "euc-jp", "x-euc-jp" ],
            name: "EUC-JP"
        }, {
            labels: [ "csiso2022jp", "iso-2022-jp" ],
            name: "ISO-2022-JP"
        }, {
            labels: [ "csshiftjis", "ms932", "ms_kanji", "shift-jis", "shift_jis", "sjis", "windows-31j", "x-sjis" ],
            name: "Shift_JIS"
        } ],
        heading: "Legacy multi-byte Japanese encodings"
    }, {
        encodings: [ {
            labels: [ "cseuckr", "csksc56011987", "euc-kr", "iso-ir-149", "korean", "ks_c_5601-1987", "ks_c_5601-1989", "ksc5601", "ksc_5601", "windows-949" ],
            name: "EUC-KR"
        } ],
        heading: "Legacy multi-byte Korean encodings"
    }, {
        encodings: [ {
            labels: [ "csiso2022kr", "hz-gb-2312", "iso-2022-cn", "iso-2022-cn-ext", "iso-2022-kr" ],
            name: "replacement"
        }, {
            labels: [ "utf-16be" ],
            name: "UTF-16BE"
        }, {
            labels: [ "utf-16", "utf-16le" ],
            name: "UTF-16LE"
        }, {
            labels: [ "x-user-defined" ],
            name: "x-user-defined"
        } ],
        heading: "Legacy miscellaneous encodings"
    } ], label_to_encoding = {}, encoders = (encodings.forEach(function(category) {
        category.encodings.forEach(function(encoding) {
            encoding.labels.forEach(function(label) {
                label_to_encoding[label] = encoding;
            });
        });
    }), {}), decoders = {};
    function indexCodePointFor(pointer, index) {
        return index && index[pointer] || null;
    }
    function indexPointerFor(code_point, index) {
        index = index.indexOf(code_point);
        return -1 === index ? null : index;
    }
    function index(name) {
        if ("encoding-indexes" in global) return global["encoding-indexes"][name];
        throw Error("Indexes missing. Did you forget to include encoding-indexes.js?");
    }
    function TextDecoder(label, options) {
        if (!(this instanceof TextDecoder)) throw TypeError("Called as a function. Did you forget 'new'?");
        label = void 0 !== label ? String(label) : "utf-8", options = ToDictionary(options), 
        this._encoding = null, this._decoder = null, this._ignoreBOM = !1, this._BOMseen = !1, 
        this._error_mode = "replacement", this._do_not_flush = !1;
        var encoding = getEncoding(label);
        if (null === encoding || "replacement" === encoding.name) throw RangeError("Unknown encoding: " + label);
        if (decoders[encoding.name]) return this._encoding = encoding, Boolean(options.fatal) && (this._error_mode = "fatal"), 
        Boolean(options.ignoreBOM) && (this._ignoreBOM = !0), Object.defineProperty || (this.encoding = this._encoding.name.toLowerCase(), 
        this.fatal = "fatal" === this._error_mode, this.ignoreBOM = this._ignoreBOM), 
        this;
        throw Error("Decoder not present. Did you forget to include encoding-indexes.js?");
    }
    function TextEncoder(label, options) {
        if (!(this instanceof TextEncoder)) throw TypeError("Called as a function. Did you forget 'new'?");
        options = ToDictionary(options), this._encoding = null, this._encoder = null, 
        this._do_not_flush = !1, this._fatal = Boolean(options.fatal) ? "fatal" : "replacement";
        if (Boolean(options.NONSTANDARD_allowLegacyEncoding)) {
            options = getEncoding(label = void 0 !== label ? String(label) : "utf-8");
            if (null === options || "replacement" === options.name) throw RangeError("Unknown encoding: " + label);
            if (!encoders[options.name]) throw Error("Encoder not present. Did you forget to include encoding-indexes.js?");
            this._encoding = options;
        } else this._encoding = getEncoding("utf-8"), void 0 !== label && "console" in global && console.warn("TextEncoder constructor called with encoding label, which is ignored.");
        return Object.defineProperty || (this.encoding = this._encoding.name.toLowerCase()), 
        this;
    }
    function UTF8Decoder(options) {
        var fatal = options.fatal, utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
            if (-1 === bite && 0 !== utf8_bytes_needed) return utf8_bytes_needed = 0, 
            decoderError(fatal);
            if (-1 === bite) return -1;
            if (0 === utf8_bytes_needed) {
                if (inRange(bite, 0, 127)) return bite;
                if (inRange(bite, 194, 223)) utf8_bytes_needed = 1, utf8_code_point = 31 & bite; else if (inRange(bite, 224, 239)) 224 === bite && (utf8_lower_boundary = 160), 
                237 === bite && (utf8_upper_boundary = 159), utf8_bytes_needed = 2, 
                utf8_code_point = 15 & bite; else {
                    if (!inRange(bite, 240, 244)) return decoderError(fatal);
                    240 === bite && (utf8_lower_boundary = 144), 244 === bite && (utf8_upper_boundary = 143), 
                    utf8_bytes_needed = 3, utf8_code_point = 7 & bite;
                }
                return null;
            }
            var code_point;
            return inRange(bite, utf8_lower_boundary, utf8_upper_boundary) ? (utf8_lower_boundary = 128, 
            utf8_upper_boundary = 191, utf8_code_point = utf8_code_point << 6 | 63 & bite, 
            (utf8_bytes_seen += 1) !== utf8_bytes_needed ? null : (code_point = utf8_code_point, 
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0, code_point)) : (utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0, 
            utf8_lower_boundary = 128, utf8_upper_boundary = 191, stream.prepend(bite), 
            decoderError(fatal));
        };
    }
    function UTF8Encoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (-1 === code_point) return -1;
            if (isASCIICodePoint(code_point)) return code_point;
            inRange(code_point, 128, 2047) ? (count = 1, offset = 192) : inRange(code_point, 2048, 65535) ? (count = 2, 
            offset = 224) : inRange(code_point, 65536, 1114111) && (count = 3, offset = 240);
            for (var count, offset, bytes = [ (code_point >> 6 * count) + offset ]; 0 < count; ) bytes.push(128 | 63 & code_point >> 6 * (count - 1)), 
            --count;
            return bytes;
        };
    }
    function SingleByteDecoder(index, options) {
        var fatal = options.fatal;
        this.handler = function(stream, bite) {
            return -1 === bite ? -1 : isASCIIByte(bite) ? bite : null === (bite = index[bite - 128]) ? decoderError(fatal) : bite;
        };
    }
    function SingleByteEncoder(index, options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            var pointer;
            return -1 === code_point ? -1 : isASCIICodePoint(code_point) ? code_point : (null === (pointer = indexPointerFor(code_point, index)) && encoderError(code_point), 
            pointer + 128);
        };
    }
    function GB18030Decoder(options) {
        var fatal = options.fatal, gb18030_first = 0, gb18030_second = 0, gb18030_third = 0;
        this.handler = function(stream, bite) {
            var code_point, buffer, pointer;
            return -1 === bite && 0 === gb18030_first && 0 === gb18030_second && 0 === gb18030_third ? -1 : (-1 !== bite || 0 === gb18030_first && 0 === gb18030_second && 0 === gb18030_third || (gb18030_third = gb18030_second = gb18030_first = 0, 
            decoderError(fatal)), 0 !== gb18030_third ? (code_point = null, inRange(bite, 48, 57) && (code_point = function(pointer) {
                if (39419 < pointer && pointer < 189e3 || 1237575 < pointer) return null;
                if (7457 === pointer) return 59335;
                for (var offset = 0, code_point_offset = 0, idx = index("gb18030-ranges"), i = 0; i < idx.length; ++i) {
                    var entry = idx[i];
                    if (!(entry[0] <= pointer)) break;
                    offset = entry[0], code_point_offset = entry[1];
                }
                return code_point_offset + pointer - offset;
            }(10 * (126 * (10 * (gb18030_first - 129) + gb18030_second - 48) + gb18030_third - 129) + bite - 48)), 
            buffer = [ gb18030_second, gb18030_third, bite ], gb18030_third = gb18030_second = gb18030_first = 0, 
            null === code_point ? (stream.prepend(buffer), decoderError(fatal)) : code_point) : 0 !== gb18030_second ? inRange(bite, 129, 254) ? (gb18030_third = bite, 
            null) : (stream.prepend([ gb18030_second, bite ]), gb18030_second = gb18030_first = 0, 
            decoderError(fatal)) : 0 !== gb18030_first ? inRange(bite, 48, 57) ? (gb18030_second = bite, 
            null) : (buffer = gb18030_first, gb18030_first = 0, (pointer = null) === (code_point = null === (pointer = inRange(bite, 64, 126) || inRange(bite, 128, 254) ? 190 * (buffer - 129) + (bite - (bite < 127 ? 64 : 65)) : pointer) ? null : indexCodePointFor(pointer, index("gb18030"))) && isASCIIByte(bite) && stream.prepend(bite), 
            null === code_point ? decoderError(fatal) : code_point) : isASCIIByte(bite) ? bite : 128 === bite ? 8364 : inRange(bite, 129, 254) ? (gb18030_first = bite, 
            null) : decoderError(fatal));
        };
    }
    function GB18030Encoder(options, gbk_flag) {
        options.fatal;
        this.handler = function(stream, code_point) {
            var pointer, trail;
            return -1 === code_point ? -1 : isASCIICodePoint(code_point) ? code_point : 58853 === code_point ? encoderError(code_point) : gbk_flag && 8364 === code_point ? 128 : null !== (pointer = indexPointerFor(code_point, index("gb18030"))) ? (trail = pointer % 190, 
            [ floor(pointer / 190) + 129, trail + (trail < 63 ? 64 : 65) ]) : gbk_flag ? encoderError(code_point) : (pointer = function(code_point) {
                if (59335 === code_point) return 7457;
                for (var offset = 0, pointer_offset = 0, idx = index("gb18030-ranges"), i = 0; i < idx.length; ++i) {
                    var entry = idx[i];
                    if (!(entry[1] <= code_point)) break;
                    offset = entry[1], pointer_offset = entry[0];
                }
                return pointer_offset + code_point - offset;
            }(code_point), [ (trail = floor(pointer / 10 / 126 / 10)) + 129, (code_point = floor((pointer -= 10 * trail * 126 * 10) / 10 / 126)) + 48, (trail = floor((pointer -= 10 * code_point * 126) / 10)) + 129, 48 + (pointer - 10 * trail) ]);
        };
    }
    function Big5Decoder(options) {
        var fatal = options.fatal, Big5_lead = 0;
        this.handler = function(stream, bite) {
            if (-1 === bite && 0 !== Big5_lead) return Big5_lead = 0, decoderError(fatal);
            if (-1 === bite && 0 === Big5_lead) return -1;
            if (0 === Big5_lead) return isASCIIByte(bite) ? bite : inRange(bite, 129, 254) ? (Big5_lead = bite, 
            null) : decoderError(fatal);
            var lead = Big5_lead, pointer = null;
            switch (Big5_lead = 0, pointer = inRange(bite, 64, 126) || inRange(bite, 161, 254) ? 157 * (lead - 129) + (bite - (bite < 127 ? 64 : 98)) : pointer) {
              case 1133:
                return [ 202, 772 ];

              case 1135:
                return [ 202, 780 ];

              case 1164:
                return [ 234, 772 ];

              case 1166:
                return [ 234, 780 ];
            }
            lead = null === pointer ? null : indexCodePointFor(pointer, index("big5"));
            return null === lead && isASCIIByte(bite) && stream.prepend(bite), null === lead ? decoderError(fatal) : lead;
        };
    }
    function Big5Encoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            var pointer, lead;
            return -1 === code_point ? -1 : isASCIICodePoint(code_point) ? code_point : null === (pointer = function(code_point) {
                var index_ = big5_index_no_hkscs = big5_index_no_hkscs || index("big5").map(function(code_point, pointer) {
                    return pointer < 5024 ? null : code_point;
                });
                return 9552 === code_point || 9566 === code_point || 9569 === code_point || 9578 === code_point || 21313 === code_point || 21317 === code_point ? index_.lastIndexOf(code_point) : indexPointerFor(code_point, index_);
            }(code_point)) || (lead = floor(pointer / 157) + 129) < 161 ? encoderError(code_point) : [ lead, (code_point = pointer % 157) + (code_point < 63 ? 64 : 98) ];
        };
    }
    function EUCJPDecoder(options) {
        var fatal = options.fatal, eucjp_jis0212_flag = !1, eucjp_lead = 0;
        this.handler = function(stream, bite) {
            var lead, code_point;
            return -1 === bite && 0 !== eucjp_lead ? (eucjp_lead = 0, decoderError(fatal)) : -1 === bite && 0 === eucjp_lead ? -1 : 142 === eucjp_lead && inRange(bite, 161, 223) ? (eucjp_lead = 0, 
            65216 + bite) : 143 === eucjp_lead && inRange(bite, 161, 254) ? (eucjp_jis0212_flag = !0, 
            eucjp_lead = bite, null) : 0 !== eucjp_lead ? (lead = eucjp_lead, eucjp_lead = 0, 
            code_point = null, inRange(lead, 161, 254) && inRange(bite, 161, 254) && (code_point = indexCodePointFor(94 * (lead - 161) + (bite - 161), index(eucjp_jis0212_flag ? "jis0212" : "jis0208"))), 
            eucjp_jis0212_flag = !1, inRange(bite, 161, 254) || stream.prepend(bite), 
            null === code_point ? decoderError(fatal) : code_point) : isASCIIByte(bite) ? bite : 142 === bite || 143 === bite || inRange(bite, 161, 254) ? (eucjp_lead = bite, 
            null) : decoderError(fatal);
        };
    }
    function EUCJPEncoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            var pointer;
            return -1 === code_point ? -1 : isASCIICodePoint(code_point) ? code_point : 165 === code_point ? 92 : 8254 === code_point ? 126 : inRange(code_point, 65377, 65439) ? [ 142, code_point - 65377 + 161 ] : null === (pointer = indexPointerFor(code_point = 8722 === code_point ? 65293 : code_point, index("jis0208"))) ? encoderError(code_point) : [ floor(pointer / 94) + 161, pointer % 94 + 161 ];
        };
    }
    function ISO2022JPDecoder(options) {
        var fatal = options.fatal, states_ASCII = 0, states_Roman = 1, states_Katakana = 2, states_LeadByte = 3, states_TrailByte = 4, states_EscapeStart = 5, states_Escape = 6, iso2022jp_decoder_state = states_ASCII, iso2022jp_decoder_output_state = states_ASCII, iso2022jp_lead = 0, iso2022jp_output_flag = !1;
        this.handler = function(stream, bite) {
            switch (iso2022jp_decoder_state) {
              default:
              case states_ASCII:
                return 27 === bite ? (iso2022jp_decoder_state = states_EscapeStart, 
                null) : inRange(bite, 0, 127) && 14 !== bite && 15 !== bite && 27 !== bite ? (iso2022jp_output_flag = !1, 
                bite) : -1 === bite ? -1 : (iso2022jp_output_flag = !1, decoderError(fatal));

              case states_Roman:
                return 27 === bite ? (iso2022jp_decoder_state = states_EscapeStart, 
                null) : 92 === bite ? (iso2022jp_output_flag = !1, 165) : 126 === bite ? (iso2022jp_output_flag = !1, 
                8254) : inRange(bite, 0, 127) && 14 !== bite && 15 !== bite && 27 !== bite && 92 !== bite && 126 !== bite ? (iso2022jp_output_flag = !1, 
                bite) : -1 === bite ? -1 : (iso2022jp_output_flag = !1, decoderError(fatal));

              case states_Katakana:
                return 27 === bite ? (iso2022jp_decoder_state = states_EscapeStart, 
                null) : inRange(bite, 33, 95) ? (iso2022jp_output_flag = !1, 65344 + bite) : -1 === bite ? -1 : (iso2022jp_output_flag = !1, 
                decoderError(fatal));

              case states_LeadByte:
                return 27 === bite ? (iso2022jp_decoder_state = states_EscapeStart, 
                null) : inRange(bite, 33, 126) ? (iso2022jp_output_flag = !1, iso2022jp_lead = bite, 
                iso2022jp_decoder_state = states_TrailByte, null) : -1 === bite ? -1 : (iso2022jp_output_flag = !1, 
                decoderError(fatal));

              case states_TrailByte:
                if (27 === bite) iso2022jp_decoder_state = states_EscapeStart; else {
                    if (inRange(bite, 33, 126)) return iso2022jp_decoder_state = states_LeadByte, 
                    null === (code_point = indexCodePointFor(94 * (iso2022jp_lead - 33) + bite - 33, index("jis0208"))) ? decoderError(fatal) : code_point;
                    -1 === bite ? (iso2022jp_decoder_state = states_LeadByte, stream.prepend(bite)) : iso2022jp_decoder_state = states_LeadByte;
                }
                return decoderError(fatal);

              case states_EscapeStart:
                return 36 === bite || 40 === bite ? (iso2022jp_lead = bite, iso2022jp_decoder_state = states_Escape, 
                null) : (stream.prepend(bite), iso2022jp_output_flag = !1, iso2022jp_decoder_state = iso2022jp_decoder_output_state, 
                decoderError(fatal));

              case states_Escape:
                var code_point = iso2022jp_lead, state = (iso2022jp_lead = 0, null);
                return (40 === code_point && 66 === bite && (state = states_ASCII), 
                40 === code_point && 74 === bite && (state = states_Roman), 40 === code_point && 73 === bite && (state = states_Katakana), 
                null !== (state = 36 !== code_point || 64 !== bite && 66 !== bite ? state : states_LeadByte)) ? (iso2022jp_decoder_state = state, 
                state = iso2022jp_output_flag, iso2022jp_output_flag = !0, state ? decoderError(fatal) : null) : (stream.prepend([ code_point, bite ]), 
                iso2022jp_output_flag = !1, iso2022jp_decoder_state = iso2022jp_decoder_output_state, 
                decoderError(fatal));
            }
        };
    }
    function ISO2022JPEncoder(options) {
        options.fatal;
        var states_ASCII = 0, states_Roman = 1, states_jis0208 = 2, iso2022jp_state = states_ASCII;
        this.handler = function(stream, code_point) {
            if (-1 === code_point && iso2022jp_state !== states_ASCII) return stream.prepend(code_point), 
            iso2022jp_state = states_ASCII, [ 27, 40, 66 ];
            if (-1 === code_point && iso2022jp_state === states_ASCII) return -1;
            if (!(iso2022jp_state !== states_ASCII && iso2022jp_state !== states_Roman || 14 !== code_point && 15 !== code_point && 27 !== code_point)) return encoderError(65533);
            if (iso2022jp_state === states_ASCII && isASCIICodePoint(code_point)) return code_point;
            if (iso2022jp_state === states_Roman && (isASCIICodePoint(code_point) && 92 !== code_point && 126 !== code_point || 165 == code_point || 8254 == code_point)) {
                if (isASCIICodePoint(code_point)) return code_point;
                if (165 === code_point) return 92;
                if (8254 === code_point) return 126;
            }
            var pointer;
            return isASCIICodePoint(code_point) && iso2022jp_state !== states_ASCII ? (stream.prepend(code_point), 
            iso2022jp_state = states_ASCII, [ 27, 40, 66 ]) : 165 !== code_point && 8254 !== code_point || iso2022jp_state === states_Roman ? null === (pointer = indexPointerFor(code_point = 8722 === code_point ? 65293 : code_point, index("jis0208"))) ? encoderError(code_point) : iso2022jp_state !== states_jis0208 ? (stream.prepend(code_point), 
            iso2022jp_state = states_jis0208, [ 27, 36, 66 ]) : [ floor(pointer / 94) + 33, pointer % 94 + 33 ] : (stream.prepend(code_point), 
            iso2022jp_state = states_Roman, [ 27, 40, 74 ]);
        };
    }
    function ShiftJISDecoder(options) {
        var fatal = options.fatal, Shift_JIS_lead = 0;
        this.handler = function(stream, bite) {
            var pointer, lead;
            return -1 === bite && 0 !== Shift_JIS_lead ? (Shift_JIS_lead = 0, decoderError(fatal)) : -1 === bite && 0 === Shift_JIS_lead ? -1 : 0 !== Shift_JIS_lead ? (lead = Shift_JIS_lead, 
            pointer = null, Shift_JIS_lead = 0, (inRange(bite, 64, 126) || inRange(bite, 128, 252)) && (pointer = 188 * (lead - (lead < 160 ? 129 : 193)) + bite - (bite < 127 ? 64 : 65)), 
            inRange(pointer, 8836, 10715) ? 48508 + pointer : (null === (lead = null === pointer ? null : indexCodePointFor(pointer, index("jis0208"))) && isASCIIByte(bite) && stream.prepend(bite), 
            null === lead ? decoderError(fatal) : lead)) : isASCIIByte(bite) || 128 === bite ? bite : inRange(bite, 161, 223) ? 65216 + bite : inRange(bite, 129, 159) || inRange(bite, 224, 252) ? (Shift_JIS_lead = bite, 
            null) : decoderError(fatal);
        };
    }
    function ShiftJISEncoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            var pointer;
            return -1 === code_point ? -1 : isASCIICodePoint(code_point) || 128 === code_point ? code_point : 165 === code_point ? 92 : 8254 === code_point ? 126 : inRange(code_point, 65377, 65439) ? code_point - 65377 + 161 : null === (pointer = function(code_point) {
                return (shift_jis_index = shift_jis_index || index("jis0208").map(function(code_point, pointer) {
                    return inRange(pointer, 8272, 8835) ? null : code_point;
                })).indexOf(code_point);
            }(code_point = 8722 === code_point ? 65293 : code_point)) ? encoderError(code_point) : [ (code_point = floor(pointer / 188)) + (code_point < 31 ? 129 : 193), (code_point = pointer % 188) + (code_point < 63 ? 64 : 65) ];
        };
    }
    function EUCKRDecoder(options) {
        var fatal = options.fatal, euckr_lead = 0;
        this.handler = function(stream, bite) {
            var pointer, lead;
            return -1 === bite && 0 !== euckr_lead ? (euckr_lead = 0, decoderError(fatal)) : -1 === bite && 0 === euckr_lead ? -1 : 0 !== euckr_lead ? (lead = euckr_lead, 
            euckr_lead = 0, lead = (pointer = null) === (pointer = inRange(bite, 65, 254) ? 190 * (lead - 129) + (bite - 65) : pointer) ? null : indexCodePointFor(pointer, index("euc-kr")), 
            null === pointer && isASCIIByte(bite) && stream.prepend(bite), null === lead ? decoderError(fatal) : lead) : isASCIIByte(bite) ? bite : inRange(bite, 129, 254) ? (euckr_lead = bite, 
            null) : decoderError(fatal);
        };
    }
    function EUCKREncoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            var pointer;
            return -1 === code_point ? -1 : isASCIICodePoint(code_point) ? code_point : null === (pointer = indexPointerFor(code_point, index("euc-kr"))) ? encoderError(code_point) : [ floor(pointer / 190) + 129, pointer % 190 + 65 ];
        };
    }
    function convertCodeUnitToBytes(code_unit, utf16be) {
        var byte1 = code_unit >> 8, code_unit = 255 & code_unit;
        return utf16be ? [ byte1, code_unit ] : [ code_unit, byte1 ];
    }
    function UTF16Decoder(utf16_be, options) {
        var fatal = options.fatal, utf16_lead_byte = null, utf16_lead_surrogate = null;
        this.handler = function(stream, bite) {
            var lead_surrogate;
            return -1 !== bite || null === utf16_lead_byte && null === utf16_lead_surrogate ? -1 === bite && null === utf16_lead_byte && null === utf16_lead_surrogate ? -1 : null === utf16_lead_byte ? (utf16_lead_byte = bite, 
            null) : (bite = utf16_be ? (utf16_lead_byte << 8) + bite : (bite << 8) + utf16_lead_byte, 
            (utf16_lead_byte = null) !== utf16_lead_surrogate ? (lead_surrogate = utf16_lead_surrogate, 
            utf16_lead_surrogate = null, inRange(bite, 56320, 57343) ? 65536 + 1024 * (lead_surrogate - 55296) + (bite - 56320) : (stream.prepend(convertCodeUnitToBytes(bite, utf16_be)), 
            decoderError(fatal))) : inRange(bite, 55296, 56319) ? (utf16_lead_surrogate = bite, 
            null) : inRange(bite, 56320, 57343) ? decoderError(fatal) : bite) : decoderError(fatal);
        };
    }
    function UTF16Encoder(utf16_be, options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            var lead;
            return -1 === code_point ? -1 : inRange(code_point, 0, 65535) ? convertCodeUnitToBytes(code_point, utf16_be) : (lead = convertCodeUnitToBytes(55296 + (code_point - 65536 >> 10), utf16_be), 
            code_point = convertCodeUnitToBytes(56320 + (code_point - 65536 & 1023), utf16_be), 
            lead.concat(code_point));
        };
    }
    function XUserDefinedDecoder(options) {
        options.fatal;
        this.handler = function(stream, bite) {
            return -1 === bite ? -1 : isASCIIByte(bite) ? bite : 63360 + bite - 128;
        };
    }
    function XUserDefinedEncoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            return -1 === code_point ? -1 : isASCIICodePoint(code_point) ? code_point : inRange(code_point, 63360, 63487) ? code_point - 63360 + 128 : encoderError(code_point);
        };
    }
    Object.defineProperty && (Object.defineProperty(TextDecoder.prototype, "encoding", {
        get: function() {
            return this._encoding.name.toLowerCase();
        }
    }), Object.defineProperty(TextDecoder.prototype, "fatal", {
        get: function() {
            return "fatal" === this._error_mode;
        }
    }), Object.defineProperty(TextDecoder.prototype, "ignoreBOM", {
        get: function() {
            return this._ignoreBOM;
        }
    })), TextDecoder.prototype.decode = function(input, options) {
        input = "object" == typeof input && input instanceof ArrayBuffer ? new Uint8Array(input) : "object" == typeof input && "buffer" in input && input.buffer instanceof ArrayBuffer ? new Uint8Array(input.buffer, input.byteOffset, input.byteLength) : new Uint8Array(0);
        options = ToDictionary(options), this._do_not_flush || (this._decoder = decoders[this._encoding.name]({
            fatal: "fatal" === this._error_mode
        }), this._BOMseen = !1), this._do_not_flush = Boolean(options.stream);
        for (var result, input_stream = new Stream(input), output = []; ;) {
            var token = input_stream.read();
            if (-1 === token) break;
            if (-1 === (result = this._decoder.handler(input_stream, token))) break;
            null !== result && (Array.isArray(result) ? output.push.apply(output, result) : output.push(result));
        }
        if (!this._do_not_flush) {
            for (;-1 !== (result = this._decoder.handler(input_stream, input_stream.read())) && (null !== result && (Array.isArray(result) ? output.push.apply(output, result) : output.push(result)), 
            !input_stream.endOfStream()); );
            this._decoder = null;
        }
        return function(stream) {
            array = [ "UTF-8", "UTF-16LE", "UTF-16BE" ], item = this._encoding.name, 
            -1 === array.indexOf(item) || this._ignoreBOM || this._BOMseen || (0 < stream.length && 65279 === stream[0] ? (this._BOMseen = !0, 
            stream.shift()) : 0 < stream.length && (this._BOMseen = !0));
            for (var array, item, code_points = stream, s = "", i = 0; i < code_points.length; ++i) {
                var cp = code_points[i];
                cp <= 65535 ? s += String.fromCharCode(cp) : (cp -= 65536, s += String.fromCharCode(55296 + (cp >> 10), 56320 + (1023 & cp)));
            }
            return s;
        }.call(this, output);
    }, Object.defineProperty && Object.defineProperty(TextEncoder.prototype, "encoding", {
        get: function() {
            return this._encoding.name.toLowerCase();
        }
    }), TextEncoder.prototype.encode = function(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "", options = ToDictionary(options), 
        this._do_not_flush || (this._encoder = encoders[this._encoding.name]({
            fatal: "fatal" === this._fatal
        })), this._do_not_flush = Boolean(options.stream);
        for (var result, input = new Stream(function(string) {
            for (var s = String(string), n = s.length, i = 0, u = []; i < n; ) {
                var d, c = s.charCodeAt(i);
                c < 55296 || 57343 < c ? u.push(c) : 56320 <= c && c <= 57343 ? u.push(65533) : 55296 <= c && c <= 56319 && (i !== n - 1 && 56320 <= (d = s.charCodeAt(i + 1)) && d <= 57343 ? (u.push(65536 + ((1023 & c) << 10) + (1023 & d)), 
                i += 1) : u.push(65533)), i += 1;
            }
            return u;
        }(opt_string)), output = []; ;) {
            var token = input.read();
            if (-1 === token) break;
            if (-1 === (result = this._encoder.handler(input, token))) break;
            Array.isArray(result) ? output.push.apply(output, result) : output.push(result);
        }
        if (!this._do_not_flush) {
            for (;;) {
                if (-1 === (result = this._encoder.handler(input, input.read()))) break;
                Array.isArray(result) ? output.push.apply(output, result) : output.push(result);
            }
            this._encoder = null;
        }
        return new Uint8Array(output);
    }, encoders["UTF-8"] = function(options) {
        return new UTF8Encoder(options);
    }, decoders["UTF-8"] = function(options) {
        return new UTF8Decoder(options);
    }, "encoding-indexes" in global && encodings.forEach(function(category) {
        "Legacy single-byte encodings" === category.heading && category.encodings.forEach(function(encoding) {
            var encoding = encoding.name, idx = index(encoding.toLowerCase());
            decoders[encoding] = function(options) {
                return new SingleByteDecoder(idx, options);
            }, encoders[encoding] = function(options) {
                return new SingleByteEncoder(idx, options);
            };
        });
    }), decoders.GBK = function(options) {
        return new GB18030Decoder(options);
    }, encoders.GBK = function(options) {
        return new GB18030Encoder(options, !0);
    }, encoders.gb18030 = function(options) {
        return new GB18030Encoder(options);
    }, decoders.gb18030 = function(options) {
        return new GB18030Decoder(options);
    }, encoders.Big5 = function(options) {
        return new Big5Encoder(options);
    }, decoders.Big5 = function(options) {
        return new Big5Decoder(options);
    }, encoders["EUC-JP"] = function(options) {
        return new EUCJPEncoder(options);
    }, decoders["EUC-JP"] = function(options) {
        return new EUCJPDecoder(options);
    }, encoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPEncoder(options);
    }, decoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPDecoder(options);
    }, encoders.Shift_JIS = function(options) {
        return new ShiftJISEncoder(options);
    }, decoders.Shift_JIS = function(options) {
        return new ShiftJISDecoder(options);
    }, encoders["EUC-KR"] = function(options) {
        return new EUCKREncoder(options);
    }, decoders["EUC-KR"] = function(options) {
        return new EUCKRDecoder(options);
    }, encoders["UTF-16BE"] = function(options) {
        return new UTF16Encoder(!0, options);
    }, decoders["UTF-16BE"] = function(options) {
        return new UTF16Decoder(!0, options);
    }, encoders["UTF-16LE"] = function(options) {
        return new UTF16Encoder(!1, options);
    }, decoders["UTF-16LE"] = function(options) {
        return new UTF16Decoder(!1, options);
    }, encoders["x-user-defined"] = function(options) {
        return new XUserDefinedEncoder(options);
    }, decoders["x-user-defined"] = function(options) {
        return new XUserDefinedDecoder(options);
    }, global.TextEncoder || (global.TextEncoder = TextEncoder), global.TextDecoder || (global.TextDecoder = TextDecoder), 
    "undefined" != typeof module && module.exports && (module.exports = {
        TextEncoder: global.TextEncoder,
        TextDecoder: global.TextDecoder,
        EncodingIndexes: global["encoding-indexes"]
    });
}(this), Scene.prototype.reexecute = function() {
    this.lineNum = this.stats.testEntryPoint || 0, this.finished = 0, this.indent = this.getIndent(this.lines[this.lineNum]), 
    this.prevLine = "empty", this.screenEmpty = !0, this.execute();
}, Scene.prototype.printLoop = function() {
    for (var line; !this.finished && this.lineNum < this.lines.length; this.lineNum++) if (trim(line = this.lines[this.lineNum])) {
        var indent = this.getIndent(line);
        if (indent > this.indent) {
            if (/\s*\*comment\b/.test(line)) continue;
            throw new Error(this.lineMsg() + "increasing indent not allowed, expected " + this.indent + " was " + indent);
        }
        if (indent < this.indent && this.dedent(indent), this.temps._choiceEnds[this.lineNum] && (this.getVar("implicit_control_flow") || 0 < this.temps._fakeChoiceDepth)) this.rollbackLineCoverage(), 
        this.lineNum = this.temps._choiceEnds[this.lineNum], this.rollbackLineCoverage(), 
        0 < this.temps._fakeChoiceDepth && this.temps._fakeChoiceDepth--; else {
            if (this.indent = indent, /^\s*#/.test(line)) throw new Error(this.lineMsg() + "It is illegal to fall out of a *choice statement; you must *goto or *finish before the end of the indented block.");
            this.runCommand(line) || (this.prevLine = "text", this.screenEmpty = !1, 
            this.initialCommands = !1, this.printLine(line));
        }
    } else this.paragraph();
    this.rollbackLineCoverage(), this.finished || this.autofinish(), this.save("temp"), 
    this.skipFooter ? this.skipFooter = !1 : printFooter();
}, Scene.prototype.dedent = function(newDent) {}, Scene.prototype.printLine = function(line) {
    if (!line) return null;
    this.screenEmpty = !1, line = this.replaceVariables(line.replace(/^\s*/, "")), 
    this.accumulatedParagraph.push(line), /([-\u2011-\u2014]|\[c\/\])$/.test(line) || this.accumulatedParagraph.push(" ");
}, Scene.prototype.replaceVariables = function(line) {
    line = String(line);
    for (var replacer = /([$@](\!?\!?)\{)/, index = 0, output = [], result = replacer.exec(line); result; result = replacer.exec(line.substring(index))) {
        output.push(line.substring(index, index + result.index));
        for (var curlies = 0, closingCurly = -1, exprStart = index + result.index + result[1].length, i = exprStart; i < line.length; i++) if ("{" === (c = line.charAt(i))) curlies++; else if ("}" === c) {
            if (!curlies) {
                closingCurly = i;
                break;
            }
            curlies--;
        }
        if (-1 == closingCurly) throw new Error(this.lineMsg() + "invalid " + result[0] + "} variable substitution at letter " + (index + result.index + 1));
        var stack, value, body = line.substring(exprStart, closingCurly);
        if ("$" === result[0].charAt(0)) stack = this.tokenizeExpr(body), value = this.evaluateExpr(stack); else {
            if (/^\s*\(/.test(body)) {
                for (var c, parens = 0, closingParen = -1, i = 1; i < body.length; i++) if ("(" === (c = body.charAt(i))) parens++; else if (")" === c) {
                    if (!parens) {
                        closingParen = i;
                        break;
                    }
                    parens--;
                }
                if (-1 == closingParen) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; missing closing parenthesis )");
                if (" " != body.charAt(closingParen + 1)) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; there should be a space after the closing parenthesis )");
                expr = body.substring(1, closingParen), options = body.substring(closingParen + 2).split("|");
            } else {
                if (!/^\S+ /.test(body)) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; there should be a space after the first word");
                var exprStart = body.indexOf(" "), expr = body.substring(0, exprStart), options = body.substring(exprStart + 1).split("|");
            }
            if (options.length < 2) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; there should be at least one pipe | to separate options");
            if (stack = this.tokenizeExpr(expr), (0 | (value = num(value = "boolean" != typeof (value = this.evaluateExpr(stack)) && !/^(true|false)$/i.test(value) ? value : bool(value) ? 1 : 2, this.lineNum + 1, this.name))) !== value) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; '" + expr + "' is equal to " + value + " which is not a whole integer number");
            if (value < 1) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; '" + expr + "' is equal to " + value + " which is not a positive number");
            if (value > options.length) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; '" + expr + "' is equal to " + value + " but there are only " + options.length + " options");
            value = options[value - 1], value = this.replaceVariables(value);
        }
        exprStart = result[2];
        exprStart && (value = String(value)), "!" == exprStart ? value = value.charAt(0).toUpperCase() + value.slice(1) : "!!" == exprStart && (value = value.toUpperCase()), 
        "undefined" != typeof highlightGenderPronouns && highlightGenderPronouns && /\b(he|him|his|she|her|hers)\b/gi.test(value) && output.push(""), 
        output.push(value), index = closingCurly + 1;
    }
    return 0 === index ? line : (output.push(line.substring(index)), output.join(""));
}, Scene.prototype.paragraph = function() {
    printParagraph(this.accumulatedParagraph.join("")), this.accumulatedParagraph = [], 
    this.prevLine = "empty";
}, Scene.prototype.loadSceneFast = function(url) {
    if (!this.loading) {
        this.loading = !0;
        var result, startedWaiting, sceneName, fileName, self = this;
        if ("undefined" != typeof cachedResults && cachedResults && cachedResults[this.name]) return result = window.cachedResults[this.name], 
        safeTimeout(function() {
            self.loadLinesFast(result.crc, result.lines, result.labels);
        }, 0);
        if ("undefined" != typeof allScenes) {
            if (result = allScenes[this.name]) return safeTimeout(function() {
                self.loadLinesFast(result.crc, result.lines, result.labels);
            }, 0);
            throw new Error("Couldn't load scene '" + this.name + "'\nThe file doesn't exist.");
        }
        if ("undefined" != typeof window && window.isIosApp && window.isFile && !window.isOmnibusApp) return startLoading(), 
        startedWaiting = new Date().getTime(), awaitAllScenes();
        if (window.purchases[self.name] && isStoreSceneCacheRequired()) return sceneName = this.name.replace(/ /g, "_"), 
        window.store.get("cache_scene_hash_" + sceneName, function(ok, hash) {
            function keepScene(result) {
                window.cachedResults || (window.cachedResults = {}), cachedResults[self.name] = result, 
                self.loadLinesFast(result.crc, result.lines, result.labels);
            }
            function loadPaidScene() {
                startLoading(), updateSinglePaidSceneCache(self.name, function(err, result) {
                    if (doneLoading(), err) {
                        if ("not registered" === err) return logout(), loginDiv(), 
                        clearScreen(function() {
                            loginForm(main, 0, "Please sign in to access this part of the game.", function() {
                                clearScreen(loadAndRestoreGame);
                            });
                        });
                        "not purchased" === err ? (window.rerestore = function() {
                            restorePurchases(window.purchases[self.name], function(purchased) {
                                window.location.reload();
                            });
                        }, main.innerHTML = "<div id='text'><p>Our apologies; we were unable to access your purchase while loading game data. (Error 403x)  Please restore purchases now; if that doesn't work, please email " + getSupportEmail() + " with details, including the error number 403x.</p> <p><button class='next' onclick='window.rerestore();'>Restore Now</button></p></div>", 
                        curl()) : (main.innerHTML = "<div id='text'><p>Our apologies; there was a " + err + " error while loading game data.  Please refresh now; if that doesn't work, please click the Restart button and email " + getSupportEmail() + " with details, including the error number.</p> <p><button class='next' onclick='window.location.reload();'>Refresh Now</button></p></div>", 
                        curl());
                    } else keepScene(result);
                });
            }
            ok && hash == hashes.scenes[sceneName + ".txt.json"] ? window.store.get("cache_scene_" + sceneName, function(ok, text) {
                if (ok && text) {
                    var parsed;
                    try {
                        parsed = jsonParse(text);
                    } catch (e) {
                        window.console && console.error(e, e.stack);
                    }
                    if (parsed && parsed.crc && parsed.lines && parsed.labels) return keepScene(parsed);
                }
                loadPaidScene();
            }) : loadPaidScene();
        });
        startLoading(), url || (fileName = this.name.replace(/ /g, "_") + ".txt.json", 
        url = Scene.baseUrl + "/" + fileName, "https:" == window.location.protocol && window.hashes && window.hashes.scenes[fileName] && (url += "?hash=" + hashes.scenes[fileName]));
        var xhr = findXhr(), self = (xhr.open("GET", url, !0), this), done = !1;
        if (xhr.onreadystatechange = function() {
            if (!done && 4 == xhr.readyState) {
                if (403 == xhr.status) try {
                    if ("not registered" == JSON.parse(xhr.responseText).error) return isRegistered(function(registered) {
                        return registered && (logout(), loginDiv()), clearScreen(function() {
                            loginForm(main, 0, "Please sign in to access this part of the game.", function() {
                                clearScreen(loadAndRestoreGame);
                            });
                        });
                    });
                } catch (e) {}
                var result;
                done = !0;
                try {
                    result = jsonParse(xhr.responseText);
                } catch (e) {
                    window.console && console.error(e, e.stack);
                }
                if (!window.isWeb || 200 == xhr.status && result) {
                    if ("" === xhr.responseText) throw new Error("Couldn't load " + url + "\nThe file is probably missing or empty.");
                    window.cachedResults || (window.cachedResults = {}), cachedResults[self.name] = result, 
                    self.loadLinesFast(result.crc, result.lines, result.labels);
                } else doneLoading(), 200 != (result = xhr.status) && result || (result = "network"), 
                main.innerHTML = "<div id='text'><p>Our apologies; there was a " + result + " error while loading game data.  Please refresh your browser now; if that doesn't work, please click the Restart button and email " + getSupportEmail() + " with details.</p> <p><button onclick='window.location.reload();'>Refresh Now</button></p></div>", 
                curl();
            }
        }, isIE) xhr.send(null); else try {
            xhr.send(null);
        } catch (e) {
            "file:" == window.location.protocol && !window.isMobile && /Chrome/.test(navigator.userAgent) ? window.onerror('We\'re sorry, Google Chrome has blocked ChoiceScript from functioning.  ("file:" URLs cannot load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.') : window.onerror("Couldn't load URL: " + url + "\n" + e);
        }
    }
    function retryScenes(event, command) {
        command = command || "retryscenes", clearScreen(function() {
            startLoading(), "retryscenes" == command && curl(), window.downloadState = null, 
            callIos(command), startedWaiting = new Date().getTime(), awaitAllScenes();
        });
    }
    function awaitAllScenes() {
        if ("undefined" != typeof allScenes) {
            if (!(result = allScenes[self.name])) throw new Error("Couldn't load scene '" + self.name + "'\nThe file doesn't exist.");
            self.loadLinesFast(result.crc, result.lines, result.labels);
        } else {
            var retry;
            "failed" == window.downloadState || 5e3 < new Date().getTime() - startedWaiting ? (doneLoading(), 
            window.downloadRequired ? (self.printLine("We weren't able to download the latest version of the game."), 
            self.paragraph(), printButton("Try Again", main, !1, retryScenes)) : (self.printLine("We weren't able to download the latest version of the game. Please try downloading again. The latest version may contain important fixes."), 
            self.paragraph(), retry = {
                name: "Try downloading again."
            }, printOptions([ "" ], [ retry, {
                name: "Continue playing without the latest version."
            } ], function(option) {
                option == retry ? retryScenes() : retryScenes(0, "requestscenesforce");
            }))) : setTimeout(awaitAllScenes, 0);
        }
    }
}, Scene.prototype.loadLinesFast = function(crc, lines, labels) {
    this.crc = crc, this.lines = lines, this.labels = labels, this.loading = !1, 
    this.loaded = !0;
    var self = this;
    this.executing && safeCall(this, function() {
        doneLoading(), self.execute();
    });
}, Scene.prototype.loadScene = function() {
    if (!this.loading) {
        if (this.loading = !0, window.isFile) return this.loadFile();
        startLoading();
        var url = Scene.baseUrl + "/" + this.name + ".txt", xhr = findXhr(), self = (xhr.open("GET", url, !0), 
        this), done = !1;
        if (xhr.onreadystatechange = function() {
            if (!done && 4 == xhr.readyState) {
                if (done = !0, 403 == xhr.status) try {
                    if ("not registered" == JSON.parse(xhr.responseText).error) return isRegistered(function(registered) {
                        return registered && (logout(), loginDiv()), clearScreen(function() {
                            loginForm(main, 0, "Please sign in to access this part of the game.", function() {
                                clearScreen(loadAndRestoreGame);
                            });
                        });
                    });
                } catch (e) {}
                if (window.isWeb && 200 != xhr.status) status = xhr.status || "network", 
                main.innerHTML = "<p>Our apologies; there was a " + status + " error while loading game data.  Please refresh your browser now; if that doesn't work, please email " + getSupportEmail() + " with details.</p> <p><button onclick='window.location.reload();'>Refresh Now</button></p>"; else {
                    if ("" === xhr.responseText) return "file:" == window.location.protocol && !window.isMobile && /Chrome/.test(navigator.userAgent) ? void window.onerror('We\'re sorry, Google Chrome has blocked ChoiceScript from functioning.  ("file:" URLs cannot load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.') : void window.onerror("Couldn't load " + url + "\nThe file is probably missing or empty.");
                    var status = xhr.responseText;
                    scene = (scene = status).replace(/\r/g, ""), this.loading = !1, 
                    self.loadLines(scene), self.executing && safeCall(self, function() {
                        doneLoading(), self.execute();
                    });
                }
            }
        }, isIE) xhr.send(null); else try {
            xhr.send(null);
        } catch (e) {
            if ("file:" == window.location.protocol && !window.isMobile) {
                if (/Chrome/.test(navigator.userAgent)) return void window.onerror('We\'re sorry, Google Chrome has blocked ChoiceScript from functioning.  ("file:" URLs cannot load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.');
                if (1012 === e.code) return void window.onerror("Couldn't load scene file: " + url + "\nThe file is probably missing.");
            }
            window.onerror("Couldn't load URL: " + url + "\n" + e);
        }
    }
}, Scene.prototype.loadFile = function() {
    var _this = this;
    if ("object" != typeof uploadedFiles) clearScreen(function() {
        var header = document.getElementById("header"), makeYourOwnGames = (header && (header.style.display = "none"), 
        document.getElementById("makeyourowngames")), text = (makeYourOwnGames && (makeYourOwnGames.style.display = "none"), 
        _this.printLine('[b]Please "Upload" ChoiceScript[/b]'), _this.paragraph(), 
        _this.printLine('To begin, you\'ll need to grant permission to "upload" your choicescript folder containing index.html.'), 
        _this.paragraph(), _this.printLine("Use the button below to select your choicescript folder."), 
        _this.paragraph(), document.getElementById("text")), input = document.createElement("input");
        input.type = "file", input.webkitdirectory = !0, input.multiple = !0, input.addEventListener("change", function(e) {
            for (var numFiles = input.files.length, startupCandidates = [], i = 0; i < numFiles; i++) "startup.txt" === (file = input.files[i]).name && startupCandidates.push(file);
            if (!startupCandidates.length) return clearScreen(function() {
                _this.printLine("We couldn't find startup.txt in the folder you chose. Please try again."), 
                _this.paragraph(), document.getElementById("text").appendChild(input), 
                curl();
            });
            if (1 < startupCandidates.length) return clearScreen(function() {
                _this.printLine("There were multiple files called startup.txt in the folder you chose. Please try again."), 
                _this.paragraph();
                for (var i = 0; i < startupCandidates.length; i++) _this.printLine(" " + startupCandidates[i].webkitRelativePath);
                _this.paragraph(), document.getElementById("text").appendChild(input), 
                curl();
            });
            for (var startup = startupCandidates[0], rootDirTest = new RegExp("^" + startup.webkitRelativePath.replace(/\/startup.txt$/, "/[^/]+$")), sceneFiles = {}, i = 0; i < numFiles; i++) {
                var file = input.files[i];
                rootDirTest.test(file.webkitRelativePath) && (sceneFiles[file.name] = file);
            }
            window.uploadedFiles = sceneFiles, header && (header.style.display = ""), 
            makeYourOwnGames && (makeYourOwnGames.style.display = ""), clearScreen(function() {
                _this.loadFile();
            });
        }), text.appendChild(input), _this.paragraph(), _this.printLine("(We're not actually going to transfer your code over the Internet, but this web page needs permission to upload your choicescript folder in order to access your code and run it. The power to access your code would also grant us the power to transfer your code elsewhere, but we're not going to do that. JavaScript programmers can read our JavaScript to verify that this is true.)"), 
        _this.paragraph(), curl();
    }); else {
        var fileName = this.name + ".txt";
        if (uploadedFiles[fileName]) startLoading(), new Response(uploadedFiles[fileName]).text().then(function(result) {
            scene = (scene = result).replace(/\r/g, ""), _this.loading = !1, safeCall(_this, function() {
                _this.loadLines(scene), doneLoading(), _this.execute();
            });
        }); else {
            for (var otherFileName in uploadedFiles) if (fileName.toLowerCase() === otherFileName.toLowerCase()) return main.innerHTML = "<p>Couldn't find " + fileName + " in the uploaded folder, but we did find " + otherFileName + ". Scene file names must match exactly, including capitalization.</p> <p><button onclick='window.location.reload();'>Refresh Now</button></p>", 
            void curl();
            main.innerHTML = "<p>Couldn't find " + fileName + " in the uploaded folder.</p> <p><button onclick='window.location.reload();'>Refresh Now</button></p>", 
            curl();
        }
    }
}, Scene.prototype.checkSum = function() {
    if (this.temps.choice_crc && (!this.randomtest && !this.quicktest && this.temps.choice_crc != this.crc && this.lineNum)) return "undefined" != typeof alertify && (initStore() ? alertify.log("The game has updated. Restarting chapter.") : alertify.log(this.name + ".txt has updated. Restarting chapter.")), 
    safeTimeout(function() {
        clearScreen(function() {
            loadAndRestoreGame("backup");
        });
    }, 0), !1;
    return this.temps.choice_crc = this.crc, !0;
}, Scene.prototype.loadLines = function(str) {
    this.crc = crc32(str), this.lines = str.split(/\r?\n/), this.parseLabels(), 
    this.loaded = !0;
}, Scene.prototype.execute = function() {
    if (this.loaded) {
        if (this.checkSum()) {
            if (this.nav && this.nav.repairStats(stats), this.temps._choiceEnds || (this.temps._choiceEnds = {}), 
            doneLoading(), void 0 !== this.targetLabel) {
                var label = this.targetLabel.label.toLowerCase();
                if (void 0 === this.labels[label]) throw new Error(this.targetLabel.origin + " line " + (this.targetLabel.originLine + 1) + ": " + this.name + " doesn't contain label " + label);
                this.lineNum = this.labels[label], this.indent = this.getIndent(this.lines[this.lineNum]), 
                delete this.targetLabel;
            }
            this.lineNum || (this.stats.choice_subscene_stack || []).length || this.save("backup"), 
            this.redirectingFromStats && (this.save(""), delete this.redirectingFromStats), 
            this.printLoop();
        }
    } else this.executing = !0, Scene.generatedFast || "undefined" != typeof generatedFast && generatedFast || "undefined" != typeof allScenes ? this.loadSceneFast() : this.loadScene();
}, Scene.prototype.parseLabels = function() {
    var lineLength = this.lines.length, oldLineNum = this.lineNum, screenshots = "choicescript_screenshots" == this.name, seenChoiceWithoutSet = 0;
    for (this.lineNum = 0; this.lineNum < lineLength; this.lineNum++) {
        this.rollbackLineCoverage();
        var line = this.lines[this.lineNum], invalidCharacter = (0 == this.lineNum && 65279 == line.charCodeAt(0) && (lines[0] = line.substring(1)), 
        line.match(/^(.*)\ufffd/));
        if (invalidCharacter) throw new Error(this.lineMsg() + "invalid character. (ChoiceScript text should be saved in the UTF-8 encoding.) " + invalidCharacter[0]);
        invalidCharacter = /^(\s*)\*(\w+)(.*)/.exec(line);
        if (invalidCharacter) {
            invalidCharacter[1].length;
            line = invalidCharacter[2].toLowerCase(), invalidCharacter = trim(invalidCharacter[3]);
            if ("label" == line) {
                if (invalidCharacter = invalidCharacter.toLowerCase(), /\s/.test(invalidCharacter)) throw new Error(this.lineMsg() + "label '" + invalidCharacter + "' is not allowed to contain spaces");
                if (this.labels.hasOwnProperty(invalidCharacter)) throw new Error(this.lineMsg() + "label '" + invalidCharacter + "' already defined on line " + (+this.labels[invalidCharacter] + 1));
                this.labels[invalidCharacter] = this.lineNum;
            } else if (screenshots) if ("fake_choice" == line) {
                if (seenChoiceWithoutSet) throw new Error(this.lineMsg() + "In choicescript_screenshots, you need to *set at least one variable between *fake_choice commands, so the stat screen looks interesting. There was no *set since the last *fake_choice on line " + seenChoiceWithoutSet + ".");
                seenChoiceWithoutSet = this.lineNum + 1;
            } else "set" == line && (seenChoiceWithoutSet = 0);
        }
    }
    this.rollbackLineCoverage(), this.lineNum = oldLineNum;
}, Scene.prototype.runCommand = function(line) {
    line = /^\s*\*(\w+)(.*)/.exec(line);
    if (!line) return !("startup" != this.secondaryMode || !this.startupCallback) && (this.finished = !0, 
    this.skipFooter = !0, this.startupCallback(), !0);
    var command = line[1].toLowerCase(), line = trim(line[2]);
    if (!Scene.validCommands[command]) throw new Error(this.lineMsg() + "Non-existent command '" + command + "'");
    if ("comment" != command) {
        if (Scene.initialCommands[command]) {
            if ("startup" != String(this.name).toLowerCase() || !this.initialCommands) throw new Error(this.lineMsg() + "Invalid " + command + " instruction, only allowed at the top of startup.txt");
        } else {
            if ("startup" == this.secondaryMode && this.startupCallback) return this.finished = !0, 
            this.skipFooter = !0, this.startupCallback(), !0;
            this.initialCommands = !1;
        }
        if ("choice" == command && "choicescript_screenshots" == String(this.name).toLowerCase()) throw new Error(this.lineMsg() + "choicescript_screenshots files should only contain *fake_choice commands, not real *choice commands");
        this[command](line);
    }
    return !0;
}, Scene.prototype.choice = function(data) {
    for (var startLineNum = this.lineNum, groups = data.split(/ /), i = 0; i < groups.length; i++) if (!/^\w*$/.test(groups[i])) throw new Error(this.lineMsg() + "invalid choice group name: " + groups[i]);
    var options = this.parseOptions(this.indent, groups), self = this;
    if (this.renderOptions(groups, options, function(option) {
        self.standardResolution(option);
    }), this.finished = !0, 0 < this.temps._fakeChoiceDepth || this.getVar("implicit_control_flow")) for (this.temps._choiceEnds || (this.temps._choiceEnds = {}), 
    i = 0; i < options.length; i++) this.temps._choiceEnds[options[i].line - 1] = this.lineNum;
    this.lineNum = startLineNum;
}, Scene.prototype.fake_choice = function(data) {
    void 0 === this.temps._fakeChoiceDepth && (this.temps._fakeChoiceDepth = 0), 
    this.temps._fakeChoiceDepth++, this.choice(data);
}, Scene.prototype.standardResolution = function(option) {
    this.lineNum = option.line, this.indent = this.getIndent(this.nextNonBlankLine(!0)), 
    option.reuse && "allow" != option.reuse && (this.temps.choice_used[option.line - 1] = 1), 
    this.nav && this.nav.bugLog.push("#" + (option.line + 1) + " " + option.name), 
    this.finished = !1, this.resetPage();
}, Scene.prototype.nextNonBlankLine = function(includingThisOne) {
    var line, i = this.lineNum;
    for (includingThisOne || i++; isDefined(line = this.lines[i]) && !trim(line); ) i++;
    return line;
}, Scene.prototype.previousNonBlankLineNum = function() {
    for (var line, i = this.lineNum - 1; isDefined(line = this.lines[i]) && !trim(line); ) i--;
    return i;
}, Scene.prototype.resetCheckedPurchases = function() {
    for (var temp in this.temps) /^choice_purchased/.test(temp) && delete this.temps[temp];
}, Scene.prototype.resetPage = function() {
    var self = this;
    this.resetCheckedPurchases(), clearScreen(function() {
        self.save(""), self.prevLine = "empty", self.screenEmpty = !0, self.execute();
    });
}, Scene.prototype.save = function(slot) {
    if (this.saveSlot) transferTempStatWrites(); else {
        if (!slot) {
            for (var key in slot = "", tempStatWrites) tempStatWrites.hasOwnProperty(key) && (this.stats[key] = tempStatWrites[key]);
            tempStatWrites = {};
        }
        saveCookie(function() {}, slot, this.stats, this.temps, this.lineNum, this.indent, this.debugMode, this.nav);
    }
}, Scene.prototype.goto = function(line) {
    line = /[\[\{]/.test(line) ? this.evaluateReference(this.tokenizeExpr(line)) : String(line).toLowerCase();
    if (void 0 === this.labels[line]) throw new Error(this.lineMsg() + "bad label " + line);
    if (this.lineNum = this.labels[line], this.indent = this.getIndent(this.lines[this.lineNum]), 
    this.localCoverage || (this.localCoverage = {}), this.localCoverage[this.lineNum]) {
        if (this.localCoverage[this.lineNum]++, this.looplimit_count && this.localCoverage[this.lineNum] > this.looplimit_count) throw new Error(this.lineMsg() + "visited this line too many times (" + this.looplimit_count + ")");
    } else this.localCoverage[this.lineNum] = 1;
}, Scene.prototype.gosub = function(data) {
    for (var label = /\S+/.exec(data)[0], data = data.substring(label.length + 1), args = [], stack = this.tokenizeExpr(data); stack.length; ) args.push(this.evaluateValueToken(stack.shift(), stack));
    this.temps.choice_substack || (this.temps.choice_substack = []), this.temps.choice_substack.push({
        lineNum: this.lineNum,
        indent: this.indent
    }), this.temps.param = args, this.goto(label);
}, Scene.prototype.gosub_scene = function(data) {
    this.stats.choice_subscene_stack || (this.stats.choice_subscene_stack = []), 
    this.stats.choice_subscene_stack.push({
        name: this.name,
        lineNum: this.lineNum + 1,
        indent: this.indent,
        temps: this.temps
    }), this.goto_scene(data);
}, Scene.prototype.params = function(data) {
    var words = /\w+/.exec(data), nextParamNum = 1;
    for (this.temps.param_count = this.temps.param.length; words; ) {
        var varName = words[0];
        if (this.validateVariable(varName), this.temps.param.length < 1) throw new Error(this.lineMsg() + "No parameter passed for " + varName);
        var paramVal = this.temps.param.shift();
        this.temps[varName] = paramVal, this.temps["param_" + nextParamNum] = paramVal, 
        nextParamNum++, data = data.substring(varName.length + 1), words = /\w+/.exec(data);
    }
    for (;0 < this.temps.param.length; ) {
        paramVal = this.temps.param.shift();
        this.temps["param_" + nextParamNum] = paramVal, nextParamNum++;
    }
}, Scene.prototype.return = function() {
    var scene, stackFrame;
    if (this.temps.choice_substack && this.temps.choice_substack.length) stackFrame = this.temps.choice_substack.pop(), 
    this.lineNum = stackFrame.lineNum, this.indent = stackFrame.indent; else {
        if (!this.stats.choice_subscene_stack || !this.stats.choice_subscene_stack.length) throw this.temps.choice_substack || this.stats.choice_subscene_stack ? new Error(this.lineMsg() + "invalid return; we've already returned from the last gosub") : new Error(this.lineMsg() + "invalid return; gosub has not yet been called");
        (stackFrame = this.stats.choice_subscene_stack.pop()).name == this.name ? (this.temps = stackFrame.temps, 
        this.lineNum = stackFrame.lineNum - 1, this.indent = stackFrame.indent) : (this.finished = !0, 
        this.skipFooter = !0, (scene = new Scene(stackFrame.name, this.stats, this.nav, {
            debugMode: this.debugMode,
            secondaryMode: this.secondaryMode,
            saveSlot: this.saveSlot
        })).temps = stackFrame.temps, scene.screenEmpty = this.screenEmpty, scene.prevLine = this.prevLine, 
        scene.lineNum = stackFrame.lineNum, scene.indent = stackFrame.indent, scene.accumulatedParagraph = this.accumulatedParagraph, 
        this.randomtest ? clearScreen(function() {
            scene.execute();
        }) : scene.execute());
    }
}, Scene.prototype.gotoref = function(expression) {
    expression = this.tokenizeExpr(expression), expression = this.evaluateExpr(expression);
    this.goto(expression);
}, Scene.prototype.finish = function(buttonName) {
    this.paragraph(), this.finished = !0;
    var self = this;
    if ("stats" == this.secondaryMode) return "undefined" == typeof window || window.isIosApp && window.isIPad ? void 0 : this.screenEmpty ? void returnFromStats() : (buttonName = this.replaceVariables(buttonName = buttonName || "Next"), 
    void printButton(buttonName, main, !1, function() {
        returnFromStats();
    }));
    var nextSceneName = this.nav && nav.nextSceneName(this.name);
    nextSceneName ? this.screenEmpty ? this.goto_scene(nextSceneName) : (buttonName = this.replaceVariables(buttonName = buttonName || "Next Chapter"), 
    printButton(buttonName, main, !1, function() {
        safeCall(self, function() {
            new Scene(nextSceneName, self.stats, self.nav, {
                debugMode: self.debugMode,
                secondaryMode: self.secondaryMode
            }).resetPage();
        });
    }), this.debugMode && println(computeCookie(this.stats, this.temps, this.lineNum, this.indent))) : this.secondaryMode || this.ending();
}, Scene.prototype.autofinish = function(buttonName) {
    this.finish(buttonName);
}, Scene.prototype.reset = function() {
    this.nav.resetStats(this.stats), this.stats.scene = this;
}, Scene.prototype.parseGotoScene = function(data) {
    var sceneName, label, stack, param = [];
    if (/[\[\{]/.test(data)) for (stack = this.tokenizeExpr(data), sceneName = this.evaluateReference(stack, {
        toLowerCase: !1
    }), stack.length && (label = this.evaluateReference(stack)); stack.length; ) param.push(this.evaluateValueToken(stack.shift(), stack)); else {
        var match = /(\S+)\s+(\S+)\s*(.*)/.exec(data);
        if (match) for (sceneName = match[1], label = match[2], stack = this.tokenizeExpr(match[3]); stack.length; ) param.push(this.evaluateValueToken(stack.shift(), stack)); else {
            if ("" === data) throw new Error(this.lineMsg() + "missing scene name");
            sceneName = data;
        }
    }
    return {
        sceneName: sceneName,
        label: label,
        param: param
    };
}, Scene.prototype.goto_scene = function(data) {
    var scene, data = this.parseGotoScene(data);
    data.sceneName == this.name ? (void 0 === data.label ? this.lineNum = -1 : this.goto(data.label), 
    this.temps = {
        choice_reuse: "allow",
        choice_user_restored: !1,
        _choiceEnds: {}
    }, this.temps.param = data.param, this.initialCommands = !0) : (this.finished = !0, 
    this.skipFooter = !0, (scene = new Scene(data.sceneName, this.stats, this.nav, {
        debugMode: this.debugMode,
        secondaryMode: this.secondaryMode,
        saveSlot: this.saveSlot
    })).screenEmpty = this.screenEmpty, scene.prevLine = this.prevLine, scene.accumulatedParagraph = this.accumulatedParagraph, 
    void 0 !== data.label && (scene.targetLabel = {
        label: data.label,
        origin: this.name,
        originLine: this.lineNum
    }), void 0 !== data.param && (scene.temps.param = data.param), this.redirectingFromStats && (scene.redirectingFromStats = !0), 
    scene.execute());
}, Scene.prototype.redirect_scene = function(data) {
    if ("stats" != this.secondaryMode) throw new Error(this.lineMsg() + "The *redirect_scene command can only be used from the stats screen.");
    var result = this.parseGotoScene(data), self = (this.finished = !0, this.skipFooter = !0, 
    this);
    redirectFromStats(result.sceneName, result.label, this.lineNum, function() {
        delete self.secondaryMode, delete self.saveSlot, self.redirectingFromStats = !0, 
        self.goto_scene(data);
    });
}, Scene.prototype.product = function(productId) {
    if (!/^[a-z]+$/.test(productId)) throw new Error(this.lineMsg() + "Invalid product id (only lowercase letters, no numbers or punctuation): " + productId);
    this.nav && (this.nav.products[productId] = {});
}, Scene.prototype.restore_purchases = function(data) {
    var self = this, target = (target = this.target) || document.getElementById("text"), target = printButton("Restore Purchases", target, !1, function() {
        safeCall(self, function() {
            restorePurchases(null, function() {
                self.goto(data), self.finished = !1, self.resetPage();
            });
        });
    });
    setClass(target, ""), this.prevLine = "block";
}, Scene.prototype.check_purchase = function(data) {
    this.finished = !0, this.skipFooter = !0;
    for (var self = this, productList = data.split(/ /), i = 0; i < productList.length; i++) {
        var product = productList[i];
        if (!this.nav.products[product] && "adfree" != product) throw new Error(this.lineMsg() + "The product " + product + " wasn't declared in a *product command");
    }
    checkPurchase(data, function(ok, result) {
        self.finished = !1, self.skipFooter = !1, ok || (result = {
            billingSupported: !0
        }, self.temps.choice_purchase_error = !0), result = result || {};
        for (var products = data.split(/ /), everything = !0, i = 0; i < products.length; i++) {
            var purchasedProduct = result[products[i]] || !1;
            (self.temps["choice_purchased_" + products[i]] = purchasedProduct) || (everything = !1);
        }
        self.temps.choice_purchased_everything = everything, self.temps.choice_purchase_supported = !!result.billingSupported, 
        self.execute();
    });
}, Scene.prototype.parsePurchase = function(data) {
    var result;
    if (/^\{/.test(data)) {
        try {
            result = JSON.parse(data);
        } catch (e) {
            throw new Error(this.lineMsg() + "Couldn't parse purchase JSON: " + e);
        }
        if (!result.product) throw new Error(this.lineMsg() + "JSON missing product");
        if (!result.goto) throw new Error(this.lineMsg() + "JSON missing goto");
        if (result.priceGuess && result.discount) throw new Error(this.lineMsg() + "JSON has both top-level priceGuess and discount; there should be one or the other");
        if (!result.priceGuess && !result.discount) throw new Error(this.lineMsg() + "JSON has neither top-level priceGuess nor discount; there should be one or the other");
        if (result.discount) {
            if (!result.discount.end) throw new Error(this.lineMsg() + "JSON discount doesn't include end");
            if (result.discount.end = parseDateStringInCurrentTimezone(result.discount.end, this.lineNum + 1), 
            !result.discount.lowPrice) throw new Error(this.lineMsg() + "JSON discount doesn't include lowPrice");
            if (!/^\$/.test(result.discount.lowPrice)) throw new Error(this.lineMsg() + "lowPrice " + fullPriceGuess + "doesn't start with dollar");
            if (!result.discount.fullPrice) throw new Error(this.lineMsg() + "JSON discount doesn't include fullPrice");
            if (!/^\$/.test(result.discount.fullPrice)) throw new Error(this.lineMsg() + "fullPrice " + fullPriceGuess + "doesn't start with dollar");
        }
        result.title || (result.title = "It");
    } else {
        var parsed = /^(\w+)\s+(\S+)\s+(.*)/.exec(data);
        if (!parsed) throw new Error(this.lineMsg() + "invalid line; can't parse purchaseable product: " + data);
        result = {
            product: parsed[1],
            priceGuess: parsed[2],
            goto: parsed[3],
            title: "It"
        };
    }
    data = result.product;
    if (!this.nav.products[data] && "adfree" != data) throw new Error(this.lineMsg() + "The product " + data + " wasn't declared in a *product command");
    if (void 0 === this.temps["choice_purchased_" + data]) throw new Error(this.lineMsg() + "Didn't check_purchases on this page");
    return result;
}, Scene.prototype.purchase = function(data) {
    data = this.parsePurchase(data);
    data.discount ? this.buyButtonDiscount(data.product, data.discount.end, data.discount.fullPrice, data.discount.lowPrice, data.goto, data.title) : this.buyButton(data.product, data.priceGuess, data.goto, data.title);
}, Scene.prototype.buyButton = function(product, priceGuess, label, title) {
    this.finished = !0, this.skipFooter = !0;
    function purchaseFinished() {
        label && self.goto(label), self.finished = !1, self.skipFooter = !1, self.resetPage();
    }
    var self = this;
    getPrice(product, function(price) {
        var buttonText;
        price && "free" != price ? ("guess" == price && (price = priceGuess + " USD"), 
        buttonText = self.getVar("choice_prerelease") ? "Pre-Order " + title : "Buy " + title + " Now", 
        "hide" != price && (buttonText += " for " + price), price = (price = self.target) || document.getElementById("text"), 
        self.paragraph(), printButton(buttonText, price, !1, function() {
            safeCall(self, function() {
                purchase(product, function() {
                    safeCall(self, purchaseFinished);
                });
            });
        }), self.prevLine = "block", isRestorePurchasesSupported() && (self.prevLine = "text", 
        printLink(printParagraph("If you've already purchased, click here to "), "#", "restore purchases", function(e) {
            preventDefault(e), safeCall(self, function() {
                restorePurchases(product, function(purchased) {
                    purchased ? purchaseFinished() : clearScreen(function() {
                        loadAndRestoreGame("", window.forcedScene);
                    });
                });
            });
        })), label && (self.skipFooter = !1, self.finished = !1, self.execute())) : purchaseFinished();
    });
}, Scene.prototype.purchase_discount = function(line) {
    this.paragraph();
    var args = trim(String(line)).split(" ");
    if (5 != args.length) throw new Error(this.lineMsg() + "expected five arguments, saw " + args.length + ": " + line);
    var product = args[0], expectedEndDate = parseDateStringInCurrentTimezone(args[1], this.lineNum + 1), fullPriceGuess = this.replaceVariables(args[2]), discountedPriceGuess = this.replaceVariables(args[3]), args = args[4], startsWithDollar = /^\$/;
    if (!startsWithDollar.test(fullPriceGuess)) throw new Error(this.lineMsg() + "full price guess " + fullPriceGuess + "doesn't start with dollar: " + line);
    if (!startsWithDollar.test(discountedPriceGuess)) throw new Error(this.lineMsg() + "discounted price guess " + discountedPriceGuess + "doesn't start with dollar: " + line);
    this.buyButtonDiscount(product, expectedEndDate, fullPriceGuess, discountedPriceGuess, args, "It");
}, Scene.prototype.buyButtonDiscount = function(product, expectedEndDate, fullPriceGuess, discountedPriceGuess, label, title) {
    var discountText = this.getVar("choice_prerelease") ? "[b]Buy now before the price increases![/b]" : "[b]On sale until " + shortMonthStrings[expectedEndDate.getMonth() + 1] + " " + expectedEndDate.getDate() + "! Buy now before the price increases![/b]";
    "undefined" != typeof printDiscount && printDiscount(product, expectedEndDate.getYear() + 1900, expectedEndDate.getMonth() + 1, expectedEndDate.getDate(), discountText), 
    discountText = new Date().getTime() < expectedEndDate.getTime() ? discountedPriceGuess : fullPriceGuess, 
    this.buyButton(product, discountText, label, title);
}, Scene.prototype.print_discount = function(line) {
    var result = /(\w+) (\d{4})-(\d{2})-(\d{2}) (.*$)/.exec(line);
    if (!result) throw new Error("invalid discount: " + line);
    var line = result[1], fullYear = result[2], oneBasedMonthNumber = parseInt(result[3], 10), dayOfMonth = parseInt(result[4], 10), result = result[5];
    this.temps.choice_discount_ends = "POISONTOKEN", result = this.replaceVariables(result).replace("POISONTOKEN", "${choice_discount_ends}"), 
    delete this.temps.choice_discount_ends, "undefined" != typeof printDiscount && printDiscount(line, fullYear, oneBasedMonthNumber, dayOfMonth, result);
}, Scene.prototype.abort = function() {
    this.paragraph(), this.finished = !0;
}, Scene.prototype.create = function(line) {
    var result = /^(\w*)(.*)/.exec(line);
    if (!result) throw new Error(this.lineMsg() + "Invalid create instruction, no variable specified: " + line);
    var variable = result[1], result = (this.validateVariable(variable), variable = variable.toLowerCase(), 
    result[2]), result = this.tokenizeExpr(result);
    if (1 < result.length) throw new Error(this.lineMsg() + "Invalid create instruction, too many values: " + line);
    this.createVariable(variable, result[0], line);
}, Scene.prototype.createVariable = function(variable, token, line) {
    var self = this;
    if (!token) throw new Error(this.lineMsg() + "Invalid create instruction, no value specified: " + line);
    function complexError() {
        throw new Error(self.lineMsg() + "Invalid create instruction, value must be a number, true/false, or a quoted string: " + line);
    }
    if (/STRING|NUMBER|VAR/.test(token.name) || complexError(), "VAR" != token.name || /^true|false$/i.test(token.value) || complexError(), 
    "STRING" == token.name && /(\$|@)!?!?{/.test(token.value)) throw new Error(this.lineMsg() + "Invalid create instruction, value must be a simple string without ${} or @{}: " + line);
    token = this.evaluateExpr([ token ]);
    if (this.created || (this.created = {}), this.created[variable]) throw new Error(this.lineMsg() + "Invalid create. " + variable + " was previously created on line " + this.created[variable]);
    this.created[variable] = this.lineNum + 1, this.stats[variable] = token, this.nav && (this.nav.startingStats[variable] = token);
}, Scene.prototype.create_array = function(line) {
    this.defineArray("create", line);
}, Scene.prototype.temp = function(line) {
    var result = /^(\w*)(.*)/.exec(line);
    if (!result) throw new Error(this.lineMsg() + "Invalid temp instruction, no variable specified: " + line);
    var line = result[1], result = (this.validateVariable(line), result[2]), result = this.tokenizeExpr(result);
    0 === result.length ? this.temps[line.toLowerCase()] = null : (result = this.evaluateExpr(result), 
    void 0 !== this.stats[line.toLowerCase()] && this.warning("This is a temp, but we already ran *create " + line), 
    this.temps[line.toLowerCase()] = result);
}, Scene.prototype.temp_array = function(line) {
    this.defineArray("temp", line);
}, Scene.prototype.defineArray = function(command, line) {
    var result = /^(\w+)(.*)/.exec(line);
    if (!result) throw new Error(this.lineMsg() + "Invalid " + command + "_array instruction, no array name specified: " + line);
    var variable = result[1], stack = (this.validateVariable(variable), variable = variable.toLowerCase(), 
    this.tokenizeExpr(result[2].trim()));
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid " + command + "_array instruction, missing length: " + line);
    var token, length = Number(stack.shift().value);
    if (length !== Math.floor(length) || length < 1) throw new Error(this.lineMsg() + "Invalid " + command + "_array instruction, length should be a whole number greater than 0: " + line);
    var i, value = null, self = this;
    function create(suffix) {
        "create" === command ? self.createVariable(variable + "_" + suffix, token, line) : self.temps[variable + "_" + suffix] = value;
    }
    function next() {
        if (!(token = stack[0])) throw new Error(self.lineMsg() + "Too few values. Expected 1 default value or " + length + " explicit values, not " + i + ": " + line);
        value = self.evaluateValueToken(stack.shift(), stack);
    }
    if (stack.length && next(), stack.length) for (create(1), i = 1; i < length; i++) next(), 
    create(i + 1); else for (i = 0; i < length; i++) create(i + 1);
    if (stack.length) throw new Error(this.lineMsg() + "Too many values. Expected 1 default value or " + length + " explicit values: " + line);
    token = {
        name: "NUMBER",
        value: length
    }, value = length, create("count");
}, Scene.prototype.getVar = function(variable) {
    var value;
    if ((variable = String(variable).toLowerCase()) && !isNaN(+variable) && String(+variable) === variable) return +variable;
    if ("true" == variable) return !0;
    if ("false" == variable) return !1;
    if ("choice_subscribe_allowed" == variable) return !0;
    if ("choice_register_allowed" == variable) return isRegisterAllowed();
    if ("choice_registered" == variable) return "undefined" != typeof window && !!window.registered;
    if ("choice_is_web" == variable) return "undefined" != typeof window && !!window.isWeb;
    if ("choice_is_steam" == variable) return "undefined" != typeof window && !!window.isSteamApp;
    if ("choice_is_ios_app" == variable) return "undefined" != typeof window && !!window.isIosApp;
    if ("choice_is_ipad_app" == variable) return "undefined" != typeof window && !!window.isIosApp && !!window.isIPad;
    if ("choice_is_android_app" == variable) return "undefined" != typeof window && !!window.isAndroidApp;
    if ("choice_is_omnibus_app" == variable) return "undefined" != typeof window && !!window.isOmnibusApp;
    if ("choice_is_amazon_app" == variable) return "undefined" != typeof window && !!window.isAmazonApp;
    if ("choice_is_advertising_supported" == variable) return "undefined" != typeof isAdvertisingSupported && !!isAdvertisingSupported();
    if ("choice_is_trial" == variable) return !("undefined" == typeof isTrial || !isTrial);
    if ("choice_release_date" == variable) return "undefined" != typeof window && window.releaseDate ? simpleDateFormat(window.releaseDate) : "release day";
    if ("choice_prerelease" == variable) return "undefined" != typeof isPrerelease && !!isPrerelease();
    if ("choice_kindle" == variable) return "undefined" != typeof isKindle && !!isKindle;
    if ("choice_randomtest" == variable) return !!this.randomtest;
    if ("choice_quicktest" == variable) return !1;
    if ("choice_linenum" == variable) return this.lineNum;
    if ("choice_scene" == variable) return this.name;
    if ("choice_restore_purchases_allowed" == variable) return isRestorePurchasesSupported();
    if ("choice_save_allowed" == variable) return areSaveSlotsSupported();
    if ("choice_time_stamp" == variable) return Math.floor(new Date() / 1e3);
    if ("choice_nightmode" == variable) return "undefined" != typeof isNightMode && isNightMode();
    if ("choice_title" == variable && void 0 === this.stats.choice_title) throw new Error(this.lineMsg() + "This game is missing a *title command");
    if (this.temps.hasOwnProperty(variable)) {
        if (null == (value = this.temps[variable])) throw new Error(this.lineMsg() + "Variable '" + variable + "' exists but has no value");
        this.debugMode && println("temps[" + variable + "]==" + value);
    } else {
        if (!this.stats.hasOwnProperty(variable)) {
            if ("implicit_control_flow" == variable) return !1;
            throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
        }
        if (null == (value = this.stats[variable])) throw new Error(this.lineMsg() + "Variable '" + variable + "' exists but has no value");
        this.debugMode && println("stats[" + variable + "]==" + value);
    }
    return value;
}, Scene.prototype.setVar = function(variable, value) {
    if (variable = variable.toLowerCase(), this.debugMode && println(variable + "=" + value), 
    void 0 === this.temps[variable]) {
        if (void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
        this.stats[variable] = value, "temp" == this.saveSlot && (tempStatWrites[variable] = value), 
        "implicit_control_flow" == variable && this.nav && (this.nav.startingStats.implicit_control_flow = value);
    } else this.temps[variable] = value;
}, Scene.prototype.delete = function(variable) {
    if (variable = variable.toLowerCase(), void 0 === this.temps[variable]) {
        if (void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
        delete this.stats[variable];
    } else delete this.temps[variable];
}, Scene.prototype.delete_array = function(arrayName) {
    if (arrayName = arrayName.toLowerCase(), void 0 === this.temps[arrayName + "_count"]) {
        if (void 0 === this.stats[arrayName + "_count"]) throw new Error(this.lineMsg() + "Non-existent array '" + arrayName + "'");
        var length = this.stats[arrayName + "_count"];
        delete this.stats[arrayName + "_count"];
        for (var i = 1; i <= length; i++) delete this.stats[arrayName + "_" + i];
    } else {
        length = this.temps[arrayName + "_count"];
        delete this.temps[arrayName + "_count"];
        for (i = 1; i <= length; i++) delete this.temps[arrayName + "_" + i];
    }
}, Scene.prototype.parseOptions = function(startIndent, choicesRemaining, expectedSubOptions) {
    var previousSubOptions, prevOption, ifResult, nextIndent = null, options = [], choiceEnds = [], currentChoice = (currentChoice = choicesRemaining[0]) || "choice", suboptionsEncountered = !1, bodyExpected = !1, namesEncountered = {}, atLeastOneSelectableOption = !1, self = (this.lineNum, 
    this);
    function removeModifierCommand(stripParethentical) {
        if (stripParethentical) {
            stripParethentical = line.indexOf("(") + 1, stripParethentical = matchBracket(line, "()", stripParethentical);
            if (-1 == stripParethentical) throw new Error(self.lineMsg() + "missing closing parenthesis");
            line = trim(line.substr(stripParethentical + 1));
        } else line = trim(line.replace(/^\s*\*(\w+)(.*)/, "$2"));
        (parsed = /^\s*\*(\w+)(.*)/.exec(line)) ? (command = parsed[1].toLowerCase(), 
        data = trim(parsed[2])) : command = "";
    }
    for (;isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null == nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one '" + currentChoice + "'");
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) break;
        if (indent < this.indent && (this.dedent(indent), this.indent = indent), 
        indent > this.indent) {
            if (1 < choicesRemaining.length) throw new Error(this.lineMsg() + "invalid indent, there were subchoices remaining: [" + choicesRemaining.join(",") + "]");
            this.rollbackLineCoverage(), bodyExpected = !1;
        } else {
            !options.length || (prevOption = options[options.length - 1]).endLine || (prevOption.endLine = this.lineNum);
            var parsed = /^\s*\*(\w+)(.*)/.exec(line), indent = !1, inlineIf = null, selectableIf = null, self = this, reuse = this.temps.choice_reuse;
            if (parsed) {
                var command = parsed[1].toLowerCase(), data = trim(parsed[2]);
                if ("hide_reuse" == command && (reuse = "hide", removeModifierCommand()), 
                "disable_reuse" == command && (reuse = "disable", removeModifierCommand()), 
                "allow_reuse" == command && (reuse = "allow", removeModifierCommand()), 
                "random_weight" == command && removeModifierCommand(!0), "print" == command) line = this.evaluateExpr(this.tokenizeExpr(data)); else if ("if" == command) {
                    if (choiceEnds.push(this.lineNum), !(ifResult = this.parseOptionIf(data, command))) {
                        this.if(data, !0);
                        continue;
                    }
                    if (inlineIf = ifResult.condition, !ifResult.result) continue;
                    line = ifResult.line;
                } else {
                    if ("else" == command) {
                        if (data) throw new Error(this.lineMsg() + "Invalid content after *" + command + "; move the #option to the next line, indented: " + data);
                        this[command](data, !0);
                        continue;
                    }
                    if (/^(elseif|elsif)$/.test(command)) {
                        if (ifResult = this.parseOptionIf(data, command)) throw new Error(this.lineMsg() + "Invalid content after *" + command + "; move the #option to the next line, indented: " + ifResult.line);
                        this[command](data, !0);
                        continue;
                    }
                    if ("selectable_if" == command) {
                        if (!(ifResult = this.parseOptionIf(data, command))) throw new Error(this.lineMsg() + "Couldn't parse the line after *selectable_if: " + data);
                        line = ifResult.line, selectableIf = ifResult.condition, 
                        indent = indent || !ifResult.result;
                    } else {
                        if ("comment" == command) continue;
                        if (command) throw Scene.validCommands[command] ? new Error(this.lineMsg() + "Invalid indent? Expected an #option here, not *" + command) : new Error(this.lineMsg() + "Non-existent command '" + command + "'");
                    }
                }
            }
            if ("allow" != reuse && (this.temps.choice_used || (this.temps.choice_used = {}), 
            this.temps.choice_used[this.lineNum])) {
                if ("hide" == reuse) continue;
                indent = !0;
            }
            if (!/^\s*\#\s*\S/.test(line)) throw new Error(this.lineMsg() + "Expected option starting with #");
            this.replaceVariables(line);
            var line, option = {
                name: line = trim(trim(line).substring(1)),
                group: currentChoice
            };
            if ("allow" != reuse && (option.reuse = reuse), this.displayOptionConditions) {
                option.displayIf = [];
                for (var i = 0; i < this.displayOptionConditions.length; i++) option.displayIf[i] = this.displayOptionConditions[i];
                inlineIf && option.displayIf.push(inlineIf);
            } else inlineIf && (option.displayIf = [ inlineIf ]);
            selectableIf && (option.selectableIf = selectableIf), option.line = this.lineNum + 1, 
            indent && (option.unselectable = !0), namesEncountered[line] ? this.conflictingOptions(this.lineMsg() + "Invalid option; conflicts with option '" + option.name + "' on line " + namesEncountered[line]) : namesEncountered[line] = option.line, 
            options.push(option), 1 < choicesRemaining.length ? (option.suboptions = this.parseOptions(this.indent, choicesRemaining.slice(1), previousSubOptions), 
            this.indent = nextIndent, previousSubOptions = previousSubOptions || option.suboptions, 
            suboptionsEncountered = !0) : bodyExpected = !0, indent || (atLeastOneSelectableOption = !0);
        }
    } else this.rollbackLineCoverage();
    if (1 < choicesRemaining.length && !suboptionsEncountered) throw new Error(this.lineMsg() + "invalid indent, there were subchoices remaining: [" + choicesRemaining.join(",") + "]");
    if (bodyExpected && (void 0 === this.temps._fakeChoiceDepth || this.temps._fakeChoiceDepth < 1)) throw new Error(this.lineMsg() + "Expected choice body");
    for (atLeastOneSelectableOption || this.conflictingOptions(this.lineMsg() + "No selectable options"), 
    expectedSubOptions && this.verifyOptionsMatch(expectedSubOptions, options), 
    this.rollbackLineCoverage(), prevOption = options[options.length - 1], this.lineNum = this.previousNonBlankLineNum(), 
    prevOption.endLine || (prevOption.endLine = this.lineNum + 1), i = 0; i < choiceEnds.length; i++) this.temps._choiceEnds[choiceEnds[i]] = this.lineNum;
    return this.rollbackLineCoverage(), options;
}, Scene.prototype.parseOptionIf = function(data) {
    var condition, stack, data = /^\s*\((.*)\)\s+(#.*)/.exec(data);
    if (data) return condition = data[1], stack = this.tokenizeExpr(condition), 
    stack = this.evaluateExpr(stack), this.debugMode && println(condition + " :: " + stack), 
    {
        result: stack = (stack = bool(stack, this.lineNum + 1)) || this.testPath,
        line: data[2],
        condition: null
    };
}, Scene.prototype.conflictingOptions = function(str) {
    throw new Error(str);
}, Scene.prototype.verifyOptionsMatch = function(prev, current) {
    function findMatch(name, options) {
        for (var i = 0; i < options.length; i++) {
            var option = options[i];
            if (option && name == option.name) return option;
        }
        return null;
    }
    for (var prevOpt, curOpt, i = 0; i < prev.length; i++) if (!(curOpt = findMatch((prevOpt = prev[i]).name, current))) throw new Error(this.lineMsg() + "Missing expected suboption '" + prevOpt.name + "'; all suboptions must have same option list");
    if (prev.length != current.length) {
        for (i = 0; i < current.length; i++) if (!(prevOpt = findMatch((curOpt = current[i]).name, prev))) throw new Error(this.lineMsg() + "Added unexpected suboption '" + curOpt.name + "'; all suboptions must have same option list");
        throw new Error(this.lineMsg() + "Bug? previous options and current options mismatch, but no particular missing element");
    }
}, Scene.prototype.renderOptions = function(groups, options, callback) {
    var self = this;
    !function replaceVars(options) {
        for (var i = 0; i < options.length; i++) {
            var option = options[i];
            option.name = self.replaceVariables(option.name), option.suboptions && replaceVars(option.suboptions);
        }
    }(options), this.paragraph(), printOptions(groups, options, callback), this.debugMode && println(computeCookie(this.stats, this.temps, this.lineNum, this.indent)), 
    this.finished && printFooter();
}, Scene.prototype.page_break = function(buttonName) {
    var self;
    this.screenEmpty || (buttonName = this.replaceVariables(buttonName = buttonName || "Next"), 
    this.paragraph(), this.finished = !0, self = this, printButton(buttonName, main, !1, function() {
        delayBreakEnd(), self.finished = !1, self.resetPage();
    }), this.debugMode && println(computeCookie(this.stats, this.temps, this.lineNum, this.indent)));
}, Scene.prototype.page_break_advertisement = function(line) {
    if (line) throw new Error(this.lineMsg() + "*page_break_advertisement doesn't allow you to change the button message. This text will never be shown: " + line);
    var self = this;
    this.finished = !0, showFullScreenAdvertisementButton("Watch an Ad to Continue", function() {
        self.page_break("");
    }, function() {
        delayBreakEnd(), self.finished = !1, self.skipFooter = !1, self.resetPage();
    });
}, Scene.prototype.finish_advertisement = function(line) {
    if (line) throw new Error(this.lineMsg() + "*finish_advertisement doesn't allow you to change the button message. This text will never be shown: " + line);
    var self = this;
    this.finished = !0, showFullScreenAdvertisementButton("Watch an Ad for the Next Chapter", function() {
        self.finish("");
    }, function() {
        new Scene(self.nav && nav.nextSceneName(self.name), self.stats, self.nav, {
            debugMode: self.debugMode,
            secondaryMode: self.secondaryMode
        }).resetPage();
    });
}, Scene.prototype.line_break = function() {
    this.accumulatedParagraph.length ? this.accumulatedParagraph.push("[n/]") : println();
}, Scene.prototype.image = function(data, invert) {
    this.paragraph();
    var dataImageVal, source, alignment, dataImage = !1, dataImageEnd = ((data = data || "").match(/data:image/) && (data = 0 <= (dataImageEnd = data.indexOf(" ")) ? (dataImageVal = data.substring(0, dataImageEnd), 
    "CSIDE_DATA_IMG.png" + data.slice(dataImageEnd)) : (dataImageVal = data, "CSIDE_DATA_IMG.png"), 
    dataImage = !0), data = this.replaceVariables(data), /(\S+) (\S+)(.*)/.exec(data)), alt = null;
    if (dataImageEnd ? (source = dataImageEnd[1], alignment = dataImageEnd[2], alt = trim(dataImageEnd[3])) : source = data, 
    "" === source) throw new Error(this.lineMsg() + "*image requires the file name of an image");
    if ("CSIDE_DATA_IMG.png" === source && (source = dataImageVal), !/(right|left|center|none)/.test(alignment = alignment || "center")) throw new Error(this.lineMsg() + "Invalid alignment, expected right, left, center, or none: " + data);
    printImage(source, alignment, alt, invert), this.verifyImage && !dataImage && this.verifyImage(source), 
    "none" == alignment && (this.prevLine = "text"), this.screenEmpty = !1;
}, Scene.prototype.text_image = function(data) {
    this.image(data, "invert");
}, Scene.prototype.sound = function(source) {
    "function" == typeof playSound && playSound(source), this.verifyImage && this.verifyImage(source);
}, Scene.prototype.kindle_image = function() {}, Scene.prototype.youtube = function(slug) {
    "undefined" != typeof printYoutubeFrame && (printYoutubeFrame(slug), this.prevLine = "block", 
    this.screenEmpty = !1);
}, Scene.prototype.kindle_search = Scene.prototype.kindle_product = function(data) {
    var result = /^\((.+)\) ([^\)]+)/.exec(data);
    if (!result) throw new Error(this.lineMsg() + "Invalid arguments: " + data);
    data = result[1], result = result[2];
    "undefined" != typeof kindleButton && kindleButton(this.target, data, result);
}, Scene.prototype.link = function(data) {
    var result = /^(\S+)\s*(.*)/.exec(data);
    if (!result) throw new Error(this.lineMsg() + "invalid line; this line should have an URL: " + data);
    data = result[1].replace(/\]/g, "%5D"), result = trim(result[2]) || data;
    this.printLine("[url=" + data + "]" + result + "[/url]"), this.prevLine = "text", 
    this.screenEmpty = !1;
}, Scene.prototype.link_button = function(data) {
    if ("undefined" != typeof window) {
        var result = /^(\S+)\s*(.*)/.exec(data);
        if (!result) throw new Error(this.lineMsg() + "invalid line; this line should have an URL: " + data);
        var href = result[1], data = trim(result[2]) || href;
        this.paragraph();
        result = (result = this.target) || document.getElementById("text");
        printButton(data, result, !1, function() {
            window.location.href = href;
        }), this.prevLine = "empty", this.screenEmpty = !1;
    }
}, Scene.prototype.getIndent = function(line) {
    if (null == line) return 0;
    line = line.match(/^([ \t]*)/);
    if (null == line) return 0;
    var line = line[0], len = line.length;
    if (0 === len) return 0;
    var tab = /\t/.test(line), line = / /.test(line);
    if (tab && line) throw new Error(this.lineMsg() + "Tabs and spaces appear on the same line");
    if (tab) {
        if (this.firstTab = this.lineNum + 1, this.firstSpace) throw new Error(this.lineMsg() + "Illegal mixing of spaces and tabs; this line has a tab, but there were spaces on line " + this.firstSpace);
    } else if (this.firstSpace = this.lineNum + 1, this.firstTab) throw new Error(this.lineMsg() + "Illegal mixing of spaces and tabs; this line has a space, but there were tabs on line " + this.firstTab);
    return len;
}, Scene.prototype.comment = function(line) {
    this.debugMode && println("*comment " + line);
}, Scene.prototype.advertisement = function(durationInSeconds) {
    if (/^\s*\*delay_break/.test(this.lines[this.lineNum - 1])) throw new Error(this.lineMsg() + "*advertisement is not allowed immediately after *delay_break (*delay_break includes its own advertisement)");
    var self;
    this.getVar("choice_prerelease") || this.getVar("choice_is_steam") || ((self = this).finished = !0, 
    this.skipFooter = !0, startLoading(), checkPurchase("adfree", function(ok, result) {
        doneLoading(), result.adfree ? (self.finished = !1, self.skipFooter = !1, 
        self.execute()) : (self.printLine("Come back later to play the next part of [i]${choice_title}[/i]!"), 
        self.paragraph(), self.printLine("Or you can buy the game now to skip the wait."), 
        self.paragraph(), self.buyButton("adfree", "$1.99", null, "It"), self.delay_break(durationInSeconds || 300));
    }));
}, Scene.prototype.looplimit_count = 1e3, Scene.prototype.looplimit = function(count) {
    this.looplimit_count = num(count, this.lineNum, this.name);
}, Scene.prototype.hide_reuse = function() {
    this.temps.choice_reuse = "hide";
}, Scene.prototype.disable_reuse = function() {
    this.temps.choice_reuse = "disable";
}, Scene.prototype.allow_reuse = function() {
    this.temps.choice_reuse = "allow";
}, Scene.prototype.label = function() {}, Scene.prototype.print = function(expr) {
    expr = this.evaluateExpr(this.tokenizeExpr(expr));
    this.prevLine = "text", this.screenEmpty = !1, this.printLine(expr);
}, Scene.prototype.parseInputText = function(line) {
    var stack = this.tokenizeExpr(line), line = this.evaluateReference(stack);
    if (void 0 === this.temps[line] && void 0 === this.stats[line]) throw new Error(this.lineMsg() + "Non-existent variable '" + line + "'");
    for (var inputOptions = {
        long: !1,
        allow_blank: !1
    }, i = 0; i < stack.length; i++) {
        var token = stack[i];
        if ("VAR" !== token.name) throw new Error(this.lineMsg() + "Couldn't understand this input_text line");
        token = token.value;
        if (void 0 === inputOptions[token]) throw new Error(this.lineMsg() + "Couldn't understand this input_text option: " + token);
        inputOptions[token] = !0;
    }
    return {
        variable: line,
        inputOptions: inputOptions
    };
}, Scene.prototype.input_text = function(line) {
    var line = this.parseInputText(line), variable = line.variable, self = (this.finished = !0, 
    this.paragraph(), this);
    printInput(this.target, line.inputOptions, function(value) {
        safeCall(self, function() {
            value = (value = trim(String(value))).replace(/\n/g, "[n/]"), self.nav && self.nav.bugLog.push("*input_text " + variable + " " + value), 
            self.finished = !1, self.setVar(variable, value), self.resetPage();
        });
    }), this.debugMode && println(computeCookie(this.stats, this.temps, this.lineNum, this.indent));
}, Scene.prototype.input_number = function(data) {
    data = this.tokenizeExpr(data);
    if (!data.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    var simpleConstants, variable = this.evaluateReference(data);
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    if (simpleConstants = 2 == data.length && "NUMBER" == data[0].name && "NUMBER" == data[1].name, 
    !data.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    var minimum = this.evaluateValueToken(data.shift(), data);
    if (isNaN(+minimum)) throw new Error(this.lineMsg() + "Invalid minimum, not numeric: " + minimum);
    if (!data.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    var intRequired, maximum = this.evaluateValueToken(data.shift(), data);
    if (data.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    if (isNaN(+maximum)) throw new Error(this.lineMsg() + "Invalid maximum, not numeric: " + maximum);
    if ((!this.quicktest || simpleConstants) && parseFloat(minimum) > parseFloat(maximum)) throw new Error(this.lineMsg() + "Minimum " + minimum + " should not be greater than maximum " + maximum);
    function isInt(x) {
        var y = parseInt(x, 10);
        return !isNaN(y) && (x == y && x.toString() == y.toString());
    }
    isInt(minimum) && isInt(maximum) && (intRequired = 1), this.finished = !0, this.paragraph();
    var self = this;
    printInput(this.target, {
        numeric: !0
    }, function(value) {
        safeCall(self, function() {
            var numValue = parseFloat("" + value);
            isNaN(numValue) ? asyncAlert("Please type in a number.") : intRequired && !isInt(value) ? asyncAlert("Please type in an integer number.") : numValue < +minimum ? asyncAlert("Please use a number greater than or equal to " + minimum) : +maximum < numValue && !this.quicktest ? asyncAlert("Please use a number less than or equal to " + maximum) : (self.nav && self.nav.bugLog.push("*input_number " + variable + " " + value), 
            self.finished = !1, self.setVar(variable, numValue), self.resetPage());
        });
    }, minimum, maximum, intRequired), this.debugMode && println(computeCookie(this.stats, this.temps, this.lineNum, this.indent));
}, Scene.prototype.script = function script(code) {
    var stats = this.stats, temps = this.temps;
    try {
        "undefined" == typeof window ? function() {
            var window = _global;
            eval(code);
        }.call(this) : eval(code);
    } catch (e) {
        throw new Error(this.lineMsg() + "error executing *script: " + e + (e.stack ? "\n" + e.stack : ""));
    }
}, Scene.prototype.validateVariable = function(variable) {
    if (!variable || !/^[a-zA-Z]/.test(variable)) throw new Error(this.lineMsg() + "Invalid variable name, must start with a letter: " + variable);
    if (!/^\w+$/.test(variable)) throw new Error(this.lineMsg() + "Invalid variable name: '" + variable + "'");
    if (/^(and|or|true|false|scene|scenename)$/i.test(variable)) throw new Error(this.lineMsg() + "Invalid variable name, '" + variable + "' is a reserved word");
    if (/^choice_/.test(variable)) throw new Error(this.lineMsg() + "Invalid variable name, variables may not start with 'choice_'; this is a reserved prefix");
}, Scene.prototype.rand = function(data) {
    data = this.tokenizeExpr(data);
    if (!data.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var variable = this.evaluateReference(data);
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    if (!data.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var minimum = this.evaluateValueToken(data.shift(), data);
    if (!data.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var random, maximum = this.evaluateValueToken(data.shift(), data);
    if (data.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    if (data = maximum - minimum, isNaN(data)) throw new Error(this.lineMsg() + "Invalid rand statement, min and max must be numbers");
    if (data < 0) throw new Error(this.lineMsg() + "Invalid rand statement, min must be less than max: " + minimum + " > " + maximum);
    function isInt(x) {
        var y = parseInt(x, 10);
        return !isNaN(y) && (x == y && x.toString() == y.toString());
    }
    0 == data ? this.setVar(variable, minimum) : (random = Math.random(), maximum = isInt(minimum) && isInt(maximum) ? +minimum + Math.floor(random * (1 + data)) : +minimum + random * data, 
    this.setVar(variable, maximum), this.randomLog && this.randomLog("*rand " + variable + " " + maximum), 
    this.nav && this.nav.bugLog.push("*rand " + variable + " " + maximum));
}, Scene.prototype.set = function(line) {
    var stack = this.tokenizeExpr(line), variable = this.evaluateReference(stack);
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    if (0 === stack.length) throw new Error(this.lineMsg() + "Invalid set instruction, no expression specified: " + line);
    /OPERATOR|FAIRMATH/.test(stack[0].name) && stack.unshift({
        name: "VAR",
        value: variable,
        pos: "(implicit)"
    });
    line = this.evaluateExpr(stack);
    this.setVar(variable, line);
}, Scene.prototype.setref = function(line) {
    var line = this.tokenizeExpr(line), variable = this.evaluateValueToken(line.shift(), line), variable = String(variable).toLowerCase();
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    /OPERATOR|FAIRMATH/.test(line[0].name) && line.unshift({
        name: "VAR",
        value: variable,
        pos: "(implicit)"
    });
    line = this.evaluateExpr(line);
    this.setVar(variable, line);
}, Scene.prototype.share_this_game = function(now) {
    now = !!trim(now), this.paragraph(), printShareLinks(this.target, now), this.prevLine = "empty";
}, Scene.prototype.more_games = function(now) {
    var self;
    "undefined" != typeof window && "undefined" != typeof moreGames && (trim(now) ? moreGames() : ((self = this).paragraph(), 
    now = (now = this.target) || document.getElementById("text"), now = printButton("Play More Games Like This", now, !1, function() {
        safeCall(self, moreGames);
    }), setClass(now, ""), this.prevLine = "block"));
}, Scene.prototype.ending = function() {
    var self;
    "undefined" != typeof window && (this.paragraph(), (options = []).push({
        name: "Play again.",
        group: "choice",
        restart: !0
    }), window.isOmnibusApp || options.push({
        name: "Play more games like this.",
        group: "choice",
        moreGames: !0
    }), options.push({
        name: "Share this game with friends.",
        group: "choice",
        share: !0
    }), options.push({
        name: "Email me when new games are available.",
        group: "choice",
        subscribe: !0
    }), self = this, function endingMenu() {
        printFollowButtons(), self.renderOptions([ "" ], options, function(option) {
            if (option.restart) return restartGame();
            option.moreGames ? (self.more_games("now"), "undefined" != typeof curl && curl()) : option.share ? clearScreen(function() {
                self.share_this_game("now"), endingMenu();
            }) : option.subscribe && subscribeLink();
        });
    }(), this.finished = !0);
}, Scene.prototype.restart = function() {
    if (delayBreakEnd(), this.secondaryMode) {
        if ("stats" != this.secondaryMode) throw new Error(this.lineMsg() + "Cannot *restart in " + this.secondaryMode + " mode");
        this.reset(), this.redirect_scene(this.nav.getStartupScene());
    } else restartGame();
    this.finished = !0;
}, Scene.prototype.subscribe = function(data) {
    this.paragraph();
    var options = {};
    if (data) try {
        options = JSON.parse(data);
    } catch (e) {
        throw new Error(this.lineMsg() + "Couldn't parse subscribe arguments: " + data);
    }
    this.prevLine = "block", this.finished = !0, this.skipFooter = !0;
    var self = this;
    subscribe(this.target, options, function(now) {
        self.finished = !1, now ? (self.skipFooter = !1, self.execute()) : self.resetPage();
    });
}, Scene.prototype.restore_game = function(data) {
    var cancelLabel;
    if (data) {
        var result = /^cancel=(\S+)$/.exec(data);
        if (!result) throw new Error(this.lineMsg() + "invalid restore_game line: " + data);
        cancelLabel = result[1];
    }
    this.finished = !0, this.skipFooter = !0;
    var self = this, unrestorableScenes = this.parseRestoreGame(!1);
    getDirtySaveList(function(dirtySaveList) {
        getSaves(function(saveList) {
            !function renderRestoreMenu(saveList, dirtySaveList) {
                self.paragraph();
                for (var options = [], i = 0; i < saveList.length; i++) {
                    var name, save = saveList[i], date = new Date(+save.timestamp);
                    save && (name = "", save.temps && save.temps.choice_restore_name && (name = save.temps.choice_restore_name), 
                    options.push({
                        name: name + " (" + simpleDateTimeFormat(date) + ")",
                        group: "choice",
                        state: save
                    }));
                }
                options.push({
                    name: "Retrieve saved games online from choiceofgames.com.",
                    group: "choice",
                    fetch: !0
                }), dirtySaveList.length && options.push({
                    name: "Upload saved games to choiceofgames.com.",
                    group: "choice",
                    upload: !0
                }), options.push({
                    name: "Cancel.",
                    group: "choice",
                    cancel: !0
                });
                self.renderOptions([ "" ], options, function(option) {
                    var state, sceneName;
                    option.upload ? clearScreen(function() {
                        fetchEmail(function(defaultEmail) {
                            self.printLine("Please type your email address to identify yourself."), 
                            self.paragraph(), promptEmailAddress(this.target, defaultEmail, "allowContinue", function(cancel, email) {
                                cancel ? (self.finished = !1, void 0 !== cancelLabel && self.goto(cancelLabel), 
                                self.resetPage()) : clearScreen(function() {
                                    startLoading(), submitDirtySaves(dirtySaveList, email, function(ok) {
                                        doneLoading(), self.prevLine = "text", ok ? (ok = dirtySaveList.length + (1 == dirtySaveList.length ? " save" : " saves"), 
                                        self.printLine("Uploaded " + ok + "."), 
                                        renderRestoreMenu(saveList, [])) : (self.printLine("Error uploading saves. Please try again later."), 
                                        renderRestoreMenu(saveList, dirtySaveList));
                                    });
                                });
                            });
                        });
                    }) : option.fetch ? clearScreen(function() {
                        fetchEmail(function(defaultEmail) {
                            self.printLine("Please type your email address to identify yourself."), 
                            self.paragraph(), promptEmailAddress(this.target, defaultEmail, "allowContinue", function(cancel, email) {
                                cancel ? (self.finished = !1, void 0 !== cancelLabel && self.goto(cancelLabel), 
                                self.resetPage()) : clearScreen(function() {
                                    startLoading(), getRemoteSaves(email, function(remoteSaveList) {
                                        doneLoading(), self.prevLine = "text", remoteSaveList ? mergeRemoteSaves(remoteSaveList, "recordDirty", function(saveList, newRemoteSaves, dirtySaveList) {
                                            var downloadCount;
                                            remoteSaveList.length ? (downloadCount = remoteSaveList.length + " saved " + (1 == remoteSaveList.length ? "game" : "games"), 
                                            self.printLine("Synchronized " + downloadCount + ". Downloaded " + newRemoteSaves + " new saved " + (1 == newRemoteSaves ? "game" : "games") + ".")) : self.printLine('No saves downloaded for email address "' + email + "\". (Is that the correct email address?) If you're having trouble, please contact support at " + getSupportEmail() + "."), 
                                            renderRestoreMenu(saveList, dirtySaveList);
                                        }) : (self.printLine("Error downloading saves. Please try again later."), 
                                        renderRestoreMenu(saveList, dirtySaveList));
                                    });
                                });
                            });
                        });
                    }) : option.password ? clearScreen(function() {
                        self.restore_password();
                    }) : option.cancel ? (self.finished = !1, void 0 !== cancelLabel && self.goto(cancelLabel), 
                    self.resetPage()) : (sceneName = null, (state = option.state).stats && state.stats.sceneName && (sceneName = ("" + state.stats.sceneName).toLowerCase()), 
                    (option = unrestorableScenes[sceneName]) ? (asyncAlert(option), 
                    self.finished = !1, self.resetPage()) : saveCookie(function() {
                        clearScreen(function() {
                            restoreGame(state, null, !0);
                        });
                    }, "", state.stats, state.temps, state.lineNum, state.indent, this.debugMode, this.nav));
                });
            }(saveList, dirtySaveList);
        });
    });
}, Scene.prototype.restore_password = function() {
    var alreadyFinished = this.finished, self = (this.finished = !0, this.paragraph(), 
    this.printLine('Please paste your password here, then press "Next" below to continue.'), 
    this.prevLine = "text", this.paragraph(), this), unrestorableScenes = this.parseRestoreGame(alreadyFinished);
    getPassword(this.target, function(cancel, password) {
        if (cancel) self.finished = !1, self.resetPage(); else {
            password = (password = password.replace(/\s/g, "")).replace(/^.*BEGINPASSWORD-----/, "");
            var state, cancel = self.deobfuscatePassword(password);
            cancel = (cancel = cancel.replace(/^[^\{]*/, "")).replace(/[^\}]*$/, "");
            try {
                state = jsonParse(cancel);
            } catch (e) {
                return void asyncAlert("Sorry, that password was invalid. Please contact " + getSupportEmail() + " for assistance. Be sure to include your password in the email.");
            }
            password = null, cancel = (state.stats && state.stats.sceneName && (password = ("" + state.stats.sceneName).toLowerCase()), 
            unrestorableScenes[password]);
            cancel ? (asyncAlert(cancel), self.finished = !1, self.resetPage()) : saveCookie(function() {
                clearScreen(function() {
                    restoreGame(state, null, !1);
                });
            }, "", state.stats, state.temps, state.lineNum, state.indent, this.debugMode, this.nav);
        }
    }), alreadyFinished && printFooter();
}, Scene.prototype.parseRestoreGame = function(alreadyFinished) {
    alreadyFinished && (this.lineNum--, this.rollbackLineCoverage());
    for (var nextIndent = null, unrestorableScenes = {}, startIndent = this.indent; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null == nextIndent && startIndent < indent && (this.indent = nextIndent = indent), 
        indent <= startIndent) return alreadyFinished || (this.lineNum--, this.rollbackLineCoverage()), 
        unrestorableScenes;
        if (indent != this.indent) throw new Error(this.lineMsg() + "invalid indent, expected " + this.indent + ", was " + indent);
        var line = trim(line), indent = /^(\w+)\s+(.*)/.exec(line);
        if (!indent) throw new Error(this.lineMsg() + "invalid line; this line should have a scene name followed by an error message: " + line);
        line = indent[1].toLowerCase(), indent = trim(indent[2]);
        unrestorableScenes[line] = indent;
    } else this.rollbackLineCoverage();
    return alreadyFinished || (this.lineNum--, this.rollbackLineCoverage()), unrestorableScenes;
}, Scene.prototype.check_registration = function() {
    var self;
    "undefined" != typeof window && "undefined" != typeof isRegistered && (this.finished = !0, 
    this.skipFooter = !0, self = this, isRegistered(function() {
        self.finished = !1, self.skipFooter = !1, self.execute();
    }));
}, Scene.prototype.login = function(optional) {
    if ("undefined" != typeof window && "undefined" != typeof loginForm) {
        if (optional = trim(optional)) {
            if ("optional" != optional) throw new Error(this.lineMsg() + "invalid *login option: " + optional);
            optional = 1;
        }
        var self = this;
        this.finished = !0, this.skipFooter = !0, this.paragraph();
        var target = (target = this.target) || document.getElementById("text");
        loginForm(target, optional, null, function() {
            clearScreen(function() {
                self.finished = !1, self.prevLine = "empty", self.screenEmpty = !0, 
                self.execute();
            });
        });
    }
}, Scene.prototype.save_game = function(destinationSceneName) {
    if (!destinationSceneName) throw new Error(this.lineMsg() + "*save_game requires a destination file name, e.g. *save_game Episode2");
    var self;
    this.temps.choice_user_restored || ((self = this).finished = !0, this.skipFooter = !0, 
    fetchEmail(function(defaultEmail) {
        self.paragraph();
        var form = document.createElement("form"), message = (setClass(form, "saveGame"), 
        form.action = "#", document.createElement("div")), saveName = (message.style.color = "red", 
        message.style.fontWeight = "bold", form.appendChild(message), document.createElement("input")), emailInput = (saveName.type = "text", 
        saveName.name = "saveName", saveName.setAttribute("placeholder", "Type a name for your saved game"), 
        saveName.setAttribute("style", "display:block; font-size: 25px; width: 90%; margin: 1rem 0"), 
        form.appendChild(saveName), println("Please login to the choiceofgames.com save system with your email address below.", form), 
        document.createElement("input"));
        try {
            emailInput.type = "email";
        } catch (e) {}
        emailInput.name = "email", emailInput.value = defaultEmail, emailInput.setAttribute("placeholder", "you@example.com"), 
        emailInput.setAttribute("style", "display:block; font-size: 25px; width: 90%; margin: 1rem 0"), 
        form.appendChild(emailInput);
        var defaultEmail = document.createElement("label"), subscribeBox = (defaultEmail.setAttribute("for", "subscribeBox"), 
        document.createElement("input")), defaultEmail = (subscribeBox.type = "checkbox", 
        subscribeBox.name = "subscribe", subscribeBox.setAttribute("id", "subscribeBox"), 
        subscribeBox.setAttribute("checked", !0), defaultEmail.appendChild(subscribeBox), 
        defaultEmail.appendChild(document.createTextNode("Email me when new games are available.")), 
        form.appendChild(defaultEmail), this.target);
        (defaultEmail = defaultEmail || document.getElementById("text")).appendChild(form), 
        printButton("Next", form, !0), printButton("Cancel", defaultEmail, !1, function() {
            clearScreen(function() {
                self.finished = !1, self.prevLine = "empty", self.screenEmpty = !0, 
                self.execute();
            });
        }), form.onsubmit = function(e) {
            preventDefault(e), safeCall(this, function() {
                var messageText;
                if (trim(saveName.value)) {
                    var stat, slot = "save" + new Date().getTime(), saveStats = {};
                    for (stat in self.stats) "scene" != stat && (saveStats[stat] = self.stats[stat]);
                    saveStats.scene = {
                        name: destinationSceneName
                    };
                    var subscribe = subscribeBox.checked && window.isHeartsChoice ? "hc" : "cog", email = trim(emailInput.value);
                    /^\S+@\S+\.\S+$/.test(email) ? recordEmail(email, function() {
                        clearScreen(function() {
                            saveCookie(function() {
                                recordSave(slot, function() {
                                    startLoading(), submitRemoteSave(slot, email, subscribe, function(ok) {
                                        doneLoading(), ok ? (self.finished = !1, 
                                        self.prevLine = "empty", self.screenEmpty = !0, 
                                        self.execute()) : asyncAlert("Couldn't upload your saved game to choiceofgames.com. You can try again later from the Restore menu.", function() {
                                            self.finished = !1, self.prevLine = "empty", 
                                            self.screenEmpty = !0, self.execute();
                                        });
                                    });
                                });
                            }, slot, saveStats, {
                                choice_reuse: "allow",
                                choice_user_restored: !0,
                                choice_restore_name: saveName.value
                            }, 0, 0, !1, self.nav);
                        });
                    }) : (messageText = document.createTextNode('Sorry, "' + email + '" is not an email address.  Please type your email address again.'), 
                    message.innerHTML = "", message.appendChild(messageText));
                } else messageText = document.createTextNode("Please type a name for your saved game."), 
                message.innerHTML = "", message.appendChild(messageText);
            });
        }, printFooter();
    }));
}, Scene.prototype.show_password = function() {
    var password;
    this.temps.choice_user_restored || (this.paragraph(), "undefined" == typeof window || window.isMobile || (this.printLine('Please copy and paste the password in a safe place, then press "Next" below to continue.'), 
    println("", this.target), println("", this.target)), password = computeCookie(this.stats, this.temps, this.lineNum, this.indent), 
    password = this.obfuscate(password), showPassword(this.target, password), this.prevLine = "block");
}, Scene.prototype.obfuscate = function(password) {
    var self = this;
    return password.replace(/./g, function(x) {
        return self.obfuscator[x];
    });
}, Scene.prototype.obfuscator = {
    " ": "k",
    "!": "E",
    '"': "`",
    "#": "\\",
    $: "r",
    "%": "J",
    "&": "o",
    "'": "0",
    "(": "Z",
    ")": "M",
    "*": "G",
    "+": "t",
    ",": "Y",
    "-": "f",
    ".": "2",
    "/": "!",
    0: "i",
    1: "*",
    2: "1",
    3: "3",
    4: "[",
    5: "6",
    6: "v",
    7: '"',
    8: "F",
    9: "9",
    ":": "{",
    ";": "Q",
    "<": "?",
    "=": "5",
    ">": "#",
    "?": "K",
    "@": "/",
    A: "=",
    B: "N",
    C: "z",
    D: "$",
    E: "W",
    F: "(",
    G: ")",
    H: "q",
    I: "C",
    J: "+",
    K: "U",
    L: ".",
    M: "H",
    N: "B",
    O: "S",
    P: "X",
    Q: "I",
    R: "-",
    S: "m",
    T: "D",
    U: "^",
    V: "A",
    W: "a",
    X: "y",
    Y: ",",
    Z: "d",
    "[": "O",
    "\\": "s",
    "]": "8",
    "^": "sVii6h",
    _: "]",
    "`": "sViivi",
    a: "4",
    b: "g",
    c: "%",
    d: "w",
    e: "h",
    f: "n",
    g: "b",
    h: "7",
    i: "x",
    j: "~",
    k: "_",
    l: "l",
    m: ":",
    n: "c",
    o: "L",
    p: "j",
    q: "u",
    r: "R",
    s: "}",
    t: "p",
    u: "V",
    v: "P",
    w: "'",
    x: "T",
    y: "|",
    z: "@",
    "{": "e",
    "|": 'sVii"%',
    "}": ";",
    "~": 'sVii"h'
}, Scene.prototype.deobfuscator = {
    k: " ",
    E: "!",
    "`": '"',
    "\\": "#",
    r: "$",
    J: "%",
    o: "&",
    0: "'",
    Z: "(",
    M: ")",
    G: "*",
    t: "+",
    Y: ",",
    f: "-",
    2: ".",
    "!": "/",
    i: "0",
    "*": "1",
    1: "2",
    3: "3",
    "[": "4",
    6: "5",
    v: "6",
    '"': "7",
    F: "8",
    9: "9",
    "{": ":",
    Q: ";",
    "?": "<",
    5: "=",
    "#": ">",
    K: "?",
    "/": "@",
    "=": "A",
    N: "B",
    z: "C",
    $: "D",
    W: "E",
    "(": "F",
    ")": "G",
    q: "H",
    C: "I",
    "+": "J",
    U: "K",
    ".": "L",
    H: "M",
    B: "N",
    S: "O",
    X: "P",
    I: "Q",
    "-": "R",
    m: "S",
    D: "T",
    "^": "U",
    A: "V",
    a: "W",
    y: "X",
    ",": "Y",
    d: "Z",
    O: "[",
    s: "\\",
    8: "]",
    "]": "_",
    4: "a",
    g: "b",
    "%": "c",
    w: "d",
    h: "e",
    n: "f",
    b: "g",
    7: "h",
    x: "i",
    "~": "j",
    _: "k",
    l: "l",
    ":": "m",
    c: "n",
    L: "o",
    j: "p",
    u: "q",
    R: "r",
    "}": "s",
    p: "t",
    V: "u",
    P: "v",
    "'": "w",
    T: "x",
    "|": "y",
    "@": "z",
    e: "{",
    ";": "}"
}, Scene.prototype.deobfuscatePassword = function(password) {
    var self = this;
    return password = password.replace(/./g, function(x) {
        return self.deobfuscator[x];
    });
}, Scene.prototype.stat_chart = function() {
    this.paragraph();
    var rows = this.parseStatChart(), target = (target = this.target) || document.getElementById("text"), barWidth = 0, standardFontSize = 0;
    function fixFontSize(span1, span2) {
        var spanMaxWidth;
        standardFontSize = standardFontSize || (window.getComputedStyle ? parseInt(getComputedStyle(document.body).fontSize, 10) : document.body.currentStyle ? parseInt(document.body.currentStyle.fontSize, 10) : 16), 
        barWidth = barWidth || span1.parentNode.offsetWidth, span2 = span2 ? (spanMaxWidth = barWidth / 2 - 1, 
        Math.max(span1.offsetWidth, span2.offsetWidth)) : (spanMaxWidth = barWidth, 
        span1.offsetWidth), spanMaxWidth < span2 && (spanMaxWidth = Math.floor(standardFontSize * spanMaxWidth / span2), 
        span1.parentNode.style.fontSize = spanMaxWidth + "px", window.getComputedStyle && spanMaxWidth < (span2 = parseInt(getComputedStyle(span1).fontSize, 10)) && (span1.parentNode.style.fontSize = (spanMaxWidth *= spanMaxWidth / span2) + "px"));
    }
    for (i = 0; i < rows.length; i++) {
        var div, span, statValue, row = rows[i], type = row.type, variable = row.variable, variable = this.evaluateExpr(this.tokenizeExpr(variable)), label = this.replaceVariables(row.label);
        this.replaceVariables(row.definition || "");
        if ("text" == type) div = document.createElement("div"), setClass(div, "statText"), 
        span = document.createElement("span"), trim(label) || trim(variable) ? printx(label + ": " + variable, span) : printx(" ", span), 
        div.appendChild(span), target.appendChild(div); else if ("percent" == type) div = document.createElement("div"), 
        setClass(div, "statBar statLine"), span = document.createElement("span"), 
        printx("" + label + ": " + variable + "%", span), div.appendChild(span), 
        statValue = document.createElement("div"), setClass(statValue, "statValue"), 
        statValue.style.width = variable + "%", statValue.innerHTML = "&nbsp;", 
        div.appendChild(statValue), target.appendChild(div), fixFontSize(span); else {
            if ("opposed_pair" != type) throw new Error("Bug! Parser accepted an unknown row type: " + type);
            div = document.createElement("div"), setClass(div, "statBar statLine opposed"), 
            span0 = document.createElement("span"), printx("" + label + ": " + variable + "% ", span0), 
            div.appendChild(span0), (span = document.createElement("span")).setAttribute("style", "float: right"), 
            printx(this.replaceVariables(row.opposed_label) + ": " + (100 - variable) + "%", span), 
            div.appendChild(span), statValue = document.createElement("div"), setClass(statValue, "statValue"), 
            statValue.style.width = variable + "%", statValue.innerHTML = "&nbsp;", 
            div.appendChild(statValue), target.appendChild(div), fixFontSize(span0, span);
        }
    }
    this.prevLine = "block", this.screenEmpty = !1;
}, Scene.prototype.parseStatChart = function() {
    for (var line1, line2, line2indent, nextIndent = null, rows = [], startIndent = this.indent; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null == nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one row");
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) return this.rollbackLineCoverage(), this.lineNum = this.previousNonBlankLineNum(), 
        this.rollbackLineCoverage(), rows;
        if (indent != this.indent) throw new Error(this.lineMsg() + "invalid indent, expected " + this.indent + ", was " + indent);
        var line = trim(line), indent = /^(text|percent|opposed_pair)\s+(.*)/.exec(line);
        if (!indent) throw new Error(this.lineMsg() + "invalid line; this line should start with 'percent', 'text', or 'opposed_pair'");
        var variable, label, line = indent[1].toLowerCase(), data = trim(indent[2]);
        if ("opposed_pair" == line) {
            if (this.getVar(data), line1 = this.lines[++this.lineNum], this.replaceVariables(line1), 
            (line1indent = this.getIndent(line1)) <= this.indent) throw new Error(this.lineMsg() + "invalid indent; expected at least one indented line to indicate opposed pair name. indent: " + line1indent + ", expected greater than " + this.indent);
            if (line2 = this.lines[this.lineNum + 1], (line2indent = this.getIndent(line2)) <= this.indent) rows.push({
                type: line,
                variable: data,
                label: data,
                opposed_label: trim(line1)
            }); else if (this.lineNum++, this.replaceVariables(line2), line2indent == line1indent) rows.push({
                type: line,
                variable: data,
                label: trim(line1),
                opposed_label: trim(line2)
            }); else {
                if (!(line2indent > line1indent)) throw new Error(this.lineMsg() + "invalid indent; expected a second line with indent " + line1indent + " to match line " + this.lineNum + ", or else no more opposed_pair lines");
                var line3 = this.lines[++this.lineNum], line3indent = (this.replaceVariables(line3), 
                this.getIndent(line3));
                if (line3indent != line1indent) throw new Error(this.lineMsg() + "invalid indent; this line should be the opposing label name. expected " + line1indent + " was " + line3indent);
                var line3indent = this.lines[++this.lineNum], line4indent = (this.replaceVariables(line3indent), 
                this.getIndent(line3indent));
                if (line4indent != line2indent) throw new Error(this.lineMsg() + "invalid indent; this line should be the opposing label definition. expected " + line2indent + " was " + line4indent);
                rows.push({
                    type: line,
                    variable: data,
                    label: trim(line1),
                    definition: trim(line2),
                    opposed_label: trim(line3),
                    opposed_definition: trim(line3indent)
                });
            }
        } else {
            if (/ /.test(data)) if (/^\(/.test(data)) {
                for (var parens = 0, closingParen = -1, i = 1; i < data.length; i++) {
                    var c = data.charAt(i);
                    if ("(" === c) parens++; else if (")" === c) {
                        if (!parens) {
                            closingParen = i;
                            break;
                        }
                        parens--;
                    }
                }
                if (-1 == closingParen) throw new Error(this.lineMsg() + "missing closing parenthesis");
                variable = data.substring(1, closingParen), "" === (label = trim(data.substring(closingParen + 1))) && (label = variable);
            } else {
                if (!(indent = /^(\S+) (.*)/.exec(data))) throw new Error(this.lineMsg() + "Bug! can't find a space when a space was found");
                variable = indent[1], label = indent[2];
            } else label = variable = data;
            this.evaluateExpr(this.tokenizeExpr(variable)), this.replaceVariables(label), 
            line2 = this.lines[this.lineNum + 1], (line2indent = this.getIndent(line2)) <= this.indent ? rows.push({
                type: line,
                variable: variable,
                label: label
            }) : (this.lineNum++, this.replaceVariables(line2), rows.push({
                type: line,
                variable: variable,
                label: label,
                definition: trim(line2)
            }));
        }
    } else this.rollbackLineCoverage();
    return rows;
}, Scene.prototype.timer = function(dateString) {
    var end;
    if ("release" == dateString) {
        if ("undefined" == typeof window || !window.releaseDate) return;
        end = window.releaseDate / 1e3;
    } else end = Date.parse(dateString) / 1e3;
    new Date() / 1e3 < end && ((dateString = this.target) || (dateString = document.createElement("p"), 
    document.getElementById("text").appendChild(dateString)), showTicker(dateString, end, function() {
        clearScreen(loadAndRestoreGame());
    }));
}, Scene.prototype.delay_break = function(durationInSeconds) {
    if (isNaN(+durationInSeconds)) throw new Error(this.lineMsg() + "invalid duration");
    this.finished = !0, this.skipFooter = !0;
    var target = this.target, self = (target || (target = document.createElement("p"), 
    document.getElementById("text").appendChild(target)), this.paragraph(), this);
    delayBreakStart(function(delayStart) {
        window.blockRestart = !0, showTicker(target, +durationInSeconds + +delayStart, function() {
            self.page_break_advertisement();
        }), printFooter();
    });
}, Scene.prototype.delay_ending = function(data) {
    if ("undefined" != typeof window && window.isSteamApp) return this.ending();
    var data = data.split(/ /), durationInSeconds = data[0], fullPriceGuess = data[1], singleUsePriceGuess = data[2];
    if (isNaN(+durationInSeconds)) throw new Error(this.lineMsg() + "invalid duration");
    if (!/^\$/.test(fullPriceGuess)) throw new Error(this.lineMsg() + 'invalid fullPriceGuess: "' + fullPriceGuess + '"');
    if (singleUsePriceGuess && !/^\$/.test(singleUsePriceGuess)) throw new Error(this.lineMsg() + 'invalid singleUsePriceGuess: "' + singleUsePriceGuess + '"');
    this.finished = !0, this.skipFooter = !0;
    var self = this;
    checkPurchase("adfree", function(ok, result) {
        result.adfree || !result.billingSupported ? self.ending() : getPrice("adfree", function(fullPrice) {
            "guess" == fullPrice && (fullPrice = fullPriceGuess), getPrice("skiponce", function(singleUsePrice) {
                "guess" == singleUsePrice && (singleUsePrice = singleUsePriceGuess);
                (options = []).push({
                    name: "Play again after a short wait. ",
                    unselectable: !0
                });
                var upgradeSkip = {
                    name: "Upgrade to the unlimited version for " + fullPrice + " to skip the wait forever."
                }, skipOnce = (options.push(upgradeSkip), {
                    name: "Skip the wait one time for " + singleUsePrice + "."
                }), restorePurchasesOption = (singleUsePriceGuess && options.push(skipOnce), 
                {
                    name: "Restore purchases from another device."
                }), playMoreGames = (isRestorePurchasesSupported() && options.push(restorePurchasesOption), 
                {
                    name: "Play more games like this."
                }), emailMe = (options.push(playMoreGames), {
                    name: "Email me when new games are available."
                });
                function restartNow() {
                    window.blockRestart = !1, restartGame();
                }
                options.push(emailMe), self.paragraph(), printOptions([ "" ], options, function(option) {
                    if (option == playMoreGames) self.more_games("now"), "undefined" != typeof curl && curl(); else if (option == emailMe) subscribeLink(); else if (option == upgradeSkip) purchase("adfree", restartNow); else if (option == skipOnce) purchase("skiponce", restartNow); else {
                        if (option != restorePurchasesOption) return restartGame();
                        restorePurchases("adfree", function() {
                            clearScreen(loadAndRestoreGame);
                        });
                    }
                });
                var target = document.querySelector(".choice label");
                delayBreakStart(function(delayStart) {
                    window.blockRestart = !0, showTicker(target, +durationInSeconds + +delayStart, function() {
                        clearScreen(function() {
                            self.ending();
                        });
                    }), printFooter();
                });
            });
        });
    });
}, Scene.prototype.if = function(line) {
    var stack = this.tokenizeExpr(line), stack = this.evaluateExpr(stack);
    this.debugMode && println(line + " :: " + stack), (stack = bool(stack, this.lineNum + 1)) ? this.indent = this.getIndent(this.nextNonBlankLine()) : this.skipTrueBranch(!1);
}, Scene.prototype.skipTrueBranch = function(inElse) {
    for (var startIndent = this.indent, nextIndent = null; isDefined(line = this.lines[++this.lineNum]); ) if (this.rollbackLineCoverage(), 
    trim(line)) {
        var indent = this.getIndent(line);
        if (null == nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one line in 'if' true block");
            nextIndent = indent;
        }
        if (indent <= startIndent) {
            var parsed = null;
            if (!(parsed = indent == startIndent ? /^\s*\*(\w+)(.*)/.exec(line) : parsed) || inElse) return this.lineNum = this.previousNonBlankLineNum(), 
            this.rollbackLineCoverage(), void (this.indent = indent);
            var line = parsed[1].toLowerCase(), parsed = trim(parsed[2]);
            if ("else" == line) {
                if (parsed) {
                    if (/^if\b/.test(parsed)) throw new Error(this.lineMsg() + "'else if' is invalid, use 'elseif'");
                    throw new Error(this.lineMsg() + "nothing should appear on a line after 'else': " + parsed);
                }
                this.lineNum = this.lineNum, this.indent = this.getIndent(this.nextNonBlankLine());
            } else if (/^else?if$/.test(line)) this.lineNum = this.lineNum, this.if(parsed); else {
                if ("comment" == line) continue;
                this.lineNum = this.previousNonBlankLineNum(), this.rollbackLineCoverage(), 
                this.indent = this.getIndent(this.nextNonBlankLine());
            }
            return;
        }
        if (indent < nextIndent) throw new Error(this.lineMsg() + "invalid indent, expected " + nextIndent + ", was " + indent);
    }
}, Scene.prototype.else = Scene.prototype.elsif = Scene.prototype.elseif = function(data, inChoice) {
    if (!inChoice && !this.getVar("implicit_control_flow")) throw new Error(this.lineMsg() + "It is illegal to fall in to an *else statement; you must *goto or *finish before the end of the indented block.");
    this.skipTrueBranch(!0);
}, Scene.prototype.tokenizeExpr = function(str) {
    for (var stack = [], tokenTypes = Scene.tokens, tokenTypesLength = tokenTypes.length, pos = 0; str; ) {
        for (var matched = !1, i = 0; i < tokenTypesLength; i++) {
            var tokenType = tokenTypes[i], token = tokenType.test(str, this.lineNum + 1, this);
            if (token) {
                matched = !0, str = str.substr(token.length), pos += token.length;
                var item = {
                    name: tokenType.name,
                    value: token,
                    pos: pos
                };
                if ("WHITESPACE" == tokenType.name) break;
                if ("CURLY_QUOTE" == tokenType.name) throw new Error(this.lineMsg() + "Invalid use of curly smart quote: " + token + '\nUse straight quotes " instead');
                "FUNCTION" == tokenType.name && (item.func = /^\w+/.exec(token)[0]), 
                stack.push(item);
                break;
            }
        }
        if (!matched) throw new Error(this.lineMsg() + "Invalid expression, couldn't extract another token: " + str);
    }
    return stack;
}, Scene.prototype.evaluateExpr = function(stack, parenthetical) {
    if (!stack.length) throw new Error(this.lineMsg() + "no expression specified");
    var token, value1, operator, self = this;
    function getToken() {
        var token = stack.shift();
        if (token) return token;
        throw new Error(self.lineMsg() + "null token");
    }
    if (value1 = this.evaluateValueToken(getToken(), stack), !stack.length) {
        if (parenthetical) throw new Error(this.lineMsg() + "Invalid expression, expected " + parenthetical);
        return value1;
    }
    if (token = getToken(), parenthetical && parenthetical == token.name) return value1;
    if (!(operator = Scene.operators[token.value])) throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected OPERATOR" + (parenthetical ? " or " + parenthetical : "") + ", was: " + token.name + " [" + token.value + "]");
    if ("%" === token.value && (this.warning("this is a bare % sign, which should be replaced with %+, %-, or modulo if you're really advanced."), 
    this.warning("For more details on modulo, see: https://forum.choiceofgames.com/t/21176")), 
    !stack[0]) throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected something after a " + token.value);
    if (operator = operator(value1, "auto" == stack[0].func ? this.autobalance(stack, token, value1) : this.evaluateValueToken(getToken(), stack), this.lineNum + 1, this), 
    parenthetical) {
        if (stack.length) {
            if (parenthetical == (token = getToken()).name) return operator;
            throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected " + parenthetical + ", was: " + token.name + " [" + token.value + "]");
        }
        throw new Error(this.lineMsg() + "Invalid expression, expected " + parenthetical);
    }
    if (stack.length) throw token = getToken(), new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected no more tokens, found: " + token.name + " [" + token.value + "]");
    return operator;
}, Scene.prototype.evaluateValueToken = function(token, stack) {
    var value, name = token.name;
    if ("OPEN_PARENTHESIS" == name) return this.evaluateExpr(stack, "CLOSE_PARENTHESIS");
    if ("OPEN_CURLY" == name) return value = this.evaluateExpr(stack, "CLOSE_CURLY"), 
    this.getVar(value);
    if ("FUNCTION" == name) {
        if (this.functions[token.func]) return value = this.evaluateExpr(stack, "CLOSE_PARENTHESIS"), 
        this.functions[token.func].call(this, value);
        throw new Error(this.lineMsg + "Unknown function " + token.func);
    }
    if ("NUMBER" == name) return token.value;
    if ("STRING" == name) return this.replaceVariables(token.value.slice(1, -1).replace(/\\(.)/g, "$1"));
    if ("VAR" != name) throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected NUMBER, STRING, VAR or PARENTHETICAL, was: " + name + " [" + token.value + "]");
    for (var variable = String(token.value); stack.length && "OPEN_SQUARE" == stack[0].name; ) stack.shift(), 
    variable += "_" + this.evaluateExpr(stack, "CLOSE_SQUARE");
    return this.getVar(variable);
}, Scene.prototype.evaluateReference = function(stack, options) {
    var name, toLowerCase = !0;
    function findClosingBracket(stack, type, offset) {
        for (var opens = 0, openType = "OPEN_" + type, closeType = "CLOSE_" + type, i = offset = offset || 0; i < stack.length; i++) if (stack[i].name == openType) opens++; else if (stack[i].name == closeType) {
            if (!opens) return i;
            opens--;
        }
        return -1;
    }
    function normalizeCase(name) {
        return toLowerCase ? String(name).toLowerCase() : name;
    }
    if (options && options.hasOwnProperty("toLowerCase") && (toLowerCase = !!options.toLowerCase), 
    !stack.length) throw new Error(this.lineMsg() + "Invalid expression, expected a name");
    if ("OPEN_CURLY" === stack[0].name) {
        stack.shift();
        options = findClosingBracket(stack, "CURLY");
        if (-1 == options) throw new Error(this.lineMsg() + "Invalid expression, no closing curly bracket: " + data);
        name = this.evaluateExpr(stack.slice(0, options)), stack.splice(0, options + 1);
    } else {
        if ("NUMBER" === stack[0].name) return name = stack[0].value, stack.shift(), 
        name;
        if ("VAR" !== stack[0].name) throw new Error(this.lineMsg() + "Invalid expression; expected name, found " + stack[0].name + " at char " + stack[0].pos);
        for (name = String(stack[0].value), stack.shift(); stack.length && "OPEN_SQUARE" == stack[0].name; ) {
            var closingBracket = findClosingBracket(stack, "SQUARE", 1);
            if (-1 == closingBracket) throw new Error(this.lineMsg() + "Invalid expression, no closing array bracket at char " + stack[1].pos);
            name += "_" + this.evaluateExpr(stack.slice(1, closingBracket)), stack.splice(0, closingBracket + 1);
        }
    }
    return normalizeCase(name);
}, Scene.prototype.functions = {
    not: function(value) {
        return !bool(value, this.lineNum + 1);
    },
    round: function(value) {
        if (isNaN(+value)) throw new Error(this.lineMsg() + "round() value is not a number: " + value);
        return Math.round(value);
    },
    timestamp: function(value) {
        return Date.parse(value) / 1e3;
    },
    log: function(value) {
        if (isNaN(+value)) throw new Error(this.lineMsg() + "log() value is not a number: " + value);
        return Math.log(value) / Math.log(10);
    },
    length: function(value) {
        return String(value).length;
    },
    auto: function() {
        throw new Error(this.lineMsg() + "Invalid expression, auto() must come after a < or > symbol");
    }
}, Scene.prototype.autobalance = function(stack, operatorToken, value) {
    if ("INEQUALITY" !== operatorToken.name) throw new Error(this.lineMsg() + "Invalid expression, auto() must come after a < or > symbol");
    if (stack.shift(), stack.length < 4 || "NUMBER" !== stack[0].name || "COMMA" !== stack[1].name || "VAR" != stack[2].name && "NUMBER" != stack[2].name || "CLOSE_PARENTHESIS" !== stack[3].name) throw new Error(this.lineMsg() + "Invalid expression, auto() requires (percentage, id)");
    var rateString = stack.shift().value, rate = parseFloat(rateString);
    if (isNaN(rate) || rate < 1 || 99 < rate) throw new Error(this.lineMsg() + "the first auto() parameter should be a number between 1 and 99: " + rateString);
    stack.shift();
    rateString = stack.shift().value, stack.shift(), stack = this.stats["auto_" + this.name + "_" + rateString];
    return void 0 !== stack ? stack : this.recordBalance ? this.recordBalance(value, operatorToken.value, rate, rateString) : 50;
}, Scene.prototype.evaluateValueExpr = function(expr) {
    var expr = this.tokenizeExpr(expr), token = expr.shift();
    if (!token) throw new Error(this.lineMsg() + "null token");
    var value = this.evaluateValueToken(token, expr);
    if (expr.length) {
        if (token = expr.shift()) throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected no more tokens, found: " + token.name + " [" + token.value + "]");
        throw new Error(this.lineMsg() + "null token");
    }
    return value;
}, Scene.prototype.goto_random_scene = function(data) {
    var parsed = this.parseGotoRandomScene(data), allowReuseGlobally = /\ballow_reuse\b/.test(data), data = /\ballow_no_selection\b/.test(data), parsed = this.computeRandomSelection(Math.random(), parsed, allowReuseGlobally);
    if (parsed) this.goto_scene(parsed.name); else if (!data) throw new Error(this.lineMsg() + "No selectable scenes");
}, Scene.prototype.parseGotoRandomScene = function(data) {
    for (var directives = (data = data || "").split(" "), allowReuseGlobally = !1, i = 0; i < directives; i++) {
        var directive = trim(directives[i]);
        if (directive) if ("allow_reuse" == directive) allowReuseGlobally = !0; else if ("allow_no_selection" != directive) throw new Error(this.lineMsg() + "invalid command: '" + directive + "'");
    }
    for (var nextIndent = null, options = [], startIndent = this.indent; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null == nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one line in *goto_random_scene");
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) {
            this.rollbackLineCoverage(), this.lineNum--, this.rollbackLineCoverage();
            break;
        }
        if (indent != this.indent) throw new Error(this.lineMsg() + "invalid indent, expected " + this.indent + ", was " + indent);
        line = trim(line);
        for (var option = {
            allowReuse: allowReuseGlobally
        }; command = /^\*(\S+)/.exec(line); ) if ("allow_reuse" == (command = command[1])) option.allowReuse = !0, 
        line = trim(line.substring("*allow_reuse".length)), command = /^\*(\S+)/.exec(line); else {
            if ("if" != command) throw new Error(this.lineMsg() + " invalid command: " + line);
            var command = /^\*if\s+\((.+)\)\s+([^\)]+)/.exec(line);
            if (!command) throw new Error(this.lineMsg() + " invalid *if, expected () followed by scene name: " + line);
            var line = command[2], stack = this.tokenizeExpr(command[1]);
            this.evaluateExpr(stack), option.conditional = command[1];
        }
        option.name = trim(line), options.push(option);
    } else this.rollbackLineCoverage();
    return options;
}, Scene.prototype.computeRandomSelection = function(randomFloat, options, allowReuseGlobally) {
    for (var option, filtered = [], finished = {}, grs = (allowReuseGlobally || this.stats.choice_grs || (this.stats.choice_grs = []), 
    this.stats.choice_grs), i = 0; i < grs.length; i++) finished[grs[i]] = 1;
    for (i = 0; i < options.length; i++) if ((option = options[i]).allowReuse || !finished[option.name]) {
        if (option.conditional) {
            var stack = this.tokenizeExpr(option.conditional);
            if (!this.evaluateExpr(stack)) continue;
        }
        filtered.push(option);
    }
    return filtered.length ? ((option = filtered[Math.floor(randomFloat * filtered.length)]).allowReuse || this.stats.choice_grs.push(option.name), 
    option) : null;
}, Scene.prototype.end_trial = function() {
    this.paragraph(), printLink(this.target, "#", "Start Over from the Beginning", function(e) {
        return preventDefault(e), restartGame("prompt");
    }), this.prevLine = "block", this.screenEmpty = !1, this.finished = !0;
}, Scene.prototype.achieve = function(name) {
    if (name = name.toLowerCase(), !this.nav.achievements.hasOwnProperty(name)) throw new Error(this.lineMsg() + "the achievement name " + name + " was not declared as an *achievement in startup");
    var achievement = this.nav.achievements[name];
    this.nav.achieved[name] = !0, "undefined" != typeof window && "undefined" != typeof achieve && achieve(name, achievement.title, achievement.earnedDescription);
}, Scene.prototype.check_achievements = function() {
    var self = this;
    function callback(immediately) {
        for (var achievement in nav.achievements) self.temps["choice_achieved_" + achievement] = nav.achieved.hasOwnProperty(achievement);
        immediately || (self.finished = !1, self.skipFooter = !1, self.execute());
    }
    "undefined" == typeof checkAchievements ? callback("immediately") : (this.finished = !0, 
    this.skipFooter = !0, checkAchievements(callback));
}, Scene.prototype.scene_list = function() {
    var scenes = this.parseSceneList();
    this.nav.setSceneList(scenes);
}, Scene.prototype.parseSceneList = function() {
    for (var nextIndent = null, scenes = [], startIndent = this.indent; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null == nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one row");
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) return this.rollbackLineCoverage(), this.lineNum--, 
        this.rollbackLineCoverage(), scenes;
        if (indent != this.indent) throw new Error(this.lineMsg() + "invalid indent, expected " + this.indent + ", was " + indent);
        var line = trim(line), indent = /^\$(\w*)\s+(.*)/.exec(line);
        indent && (line = indent[2]), scenes.length || "startup" == String(line).toLowerCase() || scenes.push("startup"), 
        scenes.push(line);
    } else this.rollbackLineCoverage();
    return scenes;
}, Scene.prototype.title = function(title) {
    this.stats.choice_title = trim(title), this.nav && (this.nav.startingStats.choice_title = trim(title)), 
    "undefined" != typeof changeTitle && changeTitle(title);
}, Scene.prototype.author = function(author) {
    "undefined" != typeof changeAuthor && changeAuthor(author);
}, Scene.prototype.achievement = function(data) {
    var parsed = /(\S+)\s+(\S+)\s+(\S+)\s+(.*)/.exec(data);
    if (!parsed) throw new Error(this.lineMsg() + "Invalid *achievement, requires short name, visibility, points, and display title: " + data);
    data = parsed[1];
    if (!/^[a-z][a-z0-9_]+$/.test(data)) throw new Error(this.lineMsg() + "Invalid achievement name: " + data);
    if (!this.parsedAnAchievment && 0 < Object.keys(this.nav.achievements).length && (this.nav.achievements = {}, 
    this.nav.achievementList = [], this.achievementTotal = 0, this.seenAchievementTitles = {}), 
    this.parsedAnAchievment = !0, this.nav.achievements.hasOwnProperty(data)) throw this.nav.achievements[data], 
    new Error(this.lineMsg() + "Achievement " + data + " already defined on line " + this.nav.achievements[data].lineNumber);
    var lineNumber = this.lineNum + 1, visibility = parsed[2];
    if ("hidden" != visibility && "visible" != visibility) throw new Error(this.lineMsg() + "Invalid *achievement, the second word should be either 'hidden' or 'visible': " + visibility);
    var visibility = "hidden" != visibility, pointString = parsed[3];
    if (!/[1-9][0-9]*/.test(pointString)) throw new Error(this.lineMsg() + "Invalid *achievement, the third word should be an integer number of points: " + pointString);
    pointString = parseInt(pointString, 10);
    if (100 < pointString) throw new Error(this.lineMsg() + "Invalid *achievement, no achievement may be worth more than 100 points: " + pointString);
    if (pointString < 1) throw new Error(this.lineMsg() + "Invalid *achievement, no achievement may be worth less than 1 point: " + pointString);
    if (this.achievementTotal || (this.achievementTotal = 0), this.achievementTotal += pointString, 
    1e3 < this.achievementTotal) throw new Error(this.lineMsg() + "Invalid achievements. Adding " + pointString + " would add up to more than 1,000 points: " + this.achievementTotal);
    parsed = parsed[4];
    if (/(\$\{)/.test(parsed)) throw new Error(this.lineMsg() + "Invalid *achievement. ${} not permitted in achievement title: " + parsed);
    if (/(\@\{)/.test(parsed)) throw new Error(this.lineMsg() + "Invalid *achievement. @{} not permitted in achievement title: " + parsed);
    if (/(\[)/.test(parsed)) throw new Error(this.lineMsg() + "Invalid *achievement. [] not permitted in achievement title: " + parsed);
    if (50 < parsed.length) throw new Error(this.lineMsg() + "Invalid *achievement. Title must be 50 characters or fewer: " + parsed);
    var line = this.lines[++this.lineNum];
    if (!this.getIndent(line)) throw new Error(this.lineMsg() + "Invalid *achievement. An indented description is required.");
    var preEarnedDescription = trim(line);
    if (/(\$\{)/.test(preEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. ${} not permitted in achievement description: " + preEarnedDescription);
    if (/(\@\{)/.test(preEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. @{} not permitted in achievement description: " + preEarnedDescription);
    if (/(\[)/.test(preEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. [] not permitted in achievement description: " + preEarnedDescription);
    if (200 < preEarnedDescription.length) throw new Error(this.lineMsg() + "Invalid *achievement. Pre-earned description must be 200 characters or fewer: " + preEarnedDescription);
    if (!visibility && "hidden" != preEarnedDescription.toLowerCase()) throw new Error(this.lineMsg() + "Invalid *achievement. Hidden achievements must set their pre-earned description to 'hidden'.");
    for (var postEarnedDescription = null; isDefined(line = this.lines[++this.lineNum]) && !trim(line); ) this.rollbackLineCoverage();
    if (this.getIndent(line)) {
        if (postEarnedDescription = trim(line), /(\$\{)/.test(postEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. ${} not permitted in achievement description: " + postEarnedDescription);
        if (/(\@\{)/.test(postEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. @{} not permitted in achievement description: " + postEarnedDescription);
        if (/(\[)/.test(postEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. [] not permitted in achievement description: " + postEarnedDescription);
        if (200 < postEarnedDescription.length) throw new Error(this.lineMsg() + "Invalid *achievement. Post-earned description must be 200 characters or fewer: " + postEarnedDescription);
    } else this.rollbackLineCoverage(), this.lineNum--, this.rollbackLineCoverage();
    if (!postEarnedDescription) {
        if (!visibility) throw new Error(this.lineMsg() + "Invalid *achievement. Hidden achievements must set a post-earned description.");
        postEarnedDescription = preEarnedDescription;
    }
    if (!this.nav.achievements.hasOwnProperty(data) && (this.nav.achievementList.push(data), 
    100 < this.nav.achievementList.length)) throw new Error(this.lineMsg() + "Too many *achievements. Each game can have up to 100 achievements.");
    if (this.seenAchievementTitles || (this.seenAchievementTitles = {}), this.seenAchievementTitles[parsed]) throw new Error(this.lineMsg() + 'An achievement with display title "' + parsed + '" was already defined at line ' + this.seenAchievementTitles[parsed]);
    this.seenAchievementTitles[parsed] = this.lineNum + 1, this.nav.achievements[data] = {
        visible: visibility,
        points: pointString,
        title: parsed,
        earnedDescription: postEarnedDescription,
        preEarnedDescription: preEarnedDescription,
        lineNumber: lineNumber
    }, "undefined" != typeof setButtonTitles && setButtonTitles();
}, Scene.prototype.bug = function(message) {
    throw message = message ? "Bug: " + this.replaceVariables(message) : "Bug", 
    new Error(this.lineMsg() + message);
}, Scene.prototype.warning = function(message) {}, Scene.prototype.feedback = function() {
    if ("undefined" != typeof window && !this.randomtest) {
        this.paragraph(), this.printLine("On a scale from 1 to 10, how likely are you to recommend this game to a friend?"), 
        this.paragraph();
        for (var options = [ {
            name: "10 (Most likely)"
        } ], i = 9; 1 < i; i--) options.push({
            name: i
        });
        options.push({
            name: "1 (Least likely)"
        }), options.push({
            name: "No response."
        });
        var self = this;
        this.renderOptions([ "" ], options, function(option) {
            var postFeedback, value = "null", numberMatch = /^(\d+)/.exec(option.name);
            numberMatch && (value = +numberMatch[1]), !window.storeName || (postFeedback = function() {
                if (xhrAuthRequest("POST", "feedback", function(ok, response) {
                    window.console && console.log("ok", ok, response);
                }, "game", window.storeName, "platform", platformCode(), "rating", value), 
                /^(9|10)/.test(option.name) && isReviewSupported()) return clearScreen(function() {
                    self.printLine("Great! "), promptForReview(), self.screenEmpty = !1, 
                    self.prevLine = "text", self.page_break(), printFooter();
                });
                self.finished = !1, self.resetPage();
            }, "null" == value) ? (self.finished = !1, self.resetPage()) : isRegistered(function(registered) {
                registered ? postFeedback() : clearScreen(function() {
                    loginForm(main, 1, "Please sign in to have your vote counted!", postFeedback);
                });
            });
        }), this.finished = !0;
    }
}, Scene.prototype.parseTrackEvent = function(data) {
    var event = {}, data = this.tokenizeExpr(data);
    if (!data.length) throw new Error(this.lineMsg() + "Invalid track_event statement, expected at least two args: category and action");
    if (event.category = this.evaluateValueToken(data.shift(), data), !data.length) throw new Error(this.lineMsg() + "Invalid track_event statement, expected at least two args: category and action");
    if (event.action = this.evaluateValueToken(data.shift(), data), data.length && (event.label = this.evaluateValueToken(data.shift(), data), 
    data.length)) {
        if (event.value = this.evaluateValueToken(data.shift(), data), data.length) throw new Error(this.lineMsg() + "Invalid track_event statement, expected at most four args: category, action, label, value");
        data = parseInt(event.value, 10);
        if (isNaN(data) || event.value != data || event.value.toString() != data.toString()) throw new Error(this.lineMsg() + "Invalid track_event statement, value must be an integer: " + event.value);
    }
    return event;
}, Scene.prototype.track_event = function(data) {
    data = this.parseTrackEvent(data);
    "undefined" != typeof ga && ga("send", "event", data.category, data.action, data.label, data.value);
}, Scene.prototype.ai = function(data) {}, Scene.prototype.config = function(data) {
    var data = this.tokenizeExpr(data), variable = this.evaluateReference(data);
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    if (0 === data.length) throw new Error(this.lineMsg() + "Invalid set instruction, no expression specified: " + line);
    var self, data = this.evaluateExpr(data);
    this.setVar(variable, data), void 0 === remoteConfig || this.randomtest || this.quicktest || (this.finished = !0, 
    this.skipFooter = !0, self = this, remoteConfig(variable, function(result) {
        null !== result && self.setVar(variable, result), self.finished = !1, self.skipFooter = !1, 
        self.execute();
    }));
}, Scene.prototype.ifid = function(id) {
    if (!/^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/.test(id)) throw new Error(this.lineMsg() + 'Invalid IFID. It should have five parts, like "a0a0a0a0-a0a0-a0a0-a0a0-a0a0a0a0a0a0: ' + id);
    if (!/^[A-F0-9\-]{36}$/i.test(id)) throw new Error(this.lineMsg() + "Invalid IFID. It should contain only numbers, letters A-F, and dashes: " + id);
}, Scene.prototype.lineMsg = function() {
    return this.name + " line " + (this.lineNum + 1) + ": ";
}, Scene.prototype.rollbackLineCoverage = function() {}, Scene.baseUrl = "scenes", 
Scene.regexpMatch = function(str, re) {
    re = re.exec(str);
    return re ? re[0] : null;
}, Scene.tokens = [ {
    name: "OPEN_PARENTHESIS",
    test: function(str) {
        return Scene.regexpMatch(str, /^\(/);
    }
}, {
    name: "CLOSE_PARENTHESIS",
    test: function(str) {
        return Scene.regexpMatch(str, /^\)/);
    }
}, {
    name: "OPEN_CURLY",
    test: function(str) {
        return Scene.regexpMatch(str, /^\{/);
    }
}, {
    name: "CLOSE_CURLY",
    test: function(str) {
        return Scene.regexpMatch(str, /^\}/);
    }
}, {
    name: "OPEN_SQUARE",
    test: function(str) {
        return Scene.regexpMatch(str, /^\[/);
    }
}, {
    name: "CLOSE_SQUARE",
    test: function(str) {
        return Scene.regexpMatch(str, /^\]/);
    }
}, {
    name: "FUNCTION",
    test: function(str) {
        return Scene.regexpMatch(str, /^(not|round|timestamp|log|length|auto)\s*\(/);
    }
}, {
    name: "NUMBER",
    test: function(str) {
        return Scene.regexpMatch(str, /^\d+(\.\d+)?\b/);
    }
}, {
    name: "STRING",
    test: function(str, line, sceneObj) {
        var i;
        if (!/^\"/.test(str)) return null;
        for (i = 1; i < str.length; i++) {
            var x = str.charAt(i);
            if ("\\" == x) i++; else if ('"' == x) return str.substring(0, i + 1);
        }
        line = "line " + line + ": ";
        throw sceneObj && (line = sceneObj.lineMsg()), new Error(line + "Invalid string, open quote with no close quote: " + str);
    }
}, {
    name: "CURLY_QUOTE",
    test: function(str) {
        return Scene.regexpMatch(str, /^[\u201c\u201d]/);
    }
}, {
    name: "WHITESPACE",
    test: function(str) {
        return Scene.regexpMatch(str, /^\s+/);
    }
}, {
    name: "NAMED_OPERATOR",
    test: function(str) {
        return Scene.regexpMatch(str, /^(and|or|modulo)\b/);
    }
}, {
    name: "VAR",
    test: function(str) {
        return Scene.regexpMatch(str, /^\w*/);
    }
}, {
    name: "FAIRMATH",
    test: function(str) {
        return Scene.regexpMatch(str, /^%[\+\-]/);
    }
}, {
    name: "OPERATOR",
    test: function(str) {
        return Scene.regexpMatch(str, /^[\+\-\*\/\&\%\^\#]/);
    }
}, {
    name: "INEQUALITY",
    test: function(str) {
        return Scene.regexpMatch(str, /^[\!<>]\=?/);
    }
}, {
    name: "EQUALITY",
    test: function(str) {
        return Scene.regexpMatch(str, /^=/);
    }
}, {
    name: "COMMA",
    test: function(str) {
        return Scene.regexpMatch(str, /^,/);
    }
} ], Scene.operators = {
    "+": function(v1, v2, line, sceneObj) {
        var name = null;
        return num(v1, line, name = sceneObj ? sceneObj.name : name) + num(v2, line, name);
    },
    "-": function(v1, v2, line, sceneObj) {
        var name = null;
        return num(v1, line, name = sceneObj ? sceneObj.name : name) - num(v2, line, name);
    },
    "*": function(v1, v2, line, sceneObj) {
        var name = null;
        return num(v1, line, name = sceneObj ? sceneObj.name : name) * num(v2, line, name);
    },
    "/": function(v1, v2, line, sceneObj) {
        var name = null;
        if (0 === (v2 = num(v2, line, name = sceneObj ? sceneObj.name : name))) throw new Error(name + " line " + line + ": can't divide by zero");
        return num(v1, line, name) / num(v2, line, name);
    },
    "^": function(v1, v2, line, sceneObj) {
        var name = null;
        return sceneObj && (name = sceneObj.name), Math.pow(num(v1, line, name), num(v2, line, name));
    },
    "&": function(v1, v2) {
        return [ v1, v2 ].join("");
    },
    "#": function(v1, v2, line, sceneObj) {
        var name = null, errMessage = "line " + line + ": ", sceneObj = (sceneObj && (name = sceneObj.name, 
        errMessage = sceneObj.lineMsg()), num(v2, line, name));
        if (sceneObj < 1) throw new Error(errMessage + "There is no character at position " + sceneObj + "; the position must be greater than or equal to 1.");
        if (sceneObj > String(v1).length) throw new Error(errMessage + "There is no character at position " + sceneObj + '. "' + v1 + '" is only ' + String(v1).length + " characters long.");
        return String(v1).charAt(sceneObj - 1);
    },
    "%+": function(v1, v2, line, sceneObj) {
        var value, name = null, errMessage = "line " + line + ": ";
        if (sceneObj && (name = sceneObj.name, errMessage = sceneObj.lineMsg()), 
        v1 = num(v1, line, name), v2 = num(v2, line, name), 0 <= v1 && v1 <= 100) return 0 < v2 ? (value = +v1 + v2 * ((100 - v1) / 100), 
        99 < (value = Math.floor(value)) ? 99 : value) : (value = v1 - (0 - v2) * (v1 / 100), 
        (value = Math.ceil(value)) < 1 ? 1 : value);
        throw new Error(errMessage + "Can't fairAdd to non-percentile value: " + v1);
    },
    "%-": function(v1, v2, line, sceneObj) {
        var name = null;
        return v2 = num(v2, line, name = sceneObj ? sceneObj.name : name), Scene.operators["%+"](v1, 0 - v2, line, sceneObj);
    },
    "=": function(v1, v2) {
        return v1 == v2 || String(v1) == String(v2);
    },
    "<": function(v1, v2, line, sceneObj) {
        var name = null;
        return num(v1, line, name = sceneObj ? sceneObj.name : name) < num(v2, line, name);
    },
    ">": function(v1, v2, line, sceneObj) {
        var name = null;
        return num(v1, line, name = sceneObj ? sceneObj.name : name) > num(v2, line, name);
    },
    "<=": function(v1, v2, line, sceneObj) {
        var name = null;
        return num(v1, line, name = sceneObj ? sceneObj.name : name) <= num(v2, line, name);
    },
    ">=": function(v1, v2, line, sceneObj) {
        var name = null;
        return num(v1, line, name = sceneObj ? sceneObj.name : name) >= num(v2, line, name);
    },
    "!=": function(v1, v2) {
        return v1 != v2;
    },
    and: function(v1, v2, line, sceneObj) {
        var name = null;
        return bool(v1, line, name = sceneObj ? sceneObj.name : name) && bool(v2, line, name);
    },
    or: function(v1, v2, line, sceneObj) {
        var name = null;
        return bool(v1, line, name = sceneObj ? sceneObj.name : name) || bool(v2, line, name);
    },
    modulo: function(v1, v2, line, sceneObj) {
        var name = null;
        return num(v1, line, name = sceneObj ? sceneObj.name : name) % num(v2, line, name);
    }
}, Scene.initialCommands = {
    create: 1,
    create_array: 1,
    scene_list: 1,
    title: 1,
    author: 1,
    comment: 1,
    achievement: 1,
    product: 1,
    ifid: 1
}, Scene.validCommands = {
    comment: 1,
    goto: 1,
    gotoref: 1,
    label: 1,
    looplimit: 1,
    finish: 1,
    abort: 1,
    choice: 1,
    create: 1,
    create_array: 1,
    temp: 1,
    temp_array: 1,
    delete: 1,
    delete_array: 1,
    set: 1,
    setref: 1,
    print: 1,
    if: 1,
    rand: 1,
    page_break: 1,
    line_break: 1,
    script: 1,
    else: 1,
    elseif: 1,
    elsif: 1,
    reset: 1,
    goto_scene: 1,
    fake_choice: 1,
    input_text: 1,
    ending: 1,
    share_this_game: 1,
    stat_chart: 1,
    subscribe: 1,
    show_password: 1,
    gosub: 1,
    return: 1,
    hide_reuse: 1,
    disable_reuse: 1,
    allow_reuse: 1,
    check_purchase: 1,
    restore_purchases: 1,
    purchase: 1,
    restore_game: 1,
    advertisement: 1,
    kindle_search: 1,
    kindle_product: 1,
    feedback: 1,
    save_game: 1,
    delay_break: 1,
    image: 1,
    kindle_image: 1,
    link: 1,
    input_number: 1,
    goto_random_scene: 1,
    restart: 1,
    more_games: 1,
    delay_ending: 1,
    end_trial: 1,
    login: 1,
    achieve: 1,
    scene_list: 1,
    title: 1,
    bug: 1,
    link_button: 1,
    check_registration: 1,
    sound: 1,
    author: 1,
    gosub_scene: 1,
    achievement: 1,
    check_achievements: 1,
    redirect_scene: 1,
    print_discount: 1,
    purchase_discount: 1,
    track_event: 1,
    timer: 1,
    youtube: 1,
    product: 1,
    text_image: 1,
    ai: 1,
    params: 1,
    config: 1,
    ifid: 1,
    page_break_advertisement: 1,
    finish_advertisement: 1
}, SceneNavigator.prototype.setSceneList = function(sceneList) {
    this._sceneList = sceneList, this._sceneMap = {};
    for (var i = 0; i < sceneList.length - 1; i++) {
        var scene1 = sceneList[i], scene2 = sceneList[i + 1];
        this._sceneMap[scene1] = scene2;
    }
    this._startupScene = sceneList[0];
}, SceneNavigator.prototype.nextSceneName = function(currentSceneName) {
    return this._sceneMap[currentSceneName];
}, SceneNavigator.prototype.getStartupScene = function() {
    return this._startupScene;
}, SceneNavigator.prototype.setStartingStatsClone = function(stats) {
    for (var i in this.startingStats = {}, stats) this.startingStats[i] = stats[i];
}, SceneNavigator.prototype.resetStats = function(stats) {
    for (var i in stats) delete stats[i];
    for (i in this.startingStats) stats[i] = this.startingStats[i];
    this.bugLog = [];
}, SceneNavigator.prototype.repairStats = function(stats) {
    for (var i in this.startingStats) {
        var startingStat = this.startingStats[i];
        null == startingStat || void 0 !== stats[i] && null !== stats[i] || (stats[i] = this.startingStats[i]);
    }
}, SceneNavigator.prototype.bugLog = [], SceneNavigator.prototype.achievements = {}, 
SceneNavigator.prototype.achievementList = [], SceneNavigator.prototype.achieved = {}, 
SceneNavigator.prototype.products = {}, SceneNavigator.prototype.loadAchievements = function(achievementArray) {
    if (achievementArray) {
        this.achievements = {}, this.achievementList = [];
        for (var i = 0; i < achievementArray.length; i++) {
            var achievement = achievementArray[i], achievementName = achievement[0], visible = achievement[1], points = achievement[2], title = achievement[3], earnedDescription = achievement[4], achievement = achievement[5];
            this.achievements[achievementName] = {
                visible: visible,
                points: points,
                title: title,
                earnedDescription: earnedDescription,
                preEarnedDescription: achievement
            }, this.achievementList.push(achievementName);
        }
    }
}, SceneNavigator.prototype.loadProducts = function(productArray, purchaseMap) {
    if (productArray || purchaseMap) {
        this.products = {};
        for (var scene, i = 0; i < productArray; i++) this.products[productArray[i]] = {};
        for (scene in purchaseMap) {
            var product = purchaseMap[scene];
            this.products[product] = {};
        }
    }
}, _global = "undefined" != typeof globalThis ? globalThis : this, !function() {
    var userAgent, url, protocol, appMeta;
    "undefined" != typeof window && (userAgent = navigator.userAgent, url = window.location.href, 
    protocol = window.location.protocol, appMeta = window.document.querySelector("meta[name=apple-itunes-app]")), 
    _global.isWebOS = /webOS/.test(userAgent), _global.isMobile = _global.isWebOS || /Mobile/.test(userAgent), 
    _global.isFile = /^file:/.test(url), _global.isXul = /^chrome:/.test(url);
    try {
        _global.greenworks = require("greenworks"), _global.isGreenworks = !0;
    } catch (ignored) {}
    _global.isWinOldApp = !1;
    try {
        isWinOldApp = window.external.IsWinOldApp();
    } catch (ignored) {}
    _global.isAndroid = /Android/.test(userAgent), _global.isOmnibusApp = /CoGnibus/.test(userAgent), 
    _global.isIosApp = _global.isIosApp || _global.isOmnibusApp && !_global.isAndroid, 
    _global.isAndroidApp = _global.isAndroidApp || _global.isOmnibusApp && _global.isAndroid, 
    _global.isAmazonAndroidApp = _global.isAmazonAndroidApp || _global.isAndroidApp && _global.flavor && _global.flavor.isAmazon(), 
    _global.isWeb = !_global.isIosApp && !_global.isAndroidApp && !_global.isWinOldApp && /^https?:/.test(url), 
    _global.isSecureWeb = /^https:?$/.test(protocol), _global.isSafari = /Safari/.test(userAgent), 
    _global.isIE = /(MSIE|Trident)/.test(userAgent), _global.isIPad = /iPad/.test(userAgent), 
    _global.isIPhone = /iPhone/.test(userAgent), _global.isKindleFire = /Kindle Fire/.test(userAgent), 
    _global.isWinStoreApp = "ms-appx:" == protocol, _global.isCef = !!_global.cefQuery, 
    _global.isNode = "undefined" != typeof process, _global.isHeartsChoice = appMeta && /1487052276/.test(appMeta.getAttribute("content"));
}(), _global.loadTime = new Date().getTime();

var loginUrlBase = "https://www.choiceofgames.com/api/";

function xhrAuthRequest(method, endpoint, callback) {
    for (var paramBuilder = new Array(3 * arguments.length), i = 3; i < arguments.length; i += 2) 3 < i && paramBuilder.push("&"), 
    paramBuilder.push(arguments[i]), paramBuilder.push("="), paramBuilder.push(arguments[i + 1]);
    var params = paramBuilder.join(""), xhr = findXhr(), done = ("POST" == method ? (xhr.open(method, loginUrlBase + endpoint + ".php", !0), 
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")) : xhr.open(method, loginUrlBase + endpoint + ".php?" + params, !0), 
    !1);
    xhr.onreadystatechange = function() {
        if (!done && 4 == xhr.readyState) {
            done = !0;
            var ok = 200 == xhr.status, response = {};
            try {
                xhr.responseText && (response = JSON.parse(xhr.responseText));
            } catch (e) {
                ok = !1;
            }
            ok || (response.error || (response.error = "unknown error"), response.status = xhr.status), 
            callback && safeCall(null, function() {
                callback(ok, response);
            });
        }
    }, xhr.send(params);
}

function login(email, password, register, subscribe, callback) {
    xhrAuthRequest("POST", "login", callback, "email", encodeURIComponent(email), "password", encodeURIComponent(password), "register", register, "subscribe", subscribe);
}

function forgotPassword(email, callback) {
    xhrAuthRequest("POST", "forgot", callback, "email", encodeURIComponent(email));
}

function logout(callback) {
    document.cookie = "login=0;path=/;expires=Thu, 01 Jan 1970 00:00:01 GMT;", xhrAuthRequest("GET", "logout", callback), 
    recordLogin(!1), window.knownPurchases = null, window.registered = !1, "undefined" != typeof FB && FB.logout && FB.logout(), 
    "undefined" != typeof gapi && gapi.auth && gapi.auth.signOut && gapi.auth.signOut();
}

function recordLogin(registered, loginId, email, callback) {
    initStore() ? (registered && recordEmail(email), window.store.set("login", loginId || 0, function() {
        safeCall(null, callback);
    }), window.registered = registered) : safeTimeout(callback, 0);
}

function getRemoteEmail(callback) {
    xhrAuthRequest("GET", "getuser", callback);
}

function saveCookie(callback, slot, stats, temps, lineNum, indent) {
    return writeCookie(computeCookie(stats, temps, lineNum, indent), slot, callback);
}

function computeCookie(stats, temps, lineNum, indent) {
    var scene = stats.scene, version = (delete stats.scene, scene && (stats.sceneName = scene.name), 
    "UNKNOWN"), version = toJson({
        version: version = "undefined" != typeof window && window && window.version ? window.version : version,
        stats: stats,
        temps: temps,
        lineNum: lineNum,
        indent: indent
    });
    return stats.scene = scene, version;
}

function writeCookie(value, slot, callback) {
    _global.pseudoSave || (_global.pseudoSave = {}), slot = slot || "", _global.pseudoSave[slot] = value, 
    initStore() ? window.store.set("state" + slot, value, safeCallback(callback)) : callback && safeTimeout(callback, 0);
}

function clearCookie(callback, slot) {
    writeCookie("", slot, safeCallback(callback));
}

function areSaveSlotsSupported() {
    return !(!initStore() || "cookie" == window.Persist.type);
}

function recordSave(slot, callback) {
    areSaveSlotsSupported() ? restoreObject(initStore(), "save_list", [], function(saveList) {
        saveList.push(slot), window.store.set("save_list", toJson(saveList), safeCallback(callback));
    }) : safeTimeout(callback, 0);
}

function recordDirtySlots(slots, callback) {
    areSaveSlotsSupported() ? restoreObject(initStore(), "dirty_save_list", [], function(saveList) {
        saveSet = {};
        for (var i = 0; i < saveList.length; i++) saveSet[saveList[i]] = 1;
        for (i = 0; i < slots.length; i++) saveSet[slots[i]] || saveList.push(slots[i]);
        window.store.set("dirty_save_list", toJson(saveList), safeCallback(callback));
    }) : safeTimeout(callback, 0);
}

function recordEmail(email, callback) {
    initStore() ? (window.recordedEmail = email, window.store.set("email", email, safeCallback(callback))) : safeTimeout(callback, 0);
}

function fetchEmail(callback) {
    if (initStore()) {
        if (window.recordedEmail) return safeTimeout(function() {
            callback(window.recordedEmail);
        });
        if (window.isWeb) {
            var cookieEmail = getCookieByName("login");
            if (/@/.test(cookieEmail)) return recordEmail(cookieEmail, function() {
                callback(cookieEmail);
            });
        }
        window.store.get("email", function(ok, value) {
            safeCall(null, function() {
                var temp;
                ok && (window.recordedEmail = value), callback && (temp = callback, 
                callback = null, temp(ok && value ? value : ""));
            });
        }), safeTimeout(function() {
            var temp;
            callback && (temp = callback, callback = null, temp(""));
        }, 1e3);
    } else safeTimeout(function() {
        callback("");
    }, 0);
}

function restoreObject(store, key, defaultValue, callback) {
    store ? store.get(key, function(ok, value) {
        var result = defaultValue;
        if (ok && value) try {
            result = jsonParse(value);
        } catch (e) {}
        safeCall(null, function() {
            callback(result);
        });
    }) : safeTimeout(function() {
        callback(defaultValue);
    }, 0);
}

function getDirtySaveList(callback) {
    restoreObject(initStore(), "dirty_save_list", [], function(slotList) {
        callback(slotList);
    });
}

function remoteSaveMerger(i, callback) {
    var remoteStore = new Persist.Store(window.remoteStoreNames[i]);
    restoreObject(remoteStore, "save_list", [], function(remoteSlotList) {
        fetchSavesFromSlotList(remoteStore, remoteSlotList, 0, [], function(remoteSaveList) {
            mergeRemoteSaves(remoteSaveList, 0, function() {
                ++i < window.remoteStoreNames.length ? remoteSaveMerger(i, callback) : callback.apply(null, arguments);
            });
        });
    });
}

function getSaves(callback) {
    var remoteStore;
    window.remoteStoreNames && window.remoteStoreNames.length ? remoteSaveMerger(0, callback) : window.remoteStoreName && window.storeName != window.remoteStoreName ? restoreObject(remoteStore = new Persist.Store(window.remoteStoreName), "save_list", [], function(remoteSlotList) {
        fetchSavesFromSlotList(remoteStore, remoteSlotList, 0, [], function(remoteSaveList) {
            mergeRemoteSaves(remoteSaveList, 0, callback);
        });
    }) : restoreObject(initStore(), "save_list", [], function(localSlotList) {
        fetchSavesFromSlotList(initStore(), localSlotList, 0, [], callback);
    });
}

function fetchSavesFromSlotList(store, slotList, i, saveList, callback) {
    if (i >= slotList.length) return safeCall(null, function() {
        callback(saveList);
    });
    restoreObject(store, "state" + slotList[i], null, function(saveState) {
        saveState && (saveState.timestamp = slotList[i].substring(4), saveList.push(saveState)), 
        fetchSavesFromSlotList(store, slotList, i + 1, saveList, callback);
    });
}

function isWebSavePossible() {
    return !!initStore() && (!/^http/.test(window.location.protocol) || (document.domain == window.webSaveDomain || "localhost" == document.domain));
}

function submitRemoteSave(slot, email, subscribe, callback) {
    if (!isWebSavePossible()) return safeTimeout(function() {
        callback(!1);
    });
    window.store.get("state" + slot, function(ok, value) {
        var xhr, gameName, done;
        ok ? (ok = slot.substring(4), xhr = findXhr(), gameName = window.remoteStoreName || window.storeName, 
        gameName = "email=" + email + "&game=" + gameName + "&realGame=" + window.storeName + "&json=" + encodeURIComponent(value) + "&timestamp=" + ok + "&subscribe=" + subscribe, 
        xhr.open("POST", webSaveUrl, !0), xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), 
        done = !1, xhr.onreadystatechange = function() {
            done || 4 == xhr.readyState && (done = !0, 200 == xhr.status ? safeCall(null, function() {
                callback(!0);
            }) : recordDirtySlots([ slot ], function() {
                safeCall(null, function() {
                    callback(!1);
                });
            }));
        }, xhr.send(gameName)) : recordDirtySlots([ slot ], function() {
            asyncAlert("There was a problem uploading the saved game. This is probably a bug; please contact support@choiceofgames.com with code 17891.", function() {
                safeCall(null, function() {
                    callback(!1);
                });
            });
        });
    });
}

function submitDirtySaves(dirtySaveList, email, callback) {
    !function submitDirtySave(i) {
        dirtySaveList[i] ? submitRemoteSave(dirtySaveList[i], email, !1, function(ok) {
            ok ? submitDirtySave(i + 1) : safeCall(null, function() {
                callback(!1);
            });
        }) : window.store.remove("dirty_save_list", function() {
            safeCall(null, function() {
                callback(!0);
            });
        });
    }(0);
}

function submitAnyDirtySaves(callback) {
    callback = callback || function(ok) {};
    try {
        getDirtySaveList(function(dirtySaveList) {
            if (dirtySaveList && dirtySaveList.length) try {
                fetchEmail(function(email) {
                    email ? submitDirtySaves(dirtySaveList, email, callback) : callback(!1);
                });
            } catch (e) {
                callback(!1);
            }
        });
    } catch (e) {
        callback(!1);
    }
}

function getRemoteSaves(email, callback) {
    var xhr, gameName, done;
    isWebSavePossible() ? (xhr = findXhr(), gameName = window.remoteStoreName || window.storeName, 
    xhr.open("GET", webSaveUrl + "?email=" + email + "&game=" + gameName, !0), done = !1, 
    xhr.onreadystatechange = function() {
        if (!done && 4 == xhr.readyState) if (done = !0, 200 != xhr.status) window.console && console.log("Couldn't load remote saves. " + xhr.status + ": " + xhr.responseText), 
        safeCall(null, function() {
            callback(null);
        }); else {
            for (var save, result = jsonParse(xhr.responseText), remoteSaveList = [], i = 0; i < result.length; i++) result[i] && ((save = result[i].json) && (save.timestamp = result[i].timestamp, 
            remoteSaveList.push(save)));
            safeCall(null, function() {
                callback(remoteSaveList);
            });
        }
    }, xhr.send()) : safeTimeout(function() {
        callback([]);
    }, 0);
}

function mergeRemoteSaves(remoteSaveList, recordDirty, callback) {
    isWebSavePossible() ? restoreObject(initStore(), "save_list", [], function(localSlotList) {
        fetchSavesFromSlotList(initStore(), localSlotList, 0, [], function(localSaveList) {
            for (var localSlotMap = {}, i = 0; i < localSlotList.length; i++) localSlotMap[localSlotList[i]] = 1;
            for (var remoteSlotMap = {}, i = 0; i < remoteSaveList.length; i++) remoteSlotMap["save" + remoteSaveList[i].timestamp] = 1;
            var newRemoteSaves = 0;
            for (i = 0; i < remoteSaveList.length; i++) {
                var remoteSave = remoteSaveList[i], slot = "save" + remoteSave.timestamp;
                localSlotMap[slot] || (saveCookie(null, slot, remoteSave.stats, remoteSave.temps, remoteSave.lineNum, remoteSave.indent), 
                localSlotList.push(slot), localSaveList.push(remoteSave), newRemoteSaves++);
            }
            var dirtySaveList = [];
            for (i = 0; i < localSlotList.length; i++) remoteSlotMap[localSlotList[i]] || dirtySaveList.push(localSlotList[i]);
            function finale() {
                newRemoteSaves ? window.store.set("save_list", toJson(localSlotList), function() {
                    safeCall(null, function() {
                        callback(localSaveList, newRemoteSaves, dirtySaveList);
                    });
                }) : safeCall(null, function() {
                    callback(localSaveList, newRemoteSaves, dirtySaveList);
                });
            }
            recordDirty ? window.store.set("dirty_save_list", toJson(dirtySaveList), finale) : finale();
        });
    }) : safeTimeout(function() {
        callback([], 0, []);
    }, 0);
}

function getAppId() {
    var appBanner;
    return window.isIosApp ? (appBanner = document.querySelector("meta[name=apple-itunes-app]"), 
    /app-id=(\d+)/.exec(appBanner.getAttribute("content"))[1]) : window.isAndroidApp ? (appBanner = document.getElementById("androidLink"), 
    /id=([\.\w]+)/.exec(appBanner.href)[1]) : void 0;
}

function submitReceipts(receipts, callback) {
    console.log("submitReceipts: " + JSON.stringify(receipts)), callback = callback || function(error) {
        window.transferPurchaseCallback && window.transferPurchaseCallback(error || "done");
    };
    var error, appId = receipts.appId, count = 0;
    function submitCallback(product) {
        return function(ok, response) {
            ok || (console.log("failed: " + product + " " + JSON.stringify(response)), 
            error || (ok = /^receipt transaction already processed: (\d+) current login (\d+)$/.exec(response.error), 
            callback(ok ? "409-" + ok[1] + "-" + ok[2] : response.status + "r")), 
            error = !0), error || --count || (receipts.avoidOverrides || cacheKnownPurchases(response), 
            callback());
        };
    }
    window.isAndroidApp ? window.store.get("login", function(ok, loginId) {
        loginId = loginId || 0;
        var platform = window.isAmazonAndroidApp ? "amazon" : "google";
        if (receipts.prePurchased && "google" == platform) for (var i = 0; i < receipts.prePurchased.length; i++) {
            var product = receipts.prePurchased[i];
            count++, xhrAuthRequest("POST", "submit-device-receipt", submitCallback(product), "platform", platform, "company", receipts.company, "game_id", window.storeName, "app_package", appId, "product_id", product, "signature", encodeURIComponent(receipts.signature), "receipt", encodeURIComponent(receipts.signedData), "login_id", loginId);
        }
        if (receipts.iaps) for (var product in receipts.iaps) count++, xhrAuthRequest("POST", "submit-device-receipt", submitCallback(product), "platform", platform, "company", receipts.company, "game_id", window.storeName, "app_package", appId, "product_id", product, "receipt", encodeURIComponent(receipts.iaps[product]), "login_id", loginId);
        count || safeTimeout(function() {
            callback();
        }, 0);
    }) : callback("error");
}

function delayBreakStart(callback) {
    var nowInSeconds = Math.floor(new Date().getTime() / 1e3);
    initStore() ? window.store.get("delayBreakStart", function(ok, value) {
        var valueNum = +value;
        safeCall(null, function() {
            ok && value && !isNaN(valueNum) ? callback(valueNum) : (window.store.set("delayBreakStart", nowInSeconds), 
            callback(nowInSeconds));
        });
    }) : safeTimeout(function() {
        callback(nowInSeconds);
    }, 0);
}

function delayBreakEnd() {
    initStore() && window.store.remove("delayBreakStart");
}

function initStore() {
    if (!window.storeName) return !1;
    if (!window.store) try {
        window.store = new Persist.Store(window.storeName);
    } catch (e) {}
    return window.store;
}

function loadAndRestoreGame(slot, forcedScene) {
    function valueLoaded(ok, value) {
        safeCall(null, function() {
            var state = null;
            if (ok && value && "" + value) state = jsonParse(value); else if ("backup" == slot) return console.log("loadAndRestoreGame couldn't find backup"), 
            "undefined" != typeof alertify && alertify.log("Failed restarting chapter. Restarting the game from scratch."), 
            restartGame();
            restoreGame(state, forcedScene);
        });
    }
    return slot = slot || "", _global.pseudoSave && pseudoSave[slot] ? valueLoaded(!0, pseudoSave[slot]) : initStore() ? void window.store.get("state" + slot, valueLoaded) : restoreGame(null, forcedScene);
}

function isStateValid(state) {
    return !!state && (!!state.stats && !!state.stats.sceneName);
}

function restartGame(shouldPrompt) {
    function actuallyRestart(result) {
        result && (delayBreakEnd(), submitAnyDirtySaves(), clearCookie(function() {}, "temp"), 
        clearCookie(function() {
            _global.nav.resetStats(_global.stats), clearScreen(restoreGame);
        }, ""));
    }
    _global.blockRestart ? asyncAlert("Please wait until the timer has run out.") : shouldPrompt ? asyncConfirm("Start over from the beginning?", actuallyRestart) : actuallyRestart(!0);
}

function restoreGame(state, forcedScene, userRestored) {
    var parts, scene, secondaryMode = null, saveSlot = "", forcedSceneLabel = null;
    /\|/.test(forcedScene) && (forcedScene = (parts = forcedScene.split("|"))[0], 
    forcedSceneLabel = parts[1]), "choicescript_stats" == forcedScene ? (secondaryMode = "stats", 
    saveSlot = "temp") : "choicescript_upgrade" == forcedScene && (secondaryMode = "upgrade", 
    saveSlot = "temp"), isStateValid(state) ? (forcedScene && (state.stats.sceneName = forcedScene), 
    _global.stats = state.stats, scene = new Scene(state.stats.sceneName, state.stats, _global.nav, {
        debugMode: state.debug || _global.debug,
        secondaryMode: secondaryMode,
        saveSlot: saveSlot
    }), forcedScene || (scene.temps = state.temps, scene.lineNum = state.lineNum, 
    scene.indent = state.indent), userRestored && (scene.temps.choice_user_restored = !0)) : scene = new Scene(forcedScene || _global.nav.getStartupScene(), _global.stats, _global.nav, {
        debugMode: _global.debug,
        secondaryMode: secondaryMode,
        saveSlot: saveSlot
    }), null !== forcedSceneLabel && (scene.targetLabel = {
        label: forcedSceneLabel,
        origin: "url",
        originLine: 0
    }), safeCall(scene, scene.execute);
}

function redirectScene(sceneName, label, originLine) {
    var scene = new Scene(sceneName, window.stats, window.nav, {
        debugMode: window.debug
    });
    label && (scene.targetLabel = {
        label: label,
        origin: "choicescript_stats",
        originLine: originLine
    }), scene.redirectingFromStats = !0, clearScreen(function() {
        scene.execute();
    });
}

function transferTempStatWrites() {
    _global.isIosApp && callIos("transferwrites", JSON.stringify(tempStatWrites));
}

function getCookieByName(cookieName, ck) {
    if (ck = ck || window.document.cookie) for (var ckPairs = ck.split(/;/), i = 0; i < ckPairs.length; i++) {
        var ckNameValue = trim(ckPairs[i]).split(/=/);
        if (decodeURIComponent(ckNameValue[0]) === cookieName) return decodeURIComponent(ckNameValue[1]);
    }
    return null;
}

function parseQueryString(str) {
    if (!str) return null;
    if (!(str = String(str).substring(1))) return null;
    for (var map = {}, pairs = str.split("&"), i = pairs.length; i--; ) {
        var parts = pairs[i].split("=");
        map[parts[0]] = parts[1];
    }
    return map;
}

function trim(str) {
    return null == str ? null : str.replace(/^\s+/g, "").replace(/\s+$/g, "");
}

function findOptimalDomain(docDomain) {
    return "localhost" != (docDomain = docDomain || document.domain) && "127.0.0.1" != docDomain && !/^\d+\.\d+\.\d+\.\d+$/.test(docDomain) && (docDomain = docDomain.match(/(\w+\.\w{3}$)/)) ? docDomain[1] : null;
}

function num(x, line, sceneName) {
    errorInfo = "line " + (line = line || "UNKNOWN"), sceneName && (errorInfo = sceneName + " " + errorInfo);
    line = parseFloat(x);
    if (isNaN(line)) throw new Error(errorInfo + ": Not a number: " + x);
    if (isFinite(line)) return line;
    throw new Error(errorInfo + ": Not finite " + x);
}

function bool(x, line, sceneName) {
    if ("boolean" == typeof x) return x;
    if ("true" === x) return !0;
    if ("false" === x) return !1;
    throw errorInfo = "line " + (line = line || "UNKNOWN"), sceneName && (errorInfo = sceneName + " " + errorInfo), 
    new Error(errorInfo + ": Neither true nor false: " + x);
}

function findXhr() {
    var ieFile = isIE && isFile;
    if (window.XMLHttpRequest && !ieFile) return new window.XMLHttpRequest();
    for (var ids = [ "Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0" ], i = 0; i < 3; i++) try {
        return new ActiveXObject(ids[i]);
    } catch (e) {}
    throw new Error("Couldn't create XHR object");
}

function crc32(str, crc) {
    crc = crc || 0;
    var n;
    crc ^= -1;
    for (var i = 0, iTop = str.length; i < iTop; i++) n = 255 & (crc ^ str.charCodeAt(i)), 
    crc = crc >>> 8 ^ "0x" + crcTable.substr(9 * n, 8);
    return -1 ^ crc;
}

function simpleDateFormat(date) {
    var day = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ][date.getDay()], month = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ][date.getMonth()], minutes = date.getMinutes(), yearString = "";
    return 31536e6 < new Date().getTime() - date.getTime() && (yearString = ", " + date.getFullYear()), 
    day + ", " + month + " " + date.getDate() + yearString;
}

function simpleDateTimeFormat(date) {
    var minutes = date.getMinutes();
    return minutes < 10 && (minutes = "0" + minutes), simpleDateFormat(date) + ", " + date.getHours() + ":" + minutes;
}

function jsonParse(str) {
    if ("undefined" == typeof JSON) return eval("(" + str + ")");
    try {
        return JSON.parse(str);
    } catch (e) {
        try {
            return eval("(" + str + ")");
        } catch (e2) {
            try {
                eval("1");
            } catch (e3) {
                var str2 = (str + "").replace(/([,\{])\s*(\w+)\s*\:/g, '$1"$2":');
                try {
                    return JSON.parse(str2);
                } catch (e4) {}
            }
            return JSON.parse(str);
        }
    }
}

function cefQuerySimple(method) {
    cefQuery({
        request: method,
        onSuccess: function(response) {
            console.log(method + " success");
        },
        onFailure: function(error_code, error_message) {
            console.error(method + " error: " + error_message);
        }
    });
}

function parseDateStringInCurrentTimezone(YYYY_MM_DD, line) {
    var fullYear, oneBasedMonthNumber, result = /^(\d{4})-(\d{2})-(\d{2})$/.exec(YYYY_MM_DD);
    if (result) return fullYear = result[1], oneBasedMonthNumber = parseInt(result[2], 10), 
    result = parseInt(result[3], 10), oneBasedMonthNumber = shortMonthStrings[oneBasedMonthNumber], 
    new Date(oneBasedMonthNumber + " " + result + ", " + fullYear);
    throw new Error("line " + line + ": invalid date string " + YYYY_MM_DD);
}

function matchBracket(line, brackets, startIndex) {
    for (var openBracket = brackets[0], closeBracket = brackets[1], brackets = 0, i = startIndex; i < line.length; i++) {
        var c = line.charAt(i);
        if (c === openBracket) brackets++; else if (c === closeBracket) {
            if (!brackets) return i;
            brackets--;
        }
    }
    return -1;
}

function isStoreSceneCacheRequired() {
    if (!(initStore() && _global.purchases && _global.checkPurchase && _global.hashes) || _global.isOmnibusApp && _global.isIosApp || !hashes.scenes) return !1;
    var scene, empty = !0;
    for (scene in purchases) if (!/^fake:/.test(scene)) {
        empty = !1;
        break;
    }
    return !empty;
}

function updateSinglePaidSceneCache(sceneName, callback) {
    var fileName = (sceneName = sceneName.replace(/ /g, "_")) + ".txt.json";
    initStore() && _global.hashes && hashes.scenes && hashes.scenes[fileName] && !function actualRequest(receiptsSent) {
        var xhr = new XMLHttpRequest(), canonical = document.querySelector("link[rel=canonical]"), canonical = canonical && canonical.getAttribute("href"), canonical = (canonical = window.beta ? canonical.replace("https://www.choiceofgames.com/", "https://www.choiceofgames.com/beta/") : canonical) + "scenes/" + fileName + "?hash=" + hashes.scenes[fileName];
        xhr.open("GET", canonical), xhr.withCredentials = !0, xhr.onload = function() {
            var error, result;
            if (200 !== xhr.status) try {
                error = JSON.parse(xhr.responseText).error;
            } catch (e) {}
            if (404 === xhr.status) try {
                if ("hash doesn't match" === error) return awaitAppUpdate(function() {
                    callback("strange");
                });
            } catch (e) {
                window.console && console.error(e, e.stack);
            }
            if (403 == xhr.status && _global.isOmnibusApp && _global.isAndroidApp) {
                if (!receiptsSent) return window.receiptRequestCallback = function(receipts) {
                    window.receiptRequestCallback = null, submitReceipts(receipts, function(error) {
                        if (error) return callback(error);
                        actualRequest("receiptsSent");
                    });
                }, void androidBilling.requestReceipts();
                if ("not registered" === error || "not purchased" == error) return callback(error);
            } else if (200 !== xhr.status) return callback(xhr.status);
            try {
                result = jsonParse(xhr.responseText);
            } catch (e) {
                window.console && console.error(e, e.stack);
            }
            if (!(result && result.crc && result.lines && result.labels)) return callback("network");
            window.store.set("cache_scene_" + sceneName, xhr.responseText, function() {
                window.store.set("cache_scene_hash_" + sceneName, hashes.scenes[fileName], function() {
                    callback(null, result);
                });
            });
        }, xhr.onerror = function() {
            callback("network");
        }, console.log("updateSinglePaidSceneCache " + canonical), xhr.send();
    }();
}

function updateAllPaidSceneCaches(receiptsSent) {
    if (isStoreSceneCacheRequired()) if (_global.isOmnibusApp && _global.isAndroidApp && !receiptsSent) window.receiptRequestCallback = function(receipts) {
        submitReceipts(receipts, function() {
            updateAllPaidSceneCaches("receiptsSent");
        });
    }, androidBilling.requestReceipts(); else {
        var scene, flipped = {};
        for (scene in purchases) /^fake:/.test(scene) || (scene = scene.replace(/ /g, "_"), 
        flipped[purchases[scene]] || (flipped[purchases[scene]] = []), flipped[purchases[scene]].push(scene));
        var product, products = [];
        for (product in flipped) products.push(product);
        products.length && checkPurchase(products.join(" "), function(ok, result) {
            if (ok && result) {
                var product, sceneList = [], push = Array.prototype.push;
                for (product in flipped) result[product] && push.apply(sceneList, flipped[product]);
                if (sceneList.length) for (var i = 0; i < sceneList.length; i++) !function(i) {
                    var scene = sceneList[i], fileName = scene + ".txt.json";
                    window.store.get("cache_scene_hash_" + scene, function(ok, result) {
                        ok && result === hashes.scenes[fileName] || updateSinglePaidSceneCache(scene, function() {});
                    });
                }(i);
            }
        });
    } else window.isOmnibusApp && window.isAndroidApp && (window.receiptRequestCallback = submitReceipts, 
    androidBilling.requestReceipts());
}

function checkForAppUpdates() {
    navigator.serviceWorker && navigator.serviceWorker.getRegistration().then(function(reg) {
        reg && reg.update();
    });
}

function refreshIfAppUpdateReady() {
    if (navigator.serviceWorker) {
        if (window.controllerchanged) return window.location.reload();
        navigator.serviceWorker.getRegistration().then(function(reg) {
            if (reg.waiting) return reg.waiting.postMessage("skipWaiting"), window.location.reload();
        });
    }
}

function awaitAppUpdate(callback) {
    var calledBack, maybeCallback;
    return navigator.serviceWorker && navigator.serviceWorker.controller ? (calledBack = !1, 
    maybeCallback = function() {
        calledBack || (calledBack = !0, callback());
    }, window.controllerchanged ? maybeCallback() : (setTimeout(maybeCallback, 1e4), 
    void navigator.serviceWorker.getRegistration().then(function(reg) {
        var watchStateChange;
        return reg ? reg.waiting ? (reg.waiting.postMessage("skipWaiting"), maybeCallback()) : (watchStateChange = function() {
            "installed" == this.state && (reg.waiting && reg.waiting.postMessage("skipWaiting"), 
            maybeCallback());
        }, reg.installing && reg.installing.addEventListener("statechange", watchStateChange), 
        reg.update(), void reg.addEventListener("updatefound", function() {
            reg.installing.addEventListener("statechange", watchStateChange);
        })) : maybeCallback();
    }))) : callback();
}

function remoteConfig(variable, callback) {
    var nonce, result;
    if (_global.isOmnibusApp) return _global.isIosApp ? (nonce = "remoteConfig" + variable + +new Date(), 
    window[nonce] = function(value) {
        delete window[nonce], callback(value);
    }, void callIos("remoteconfig", variable + " " + nonce)) : (result = _global.androidRemoteConfig && androidRemoteConfig.remoteConfig(variable) || null, 
    safeTimeout(function() {
        callback(result);
    }, 0));
    safeTimeout(function() {
        callback(null);
    }, 0);
}

function autotester(sceneText, nav, sceneName, extraLabels) {
    if (19e5 < sceneText.length) throw new Error(sceneName + ": this scene is too large. It may crash on some devices");
    function log(msg) {
        "undefined" != typeof console && console.log(msg);
    }
    var inputCallback, coverage = [], sceneList = (printx = printParagraph = function(msg, parent) {}, 
    []);
    Scene.prototype.oldSceneList || (Scene.prototype.oldSceneList = Scene.prototype.scene_list), 
    Scene.prototype.scene_list = function() {
        if ("startup" != this.name || !this.screenEmpty || !this.initialCommands) throw new Error(this.lineMsg() + "Invalid scene_list instruction, only allowed at the top of startup.txt");
        for (var scenes = this.parseSceneList(), i = 0; i < scenes.length; i++) this.verifySceneFile(scenes[i]);
    }, Scene.prototype.quicktest = !0, Scene.prototype.finish = function(buttonName) {
        this.paragraph(), this.finished = !0, buttonName = this.replaceVariables(buttonName = buttonName || "Next Chapter"), 
        this.testFinish && this.testFinish();
    }, Scene.prototype.bug = function() {
        this.finished = !0;
    }, Scene.prototype.page_break = function(buttonName) {
        this.finished = !1, this.replaceVariables(buttonName), this.resetCheckedPurchases();
    }, Scene.prototype.subscribe = function() {}, Scene.prototype.feedback = function() {}, 
    Scene.prototype.save = function() {}, Scene.prototype.restore_purchases = function() {}, 
    Scene.prototype.advertisement = function() {
        if ("startup" === this.name) throw new Error(this.lineMsg() + "*advertisement is not allowed in startup.txt");
        if (/^\s*\*delay_break/.test(this.lines[this.lineNum - 1])) throw new Error(this.lineMsg() + "*advertisement is not allowed immediately after *delay_break (*delay_break includes its own advertisement)");
    }, Scene.prototype.buyButton = function(product, priceGuess, label) {
        var scene;
        seen[label] || ((scene = this.clone()).testPath.push(","), scene.testPath.push(this.lineNum + 1), 
        scene.testPath.push("$"), scene.lineNum = this.lineNum, scene.rollbackLineCoverage(), 
        scene.indent = this.indent, scene.goto(label), scene.rollbackLineCoverage(), 
        scene.resume = function() {
            this.lineNum = this.lineNum, scene.printLoop();
        }, sceneList.push(scene));
    }, Scene.prototype.delay_break = function() {}, Scene.prototype.delay_ending = function(data) {
        var data = data.split(/ /), durationInSeconds = data[0], data = data[1];
        if (isNaN(+durationInSeconds)) throw new Error(this.lineMsg() + "invalid duration");
        if (!/^\$/.test(data)) throw new Error(this.lineMsg() + "invalid price");
        this.paragraph(), this.finished = !0;
    }, Scene.prototype.check_purchase = function(data) {
        for (var products = data.split(/ /), i = 0; i < products.length; i++) this.temps["choice_purchased_" + products[i]] = !0, 
        this.nav.products && this.nav.products[products[i]] || "adfree" == products[i] || this.warning("The product " + products[i] + " wasn't declared in a *product command");
        this.temps.choice_purchase_supported = !1, this.temps.choice_purchased_everything = !0;
    }, printInput = function(target, inputOptions, callback, minimum) {
        inputCallback = function() {
            inputOptions.numeric ? callback(minimum) : callback("blah blah");
        };
    }, Scene.prototype.oldInputText || (Scene.prototype.oldInputText = Scene.prototype.input_text), 
    Scene.prototype.oldInputNumber || (Scene.prototype.oldInputNumber = Scene.prototype.input_number), 
    Scene.prototype.input_text = function(data) {
        this.oldInputText(data), this.lineNum++, inputCallback();
    }, Scene.prototype.input_number = function(data) {
        this.oldInputNumber(data), this.lineNum++, inputCallback();
    }, Scene.prototype.goto_random_scene = function(data) {
        for (var parsed = this.parseGotoRandomScene(data), i = 0; i < parsed.length; i++) {
            var name = parsed[i].name;
            this.verifySceneFile(name);
        }
        /\ballow_no_selection\b/.test(data) || (this.finished = !0);
    }, Scene.prototype.save_game = function(destinationSceneName) {
        if (!destinationSceneName) throw new Error(this.lineMsg() + "*save_game requires a destination file name, e.g. *save_game Episode2");
        this.verifySceneFile(destinationSceneName);
    }, Scene.prototype.restore_game = function(data) {
        if (this.parseRestoreGame(!1), data) {
            var result = /^cancel=(\S+)$/.exec(data);
            if (!result) throw new Error(this.lineMsg() + "invalid restore_game line: " + data);
            cancel = result[1], this.goto(cancel);
        }
    }, Scene.prototype.rollbackLineCoverage = function(lineNum) {
        lineNum = lineNum || this.lineNum, coverage[lineNum]--;
    };
    try {
        Scene.prototype.__defineGetter__("lineNum", function() {
            return this._lineNum;
        }), Scene.prototype.__defineSetter__("lineNum", function(val) {
            coverage[val] ? coverage[val]++ : coverage[val] = 1, this._lineNum = val;
        });
    } catch (e) {}
    function dojoClone(o) {
        if (!o) return o;
        if (o instanceof Array || "array" == typeof o) for (var r = [], i = 0; i < o.length; ++i) r.push(dojoClone(o[i])); else {
            if ("object" != typeof o && "function" != typeof o) return o;
            if (o.nodeType && o.cloneNode) return o.cloneNode(!0);
            if (o instanceof Date) return new Date(o.getTime());
            for (i in r = "function" == typeof o.constructor ? new o.constructor() : {}, 
            o) i in r && r[i] == o[i] || (r[i] = dojoClone(o[i]));
        }
        return r;
    }
    Scene.prototype.choice = function(data) {
        var groups = [ "choice" ];
        if (data) for (var groups = data.split(/ /), i = 0; i < groups.length; i++) if (!/^\w*$/.test(groups[i])) throw new Error(this.lineMsg() + "invalid choice group name: " + groups[i]);
        var choiceLine = this.lineNum, options = this.parseOptions(this.indent, groups);
        for (this.temps._choiceEnds || (this.temps._choiceEnds = {}), i = 0; i < options.length; i++) this.temps._choiceEnds[options[i].line - 1] = this.lineNum;
        var flattenedOptions = [];
        !function flattenOptions(list, options, flattenedOption) {
            flattenedOption = flattenedOption || {};
            for (var i = 0; i < options.length; i++) {
                var option = options[i];
                flattenedOption[option.group] = i, option.suboptions ? flattenOptions(list, option.suboptions, flattenedOption) : (flattenedOption.ultimateOption = option, 
                list.push(dojoClone(flattenedOption)));
            }
        }(flattenedOptions, options);
        for (var index = 0; index < flattenedOptions.length; index++) {
            var item = flattenedOptions[index], scene = (this.printLine(item.ultimateOption.name), 
            this.clone());
            scene.testOption = item, scene.testChoiceLine = choiceLine, scene.testPath.push(","), 
            scene.testPath.push(choiceLine + 1), scene.testPath.push("#"), scene.testPath.push(index + 1), 
            scene.testPath.push(" ("), scene.testPath.push(item.ultimateOption.line), 
            scene.testPath.push(")"), scene.resume = function() {
                this.standardResolution(this.testOption.ultimateOption);
            }, sceneList.push(scene);
        }
        this.finished = !0;
    }, Scene.prototype.clone = function() {
        this.stats.scene = null;
        var clonedStats = dojoClone(this.stats), clonedStats = new Scene(this.name, clonedStats, this.nav, {
            secondaryMode: this.secondaryMode
        });
        return clonedStats.lines = this.lines, clonedStats.labels = this.labels, 
        clonedStats.temps = dojoClone(this.temps), clonedStats.loaded = !0, clonedStats.testPath = dojoClone(this.testPath), 
        clonedStats.firstTab = this.firstTab, clonedStats.firstSpace = this.firstSpace, 
        this.stats.scene = this, clonedStats;
    }, Scene.prototype.conflictingOptions = function() {}, Scene.prototype.oldRunCommand || (Scene.prototype.oldRunCommand = Scene.prototype.runCommand), 
    Scene.prototype.runCommand = function(line) {
        return this.ignoreCoverage || !(1 < coverage[this._lineNum]) || /^\s*\*else/i.test(line) || seenInChoice[this.lineNum] ? this.oldRunCommand(line) : (this.return(), 
        !0);
    }, Scene.prototype.oldGoto || (Scene.prototype.oldGoto = Scene.prototype.goto);
    var seen = {}, seenInChoice = (Scene.prototype.goto = function(label, inChoice) {
        inChoice ? this.oldGoto(label, !0) : (inChoice = label.toLowerCase(), seen[inChoice] ? this.return() : (seen[inChoice] = 1, 
        this.oldGoto(label)));
    }, Scene.prototype.oldGosub || (Scene.prototype.oldGosub = Scene.prototype.gosub), 
    Scene.prototype.gosub = function(label, inChoice) {
        seen[label.toLowerCase()] || this.oldGosub(label);
    }, Scene.prototype.ending = function() {
        this.finished = !0;
    }, Scene.prototype.restart = Scene.prototype.ending, Scene.prototype.goto_scene = function(data) {
        data = this.parseGotoScene(data);
        this.verifySceneFile(data.sceneName), this.finished = !0;
    }, Scene.prototype.redirect_scene = function(data) {
        if ("stats" != this.secondaryMode) throw new Error(this.lineMsg() + "The *redirect_scene command can only be used from the stats screen.");
        this.goto_scene(data);
    }, Scene.prototype.gosub_scene = function(data) {
        data = this.parseGotoScene(data);
        this.verifySceneFile(data.sceneName);
    }, Scene.prototype.return = function() {
        var stackFrame;
        this.temps.choice_substack && this.temps.choice_substack.length ? (stackFrame = this.temps.choice_substack.pop(), 
        this.lineNum = stackFrame.lineNum, this.indent = stackFrame.indent) : this.finished = !0;
    }, Scene.prototype.oldElse || (Scene.prototype.oldElse = Scene.prototype.else), 
    Scene.prototype.else = function(data, inChoice) {
        inChoice ? this.oldIf("true") : this.oldElse();
    }, Scene.prototype.elseif = Scene.prototype.elsif = function(data, inChoice) {
        var stack = this.tokenizeExpr(data), stack = this.evaluateExpr(stack);
        if ("boolean" != typeof stack) throw new Error(this.lineMsg() + "Invalid boolean expression; this isn't a boolean: " + stack);
        this.else(data, inChoice);
    }, Scene.prototype.oldIf || (Scene.prototype.oldIf = Scene.prototype.if), {}), startingStats = (Scene.prototype.if = function(line, inChoice) {
        var scene, line = this.tokenizeExpr(line), line = this.evaluateExpr(line);
        if ("boolean" != typeof line) throw new Error(this.lineMsg() + "Invalid boolean expression; this isn't a boolean: " + line);
        inChoice ? seenInChoice[this.lineNum] = 1 : ((scene = this.clone()).testPath.push(","), 
        scene.testPath.push(this.lineNum + 1), scene.testPath.push("F"), scene.lineNum = this.lineNum, 
        scene.rollbackLineCoverage(), scene.indent = this.indent, scene.skipTrueBranch(), 
        scene.lineNum++, scene.rollbackLineCoverage(), scene.resume = function() {
            this.lineNum = this.lineNum, scene.printLoop();
        }, sceneList.push(scene)), this.oldIf("true");
    }, Scene.prototype.stat_chart = function() {
        this.parseStatChart();
    }, Scene.operators["/"] = function(v1, v2, line, sceneObj) {
        var name = null;
        return 0 === (v2 = num(v2, line, name = sceneObj ? sceneObj.name : name)) ? 9007199254740991 : num(v1, line, name) / num(v2, line, name);
    }, sceneName = sceneName || "test", {}), secondaryMode = ((nav = nav || {
        repairStats: function() {},
        resetStats: function() {},
        startingStats: {},
        bugLog: [],
        products: {}
    }).resetStats(startingStats), void 0);
    "choicescript_stats" == sceneName ? secondaryMode = "stats" : "choicescript_upgrade" == sceneName && (secondaryMode = "upgrade");
    var originalScene = scene = new Scene(sceneName, startingStats, nav, {
        secondaryMode: secondaryMode
    });
    for (scene.testPath = [ sceneName ], scene.loadLines(sceneText), log("executing"), 
    scene.execute(); scene = sceneList.shift(); ) log(scene.testPath.join("")), 
    scene.resume();
    if (extraLabels) for (var i = 0; i < extraLabels.length; i++) {
        var scene, extraLabel = extraLabels[i];
        for ((scene = new Scene(sceneName, startingStats, nav, {
            secondaryMode: secondaryMode
        })).lines = originalScene.lines, scene.labels = originalScene.labels, scene.loaded = !0, 
        scene.targetLabel = extraLabel, seen = {}, scene.ignoreCoverage = !0, scene.testPath = [ sceneName, ",", "goto " + extraLabel.label ], 
        log(scene.testPath.join("")), scene.execute(); scene = sceneList.shift(); ) log(scene.testPath.join("")), 
        scene.resume();
    }
    for (;scene = sceneList.shift(); ) log(scene.testPath.join("")), scene.resume();
    for (var uncovered = [], startRange = null, i = 0; i < coverage.length; i++) line = trim(originalScene.lines[i]), 
    coverage[i] ? startRange == i ? (uncovered.push(startRange), startRange = null) : startRange && (uncovered.push(startRange + "-" + i), 
    startRange = null) : null === startRange && line && !/\*(comment|bug)\b/.test(line) && (startRange = i + 1);
    return startRange && uncovered.push(startRange + "-" + (i - 1)), uncovered.length ? (log("UNCOVERED:"), 
    log(uncovered.join("\n")), [ coverage, uncovered ]) : [ coverage ];
}

webSaveDomain = "www.choiceofgames.com", webSaveUrl = "https://" + webSaveDomain + "/ajax_proxy.php/websave", 
tempStatWrites = {}, crcTable = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D", 
shortMonthStrings = [ null, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], 
nav = new SceneNavigator([ "startup" ]), stats = {};
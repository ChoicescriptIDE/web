function IDEViewModel() {
    function __normalizePath(path) {
        return path = path.replace(/\\/g, "/");
    }
    function CSIDEProject(projectData) {
        var self = this, name = ko.observable(projectData.name ? projectData.name : getLastDirName(projectData.path) ? getLastDirName(projectData.path) : "Untitled"), path = ko.observable().extend({
            normalizePaths: ""
        });
        path(projectData.path);
        var scenes = ko.observableArray([]), issues = ko.observableArray([]), console_logs = ko.observableArray([]).extend({
            rateLimit: {
                timeout: 100
            },
            callFunc: {
                func: function() {
                    setTimeout(function() {
                        var ul = $("#cs-console > ul")[0];
                        ul && (ul.scrollTop = ul.scrollHeight);
                    }, 100);
                }
            }
        }), unreadLogs = ko.observable(0), consoleOpen = ko.observable(!1), source = projectData.source, expanded = ko.observable(!1 !== projectData.expanded), locked = ko.observable(!1), readOnly = ko.observable(projectData.readOnly || !1), editing = ko.observable(!1), invalidName = ko.observable(!1);
        self.getName = ko.computed(function() {
            return name();
        }, this), self.getPath = ko.computed(function() {
            return path();
        }, this), self.getScenes = scenes, self.getIssues = ko.computed(function() {
            return issues();
        }, this), self.consoleOpen = ko.computed(function() {
            return consoleOpen();
        }, this), self.getLogs = ko.computed(function() {
            return console_logs();
        }, this), self.getUnreadLogCount = ko.computed(function() {
            return unreadLogs();
        }, this), self.issueCount = ko.computed(function() {
            return issues().length;
        }, this), self.getSource = function() {
            return source;
        }, self.isExpanded = ko.computed(function() {
            return expanded();
        }, this), self.isLocked = ko.computed(function() {
            return locked();
        }, this), self.isReadOnly = ko.computed(function() {
            return readOnly();
        }, this), self.beingEdited = ko.computed(function() {
            return editing();
        }, this), self.nameInvalid = ko.computed(function() {
            return invalidName();
        }, this), self.isDirty = ko.computed(function() {
            for (var i = 0; i < scenes().length; i++) {
                if (scenes()[i].isDirty()) return !0;
                if (i === scenes().length - 1) return !1;
            }
        }), self.getWordCount = function(exclCommandLines, selected) {
            exclCommandLines = exclCommandLines || !1;
            for (var wordCount = 0, i = 0; i < scenes().length; i++) wordCount += scenes()[i].getWordCount(exclCommandLines, selected);
            return wordCount;
        }, self.getCharCount = function(selected) {
            for (var charCount = 0, i = 0; i < scenes().length; i++) charCount += scenes()[i].getCharCount(selected);
            return charCount;
        }, self.logToConsole = function(log, type, meta) {
            "boolean" != typeof log && "number" != typeof log && "string" != typeof log || ("string" != typeof type && (type = ""),
            console_logs().length > 999 && console_logs.shift(), meta ? "string" == typeof meta.scene && "number" == typeof meta.line ? console_logs.push({
                value: log,
                type: type || "null",
                scene: meta.scene || "",
                line: meta.line || ""
            }) : (console.log(typeof meta.scene, typeof meta.line), console_logs.push({
                value: "Error: attempt to log bad meta data logged to project console!",
                type: "cm-error"
            })) : console_logs.push({
                value: log,
                type: type || "null"
            }), consoleOpen() || "system" == type || unreadLogs(unreadLogs() < 8 ? unreadLogs() + 1 : "9+"));
        }, self.toggleConsole = function(force) {
            return consoleOpen("boolean" == typeof force ? force : !consoleOpen()), consoleOpen() && unreadLogs(0),
            consoleOpen();
        }, self.clearConsole = function() {
            console_logs.removeAll();
        }, self.dismissAllIssues = function() {
            for (var issueBuffer = [], issueList = issues(), o = 0; o < issueList.length; o++) issueBuffer.push(issueList[o]);
            for (var i = 0; i < issueBuffer.length; i++) issueBuffer[i].dismiss();
            __selectTab("game");
        }, self.setExpand = function(boole, event) {
            if ("boolean" != typeof boole) return void expanded(!expanded());
            expanded(boole);
        }, self.nameInterface = ko.pureComputed({
            read: function() {
                return name();
            },
            write: function(newValue) {
                validName(newValue, !0, function(valid, errMsg) {
                    invalidName(!valid), valid ? name(newValue) : console.log(errMsg);
                });
            },
            owner: this
        }), self.rename = function(data, event) {
            if (!readOnly() && ("keyup" != event.type || 13 == event.keyCode || 27 == event.keyCode)) {
                if ("dblclick" != event.type) return invalidName() && editing() ? void 0 : (editing(!1),
                void __updatePersistenceList());
                editing(!0), setTimeout(function() {
                    $(event.target).focus().select();
                }, 10);
            }
        }, self.run = function() {
            function execRun() {
                locked() || (locked(!0), __shortCompile(self, function(err, allScenes) {
                    err ? (bootbox.alert("<h3>Compilation Error</h3>" + err.message), console.log(err)) : (cside.allScenes = allScenes,
                    notification("Running", name(), {
                        timeout: 2e3
                    }), activeProject(self), __reloadTab(__getTab("game"), "run_index.html?restart=true"),
                    cside.tabPanel("open"), __selectTab("game")), setTimeout(function() {
                        locked(!1);
                    }, 5e3);
                }));
            }
            self.isDirty() ? bootbox.confirm("This project has unsaved changes, these will not appear in the test run, do you wish to continue?", function(result) {
                result && execRun();
            }) : execRun();
        }, self.openFolder = function() {
            __openFolder(path());
        }, self.close = function() {
            __closeProject(self);
        }, self.select = function() {
            for (var i = 0; i < scenes().length; i++) if (scenes()[i].select()) return !0;
            return !1;
        }, self.save = function(cb) {
            "function" != typeof cb && (cb = function() {});
            var failed = !1, count = scenes().length;
            scenes().forEach(function(scene, index) {
                failed || scene.save(null, null, function(err) {
                    if (err) return failed = !0, cb(err);
                    0 == --count && cb(null);
                });
            });
        }, self.addNewScene = function(project, event) {
            readOnly() || (event && event.stopPropagation(), addNewScene(self));
        }, self.addScene = function(scene) {
            scene.getProject() !== self && !1 !== scene.getProject() || scenes.push(scene);
        }, self.removeScene = function(scene) {
            -1 !== scenes().lastIndexOf(scene) && (scenes.remove(scene), scenes().length < 1 && projects.remove(self));
        }, self.closeScene = function(scene) {
            function closeScene() {
                selectedScene() == scene && (selectedScene(null), editor.setValue("")), self.removeScene(scene),
                __updatePersistenceList();
            }
            scene.isDirty() ? bootbox.confirm("This scene has unsaved changes, are you sure you wish to close it?", function(result) {
                result && closeScene();
            }) : closeScene();
        }, self.exportScenes = function() {
            fh.selectFolder(function(newPath) {
                newPath && bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any files with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>", function(result) {
                    result && __copyProjectTo(path(), newPath, function(err) {
                        if (err) return void notification("Error", err.message, {
                            type: "error"
                        });
                        notification("Game Exported Successfully", "All scenes exported successfully to " + newPath, {
                            type: "success",
                            buttons: [ {
                                addClass: "btn btn-default",
                                text: "Show Folder",
                                onClick: function(note) {
                                    __openFolder(newPath), note.close();
                                }
                            } ]
                        }).setTimeout(1e4);
                    });
                });
            });
        }, self.compile = function() {
            fh.selectFolder(function(newPath) {
                newPath && bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any file with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>", function(result) {
                    result && __fullCompile(self, newPath);
                });
            });
        }, self.test = function(test) {
            __testProject(self, test);
        }, self.openAllScenes = function() {
            __openAllProjectScenes(self);
        }, self.reloadAllScenes = function() {
            for (var i = 0; i < scenes().length; i++) scenes()[i].load();
        }, self.logIssue = function(err, scene) {
            var lineNum = "number" == typeof err.lineNumber ? err.lineNumber - 1 : null, issue = new csideIssue({
                project: self,
                scene: scene,
                desc: err.message,
                lineNum: lineNum
            });
            issues.push(issue);
            var buttons = [ {
                addClass: "btn btn-danger",
                text: "Show",
                onClick: function(note) {
                    note.close(), issue.getLineNum() && issue.show(), selectedProject() == self ? __selectTab("issues") : (self.select(),
                    __selectTab("issues"));
                }
            } ];
            notification("New Issue", "New issue with project " + name(), {
                type: "error",
                buttons: buttons
            }).setTimeout(5e3);
        }, self.removeIssue = function(issue) {
            issues.remove(issue);
        };
    }
    function CSIDEScene(sceneData) {
        function saveScene(callback) {
            function finalizeSave(err) {
                err ? console.log(err) : (dirty(!1), cmDoc.markClean(), fileStats.mtime ? fileStats.mtime = new Date() : fileStats.modifiedAt = new Date()),
                saving(!1), "function" == typeof callback && callback(err);
            }
            var data = cmDoc.getValue();
            fh.writeFile(path(), data, function(err) {
                finalizeSave(err);
            });
        }
        var self = this, path = ko.observable("").extend({
            normalizePaths: ""
        });
        path(sceneData.path);
        var name = ko.observable("").extend({
            lowerCase: ""
        });
        name(getSceneName(path()));
        var isImportant = name().toUpperCase().match(reservedSceneNames), source = sceneData.source || platform, loaded = ko.observable(!1), locked = ko.observable(!1), readOnly = ko.observable(sceneData.readOnly || !1), dirty = ko.observable(!1), editing = ko.observable(!1), colouring = ko.observable(!1), saving = ko.observable(!1), inErrState = ko.observable(!1), errStateMsg = ko.observable(""), cmDoc = CodeMirror.Doc(sceneData.contents || "", "choicescript"), charCount = ko.observable(sceneData.contents ? sceneData.contents.length : 0), wordCount = ko.observable(0), selectedChars = ko.observable(0), history = cmDoc.getHistory(), fileStats = sceneData.stats || {
            mtime: new Date()
        }, markColour = ko.observable(sceneData.color ? sceneData.color : isImportant ? "rgb(119, 151, 236)" : "rgb(119, 119, 119)"), issues = ko.observableArray([]), invalidName = ko.observable(!1), nameErrMsg = ko.observable();
        self.isLocked = ko.computed(function() {
            if (locked()) return !0;
            var curScene = cside.getSelectedScene();
            return !(!curScene || !curScene.beingEdited() || curScene == self);
        }, this), self.getName = ko.computed(function() {
            return name();
        }, this), self.getPath = ko.computed(function() {
            return path();
        }, this), self.hasLoaded = ko.computed(function() {
            return loaded();
        }, this), self.isSaving = ko.computed(function() {
            return saving();
        }, this), self.isDirty = ko.computed(function() {
            return dirty();
        }, this), self.isReadOnly = ko.computed(function() {
            return readOnly();
        }, this), self.beingEdited = ko.computed(function() {
            return editing();
        }, this), self.isSelected = ko.computed(function() {
            return this === selectedScene();
        }, this), self.beingColoured = ko.computed(function() {
            return colouring();
        }, this), self.getSource = function() {
            return source;
        }, self.getProject = function() {
            return getProject(getProjectPath(path()));
        }, self.getText = function() {
            return cmDoc.getValue();
        }, self.getMarkColour = ko.computed(function() {
            return markColour();
        }, this), self.getLineHandle = function(lineNum) {
            return cmDoc.getLineHandle(lineNum);
        }, self.getLineNumber = function(lineHandle) {
            return cmDoc.getLineNumber(lineHandle);
        }, self.nameInvalid = ko.computed(function() {
            return invalidName();
        }, this), self.getNameErrorMsg = ko.computed(function() {
            return nameErrMsg();
        }, this), self.getIssues = ko.computed(function() {
            return issues();
        }, this), self.getContents = function() {
            return cmDoc.getValue();
        }, self.getErrStateMsg = ko.computed(function() {
            return errStateMsg() + " - click here to close";
        }, this), self.getErrState = ko.computed(function() {
            return inErrState();
        }, this), self.getCharCountString = function() {
            return selectedChars() > 0 ? selectedChars() + " (" + charCount() + ")" : charCount();
        }, self.getCharCount = function(selected) {
            return selected ? selectedChars() : charCount();
        }, self.getWordCountString = function() {
            var suffix = editor.getOption("exclude_cmd_lines") ? " [excl. cmds]" : " [inc. cmds]";
            if (selectedChars() > 0) {
                return __wordCount(cmDoc.getSelection(), editor.getOption("exclude_cmd_lines")) + " (" + wordCount() + ") " + suffix;
            }
            return wordCount() + suffix;
        }, self.getWordCount = function(exclCommandLines, selected) {
            return selected ? __wordCount(cmDoc.getSelection(), exclCommandLines) : __wordCount(cmDoc.getValue(), exclCommandLines);
        }, self.getState = ko.computed(function() {
            return saving() ? "fa fa-spinner fa-spin" : loaded() ? inErrState() ? "fa fa-exclamation-triangle scene-unsaved" : readOnly() ? "fa fa-lock" : dirty() ? "fa fa-save scene-unsaved" : "fa fa-save scene-saved" : "fa fa-ban";
        }), self.setText = function(value) {
            readOnly() || "string" == typeof value && cmDoc.setValue(value);
        };
        var renameSceneFile = function(newName) {
            function executeRename(err) {
                saving(!1), err ? bootbox.alert(err) : (fileStats.mtime ? fileStats.mtime = new Date() : fileStats.modifiedAt = new Date(),
                path(newPath), name(newName), __updatePersistenceList());
            }
            if (!invalidName()) {
                saving(!0);
                var newPath = self.getProject().getPath() + newName + ".txt";
                fh.renameFile(path(), newPath, function(err) {
                    executeRename(err);
                });
            }
        };
        self.nameInterface = ko.pureComputed({
            read: function() {
                return name();
            },
            write: function(newValue) {
                validName(newValue, !1, function(valid, errMsg) {
                    invalidName(!valid), valid || nameErrMsg(errMsg);
                });
            },
            owner: this
        }), self.rename = function(data, event) {
            if (!inErrState() && loaded() && !saving() && !readOnly() && ("keyup" != event.type || 13 == event.keyCode || 27 == event.keyCode)) if ("dblclick" != event.type && "click" != event.type) {
                if (invalidName() && editing()) return void $(event.target).fadeOut("fast").fadeIn("fast").focus();
                var newName = event.target.value.trim();
                newName != name() && sceneExists(newName, self.getProject(), function(exists) {
                    exists ? (notification("Failed to Rename Scene", "Scene '" + event.target.value.toLowerCase() + "' already exists in this Project", {
                        type: "error"
                    }), event.target.value = name()) : renameSceneFile(newName);
                }), editing(!1);
            } else if (isImportant) {
                if (isImportant) return void notification("", "Reserved scene cannot be renamed", {
                    type: "error",
                    layout: "bottomLeft"
                });
            } else {
                if (self.isLocked()) return;
                editing(!0), setTimeout(function() {
                    $(event.target).focus().select();
                }, 10);
            }
        }, self.recolour = function(data, event) {
            if (("mouseleave" !== event.type || colouring()) && !self.isLocked()) {
                if ("string" == typeof data && data != markColour()) {
                    var reg = new RegExp("(" + validSceneColours().join("|").replace(/\(/g, "\\(").replace(/\)/g, "\\)") + ")");
                    if (!data.match(reg)) return void console.log("Scene Recolour Error: Invalid colour");
                    markColour(data), __updatePersistenceList();
                }
                colouring(!colouring());
            }
        }, self.focusLine = function(lineNum, noArrow) {
            self !== selectedScene() && self.select(), noArrow || (editor.clearGutter("arrow-gutter"),
            editor.setGutterMarker(lineNum, "arrow-gutter", document.createTextNode("→"))),
            editor.scrollIntoView({
                line: lineNum,
                ch: 0
            }, 20);
        }, self.addIssue = function(issue) {
            if (issues.push(issue), "number" == typeof issue.getLineNum()) {
                var lh = cmDoc.getLineHandle(issue.getLineNum());
                return lh ? (cmDoc.addLineClass(lh, "background", "CodeMirror-error-background"),
                CodeMirror.on(lh, "delete", function(lineHandle, change) {
                    issues.remove(issue);
                }), lh) : null;
            }
        }, self.removeIssue = function(issue) {
            "number" == typeof issue.getLineNum() && cmDoc.removeLineClass(issue.getLineNum(), "background", "CodeMirror-error-background"),
            issues.remove(issue);
        }, self.load = function(callback) {
            function finishLoading(err, data) {
                err ? (inErrState(!0), errStateMsg(err.message), console.log(errStateMsg()), callback(err)) : (inErrState(!1),
                cmDoc.setValue(data), cmDoc.markClean(), cmDoc.clearHistory(), dirty(!1), __updatePersistenceList(),
                __testSceneIndentation(self)), loaded(!0), saving(!1), void 0 !== callback && callback(err, self);
            }
            saving() || (loaded(!1), saving(!0), "function" != typeof callback && (callback = function(err) {
                err && console.log(err.message);
            }), fh.stat(path(), function(err, newfileStats) {
                err ? finishLoading(err) : (fileStats = newfileStats, fh.readFile(path(), function(err, data) {
                    err ? finishLoading(err) : finishLoading(err, data);
                }));
            }));
        }, self.save = function(scene, event, callback) {
            function checkDate(newfileStats) {
                (newfileStats.mtime || newfileStats.modifiedAt).getTime() > lastModifiedAt.getTime() + 1e3 ? bootbox.dialog({
                    message: "'" + name() + ".txt' of <b>" + self.getProject().getName() + "</b> appears to have been modified by another program or process \t\t\t\t\t\tsince it was last saved. Are you sure you wish to save it?",
                    title: "Conflict Warning",
                    buttons: {
                        cancel: {
                            label: "Cancel",
                            callback: function() {
                                saving(!1);
                            }
                        },
                        reload: {
                            label: "Reload",
                            callback: function() {
                                saving(!1), self.load(function(err, scene) {
                                    err || scene.select();
                                });
                            }
                        },
                        yes: {
                            label: "Save",
                            className: "btn-primary",
                            callback: function() {
                                saveScene(callback);
                            }
                        }
                    },
                    onEscape: function() {
                        saving(!1);
                    }
                }) : saveScene(callback);
            }
            if (event && event.stopPropagation(), !dirty() && loaded() || inErrState() || saving() || locked() || readOnly()) return void ("function" == typeof callback && callback(null));
            saving(!0);
            var lastModifiedAt = fileStats.mtime || fileStats.modifiedAt;
            fh.stat(path(), function(err, newfileStats) {
                !err || 404 != err.code && "ENOENT" != err.code ? err ? (console.log(err), saving(!1),
                bootbox.alert("<h3>Warning</h3><p>Unable to save <b>" + name() + "</b> of <b>" + self.getProject().getName() + "</b>: " + err.message + ".</p> \t\t\t\t\t\t<p>Check your internet connection.</p>")) : checkDate(newfileStats) : saveScene(callback);
            });
        }, self.select = function() {
            if (selectedScene() !== self) return !(inErrState() || !loaded() || saving() || self.isLocked()) && (editor.clearGutter("arrow-gutter"),
            selectedScene(self), editor.swapDoc(cmDoc), self.getProject().isExpanded() || self.getProject().setExpand(!0),
            editor.setOption("readOnly", readOnly()), !0);
        }, self.close = function() {
            self.getProject().closeScene(self);
        }, self.copyTo = function(targetProject) {
            function executeCopy(err) {
                if (err) bootbox.alert(err.message), console.log(err); else {
                    var newScene = new CSIDEScene({
                        path: newPath,
                        source: source,
                        contents: cmDoc.getValue()
                    });
                    targetProject.addScene(newScene), newScene.load();
                }
            }
            if ("object" == typeof targetProject && !inErrState() && loaded() && !saving()) {
                if (targetProject.isReadOnly()) return void notification("", "Cannot Move Scene to Read-Only Project", {
                    type: "error",
                    closeWith: [ "click" ]
                });
                var newPath = targetProject.getPath() + name() + ".txt";
                fh.copyFile(path(), newPath, function(err, fileStat) {
                    executeCopy(err);
                });
            }
        }, self.moveTo = function(targetProject) {
            function executeMove(err) {
                err ? (bootbox.alert(err.message), console.log(err)) : (currentProject.removeScene(self),
                path(newPath), targetProject.addScene(self), __updatePersistenceList());
            }
            if ("object" == typeof targetProject && !inErrState() && loaded() && !saving() && !readOnly()) {
                if (isImportant) return void notification("", "Cannot Move Reserved Scene", {
                    type: "error",
                    closeWith: [ "click" ]
                });
                if (targetProject.isReadOnly()) return void notification("", "Cannot Move Scene to Read-Only Project", {
                    type: "error",
                    closeWith: [ "click" ]
                });
                var currentProject = self.getProject();
                if (targetProject !== currentProject) {
                    var newPath = targetProject.getPath() + name() + ".txt";
                    fh.renameFile(path(), newPath, function(err) {
                        executeMove(err);
                    });
                }
            }
        }, self.del = function() {
            function executeDeletion() {
                fh.deleteFile(path(), function(err) {
                    err ? bootbox.alert(err.message) : self.close();
                });
            }
            if (!inErrState() && loaded() && !saving()) return isImportant ? void notification("", "Cannot Delete Reserved Scene", {
                type: "error",
                closeWith: [ "click" ]
            }) : readOnly() ? void notification("", "Cannot Delete Read-Only Scene", {
                type: "error",
                closeWith: [ "click" ]
            }) : void bootbox.confirm("<h3>Confirm</h3><p>Are you sure you want to permanently delete '" + name() + ".txt'?</p><p style='font-size:12px;'>" + path() + "<p>", function(result) {
                result && executeDeletion();
            });
        }, CodeMirror.on(cmDoc, "beforeChange", function(cm, change) {
            saving() && loaded() && (change.cancel(), "undo" != change.origin && "redo" != change.origin || cmDoc.setHistory(history));
        }), CodeMirror.on(cmDoc, "change", function(cm, change) {
            saving() || dirty(cmDoc.isClean() ? !1 : !0), history = cmDoc.getHistory(), charCount(charCount() - change.removed.join("\n").length + change.text.join("\n").length),
            wordCount(__wordCount(cmDoc.getValue(), editor.getOption("exclude_cmd_lines")));
        }), CodeMirror.on(cmDoc, "cursorActivity", function(cm) {
            selectedChars(cmDoc.getSelection().length);
        });
    }
    function csideIssue(issueData) {
        var self = this, scene = issueData.scene || null, project = issueData.project || null;
        if (null === project) return null;
        var date, time, desc = issueData.desc || "No description available", lineHandle = null, lineNum = "number" == typeof issueData.lineNum && issueData.lineNum > -1 ? issueData.lineNum : null, d = new Date();
        if (date = d.getDate() + "/" + (d.getMonth() + 1) + "/" + d.getFullYear(), time = d.getHours() + ":" + d.getMinutes(),
        self.getScene = function() {
            return scene;
        }, self.getDesc = function() {
            return desc;
        }, self.getDate = function() {
            return date;
        }, self.getTime = function() {
            return time;
        }, self.getLineNum = function() {
            return lineHandle ? lineHandle.lineNo() : lineNum;
        }, self.dismiss = function() {
            project.removeIssue(self), scene && scene.removeIssue(self);
        }, self.show = function() {
            scene && (scene.select(), "number" == typeof self.getLineNum() && scene.focusLine(self.getLineNum(), !0));
        }, scene) {
            var lh = scene.addIssue(self);
            lh && (lineHandle = lh);
        }
    }
    function CSIDESetting(settingData) {
        var setting = this, value = ko.observable(settingData.value);
        value.extend({
            notify: "always"
        });
        var id = settingData.id, name = settingData.name, selectedOption = 0, type = settingData.type || "binary", cat = settingData.cat || "app", desc = ko.observable(settingData.desc || ""), visible = ko.observable(!0);
        if ("binary" === type) var options = [ {
            desc: "on",
            value: !0
        }, {
            desc: "off",
            value: !1
        } ]; else var options = settingData.options;
        setting.getValue = ko.computed(function() {
            return value();
        }, this), setting.getId = function() {
            return id;
        }, setting.getName = function() {
            return name;
        }, setting.getType = function() {
            return type;
        }, setting.getCat = function() {
            return cat;
        }, setting.getOptions = function() {
            return options;
        }, setting.getDesc = ko.computed(function() {
            return desc();
        }, this), setting.isVisible = ko.computed(function() {
            return visible();
        }, this), setting.setDesc = function(val) {
            desc(val);
        }, setting.apply = settingData.apply, setting.toggle = function(option, evt) {
            "binary" != type ? value(option.value) : selectedOption + 1 == options.length ? (selectedOption = 0,
            value(options[selectedOption].value)) : (selectedOption += 1, value(options[selectedOption].value));
        }, setting.setValue = function(newVal) {
            value(newVal);
        }, setting.setVisibility = function(newVal) {
            "boolean" == typeof newVal && visible(newVal);
        }, value.subscribe(function(option) {
            config.settings[cat][id] = value(), setting.apply(value()), __updateConfig();
        }), setting.extAPI = {
            getName: setting.getName,
            getType: setting.getType,
            getDesc: setting.getDesc,
            getValue: setting.getValue,
            value: value,
            toggle: setting.toggle,
            getOptions: setting.getOptions,
            isVisible: setting.isVisible
        };
    }
    function __getTab(id) {
        for (var tabs = self.tabs(), i = 0; i < tabs.length; i++) if (id === tabs[i].id) return tabs[i];
        return null;
    }
    function __getCSIDEHelp() {
        for (var i = 0; i < frames.length; i++) if (frames[i].csideHelp) return frames[i].csideHelp;
        return null;
    }
    function __openScenes(paths, selectLast) {
        for (var lastIndex = selectLast ? paths.length - 1 : paths.length, i = 0; i < lastIndex; i++) __openScene(paths[i], function() {});
        selectLast && __openScene(paths[lastIndex], function(err, scene) {
            err || scene.select();
        });
    }
    function __createImageScene(project, path) {
        var image = new Image();
        image.onload = function() {
            var canvas = document.createElement("canvas"), fileExt = getFileExtension(path), imgSceneName = (CONST_IMG_PREFIX + getLastDirName(path).replace(fileExt, "")).replace(/\s/g, "_").toLowerCase(), scenePath = project.getPath() + imgSceneName + ".txt";
            if (canvas.width = this.naturalWidth, canvas.height = this.naturalHeight, canvas.width <= 0 && canvas.height <= 0) return void notification("Image Import Failed", path, {
                type: "error"
            });
            canvas.getContext("2d").drawImage(image, 0, 0), sceneExists(imgSceneName, project, function(exists) {
                if (exists) bootbox.prompt({
                    title: "That Image Already Exists - Copy & Paste Code Below",
                    value: "*gosub_scene " + imgSceneName,
                    callback: function(result) {}
                }); else {
                    var newScene = new CSIDEScene({
                        path: scenePath,
                        source: platform
                    }), dataUrl = canvas.toDataURL();
                    newScene.setText("*comment ENCODED IMAGE FILE - DO NOT EDIT\n*comment source: " + path + "\n*comment usage: *gosub_scene " + newScene.getName() + "\n*image " + dataUrl + "\n*return"),
                    newScene.save(null, null, function(err) {
                        err ? bootbox.alert(err.message) : (notification("Image Import Successful", "", {
                            type: "success"
                        }), bootbox.prompt({
                            title: "Copy & Paste Code Below",
                            value: "*gosub_scene " + newScene.getName(),
                            callback: function(result) {}
                        }));
                    });
                }
            });
        }, image.onabort = image.onerror = function() {
            notification("Image Import Failed", path, {
                type: "error"
            });
        }, image.src = "file://" + path;
    }
    function __promptForString(callback, title, placeholder) {
        bootbox.prompt({
            title: title || "Please enter text",
            value: placeholder || "",
            callback: function(str) {
                callback("string" != typeof str ? "" : __trimWhitespace(str));
            }
        });
    }
    function addNewScene(project, name) {
        function generateName(newName) {
            sceneExists(newName, project, function(exists) {
                if (exists) {
                    var n = newName.substring(newName.lastIndexOf("_") + 1, newName.length);
                    n = isNaN(n) ? 0 : parseInt(n) + 1, generateName("Untitled_" + n);
                } else {
                    var scenePath = project.getPath() + newName + ".txt", newScene = new CSIDEScene({
                        path: scenePath,
                        source: platform,
                        readOnly: project.isReadOnly()
                    });
                    project.addScene(newScene), newScene.save(null, null, function(err) {
                        err ? bootbox.alert(err.message) : newScene.load(function(err, scene) {
                            err || scene.select();
                        });
                    });
                }
            });
        }
        if ("object" == typeof project) {
            generateName(name || "Untitled");
        }
    }
    function __addProject(project) {
        if (project instanceof CSIDEProject) return void projects.unshift(project);
        bootbox.alert("Error: Unable to add non-CSIDE Project.");
    }
    function __createProject(projectName, cb, blank) {
        blank = blank || !1, function(cpf_cb) {
            var projectPath = user.path + (projectName + "/");
            fh.makeDir(projectPath, function(err) {
                err && "EEXIST" == err.code ? (bootbox.alert("Error: That Project folder could not be created because it already exists."),
                cpf_cb(!0)) : err ? (bootbox.alert("Error: Unable to create the project folder, check your permissions."),
                cpf_cb(!0)) : cpf_cb(!1, projectPath);
            });
        }(function(err, projectPath) {
            err && cb(err);
            var project = new CSIDEProject({
                name: projectName,
                path: projectPath,
                source: platform
            });
            __addProject(project);
            var startupContents = "*title " + projectName + "\n*author " + user.name + "\n*comment your code goes here\n*finish";
            (blank ? [] : [ new CSIDEScene({
                path: projectPath + "choicescript_stats.txt",
                contents: "",
                source: platform
            }), new CSIDEScene({
                path: projectPath + "startup.txt",
                contents: startupContents,
                source: platform
            }) ]).forEach(function(scene, index) {
                scene.save(null, null, function(err) {
                    if (err) return void bootbox.alert(err.message);
                    project.addScene(scene), scene.load(function(err, scene) {
                        err || scene.select();
                    });
                });
            }), cb(null, project);
        });
    }
    function __openScene(sceneDataOrPath, callback) {
        if ("string" != typeof sceneDataOrPath) throw new Error("Error: Bad sceneData or scenePath - cannot be resolved into scene.");
        var newScene = new CSIDEScene({
            path: sceneDataOrPath,
            source: platform
        }), sceneProjectPath = getProjectPath(newScene.getPath()), sceneProject = projectIsOpen(sceneProjectPath);
        if (sceneProject) {
            if (sceneAlreadyOpen(newScene.getName(), sceneProject)) return void newScene.select();
        } else sceneProject = new CSIDEProject({
            path: sceneProjectPath,
            source: platform
        }), __addProject(sceneProject);
        sceneProject.addScene(newScene), newScene.load(callback);
    }
    function getSceneName(scenePath) {
        var sceneName = getLastDirName(scenePath);
        return sceneName.substring(0, sceneName.length - 4);
    }
    function getLastDirName(path) {
        if (("/" == path.charAt(path.length - 1) || "\\" == path.charAt(path.length - 1)) && path.length > 2 && (path = path.substring(0, path.length - 1)),
        -1 != path.lastIndexOf("/")) var divider = "/"; else var divider = "\\";
        return path.substring(path.lastIndexOf(divider) + 1, path.length);
    }
    function getFileExtension(scenePath) {
        return scenePath.substring(scenePath.lastIndexOf("."), scenePath.length);
    }
    function getProject(projectPath) {
        for (var n = 0; n < projects().length; n++) if (projects()[n].getPath() === projectPath) return projects()[n];
        return null;
    }
    function getProjectPath(scenePath) {
        return scenePath.substring(0, scenePath.lastIndexOf("/") + 1);
    }
    function sceneAlreadyOpen(sceneName, project) {
        for (var scenes = project.getScenes(), i = 0; i < scenes.length; i++) {
            if (scenes[i].getName() === sceneName) return scenes[i];
            if (i === scenes.length - 1) return !1;
        }
    }
    function projectIsOpen(projectPath) {
        for (var i = 0; i < projects().length; i++) {
            if (projects()[i].getPath() === projectPath) return projects()[i];
            if (i === projects().length - 1) return !1;
        }
    }
    function validName(name, allowSpaces, callback) {
        var err, valid = !1;
        !name || "" === name || /^\s*$/.test(name) ? err = "Name required" : !name.match(/^[\w-\s]+$/) && allowSpaces ? err = "Name contains invalid characters." : name.match(/^[\w-]+$/) || allowSpaces ? name.toUpperCase().match(reservedSceneNames) ? err = "That name is reserved" : valid = !0 : err = "Name contains invalid characters.",
        callback(valid, err);
    }
    function __trimWhitespace(str) {
        return str = str.trim(), str = str.replace(/\s{2,}/g, " ");
    }
    function __wordCount(string, exclCommandLines) {
        exclCommandLines = exclCommandLines || !1;
        var wordCount = 0;
        if (exclCommandLines) {
            var nonCommandLines = string.replace(/\*.+$/gm, "");
            nonCommandLines.replace(/^\s+|\s+$/g, "").split(/\s+/).length, wordCount = nonCommandLines.replace(/^\s+|\s+$/g, "").split(/\s+/).length;
        } else wordCount = string.replace(/^\s+|\s+$/g, "").split(/\s+/).length;
        return 1 === wordCount && "" === string && (wordCount = 0), wordCount;
    }
    function __copyProjectTo(oldPath, newPath, callback) {
        fh.readDir(oldPath, function(err, filenames) {
            if (err) return void callback(err);
            filenames = filenames.filter(function(file) {
                return ".txt" === getFileExtension(file);
            });
            for (var count = filenames.length, i = 0; i < filenames.length; i++) fh.copyFile(oldPath + filenames[i], newPath + filenames[i], function(err, data) {
                if (err) return void callback(err);
                0 == --count && callback(null);
            });
        });
    }
    function __openFolder(path) {
        usingNode ? gui.Shell.openItem(path) : fileBrowser.open(path, function(selection) {
            selection.length < 1 || (selection = selection.filter(function(file) {
                return !file.isFolder();
            }).map(function(file) {
                return file.path;
            }), __openScenes(selection, !0));
        });
    }
    function projectExists(projectPath, callback) {
        fh.stat(projectPath, function(err, stat) {
            callback(err && 404 == err.code ? !1 : "undefined" !== stat.isRemoved && 1 == stat.isRemoved ? !1 : !0);
        });
    }
    function sceneExists(sceneName, project, callback) {
        var scenePath = project.getPath() + sceneName + ".txt";
        fh.stat(scenePath, function(err, stat) {
            callback(err && 404 == err.code ? !1 : "undefined" !== stat.isRemoved && 1 == stat.isRemoved ? !1 : !0);
        });
    }
    function __closeProject(project, ask) {
        project.isDirty() ? bootbox.confirm("This project has unsaved scenes, are you sure you wish to close it?", function(result) {
            result && (project === selectedProject() && (selectedProject() == activeProject() && activeProject(null),
            selectedScene(""), editor.setValue(""), __getTab("game").href("")), projects.remove(project),
            __updatePersistenceList());
        }) : (project === selectedProject() && (selectedProject() == activeProject() && activeProject(null),
        selectedScene(""), editor.setValue(""), __getTab("game").href("")), projects.remove(project),
        __updatePersistenceList());
    }
    function __testSceneIndentation(scene) {
        for (var tabs = !1, spaces = !1, lines = scene.getText().split("\n"), i = 0; i < lines.length; i++) if (lines[i].match(/^\t+/) ? tabs = !0 : lines[i].match(/^\s+/) && (spaces = !0),
        spaces && tabs) {
            bootbox.confirm("<h3>Warning</h3><p><b>" + scene.getName() + ".txt</b> of <b>" + scene.getProject().getName() + "</b> uses both tabs and spaces for indentation. Would you like the IDE to automatically normalize all indents to your settings preference?</p>", function(result) {
                result && __normalizeSceneIndentation(scene);
            });
            break;
        }
    }
    function __normalizeSceneIndentation(scene, indentUnit) {
        var tabSize = settings.asObject("editor").tabsize;
        indentUnit = indentUnit || settings.asObject("editor").tabtype;
        var lines = scene.getText().split("\n");
        if ("spaces" == indentUnit) for (var i = 0; i < lines.length; i++) {
            var oldIndent = lines[i].match(/^\t+/);
            if (oldIndent) {
                for (var newIndent = "", c = 0; c < oldIndent[0].length * tabSize; c++) newIndent += " ";
                lines[i] = lines[i].replace(/^\t+/, newIndent);
            }
        } else {
            if ("tabs" != indentUnit) throw new Error("Scene Normalization: Bad indent unit: " + indentUnit);
            for (var i = 0; i < lines.length; i++) {
                var oldIndent = lines[i].match(/^\s+/);
                if (oldIndent) {
                    for (var newIndent = "", c = 0; c < oldIndent[0].length / tabSize; c++) newIndent += "\t";
                    lines[i] = lines[i].replace(/^\s+/, newIndent);
                }
            }
        }
        scene.setText(lines.join("\n"));
    }
    function __testProject(project, test) {
        if ("random" != test && "quick" != test) return void alert("Error: no such test as " + test + "test!");
        if (void 0 === project || "" === project) return void alert("Error: no project given to " + test + "test!");
        var path = "node_modules/cside-choicescript/" + test + "test.html";
        activeProject(project), "web-dropbox" === platform ? (project.test_win = window.open(path, "Quicktest", "toolbar=0,location=0,status=0,menubar=0,scrollbars,resizable,width=500,height=400"),
        project.test_win.addEventListener("beforeunload", function(event) {
            project.test_win = null;
        }), setTimeout(function() {
            project.test_win.title = test.toUpperCase() + "TEST - " + project.getName();
        }, 200)) : project.test_win ? (project.test_win.close(), project.test_win = null,
        __testProject(project, test)) : nw.Window.open(path, {
            focus: !0,
            width: 500,
            height: 500,
            title: ""
        }, function(test_win) {
            project.test_win = test_win, test_win.on("closed", function() {
                project.test_win.hide(), project.test_win.close(!0), project.test_win = null;
            });
        });
    }
    function __openAllProjectScenes(project) {
        function load(err, filepaths) {
            err ? console.log(err) : __openScenes(filepaths.filter(function(filepath) {
                return ".txt" === getFileExtension(filepath) && !filepath.match(CONST_IMG_PREFIX);
            }, !1).map(function(filepath) {
                return projectPath + filepath;
            }));
        }
        var projectPath = project.getPath();
        fh.readDir(projectPath, function(err, filepaths) {
            load(err, filepaths);
        });
    }
    function __reloadTab(tab, path) {
        var href = path || tab.href();
        tab.href(""), tab.href(href);
    }
    function __selectTab(id) {
        $("#tabs").tabs("option", "active", $("#" + id).index() - 1);
    }
    function __shortCompile(project, cb, transpile) {
        function addScene(fileName, data) {
            var scene = new Scene(), sceneName = getSceneName(fileName);
            try {
                scene.loadLines(data);
            } catch (err) {
                return statusBox.close(), new Error(err.message + " - " + sceneName + ".txt");
            }
            if (transpile) {
                for (var changes = [], lineNum = 0; lineNum < scene.lines.length; lineNum++) {
                    var command = /^\s*\*(\w+)(.*)/.exec(scene.lines[lineNum]);
                    if (command && cse[command[1]]) {
                        for (var block_size = 1; scene.getIndent(scene.lines[lineNum + block_size]) > scene.getIndent(scene.lines[lineNum]); ) block_size++;
                        changes.push({
                            targetLine: lineNum,
                            targetLength: block_size,
                            change: cse[command[1]].transpile(scene, command[2], lineNum, block_size)
                        });
                    }
                }
                for (var c = 0; c < changes.length; c++) Array.prototype.splice.apply(scene.lines, [ changes[c].targetLine, changes[c].targetLength ].concat(changes[c].change));
            }
            return allScenes[sceneName] = {}, allScenes[sceneName].crc = scene.temps.choice_crc,
            allScenes[sceneName].labels = scene.labels, allScenes[sceneName].lines = scene.lines,
            !1;
        }
        var statusBox = notification("Compiling... ", project.getName(), {
            closeWith: !1,
            timeout: !1
        }), allScenes = {}, failed = !1, projectPath = project.getPath();
        !function() {
            fh.readDir(projectPath, function(err, fileNames) {
                if (err) return statusBox.close(), cb(err);
                var fileNames = fileNames.filter(function(fileName) {
                    return ".txt" === getFileExtension(fileName);
                }), count = fileNames.length;
                return fileNames.forEach(function(fileName, index) {
                    fh.readFile(projectPath + fileName, function(err, data) {
                        if (!failed) return err ? (failed = !0, statusBox.close(), 404 == err.code && (err = new Error("File not found: " + fileName)),
                        cb(err)) : (err = addScene(fileName, data)) ? (statusBox.close(), cb(err)) : void (0 == --count && (statusBox.close(),
                        cb(null, allScenes)));
                    });
                }), failed ? (statusBox.close(), cb(err)) : void 0;
            });
        }();
    }
    function __fullCompile(project, path) {
        __shortCompile(project, function(err, allScenes) {
            fh.readFile("compile_head.txt", function(err, headContents) {
                fh.readFile("compile_tail.txt", function(err, tailContents) {
                    fh.writeFile(path + project.getName() + ".html", headContents + "<script>allScenes = " + JSON.stringify(allScenes) + "<\/script>" + tailContents, function(err) {
                        if (err) throw new Error("Export failed!");
                        var buttons = [ {
                            addClass: "btn btn-default",
                            text: "Show Folder",
                            onClick: function(note) {
                                __openFolder(path), note.close();
                            }
                        } ];
                        notification("Game Exported Successfully", project.getName(), {
                            type: "success",
                            buttons: buttons
                        }).setTimeout(1e4);
                    });
                });
            });
        });
    }
    function __rollbackUpdate() {
        updater.restore(function(err) {
            err ? notification("Warning - Rollback failed: Package Corrupt", err.message, {
                type: "error",
                timeout: 1e4
            }) : notification("Rollback Succesful", "The previous app package has been restored");
        });
    }
    function __update(channel) {
        if (!updating) {
            var status = notification("Downloading Update", "Do not close the program", {
                progress: !0,
                closeWith: !1,
                timeout: !1
            }), eventHandlers = {
                progress: function(val) {
                    isNaN(val) || status.setProgress(val);
                },
                error: function(title, msg) {
                    notification(title, msg, {
                        type: "error"
                    });
                }
            };
            updating = !0, updater.update(channel, eventHandlers, function(err) {
                status.close(), updating = !1, err ? (notification("Update Failed", err.message, {
                    type: "error",
                    timeout: 1e4
                }), __rollbackUpdate()) : (config.justUpdated = !0, __updateConfig(), notification("Update Complete", "Please restart the application.", {
                    closeWith: !1,
                    timeout: !1,
                    type: "success"
                }));
            });
        }
    }
    function __showUpdatePrompt(channel, update) {
        var buttons = [ {
            addClass: "btn btn-default",
            text: "Download",
            onClick: function(note) {
                note.close(), __update(channel);
            }
        }, {
            addClass: "btn btn-default",
            text: "Cancel",
            onClick: function(note) {
                note.close();
            }
        } ];
        return notification("Update Available", update.desc, {
            closeWith: !1,
            timeout: !1,
            buttons: buttons
        });
    }
    function __updateConfig() {
        var newConfig = JSON.stringify(config, null, "\t");
        localStorage.setItem("CSIDE_appConfig", newConfig);
    }
    function __updatePersistenceList() {
        config.openProjects = [], config.tabs = [];
        for (var thisProject, i = 0; i < projects().length; i++) {
            thisProject = {
                path: projects()[i].getPath(),
                source: projects()[i].getSource(),
                name: projects()[i].getName(),
                expanded: projects()[i].isExpanded(),
                openScenes: []
            };
            for (var thisScene, n = 0; n < projects()[i].getScenes().length; n++) thisScene = {
                path: projects()[i].getScenes()[n].getPath(),
                source: projects()[i].getScenes()[n].getSource(),
                color: projects()[i].getScenes()[n].getMarkColour()
            }, thisProject.openScenes.push(thisScene);
            config.openProjects.unshift(thisProject);
        }
        for (var e = 0; e < self.tabs().length; e++) config.tabs[e] = self.tabs()[e].id;
        __updateConfig();
    }
    function dragSceneEvent(arg, event, ui) {
        function execute(action) {
            sceneExists(arg.item.getName(), targetProject, function(exists) {
                exists ? ($(ui.sender).sortable("cancel"), arg.cancelDrop = !0, bootbox.alert("This project already has a scene by that name.")) : action();
            });
        }
        if (console.log(arg, arg.item, arg.targetParent, arg.targetParent(), event, ui, ui.target),
        console.log(), arg.sourceParent != arg.targetParent) {
            var targetProject = ko.dataFor(event.target), movingScene = arg.item;
            arg.cancelDrop = !0, bootbox.dialog({
                message: "Would you like to <b>move</b> or <b>copy</b> this scene to this project?",
                title: "What would you like to do?",
                buttons: {
                    copy: {
                        label: "Copy",
                        className: "btn-primary",
                        callback: function() {
                            execute(function() {
                                movingScene.copyTo(targetProject);
                            });
                        }
                    },
                    move: {
                        label: "Move",
                        callback: function() {
                            execute(function() {
                                movingScene.moveTo(targetProject);
                            });
                        }
                    },
                    cancel: {
                        label: "Cancel",
                        callback: function() {}
                    }
                }
            });
        }
    }
    function fileBrowser() {
        function fileFolderItem(data) {
            var thisFileFolder = this;
            if (thisFileFolder.is_folder = "folder" == data[".tag"] || data.isFolder || data.is_folder,
            thisFileFolder.name = data.name, thisFileFolder.path = data.path, thisFileFolder.icon = data.icon ? data.icon : data.isFolder ? "fa fa-folder-o fa-lg" : "fa fa-file-o fa-lg",
            thisFileFolder.selected = ko.observable(!1), thisFileFolder.index = data.listIndex,
            thisFileFolder.select = function(data, event, forcedValue, skipKeyCheck) {
                if (!skipKeyCheck) {
                    var selectedList = self.selection(), fullList = self.filesAndFolders();
                    if (!ctrlPressed && !shiftPressed && selectedList.length > 0) {
                        for (var s in selectedList) fullList[selectedList[s].index].selected(!1);
                        self.selection([]);
                    } else if (shiftPressed) {
                        selectedList.sort(function(a, b) {
                            return a.index - b.index;
                        });
                        var topToBottom = !1;
                        if (self.selection() < 1) for (var i = 0; i < thisFileFolder.index; i++) fullList[i].select({}, {}, !0, !0); else {
                            for (var i = 0; i < thisFileFolder.index; i++) if (fullList[i].selected()) {
                                topToBottom = !0;
                                break;
                            }
                            if (topToBottom) for (var i = selectedList[0].index; i < thisFileFolder.index; i++) fullList[i].selected() || fullList[i].select({}, {}, !0, !0); else for (var i = selectedList[selectedList.length - 1].index; i > thisFileFolder.index; i--) fullList[i].selected() || fullList[i].select({}, {}, !0, !0);
                        }
                    }
                }
                forcedValue ? thisFileFolder.selected(forcedValue) : thisFileFolder.selected() ? thisFileFolder.selected(!1) : thisFileFolder.selected(!0),
                self.selection.push(thisFileFolder);
            }, data.isFolder ? thisFileFolder.open = function() {
                self.redraw(thisFileFolder.path);
            } : thisFileFolder.open = function() {
                "function" == typeof self.callback ? (self.selection = ko.observableArray([ thisFileFolder ]),
                self.executeTask()) : self.close();
            }, thisFileFolder.dateModified = data.modifiedAt || "", "" != thisFileFolder.dateModified) {
                var parsedDate = {};
                parsedDate.day = data.modifiedAt.getDate(), parsedDate.month = data.modifiedAt.getMonth(),
                parsedDate.year = data.modifiedAt.getFullYear(), parsedDate.hours = data.modifiedAt.getHours(),
                parsedDate.mins = data.modifiedAt.getMinutes(), parsedDate.mins.toString().length < 2 && (parsedDate.mins = "0" + parsedDate.mins.toString()),
                thisFileFolder.dateModified = " - last modified at " + parsedDate.day + "/" + parsedDate.month + "/" + parsedDate.year + " at " + parsedDate.hours + ":" + parsedDate.mins;
            }
            thisFileFolder.isFolder = function() {
                return thisFileFolder.is_folder;
            };
        }
        var shiftPressed = !1, ctrlPressed = !1;
        $(document).keydown(function(e) {
            17 == e.keyCode && (e.preventDefault(), ctrlPressed = !0), 16 == e.keyCode && (e.preventDefault(),
            shiftPressed = !0);
        }), $(document).keyup(function(e) {
            17 == e.keyCode && (e.preventDefault(), ctrlPressed = !1), 16 == e.keyCode && (e.preventDefault(),
            shiftPressed = !1);
        });
        var self = this, visible = ko.observable(!1), loading = ko.observable(!1), curPath = ko.observable(""), buttonText = ko.observable("Open"), browserTitle = ko.observable("Open scenes"), stateDesc = ko.observable(""), error = ko.observable(!1);
        self.getButtonText = ko.computed(function() {
            return buttonText();
        }, this), self.getBrowserTitle = ko.computed(function() {
            return browserTitle() + ": " + curPath();
        }, this), self.isVisible = ko.computed(function() {
            return visible();
        }, this), self.isLoading = ko.computed(function() {
            return loading();
        }, this), self.getStateDesc = ko.computed(function() {
            return stateDesc();
        }, this), self.hasErrored = ko.computed(function() {
            return error();
        }, this), self.path = ko.computed(function() {
            return curPath();
        }, this), self.selectingFolder = !1, self.filesAndFolders = ko.observableArray([]),
        self.selection = ko.observableArray([]), this.cancel = function() {
            "function" == typeof self.callback && self.callback([]), self.close();
        }, this.close = function() {
            var selectedList = self.selection(), fullList = self.filesAndFolders();
            for (var s in selectedList) fullList[selectedList[s].index].selected(!1);
            self.selection([]), self.callback = null, self.selectingFolder = !1, visible(!1);
        }, this.open = function(path, callback) {
            "function" == typeof path && (callback = path, path = ""), self.selectingFolder ? (buttonText("Select"),
            browserTitle("Select a Folder")) : (buttonText("Open"), browserTitle("Open scenes")),
            self.callback = callback, path = path || curPath(), self.redraw(path), visible(!0);
        }, this.redraw = function(path) {
            stateDesc("Connecting..."), loading(!0), error(!1), curPath(path), self.filesAndFolders([]),
            self.selection([]);
            var position = 0;
            fh.readDir(path, function(err, listStats) {
                if (err) error(!0), stateDesc("Failed to connect. Please check your internet connection."); else {
                    if ("/" != curPath() && "" != curPath()) {
                        var array = curPath().split("/");
                        array.pop();
                        var parentPath = array.join("/");
                        self.filesAndFolders.push(new fileFolderItem({
                            name: "Up a level",
                            path: parentPath,
                            isFolder: !0,
                            icon: "fa fa-level-up fa-lg",
                            listIndex: position
                        })), position++;
                    }
                    for (var i = 0; i < listStats.length; i++) (listStats[i].isFolder || ".txt" == getFileExtension(listStats[i].path)) && (listStats[i].listIndex = position,
                    self.selectingFolder && !listStats[i].isFolder || (position++, self.filesAndFolders.push(new fileFolderItem(listStats[i]))));
                }
                loading(!1);
            }, !0);
        }, this.selectFolders = function(callback) {
            self.selectingFolder = !0, self.open("", callback);
        }, this.executeTask = function() {
            !self.selectingFolder && 1 == self.selection().length && self.selection()[0].isFolder() ? self.selection()[0].open() : (self.callback(self.selection()),
            self.close());
        };
    }
    function contextMenu(newTarget, newOptions) {
        var self = this, target = newTarget, options = newOptions;
        self.getTitle = function() {
            return title;
        }, self.getOptions = ko.computed(function() {
            return options();
        }, this), self.getTarget = function() {
            return target;
        };
    }
    function menuOption(newLabel, newAction, newSubMenu) {
        var self = this, label = newLabel, action = newAction, subMenu = newSubMenu;
        self.getLabel = function() {
            return label;
        }, self.getSubMenuOptions = function() {
            return subMenu;
        }, self.doAction = action;
    }
    function toolbarMenu(data) {
        var menu = this, title = ko.observable(data.title || ""), expanded = ko.observable(!1);
        menu.isActive = data.active || !0, menu.getTarget = data.target, menu.doAction = function(option) {
            expanded(!1), option.doAction(menu);
        }, menu.isExpanded = ko.computed(function() {
            return expanded();
        }, this), menu.toggle = function(force) {
            expanded("boolean" == typeof force ? force : expanded() ? !1 : !0);
        }, menu.getTitle = function() {
            return title();
        }(), menu.getOptions = ko.computed(function() {
            return data.options();
        }, this);
    }
    function CSIDE_ContextMenu() {
        var self = this;
        self.isReady = function() {
            return !0;
        };
        var menu = ko.observable();
        self.getContextMenu = ko.computed(function() {
            return menu();
        }, this), $(function() {
            function Menu(cutLabel, copyLabel, pasteLabel) {
                var menu = (require("nw.gui"), new nw.Menu()), cut = new nw.MenuItem({
                    label: cutLabel || "Cut",
                    click: function() {
                        document.execCommand("cut");
                    }
                }), copy = new nw.MenuItem({
                    label: copyLabel || "Copy",
                    click: function() {
                        document.execCommand("copy");
                    }
                }), paste = new nw.MenuItem({
                    label: pasteLabel || "Paste",
                    click: function() {
                        document.execCommand("paste");
                    }
                }), indent = new nw.MenuItem({
                    label: pasteLabel || "Indent",
                    click: function() {
                        editor.execCommand("indentMore");
                    }
                }), dedent = new nw.MenuItem({
                    label: pasteLabel || "Dedent",
                    click: function() {
                        editor.execCommand("indentLess");
                    }
                }), select = new nw.MenuItem({
                    label: "Select all",
                    click: function() {
                        editor.execCommand("selectAll");
                    }
                }), comment = new nw.MenuItem({
                    label: "Toggle block comment",
                    click: function() {
                        insertTextTags("*comment ", "", !0);
                    }
                }), dblLinebreak = new nw.MenuItem({
                    label: "Insert double line break",
                    click: function() {
                        editor.replaceSelection("\n*line_break\n*line_break\n", "end"), editor.focus();
                    }
                });
                return menu.append(cut), menu.append(copy), menu.append(paste), menu.append(indent),
                menu.append(dedent), menu.append(select), menu.append(dblLinebreak), menu.append(comment),
                menu;
            }
            usingNode && ($(".CodeMirror-scroll").on("contextmenu", function(e) {
                e.preventDefault();
            }), $("body").on("contextmenu", ".CodeMirror-code", function(e) {
                var menu = new Menu();
                e.preventDefault(), menu.popup(e.originalEvent.x, e.originalEvent.y);
            }));
        }), $(function() {
            $("#sidebar").contextmenu({
                target: "#context-menu",
                scopes: ".project-header",
                before: function(event, element) {
                    var project = ko.dataFor(element.parent().get(0));
                    return menu(new contextMenu(project, projectMenuOptions)), !0;
                }
            }), $("#main-project-wrap").contextmenu({
                target: "#context-menu",
                scopes: ".scene",
                before: function(event, element) {
                    var scene = ko.dataFor(element.get(0));
                    return !(scene.getErrState() || !scene.hasLoaded() || scene.isSaving() || scene.isLocked()) && (menu(new contextMenu(scene, sceneMenuOptions)),
                    !0);
                }
            }), $("#file-browser-ul").contextmenu({
                target: "#context-menu",
                scopes: ".file",
                before: function(event, element) {
                    var fileFolder = ko.dataFor(element.get(0));
                    return menu(fileFolder.isFolder() ? new contextMenu(fileFolder, folderMenuOptions) : new contextMenu(fileFolder, fileMenuOptions)),
                    !0;
                }
            }), $(".CodeMirror-code").contextmenu({
                target: "#context-menu",
                scopes: ".cm-spell-error",
                before: function(e, element) {
                    function replaceText(text, undo) {
                        editor.replaceSelection(text), undo && editor.getDoc().undo(), editor.focus();
                    }
                    if (!typo.working) {
                        typo.working = !0;
                        var menuElement = this.getMenu()[0];
                        menu(new contextMenu(null, ko.observableArray([ new menuOption("Working...", function() {}) ])));
                        var pos = editor.coordsChar({
                            left: e.originalEvent.x,
                            top: e.originalEvent.y
                        });
                        editor.setCursor(pos);
                        var wordCoords = editor.findWordAt(pos);
                        editor.setSelection(wordCoords.anchor, wordCoords.head);
                        var word = element.text(), menuOptions = ko.observableArray([]);
                        return typo.suggest(word, 5, function(suggestions) {
                            suggestions.length < 1 && menuOptions.push(new menuOption("No suggestions for " + word, function(menu) {}));
                            for (var i = 0; i < suggestions.length; i++) !function(i) {
                                var thisSuggestion = suggestions[i];
                                menuOptions.push(new menuOption(thisSuggestion, function(menu) {
                                    replaceText(thisSuggestion, !1), editor.focus();
                                }));
                            }(i);
                            menuOptions.push(new menuOption("Ignore '" + word + "' this session", function() {
                                userDictionary.add(word, "session"), editor.focus();
                            })), menuOptions.push(new menuOption("Add '" + word + "' to user dictionary", function() {
                                userDictionary.add(word, "persistent"), editor.focus();
                            })), typo.working = !1, menu(new contextMenu(null, menuOptions)), window.innerHeight - menuElement.offsetTop < 25 * menuOptions().length && (menuElement.style.top = menuElement.style.top.slice(0, menuElement.style.top.length - 2) - 18 * menuOptions().length + "px");
                        }), !0;
                    }
                }
            });
        });
    }
    ko.extenders.normalizePaths = function(target, option) {
        return target.subscribe(function(path) {
            target(__normalizePath(path));
        }), target;
    }, ko.extenders.lowerCase = function(target, option) {
        return target.subscribe(function(val) {
            target(val.toLowerCase());
        }), target;
    }, ko.extenders.callFunc = function(target, option) {
        return target.subscribe(function() {
            option.func();
        }), target;
    };
    var self = this;
    if (usingNode) {
        var CSIDE_version = gui.App.manifest.version, nw_version = process.versions["node-webkit"], platform = platform = "darwin" === process.platform ? "mac_os" : process.platform, updating = ("mac_os" === platform ? process.execPath.substring(0, process.execPath.lastIndexOf("/") + 1) : process.execPath.substring(0, process.execPath.lastIndexOf("\\") + 1),
        !1), autoSaveFn = null, autoUpdateCheckFn = null, autoSuggestFn = null;
        self.isUpdating = function() {
            return updating;
        };
    } else var CSIDE_version = "Dropbox Alpha", platform = "web-dropbox";
    var CONST_IMG_PREFIX = "csideimg_", user = {
        name: usingNode ? require("username").sync() : "Dropbox User",
        path: "/"
    };
    user.name = user.name.charAt(0).toUpperCase() + user.name.slice(1);
    var projectMenuOptions = ko.observableArray([ new menuOption("Add new scene", function(menu) {
        menu.getTarget().addNewScene();
    }), new menuOption("Open all scenes", function(menu) {
        menu.getTarget().openAllScenes();
    }), new menuOption("Reload all scenes", function(menu) {
        menu.getTarget().reloadAllScenes();
    }), new menuOption("Review", function(menu) {}, [ new menuOption("Word count", function(menu) {
        cside.showWordCount(menu.getTarget());
    }) ]), new menuOption("Export", function(menu) {}, [ new menuOption("All scenes to folder", function(menu) {
        menu.getTarget().exportScenes();
    }) ]), new menuOption("Open folder in " + ("mac_os" === platform ? "Finder" : "Explorer"), function(menu) {
        menu.getTarget().openFolder();
    }), new menuOption("Show/hide project", function(menu) {
        menu.getTarget().setExpand();
    }), new menuOption("Close project", function(menu) {
        menu.getTarget().close();
    }) ]), sceneMenuOptions = ko.observableArray([ new menuOption("Edit", function(menu) {}, [ new menuOption("Convert all spaces to tabs", function(menu) {
        __normalizeSceneIndentation(menu.getTarget(), "tabs");
    }), new menuOption("Convert all tabs to spaces", function(menu) {
        __normalizeSceneIndentation(menu.getTarget(), "spaces");
    }) ]), new menuOption("Review", function(menu) {}, [ new menuOption("Word count", function(menu) {
        cside.showWordCount(menu.getTarget());
    }) ]), new menuOption("Reload", function(menu) {
        menu.getTarget().load(function(err, scene) {
            err || selectedScene() !== menu.getTarget() || scene.select();
        });
    }), new menuOption("Close", function(menu) {
        menu.getTarget().close();
    }), new menuOption("Delete file", function(menu) {
        menu.getTarget().del();
    }) ]);
    usingNode && (sceneMenuOptions.push(new menuOption("Export", function(menu) {}, [ new menuOption("Copy file to folder", function(menu) {
        var scene = menu.getTarget();
        fh.selectFolder(function(newPath) {
            newPath && bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any file with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>", function(result) {
                result && fh.copyFile(scene.getPath(), newPath + scene.getName() + ".txt", function(err, data) {
                    if (err) notification("Export Failed", err.message, {
                        type: "error"
                    }); else {
                        var note, buttons = [ {
                            addClass: "btn btn-default",
                            text: "Show Folder",
                            onClick: function(note) {
                                __openFolder(newPath), note.close();
                            }
                        } ];
                        note = notification("Export Succesful", "Copied " + scene.getName() + " to " + newPath, {
                            type: "success",
                            buttons: buttons
                        }), note.setTimeout(3e3);
                    }
                });
            });
        });
    }), new menuOption("Print file", function(menu) {
        nw.Window.open("file://" + menu.getTarget().getPath(), {
            focus: !0,
            width: 800,
            height: 600
        }, function(win) {
            win.window.print();
        });
    }) ])), projectMenuOptions.splice(4, 0, new menuOption("Import", function(menu) {}, [ new menuOption("Image (as scene)", function(menu) {
        menu.getTarget().isReadOnly() || fh.selectImage(function(path) {
            path && __createImageScene(menu.getTarget(), path);
        });
    }) ])), projectMenuOptions.splice(6, 0, new menuOption("Test Project", function(menu) {}, [ new menuOption("Quicktest", function(menu) {
        menu.getTarget().test("quick");
    }), new menuOption("Randomtest", function(menu) {
        "web-dropbox" != platform ? menu.getTarget().test("random") : bootbox.alert("<h3>Apologies...</h3><p>But due to technical limitations randomtest can only be run in the Desktop version of the Choicescript IDE.</p></h3>");
    }) ])), projectMenuOptions()[5].getSubMenuOptions().push(new menuOption("Compiled game", function(menu) {
        menu.getTarget().compile();
    })));
    var projects = ko.observableArray([]), selectedScene = ko.observable(null), selectedProject = ko.computed(function() {
        return selectedScene() ? selectedScene().getProject() : null;
    });
    if (self.getSelectedProject = ko.computed(function() {
        return selectedProject();
    }, this), "mac_os" === platform) {
        var nativeMenuBar = new nw.Menu({
            type: "menubar"
        });
        "darwin" === process.platform && nativeMenuBar.createMacBuiltin("CSIDE"), win.menu = nativeMenuBar,
        function() {
            var projectMenu = new nw.Menu();
            projectMenu.getTarget = selectedProject;
            for (var subMenu, options = projectMenuOptions(), i = 0; i < options.length; i++) if (options[i].getSubMenuOptions()) {
                subMenu = new nw.Menu();
                for (var o = 0; o < options[i].getSubMenuOptions().length; o++) subMenu.append(new nw.MenuItem({
                    label: options[i].getSubMenuOptions()[o].getLabel(),
                    click: options[i].getSubMenuOptions()[o].doAction.bind(null, projectMenu)
                }));
                projectMenu.append(new nw.MenuItem({
                    label: options[i].getLabel(),
                    click: options[i].doAction.bind(null, projectMenu),
                    submenu: subMenu
                }));
            } else projectMenu.append(new nw.MenuItem({
                label: options[i].getLabel(),
                click: options[i].doAction.bind(null, projectMenu)
            }));
            var index = "mac_os" === platform ? 3 : 1;
            win.menu.insert(new nw.MenuItem({
                label: "Project",
                submenu: projectMenu
            }), index);
        }(), function() {
            var sceneMenu = new nw.Menu();
            sceneMenu.getTarget = selectedScene;
            for (var subMenu, options = sceneMenuOptions(), i = 0; i < options.length; i++) if (options[i].getSubMenuOptions()) {
                subMenu = new nw.Menu();
                for (var o = 0; o < options[i].getSubMenuOptions().length; o++) subMenu.append(new nw.MenuItem({
                    label: options[i].getSubMenuOptions()[o].getLabel(),
                    click: options[i].getSubMenuOptions()[o].doAction.bind(null, sceneMenu)
                }));
                sceneMenu.append(new nw.MenuItem({
                    label: options[i].getLabel(),
                    click: options[i].doAction.bind(null, sceneMenu),
                    submenu: subMenu
                }));
            } else sceneMenu.append(new nw.MenuItem({
                label: options[i].getLabel(),
                click: options[i].doAction.bind(null, sceneMenu)
            }));
            var index = "mac_os" === platform ? 4 : 2;
            win.menu.insert(new nw.MenuItem({
                label: "Scene",
                submenu: sceneMenu
            }), index);
        }(), "mac_os" != platform ? nw.Window.get().menu = win.menu : (ko.extenders.updateMenuBarStates = function(target, option) {
            return target.subscribe(function(scene) {
                var b = !!scene, projectIndex = "mac_os" === platform ? 3 : 1, sceneIndex = "mac_os" === platform ? 4 : 2;
                win.menu = nw.Window.get().menu;
                for (var index = projectIndex; index <= sceneIndex; index++) for (var item = 0; item < win.menu.items[index].submenu.items.length; item++) win.menu.items[index].submenu.items[item].enabled = b;
                nw.Window.get().menu = win.menu;
            }), target;
        }, selectedScene.extend({
            updateMenuBarStates: ""
        }), selectedScene.valueHasMutated());
    }
    var autoFormatMap = {
        "...": "…",
        "--": "—"
    }, reservedSceneNames = "(STARTUP|CHOICESCRIPT_STATS)", validSceneColours = ko.observableArray([ "rgb(125, 186, 125)", "rgb(172, 209, 240)", "rgb(228, 144, 150)", "rgb(237, 216, 161)", "rgb(161, 165, 237)", "rgb(224, 161, 237)", "rgb(163, 163, 163)", "rgb(230, 230, 230)" ]);
    validSceneColours = ko.observableArray([ "rgb(114, 195, 116)", "rgb(119, 151, 236)", "rgb(217, 83, 79)", "rgb(165, 147, 122)", "rgb(255, 141, 43)", "rgb(224, 121, 245)", "rgb(0, 168, 195)", "rgb(119, 119, 119)" ]);
    var uiColour = ko.observable().extend({
        notify: "always"
    });
    uiColour("90,90,90");
    var config, activeProject = (ko.observable(!1), ko.observable("")), projects = ko.observableArray([]), wordCountOn = ko.observable(!0), defaultConfig = {
        settings: {
            editor: {
                tabtype: "spaces",
                smartindent: !0,
                tabsize: "4",
                linewrap: !0,
                fontsize: "12px",
                fontfamily: "'Courier New', Courier, monospace",
                spell_dic: "en_US",
                theme: "cs-dark",
                "night-mode": !1,
                spellcheck: !0,
                autosuggest: !1,
                autoformat: !0,
                "word-count": 2,
                "visible-tabs": !1
            },
            app: {
                persist: !0,
                autosave: !0,
                cmdhelp: !1,
                "update-channel": "stable",
                "ui-colour": "90,90,90",
                "project-path": "default"
            }
        },
        justUpdated: !1,
        openProjects: [],
        userDictionary: {},
        tabs: [ "game", "issues", "settings", "help", "dictionary" ]
    };
    usingNode && defaultConfig.tabs.push("examples"), config = defaultConfig;
    try {
        storedConfig = JSON.parse(localStorage.getItem("CSIDE_appConfig"));
        for (var item in storedConfig) config[item] = storedConfig[item];
    } catch (err) {
        bootbox.alert("Sorry, there was a problem parsing your configuration settings.<br> \t\tThey have been repaired and reset to the defaults.<br><br> \t\t<b>Error:</b> " + err.message),
        localStorage.setItem("CSIDE_appConfig", JSON.stringify(defaultConfig)), config = defaultConfig;
    }
    var userDictionary = {}, fh = {
        writeFile: function(path, data, callback) {
            switch (platform) {
              case "web-dropbox":
                db.filesUpload({
                    path: path,
                    contents: data,
                    mode: {
                        ".tag": "overwrite"
                    },
                    autorename: !1
                }).then(function(response) {
                    callback(null);
                }).catch(function(err) {
                    callback(normalizeError(err));
                });
                break;

              default:
                mkdirp(getDirName(path), function(err) {
                    err ? callback(normalizeError(err)) : fs.writeFile(path, data, {
                        encoding: "utf8"
                    }, function(err) {
                        callback(normalizeError(err));
                    });
                });
            }
        },
        readFile: function(path, callback) {
            switch (platform) {
              case "web-dropbox":
                db.filesDownload({
                    path: path
                }).then(function(fileData) {
                    var reader = new FileReader();
                    reader.addEventListener("loadend", function() {
                        reader.result ? callback(null, new TextDecoder("utf-8").decode(reader.result)) : callback({});
                    }), reader.readAsArrayBuffer(fileData.result.fileBlob);
                }).catch(function(err) {
                    callback(normalizeError(err));
                });
                break;

              default:
                fs.readFile(path, {
                    encoding: "utf8"
                }, function(err, data) {
                    callback(normalizeError(err), data);
                });
            }
        },
        getDropboxImageUrl: function(path, callback) {
            // Dropbox Only
            switch (platform) {
              case "web-dropbox":
                db.filesDownload({path:path})
                  .then(function(response) {
                    try {
                      var url = window.URL.createObjectURL(response.result.fileBlob);
                      callback(null, url);
                    } catch (err) {
                      callback(normalizeError(err));
                    }
                  })
                .catch(function(err) {
                  callback(normalizeError(err));
                });
                break;
              default:
                throw new Error("getDropboxImageUrl is a Dropbox only method!");
            }
        },
        copyFile: function(oldPath, newPath, callback) {
            switch (platform) {
              case "web-dropbox":
                db.filesCopy({
                    from_path: oldPath,
                    to_path: newPath
                }).then(function(response) {
                    callback(null);
                }).catch(function(err) {
                    callback(normalizeError(err));
                });
                break;

              default:
                fs.readFile(oldPath, {
                    encoding: "utf8"
                }, function(err, data) {
                    err ? callback(normalizeError(err)) : fs.writeFile(newPath, data, function(err) {
                        callback(normalizeError(err));
                    });
                });
            }
        },
        renameFile: function(oldPath, newPath, callback) {
            switch (platform) {
              case "web-dropbox":
                db.filesMove({
                    from_path: oldPath,
                    to_path: newPath
                }).then(function(response) {
                    callback(null);
                }).catch(function(err) {
                    callback(normalizeError(err));
                });
                break;

              default:
                fs.rename(oldPath, newPath, function(err) {
                    callback(normalizeError(err));
                });
            }
        },
        deleteFile: function(path, callback) {
            switch (platform) {
              case "web-dropbox":
                db.filesDelete({
                    path: path
                }).then(function(response) {
                    callback(null);
                }).catch(function(err) {
                    callback(normalizeError(err));
                });
                break;

              default:
                trash([ path ], function(err) {
                    callback(normalizeError(err));
                });
            }
        },
        readDir: function(path, callback, dbMetaData) {
            switch (platform) {
              case "web-dropbox":
                path = "/" == path ? "" : path, db.filesListFolder({
                    path: path
                }).then(function(response) {
                    void 0 !== dbMetaData && 1 == dbMetaData ? callback(null, response.result.entries.map(function(item) {
                        return item.path = item.path_lower, item.isFolder = "folder" == item[".tag"], item;
                    })) : callback(null, response.result.entries.map(function(item) {
                        return getLastDirName(item.path_lower);
                    }));
                }).catch(function(err) {
                    callback(normalizeError(err));
                });
                break;

              default:
                fs.readdir(path, function(err, filePathArray) {
                    callback(normalizeError(err), filePathArray);
                });
            }
        },
        makeDir: function(path, callback) {
            switch (platform) {
              case "web-dropbox":
                "/" == path.slice(-1, path.length) && (path = path.slice(0, -1)), db.filesCreateFolder({
                    path: path
                }).then(function(response) {
                    callback(null);
                }).catch(function(error) {
                    err && 403 == err.status && (delete err.status, err.code = "EEXIST"), callback(normalizeError(err));
                });
                break;

              default:
                mkdirp(path, function(err) {
                    callback(normalizeError(err));
                });
            }
        },
        stat: function(path, callback) {
            switch (platform) {
              case "web-dropbox":
                db.filesGetMetadata({
                    path: path
                }).then(function(response) {
                    callback(null, {
                        mtime: new Date(response.client_modified)
                    });
                }).catch(function(err) {
                    callback(normalizeError(err));
                });
                break;

              default:
                fs.stat(path, function(err, fileStats) {
                    callback(normalizeError(err), fileStats);
                });
            }
        },
        selectFolder: function(callback) {
            switch (platform) {
              case "web-dropbox":
                fileBrowser.selectFolders(function(selection) {
                    callback(selection.length > 0 ? selection[0].path + "/" : null);
                });
                break;

              default:
                var chooser = $("#selectFolder");
                chooser.off().change(function(evt) {
                    callback($(this).val() + "/"), $(this).val("");
                }), setTimeout(function() {
                    chooser.trigger("click");
                }, 200);
            }
        },
        selectImage: function(callback) {
            switch (platform) {
              case "web-dropbox":
                bootbox.alert("TODO: Image scene import not yet implemented on the web-version.");
                break;

              default:
                var chooser = $("#getImagePaths");
                chooser.off().change(function(evt) {
                    callback($(this).val()), $(this).val("");
                }), setTimeout(function() {
                    chooser.trigger("click");
                }, 200);
            }
        }
    }, normalizeError = function(err) {
        if (!err) return null;
        if (void 0 === err.message) try {
            err.message = JSON.parse(err.responseText).error;
        } catch (e) {
            err.message = "Unable to get an error description";
        }
        if (void 0 === err.code && (err.code = err.status || "Unknown Error Code"), 409 == err.code || 429 == err.code) try {
            err.code = err.error.error[err.error.error[".tag"]][".tag"],
            err.message = "Dropbox: " + err.error.error_summary;
        } catch (e) {}
        switch (err.code) {
          case "not_found":
          case "ENOENT":
          case 404:
            err.code = 404;
        }
        return err;
    }, notification = function(title, message, options) {
        var options = options || {};
        options.theme = "cside_noty", options.layout = options.layout || "bottomRight",
        options.type = options.type || "default", options.timeout = !1 !== options.timeout && (options.timeout || 5e3),
        options.closeWith = !1 !== options.closeWith && (options.closeWith || [ "click" ]),
        options.buttons = options.buttons || null, options.animation = {
            open: {
                opacity: "toggle"
            },
            close: {
                opacity: "toggle"
            },
            easing: "swing",
            speed: 250
        }, options.text = function(title, msg) {
            return "<h5>" + title + "</h5>\t\t\t\t\t <p>" + msg + "</p>";
        }(title, message), options.progress && (options.text += "<progress value='0' max='100'></progress>");
        var n = noty(options);
        return options.progress && (n.setProgress = function(val) {
            n.$message.find(".noty_text").find("progress").val(val);
        }), n;
    };
    if (self.notification = function(title, message, options) {
        notification(title, message, options);
    }, "web-dropbox" == platform) {
        if (utils.parseQueryString(window.location.hash).access_token) {
            var db = new Dropbox.Dropbox({
                accessToken: utils.parseQueryString(window.location.hash).access_token
            });
        } else {
            var db = new Dropbox.Dropbox({
                clientId: "hnzfrguwoejpwbj"
            });
            db.getAuthenticationUrl(window.location).then(function(authUrl) {
                window.location = authUrl;
            });
        }
        db.usersGetCurrentAccount().then(function(acc) {
            user.name = acc.name.display_name;
        }).catch(function(err) {});
    }
    window.db = db;
    var dropboxAuthorised = ko.observable(!1), typo = new Typo("", "", "", {
        platform: "any"
    });
    if (self.dbAuth = ko.computed(function() {
        return dropboxAuthorised();
    }, this), self.getProjects = projects, self.getSelectedScene = ko.computed(function() {
        return selectedScene();
    }, this), self.getActiveProject = ko.computed(function() {
        return activeProject();
    }, this), self.getValidSceneColours = ko.computed(function() {
        return validSceneColours();
    }, this), self.getPlatform = function() {
        return platform;
    }, self.wordCountOn = ko.computed(function() {
        return wordCountOn();
    }), self.getUIColour = function(delta) {
        delta = delta || 0, config.settings.app["night-mode"] && (delta -= 30);
        for (var val, rgb = uiColour().split(","), i = 0; i < rgb.length; i++) val = parseInt(rgb[i]) + delta,
        val < 0 ? val = 0 : val > 255 && (val = 255), rgb[i] = val;
        return "rgb(" + rgb.join(",") + ")";
    }, self.selectTab = function(tab) {
        for (var tabs = self.tabs(), i = 0; i < tabs.length; i++) if (tab === tabs[i].id) {
            __selectTab(tab);
            break;
        }
    }, self.readFile = function(url, callback) {
        fh.readFile(url, callback);
    },
    self.getDropboxImageUrl = function(url, callback) {
        fh.getDropboxImageUrl(url, callback);
    }, self.selectScene = function(scene) {
        scene.select();
    }, self.session = {
        save: function(cb) {
            var failed = !1, count = projects().length;
            if (count < 1) return void cb(null);
            projects().forEach(function(project, index) {
                project.save(function(err) {
                    if (err) {
                        if (failed) return;
                        return failed = !0, cb(err);
                    }
                    0 == --count && cb(null);
                });
            });
        },
        isDirty: ko.computed(function() {
            for (var i = 0; i < projects().length; i++) if (projects()[i].isDirty()) return !0;
            return !1;
        })
    }, self.session.win = function() {
        var fullScreen = ko.observable(!0);
        return {
            isFullscreen: ko.computed(function() {
                return fullScreen();
            }, this),
            toggleMaximize: function() {
                fullScreen() ? win.restore() : "mac_os" === platform ? win.enterFullscreen() : win.maximize(),
                fullScreen(!fullScreen());
            }
        };
    }(), "mac_os" == platform || "web-dropbox" == platform && "MacIntel" == window.navigator.platform) var keymap = {
        "Cmd-S": function(ed) {
            selectedScene().save();
        },
        "Cmd-W": function(ed) {
            selectedScene().close();
        },
        "Cmd-N": function(ed) {
            selectedProject().addNewScene();
        },
        "Cmd-Q": function(ed) {
            usingNode && win.close();
        },
        "Shift-Cmd-S": function(ed) {
            selectedProject().save();
        },
        "Shift-Cmd-W": function(ed) {
            selectedProject().close();
        },
        "Shift-Cmd-N": function(ed) {
            self.createProject();
        },
        "Shift-Cmd-,": function(ed) {
            self.scenePanel();
        },
        "Shift-Cmd-.": function(ed) {
            self.tabPanel();
        },
        "Shift-Cmd-O": function(ed) {
            selectedProject().openAllScenes();
        },
        "Shift-Tab": function(ed) {
            ed.indentSelection("subtract");
        },
        "Cmd-O": function(ed) {
            self.openFileBrowser();
        },
        "Cmd-D": function(ed) {
            insertTextTags("${", "}");
        },
        "Cmd-B": function(ed) {
            insertTextTags("[b]", "[/b]");
        },
        "Cmd-I": function(ed) {
            insertTextTags("[i]", "[/i]");
        },
        "Cmd-T": function(ed) {
            selectedProject().test("quick");
        },
        "Shift-Cmd-T": function(ed) {
            selectedProject().test("random");
        },
        "Shift-Cmd-Enter": function(ed) {
            selectedProject().run();
        },
        "Shift-Cmd-C": function(ed) {
            selectedProject().toggleConsole() && $("#cs-console > input").focus();
        },
        "Cmd-Alt-Down": function(ed) {
            self.moveSelection("down");
        },
        "Cmd-Alt-Up": function(ed) {
            self.moveSelection("up");
        },
        F11: function(ed) {
            ed.setOption("fullScreen", !ed.getOption("fullScreen"));
        },
        Esc: function(ed) {
            ed.setOption("fullScreen", !ed.getOption("fullScreen"));
        }
    }; else var keymap = {
        "Ctrl-S": function(ed) {
            selectedScene().save();
        },
        "Ctrl-W": function(ed) {
            selectedScene().close();
        },
        "Ctrl-N": function(ed) {
            selectedProject().addNewScene();
        },
        "Ctrl-O": function(ed) {
            self.openFileBrowser();
        },
        "Shift-Ctrl-O": function(ed) {
            selectedProject().openAllScenes();
        },
        "Shift-Ctrl-S": function(ed) {
            selectedProject().save();
        },
        "Shift-Ctrl-W": function(ed) {
            selectedProject().close();
        },
        "Shift-Ctrl-N": function(ed) {
            self.createProject();
        },
        "Shift-Ctrl-,": function(ed) {
            self.scenePanel();
        },
        "Shift-Ctrl-.": function(ed) {
            self.tabPanel();
        },
        "Shift-Ctrl-Q": function(ed) {
            usingNode && win.close();
        },
        "Shift-Tab": function(ed) {
            ed.indentSelection("subtract");
        },
        "Ctrl-D": function(ed) {
            insertTextTags("${", "}");
        },
        "Ctrl-B": function(ed) {
            insertTextTags("[b]", "[/b]");
        },
        "Ctrl-I": function(ed) {
            insertTextTags("[i]", "[/i]");
        },
        "Ctrl-T": function(ed) {
            selectedProject().test("quick");
        },
        "Shift-Ctrl-T": function(ed) {
            selectedProject().test("random");
        },
        "Shift-Ctrl-Enter": function(ed) {
            selectedProject().run();
        },
        "Shift-Ctrl-C": function(ed) {
            selectedProject().toggleConsole() && $("#cs-console > input").focus();
        },
        "Shift-Ctrl-Down": function(ed) {
            self.moveSelection("down");
        },
        "Shift-Ctrl-Up": function(ed) {
            self.moveSelection("up");
        },
        F11: function(ed) {
            ed.setOption("fullScreen", !ed.getOption("fullScreen"));
        },
        Esc: function(ed) {
            ed.setOption("fullScreen", !ed.getOption("fullScreen"));
        }
    };
    var editor = CodeMirror.fromTextArea(document.getElementById("code-textarea"), {
        mode: {
            name: "choicescript",
            version: 2,
            singleLineStringErrors: !1
        },
        lineNumbers: !0,
        lineWrapping: !0,
        tabSize: 4,
        indentUnit: 4,
        indentWithTabs: !0,
        matchBrackets: !0,
        extraKeys: keymap,
        gutters: [ "arrow-gutter", "CodeMirror-linenumbers" ]
    });
    self.moveSelection = function(direction) {
        if ("up" === direction || "down" === direction) for (var selections = editor.listSelections(), i = 0; i < selections.length; i++) {
            var top = selections[i].from(), bottom = selections[i].to(), alpha = "down" === direction ? 1 : -1;
            if (void 0 === editor.getLine(top.line + alpha) || void 0 === editor.getLine(bottom.line + alpha)) return;
            0 === bottom.ch && (bottom.line--, bottom.ch = editor.getLine(bottom.line).length);
            var storeLine = "down" === direction ? editor.getLine(bottom.line + alpha) : editor.getLine(top.line + alpha), movingLines = editor.getRange({
                line: top.line,
                ch: 0
            }, {
                line: bottom.line,
                ch: editor.getLine(bottom.line).length
            });
            editor.replaceRange(movingLines, {
                line: top.line + alpha,
                ch: 0
            }, {
                line: bottom.line + alpha,
                ch: editor.getLine(bottom.line + alpha).length
            }), "down" === direction ? editor.replaceRange(storeLine, {
                line: top.line,
                ch: 0
            }, {
                line: top.line,
                ch: editor.getLine(top.line).length
            }) : editor.replaceRange(storeLine, {
                line: bottom.line,
                ch: 0
            }, {
                line: bottom.line,
                ch: editor.getLine(bottom.line).length
            }), editor.setSelection({
                line: top.line + alpha,
                ch: 0
            }, {
                line: bottom.line + alpha,
                ch: editor.getLine(bottom.line + alpha).length
            });
        }
    };
    editor.addOverlay(function() {
        var word = new RegExp(/([A-Za-z\u00C0-\u00FF\u0100-\u017F]+'[A-Za-z\u00C0-\u00FF\u0100-\u017F]+|[A-Za-z\u00C0-\u00FF\u0100-\u017F]{2,}|[AaI]'?)(?=$|[\s\.,:;\?'\-\!—…])/g), cmd = new RegExp(/^\s*\*[A-Za-z_]+\b/);
        new RegExp(/\{.*\}/g);
        return {
            token: function(stream) {
                if (0 === stream.pos) {
                    var cmd_match = cmd.exec(stream.string);
                    cmd_match && (stream.pos += cmd_match[0].length || 1);
                }
                word.lastIndex = stream.pos;
                var word_match = word.exec(stream.string);
                if (word_match && word_match.index == stream.pos) return stream.pos += word_match[0].length || 1,
                cside.spellCheck(word_match[0]) ? style = "null" : style = "spell-error";
                word_match ? stream.pos++ : stream.skipToEnd();
            }
        };
    }()), editor.on("dragover", function(cm, e) {
        $(".CodeMirror-cursors .CodeMirror-cursor").css("visibility", "visible");
        var xy = {
            left: e.x,
            top: e.y
        }, newPos = editor.coordsChar(xy);
        editor.setCursor(newPos);
    }), editor.on("dragstart", function(cm, e) {
        e.dataTransfer.setData("Text", editor.getSelection());
    }), editor.on("renderLine", function(cm, line, elt) {
        var charWidth = editor.defaultCharWidth(), off = CodeMirror.countColumn(line.text, null, cm.getOption("tabSize")) * charWidth, pixelTabSize = 8 * editor.options.tabSize, indentLevel = off / pixelTabSize, leftMargin = pixelTabSize * indentLevel;
        elt.style.paddingLeft = leftMargin + "px", elt.style.textIndent = "-" + leftMargin / (indentLevel + 1) + "px";
    }), editor.on("inputRead", function(cm, change) {
        if (1 == change.text.length) {
            if (editor.getOption("autoformat")) {
                var tok = cm.getTokenAt(change.from);
                if ("formattable" == tok.type) {
                    var replacement = autoFormatMap[tok.string];
                    void 0 !== replacement && (cm.changeGeneration(!0), cm.replaceRange(replacement, {
                        line: change.from.line,
                        ch: tok.start
                    }, {
                        line: change.from.line,
                        ch: tok.end
                    }));
                }
            }
            editor.getOption("autosuggest") && change.text[0].match(/\w$/) && (autoSuggestFn && clearTimeout(autoSuggestFn),
            autoSuggestFn = setTimeout(function() {
                CodeMirror.showHint(cm, null, {
                    completeSingle: !1,
                    extraKeys: {
                        Enter: function() {
                            return !1;
                        }
                    }
                });
            }, 150));
        }
    }), editor.refresh(), editor.forceSyntaxRedraw = function() {
        editor.setOption("mode", "choicescript");
    };
    var insertTextTags = function(tagStart, tagEnd, allowSpecialLines) {
        var text = editor.getSelection(), cursorLoc = "around";
        if (text) {
            var line, whitespace;
            text = text.split("\n");
            for (var i = 0; i < text.length; i++) "" !== (line = text[i]) && (allowSpecialLines || !line.match(/^\s*\*[A-Za-z_]+\b/) && !line.match(/^\s*#/)) && ((whitespace = line.match(/^\s+/g)) && (line = line.replace(/^\s+/g, "")),
            line = line.substring(0, tagStart.length) === tagStart && line.substring(line.length - tagEnd.length, line.length) === tagEnd ? line.substring(tagStart.length, line.length - tagEnd.length) : tagStart + line + tagEnd,
            whitespace = whitespace || "", text[i] = whitespace + line);
            text = text.join("\n");
        } else text = tagStart + tagEnd, cursorLoc = "start";
        editor.replaceSelection(text, cursorLoc), "start" === cursorLoc && editor.setCursor(editor.getCursor().line, editor.getCursor().ch + tagStart.length);
    }, __csideTabs = {
        game: {
            id: "game",
            title: "Game",
            showTitle: !0,
            iconClass: "fa fa-cube",
            href: ko.observable(""),
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: ko.computed(function() {
                return activeProject() ? activeProject().getName() : "Run a Project";
            }, this)
        },
        issues: {
            id: "issues",
            title: "Issues",
            showTitle: !0,
            iconClass: "fa fa-exclamation-triangle",
            href: "",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: ko.computed(function() {
                return selectedProject() ? "Issues with " + selectedProject().getName() : "Select a Project";
            }, this)
        },
        settings: {
            id: "settings",
            title: "Settings",
            showTitle: !1,
            iconClass: "fa fa-cog",
            href: "",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: ""
        },
        help: {
            id: "help",
            title: "Help & Information",
            showTitle: !0,
            iconClass: "fa fa-question-circle",
            href: "help/index.html",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: "Help & Information"
        },
        dictionary: {
            id: "dictionary",
            title: "User Dictionary",
            showTitle: !0,
            iconClass: "fa fa-book",
            href: "",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: "User Dictionary"
        },
        examples: {
            id: "examples",
            title: "Example Projects & Templates",
            showTitle: !0,
            iconClass: "fa fa-lightbulb-o",
            href: "",
            content: "",
            visible: ko.observable(!0),
            getHeaderTitle: "Example Projects & Templates"
        }
    };
    self.tabs = ko.observableArray([]), usingNode && (self.cs_examples = [ {
        title: "Interactive CSIDE Tutorial",
        desc: "A great starting point tutorial - developed by Vendetta. Useful for those new to both Choicescript and the Choicescript IDE.",
        path: "cs_examples/CSIDE Tutorial/"
    }, {
        title: "ChoiceScript Basics Tutorial",
        desc: "A simple tutorial template by FairyGodfeather. This example project is designed to get you started with handling name, gender and relationship stats in your ChoiceScript games. A great starting point for any new project!",
        path: "cs_examples/Basics Tutorial/"
    }, {
        title: "Pronouns with Gender-Neutral Options Template",
        desc: 'A template for including gender neutral pronouns in your game (they/them), created by Lynnea Glasser. This includes a variable system to make sure your verbs and pronouns will match ("They go on ahead"/"She goes on ahead").',
        path: "cs_examples/GNO Pronoun Template/"
    } ], self.cloneExample = function(data) {
        self.createProject("", function(err, project) {
            if (err) return void notification("Error", err.message, {
                type: "error"
            });
            __copyProjectTo(data.path, project.getPath(), function(err) {
                if (err) return void notification("Error", err.message, {
                    type: "error"
                });
                project.openAllScenes(), notification("Import Successful", data.title + " imported to " + project.getPath(), {
                    type: "success"
                });
            });
        }, !0);
    });
    var settings = {
        editor: ko.observableArray([ new CSIDESetting({
            id: "smartindent",
            name: "Smart Indentation",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Automatically indent (or dedent) the cursor after flow-control commands",
            apply: function(val) {
                val ? editor.setOption("smartIndent", !0) : editor.setOption("smartIndent", !1);
            }
        }), new CSIDESetting({
            id: "linewrap",
            name: "Line Wrapping",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Wrap lines that exceed the editor's width (no horizontal scrolling)",
            apply: function(val) {
                val ? (editor.setOption("lineWrapping", !0), editor.on("renderLine", function(cm, line, elt) {
                    var off = CodeMirror.countColumn(line.text, null, cm.getOption("tabSize")) * editor.defaultCharWidth(), pixelTabSize = 8 * editor.options.tabSize, indentLevel = off / pixelTabSize, leftMargin = pixelTabSize * indentLevel;
                    elt.style.paddingLeft = leftMargin + "px", elt.style.textIndent = "-" + leftMargin / (indentLevel + 1) + "px";
                }), editor.refresh()) : (delete editor._handlers.renderLine, editor.setOption("lineWrapping", !1),
                editor.refresh());
            }
        }), new CSIDESetting({
            id: "autosuggest",
            name: "Auto Suggest",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Prompt quick-complete word suggestions as you type",
            apply: function(val) {
                editor.setOption("autosuggest", val);
            }
        }), new CSIDESetting({
            id: "autoformat",
            name: "Auto Format",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Automatically replace certain character combinations with their formatted equivalents",
            apply: function(val) {
                editor.setOption("autoformat", val);
            }
        }), new CSIDESetting({
            id: "spellcheck",
            name: "Spell Check",
            value: !0,
            type: "binary",
            cat: "editor",
            desc: "Spell checks words as you type - excluding those on command and option lines",
            apply: function(val) {
                editor.setOption("spellcheck", val), editor.forceSyntaxRedraw();
            }
        }), new CSIDESetting({
            id: "spell_dic",
            name: "Spell Check Dictionary",
            value: "en_US",
            type: "variable",
            cat: "editor",
            options: [ {
                desc: "US",
                value: "en_US"
            }, {
                desc: "GB",
                value: "en_GB"
            } ],
            desc: "The dictionary to spellcheck against",
            apply: function(val) {
                typo = new Typo(val, typo._readFile("lib/typo/dictionaries/" + val + "/" + val + ".aff"), typo._readFile("lib/typo/dictionaries/" + val + "/" + val + ".dic"), {
                    platform: "any"
                }), editor.forceSyntaxRedraw();
            }
        }), new CSIDESetting({
            id: "visible-tabs",
            name: "Visible Tabs",
            value: !1,
            type: "binary",
            cat: "editor",
            desc: "Provides visible indentation levels when using Tabs as the indentation unit",
            apply: function(val) {
                val ? document.getElementById("editor-wrap").classList.add("visible-tabs") : document.getElementById("editor-wrap").classList.remove("visible-tabs");
            }
        }), new CSIDESetting({
            id: "word-count",
            name: "Word Count",
            value: 2,
            type: "variable",
            cat: "editor",
            desc: "Display the current scene's word and character counts at the bottom of the editor window",
            options: [ {
                desc: "Exclude cmd lines",
                value: 2
            }, {
                desc: "Include cmd lines",
                value: 1
            }, {
                desc: "Off",
                value: 0
            } ],
            apply: function(val) {
                wordCountOn(val > 0), editor.setOption("word_count", val > 0), editor.setOption("exclude_cmd_lines", val > 1);
            }
        }), new CSIDESetting({
            id: "tabtype",
            name: "Tab Type",
            value: "tabs",
            type: "variable",
            cat: "editor",
            desc: "",
            options: [ {
                desc: "Tabs",
                value: "tabs"
            }, {
                desc: "Spaces",
                value: "spaces"
            } ],
            desc: "Sets the indentation unit (used by smart indent)",
            apply: function(val) {
                "spaces" == val ? (editor.setOption("indentWithTabs", !1), keymap.Tab = function(cm) {
                    if (cm.somethingSelected()) cm.indentSelection("add"); else {
                        var spaces = Array(cm.getOption("indentUnit") + 1).join(" ");
                        cm.replaceSelection(spaces);
                    }
                }) : (editor.setOption("indentWithTabs", !0), keymap.Tab = function() {
                    editor.execCommand("defaultTab");
                });
            }
        }), new CSIDESetting({
            id: "tabsize",
            name: "Tab/Indent Block Size",
            value: "4",
            type: "variable",
            cat: "editor",
            options: [ {
                desc: "2",
                value: "2"
            }, {
                desc: "4",
                value: "4"
            }, {
                desc: "6",
                value: "6"
            }, {
                desc: "8",
                value: "8"
            } ],
            desc: "The number of spaces to indent by, or the visual size of tabs (used by smart indent)",
            apply: function(val) {
                var intVal = parseInt(val, 10);
                editor.setOption("indentUnit", intVal), editor.setOption("tabSize", intVal);
            }
        }), new CSIDESetting({
            id: "fontsize",
            name: "Font Size (px)",
            value: "12px",
            type: "variable",
            cat: "editor",
            options: [ {
                desc: "10",
                value: "10px"
            }, {
                desc: "12",
                value: "12px"
            }, {
                desc: "14",
                value: "14px"
            }, {
                desc: "16",
                value: "16px"
            } ],
            desc: "The size of the font in the editor window",
            apply: function(val) {
                $("#editor-wrap").css("font-size", val), editor.refresh();
            }
        }), new CSIDESetting({
            id: "fontfamily",
            name: "Font Family",
            value: "'Century Gothic', AppleGothic, Arial, Helvetica, sans-serif",
            type: "dropdown",
            cat: "editor",
            options: [ {
                desc: "Mono",
                value: "'Courier New', Courier, monospace"
            }, {
                desc: "Sans-Serif",
                value: "Arial, Helvetica, sans-serif"
            }, {
                desc: "Serif",
                value: "'Times New Roman', Times, serif"
            }, {
                desc: "Gothic",
                value: "'Century Gothic', AppleGothic, Arial, Helvetica, sans-serif"
            } ],
            desc: "The font family used in the editor window",
            apply: function(val) {
                $("#editor-wrap").css("font-family", val), editor.refresh();
            }
        }), new CSIDESetting({
            id: "theme",
            name: "Editor Theme",
            value: "cs-light",
            type: "dropdown",
            cat: "editor",
            options: [ {
                desc: "Dark",
                value: "cs-dark"
            }, {
                desc: "Dichromatic",
                value: "cs-dichromatic"
            }, {
                desc: "Light",
                value: "cs-light"
            }, {
                desc: "Abcdef",
                value: "abcdef"
            }, {
                desc: "Ambiance",
                value: "ambiance"
            }, {
                desc: "Blackboard",
                value: "blackboard"
            }, {
                desc: "Dracula",
                value: "dracula"
            }, {
                desc: "Icecoder",
                value: "icecoder"
            }, {
                desc: "Solarized",
                value: "solarized"
            } ],
            desc: "Sets the colour and style of the editor window and its text",
            apply: function(val) {
                "lesser-dark" != val && "choicescript" != val && "erlang-dark" != val || (val = "cs-light"),
                editor.setOption("theme", val), $("#code-footer, #cs-console").removeClass().addClass("CodeMirror cm-s-" + val);
            }
        }) ]),
        app: ko.observableArray([ new CSIDESetting({
            id: "version",
            name: "Version: " + CSIDE_version,
            value: "",
            type: "variable",
            options: [],
            desc: "",
            apply: function(val) {}
        }), new CSIDESetting({
            id: "autosave",
            name: "Autosave Scenes & Projects",
            value: !1,
            type: "binary",
            desc: "Save all unsaved changes automatically (every 5 minutes)",
            apply: function(val) {
                void 0 !== autoSaveFn && autoSaveFn && clearInterval(autoSaveFn), val && (autoSaveFn = setInterval(function() {
                    self.session.save(function(err) {
                        err && bootbox.alert("<h3>Save Error</h3>" + err.message);
                    });
                }, 3e5));
            }
        }), new CSIDESetting({
            id: "persist",
            name: "Persistent Session",
            value: !1,
            type: "binary",
            desc: "Retain open scenes & project data between sessions",
            apply: function(val) {}
        }), new CSIDESetting({
            id: "cmdhelp",
            name: "Command Help (prompts & links)",
            value: !1,
            type: "binary",
            desc: "Commands in the editor window will link to their appropriate choicescriptdev.wikia page when double-clicked",
            apply: function(val) {
                val ? $(".CodeMirror").off().on("mouseover", ".cm-builtin, .cm-keyword", function() {
                    $(this).css("cursor", "pointer"), $(this).attr("title", "Double-Click for help with this command");
                }).on("mouseout", ".cm-builtin, .cm-keyword", function() {
                    $(this).css("cursor", ""), $(this).removeAttr("title");
                }).on("dblclick", ".cm-builtin, .cm-keyword", function(e) {
                    e.preventDefault(), e.stopPropagation();
                    var cmdEle = $(this).parent().children(":first-child"), text = cmdEle.text().trim(), commandName = text.match(/^\*[\w_]+/);
                    if (commandName) {
                        commandName = commandName[0].substring(1, text.length);
                        var url = "http://www.choicescriptdev.wikia.com/" + commandName;
                        usingNode ? gui.Shell.openExternal(url) : window.open(url);
                    }
                }) : $(".CodeMirror").off();
            }
        }), new CSIDESetting({
            id: "night-mode",
            name: "Night Mode",
            value: !1,
            type: "binary",
            desc: "Toggle between a light and dark application interface",
            apply: function(val) {
                var help = __getCSIDEHelp();
                val ? ($("body").addClass("night"), help && $(help.document.body).addClass("night")) : ($("body").removeClass("night"),
                help && $(help.document.body).removeClass("night")), uiColour(uiColour());
            }
        }), new CSIDESetting({
            id: "project-path",
            name: "Project Folder",
            value: "default",
            type: "custom",
            options: [ {
                desc: "Select",
                value: "select"
            }, {
                desc: "Default",
                value: "default"
            } ],
            desc: "",
            apply: function(val) {
                var self = this;
                if ("default" == val) {
                    if (usingNode) var userDir = process.env["win32" == process.platform ? "USERPROFILE" : "HOME"];
                    var path = usingNode ? userDir + "/Documents/Choicescript Projects/" : "/Choicescript Projects/";
                    self.setDesc(path), user.path = path;
                } else "select" == val ? (fh.selectFolder(function(path) {
                    path && (path = __normalizePath(path), self.setValue(path), self.setDesc(path),
                    user.path = path, config.settings[self.getCat()][self.getId()] = path, __updateConfig());
                }), self.setValue(user.path), config.settings[self.getCat()][self.getId()] = user.path,
                __updateConfig()) : (self.setDesc(val), user.path = val);
            }
        }), new CSIDESetting({
            id: "update-channel",
            name: "Update Channel",
            value: "stable",
            type: "variable",
            options: [ {
                desc: "Stable",
                value: "stable"
            }, {
                desc: "Latest",
                value: "latest"
            }, {
                desc: "Development",
                value: "development"
            }, {
                desc: "None",
                value: "none"
            } ],
            desc: "",
            apply: function(channel) {
                var self = this;
                if ("web-dropbox" == platform) return void self.setVisibility(!1);
                if (void 0 !== autoUpdateCheckFn && autoUpdateCheckFn && clearInterval(autoUpdateCheckFn),
                "none" != channel && usingNode) {
                    var autoUpdate = function() {
                        if (!self.prompt || self.prompt.closed) {
                            var n = notification("", "<i class='fa fa-refresh fa-spin'></i> Checking for updates...", {
                                closeWith: !1,
                                timeout: !1
                            });
                            updater.checkForUpdates({
                                cside: CSIDE_version,
                                nw: nw_version
                            }, channel, function(err, update) {
                                n.close(), err ? notification("Connection Error", "Failed to obtain update data from server. " + err.message, {
                                    type: "error"
                                }) : update && (self.prompt = __showUpdatePrompt(channel, update));
                            });
                        }
                    };
                    autoUpdateCheckFn = setInterval(autoUpdate, 36e5), autoUpdate(), "development" === channel && notification("Warning - Development Updates", "Application updates from this channel have not been pre-tested, and have a high chance of being unstable.", {
                        type: "warning"
                    });
                }
            }
        }), new CSIDESetting({
            id: "ui-colour",
            name: "Colour Scheme",
            value: "rgb(90, 90, 90)",
            type: "variable",
            desc: "",
            options: [ {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(90, 90, 90)'></div>",
                value: "granite"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(175, 93, 111)'></div>",
                value: "garnet"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(147, 122, 175)'></div>",
                value: "amethyst"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(107, 166, 125)'></div>",
                value: "emerald"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(94,104,121)'></div>",
                value: "slate"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(129,127,122)'></div>",
                value: "sandstone"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(51, 164, 164)'></div>",
                value: "jade"
            }, {
                desc: "<div class='setting-colour-swatch' style='background-color: rgb(76,91,152)'></div>",
                value: "sapphire"
            } ],
            apply: function(val) {
                var colour;
                switch (val) {
                  case "granite":
                    colour = "90,90,90";
                    break;

                  case "amethyst":
                    colour = "147,122,175";
                    break;

                  case "garnet":
                    colour = "175,93,111";
                    break;

                  case "emerald":
                    colour = "60,100,80";
                    break;

                  case "slate":
                    colour = "94,104,121";
                    break;

                  case "sandstone":
                    colour = "129,127,122";
                    break;

                  case "jade":
                    colour = "51,164,164";
                    break;

                  case "sapphire":
                    colour = "76,91,152";
                    break;

                  default:
                    colour = "90,90,90";
                }
                uiColour(colour);
            }
        }) ]),
        asObject: function(settingType) {
            if (void 0 !== settings[settingType]) {
                for (var arr = settings[settingType](), obj = {}, i = 0; i < arr.length; i++) obj[arr[i].getId()] = arr[i].getValue();
                return obj;
            }
            console.log("Invalid settings type passed to settings.asObject function.");
        }
    };
    self.getEditorSettings = ko.computed(function() {
        return settings.editor().map(function(setting) {
            return setting.extAPI;
        });
    }), self.getAppSettings = ko.computed(function() {
        return settings.app().map(function(setting) {
            return setting.extAPI;
        });
    }), self.scenePanel = function(action) {
        if (!$("#page-content-wrapper").is(":animated") && !$("#sidebar").is(":animated")) {
            var sidebarLeft = $("#sidebar").css("left");
            parseInt(sidebarLeft.slice(0, sidebarLeft.length - 2)) < 0 ? ($("#page-content-wrapper").animate({
                left: 230
            }, 300, function() {
                editor.refresh();
            }), $("#sidebar").animate({
                left: 0
            }, 300, function() {
                editor.refresh();
            })) : ($("#page-content-wrapper").animate({
                left: 0
            }, 300, function() {
                editor.refresh();
            }), $("#sidebar").animate({
                left: -230
            }, 300, function() {
                editor.refresh();
            }));
        }
    };
    var consoleCmdBuf = [], consoleCmdBufPtr = 0;
    ko.observable(0);
    self.consoleInput = function(data, evt) {
        var consoleCommands = /^\*(console_)?(clear|track|untrack|track_all_off|track_all_on|track_list|help)/, validCSCommands = /^\*(?:set|temp|rand|achieve|restart|goto|goto_scene)/;
        if (evt) {
            var element = evt.originalEvent.target, input = element.value;
            if (38 === evt.keyCode) {
                if (consoleCmdBuf.length <= 0) return;
                --consoleCmdBufPtr < 0 && (consoleCmdBufPtr = consoleCmdBuf.length - 1), element.value = consoleCmdBuf[consoleCmdBufPtr];
            } else if (40 === evt.keyCode) {
                if (consoleCmdBuf.length <= 0) return;
                ++consoleCmdBufPtr > consoleCmdBuf.length - 1 && (consoleCmdBufPtr = 0), element.value = consoleCmdBuf[consoleCmdBufPtr];
            }
            if (input && 13 === evt.keyCode) {
                consoleCmdBuf.length > 9 && consoleCmdBuf.shift(), consoleCmdBuf.push(input), consoleCmdBufPtr = consoleCmdBuf.length,
                selectedProject().logToConsole(input, "*" == input.substring(0, 1) ? "cm-builtin" : "cm-variable");
                var gameFrame = document.getElementById("game-tab-frame").contentWindow || document.getElementById("#game-tab-frame");
                if (void 0 === gameFrame || void 0 === gameFrame || void 0 === gameFrame.stats) return selectedProject().logToConsole("Error: no choicescript game running", "cm-error"),
                void (element.value = "");
                if (selectedProject() != activeProject()) return selectedProject().logToConsole("Error: this project is not the one running", "cm-error"),
                void (element.value = "");
                try {
                    var toks;
                    if (input.match(/^\*/)) (toks = input.match(validCSCommands)) || (toks = input.match(consoleCommands)) ? (toks.length > 1 && "console_" !== toks[1] && (input = "*console_" + input.substring(1, input.length)),
                    input.match(/^\*goto/) ? input.match(/^\*goto\s+/) ? (input = input.replace(/^\*goto\s+/, ""),
                    gameFrame.stats.scene.CSIDEConsole_goto(input)) : (input = input.replace(/^\*goto_scene\s+/, ""),
                    gameFrame.stats.scene.CSIDEConsole_goto_scene(input)) : gameFrame.stats.scene.runCommand(input) || selectedProject().logToConsole("Error: an unknown error occured whilst attempting to execute that command", "cm-error")) : selectedProject().logToConsole("Error: invalid console command", "cm-error"); else {
                        var stack = gameFrame.stats.scene.tokenizeExpr(input), result = gameFrame.stats.scene.evaluateExpr(stack);
                        "string" == typeof result ? result = '"' + result + '"' : result || (result = "false"),
                        selectedProject().logToConsole(result, "output");
                    }
                } catch (e) {
                    e.message = e.message.replace(/line [0-9]+ of\s\w+: /, ""), selectedProject().logToConsole("Error: " + e.message, "cm-error");
                }
                element.value = "";
            }
        }
    }, self.tabPanel = function(action) {
        if (!$(".left-wrap").is(":animated") && !$(".right-wrap").is(":animated")) {
            var isOpen = !0;
            if (function(ele) {
                return 100 * ele.width() / ele.offsetParent().width();
            }($(".left-wrap")) > 60 && (isOpen = !1), "close" == action && isOpen || !action && isOpen) $(".right-wrap").animate({
                right: "-50%"
            }, 500, function() {
                editor.refresh();
            }), $(".left-wrap").animate({
                width: "100%"
            }, 500, function() {
                editor.refresh();
            }), $("#expand-collapse-bar").addClass("collapsed"); else {
                if (("open" != action || isOpen) && (action || isOpen)) return isOpen;
                $(".left-wrap").animate({
                    width: "50%"
                }, 500, function() {
                    editor.refresh();
                }), $(".right-wrap").animate({
                    right: "0%"
                }, 500, function() {
                    editor.refresh();
                }), $("#expand-collapse-bar").removeClass("collapsed");
            }
        }
    }, self.openScene = function(path, callback) {
        __openScene(path, callback);
    }, self.openFileBrowser = function() {
        if (usingNode) {
            var chooser = $("#getFilePaths");
            chooser.off().change(function(evt) {
                var selection = $(this).val().split(";");
                1 === selection.length && "" === selection[0] || ($(this).val(""), __openScenes(selection, !0));
            }), chooser.trigger("click");
        } else fileBrowser.open(function(selection) {
            selection.length < 1 || (selection = selection.filter(function(file) {
                return !file.isFolder();
            }).map(function(file) {
                return file.path;
            }), __openScenes(selection, !0));
        });
    }, self.spellCheck = function(word) {
        return !editor.options.spellcheck || (typo.check(word) || userDictionary.check(word.toLowerCase()) || word.match(/^\d+$/));
    }, userDictionary = {
        persistentList: {},
        persistentListArray: ko.observableArray([]),
        sessionList: {},
        add: function(word, list) {
            userDictionary[list + "List"][word.toLowerCase()] = !0, userDictionary.update(list);
        },
        remove: function(word, list) {
            userDictionary[list + "List"] && delete userDictionary[list + "List"][word], userDictionary.update(list);
        },
        check: function(word) {
            var pList = this.persistentList;
            return !(!this.sessionList[word] && !pList[word]);
        },
        load: function() {
            try {
                userDictionary.persistentList = JSON.parse(localStorage.getItem("userDictionary")) || {};
                for (var i in userDictionary.persistentList) userDictionary.persistentList.hasOwnProperty(i) && userDictionary.persistentListArray.push(i);
            } catch (err) {
                err ? userDictionary.update() : bootbox.alert("Sorry, there was a problem loading or parsing your user dictionary data.<br>If you're seeing this message frequently please file a bug report.");
            }
        },
        update: function(list) {
            if (void 0 === list || "persistent" == list) {
                var newDictionary = JSON.stringify(userDictionary.persistentList, null, "\t");
                localStorage.setItem("userDictionary", newDictionary), userDictionary.persistentListArray.removeAll();
                for (var i in userDictionary.persistentList) userDictionary.persistentList.hasOwnProperty(i) && userDictionary.persistentListArray.push(i);
            }
            editor.forceSyntaxRedraw();
        }
    }, self.dictWord = ko.observable(""), self.addToDictionary = function(obj, e) {
        if ("click" == e.type || "keyup" == e.type && 13 == e.keyCode) {
            if (!self.dictWord().match(/^([A-Za-z\u00C0-\u00FF\u0100-\u017F]+'[A-Za-z\u00C0-\u00FF\u0100-\u017F]+|[A-Za-z\u00C0-\u00FF\u0100-\u017F]{2,}|[AaI]'?)$/)) return void bootbox.alert("<h3>Error</h3>Unable to add to user dictionary: not a word!");
            userDictionary.add(self.dictWord(), "persistent"), self.dictWord("");
        }
    }, self.removeFromDictionary = function(word) {
        userDictionary.persistentList.hasOwnProperty(word) && userDictionary.remove(word, "persistent");
    }, self.getDictionaryArray = ko.computed(function() {
        return userDictionary.persistentListArray().sort();
    }, this), self.init = function() {
        if (usingNode || (user.name = "dropbox-user"), config.settings.app.persist) {
            for (var thisProjectData = [], i = 0; i < config.openProjects.length; i++) {
                thisProjectData = config.openProjects[i];
                var project = new CSIDEProject(thisProjectData);
                __addProject(project);
                for (var n = 0; n < thisProjectData.openScenes.length; n++) {
                    var scene = new CSIDEScene(thisProjectData.openScenes[n]);
                    project.addScene(scene), scene.load();
                }
            }
            for (var e = 0; e < config.tabs.length; e++) self.tabs.push(__csideTabs[config.tabs[e]]);
        }
        for (var scope = settings.editor(), i = 0; i < scope.length; i++) {
            var val = void 0 !== config.settings.editor[scope[i].getId()] ? config.settings.editor[scope[i].getId()] : defaultConfig.settings.editor[scope[i].getId()];
            scope[i].setValue(val);
        }
        scope = settings.app();
        for (var i = 0; i < scope.length; i++) {
            var val = void 0 !== config.settings.app[scope[i].getId()] ? config.settings.app[scope[i].getId()] : defaultConfig.settings.app[scope[i].getId()];
            scope[i].setValue(val);
        }
        if (userDictionary.load(), __selectTab("help"), config.justUpdated || void 0 === config.justUpdated) {
            config.justUpdated = !1, __updateConfig();
            var n = notification("Updated to v" + CSIDE_version, "A full list of changes can be found under 'Changelog' in the help and information tab.", {
                buttons: [ {
                    addClass: "btn btn-default",
                    text: "Show Changelog",
                    onClick: function(note) {
                        var csideHelp = __getCSIDEHelp();
                        csideHelp && (csideHelp.breadcrumbs = [ {
                            url: "home.html",
                            title: "Home"
                        }, {
                            url: "changelog.md",
                            title: "Changelog"
                        } ], csideHelp.history = [ "home.html", "changelog.md" ], csideHelp.drawPage("changelog.md")),
                        note.close();
                    }
                } ]
            });
            n.setTimeout(5e3), __getCSIDEHelp();
        }
    }, self.slideUpAndOut = function(elem) {
        $(elem).parent().find("ul").remove(), $(elem).animate({
            minHeight: 0,
            height: 0,
            padding: 0
        }, 400, function() {
            $(elem).remove();
        });
    }, self.slideDownAndIn = function(elem) {
        $(elem).hide().slideDown(400);
    }, self.fadeIn = function(elem) {
        $(elem).hide().fadeIn("fast");
    }, self.fadeOutAndUp = function(elem) {
        $(elem).animate({
            opacity: 0,
            height: 0,
            padding: 0
        }, 400, function() {
            $(elem).remove();
        });
    }, self.showWordCount = function(sceneOrProject) {
        var incWordCount = sceneOrProject.getWordCount(), exWordCount = sceneOrProject.getWordCount(!0), charCount = sceneOrProject.getCharCount(), type = sceneOrProject.constructor.name.substring("CSIDE".length, sceneOrProject.constructor.name.length), selectedTitle = "Scene" == type ? "Currently Selected Text (this scene)" : "Currently Selected Text (in all scenes)", title = type + " - " + sceneOrProject.getName(), msg = "<h5>Word Count</h5> \t\t    Including command lines: " + sceneOrProject.getWordCount() + "<br>Excluding command lines: " + sceneOrProject.getWordCount(!0);
        msg += "<br>Characters: " + sceneOrProject.getCharCount(), incWordCount = sceneOrProject.getWordCount(!1, !0),
        exWordCount = sceneOrProject.getWordCount(!0, !0), charCount = sceneOrProject.getCharCount(!0),
        msg += "<br><br><h5>" + selectedTitle + "</h5> \t\t\t\tWords including command lines: " + incWordCount + "<br>Words excluding command lines: " + exWordCount + "<br>Characters: " + charCount,
        msg += "<br><br>Please note that these figures are only approximations.<br>Project word counts only include those of open scenes.",
        bootbox.alert({
            message: msg,
            title: title
        });
    }, self.createProject = function(projectName, cb, blank) {
        function __create(projectName) {
            validName(projectName, !0, function(valid, err) {
                valid ? projectExists(user.path + projectName, function(exists) {
                    exists ? notification("Project Naming Error", "A Project with that name already exists in the project directory", {
                        type: "error"
                    }) : __createProject(projectName, cb, blank);
                }) : notification("Project Naming Error", err, {
                    type: "error"
                });
            });
        }
        blank = blank || !1, "function" != typeof cb && (cb = function(err, project) {
            err || notification("Project created", project.getPath(), {
                type: "success",
                layout: "bottomRight"
            });
        }), "string" != typeof projectName || "" == projectName ? __promptForString(function(str) {
            str && __create(str);
        }, "Name of Project?") : __create(projectName);
    };
    var cse = {
        getFreeLabelName: function(scene, prefix) {
            for (var i = 0; i < prefix && void 0 !== scene.labels[prefix + "_" + i]; i++) ;
            return prefix + "_" + i;
        },
        while: {
            transpile: function(scene, expr, line, block_size) {
                var lines = [], label = cse.getFreeLabelName(scene, "while_loop");
                return lines.push("*label " + label), lines.push("*if" + expr), lines = lines.concat(scene.lines.slice(line + 1, line + block_size)),
                lines.push("\t*goto " + label), lines;
            }
        }
    };
    if (self.updatePersistenceList = function() {
        __updatePersistenceList();
    }, self.makeSortable = function(data) {
        __makeSortable(data);
    }, self.dragSceneEvent = dragSceneEvent, ko.bindingHandlers.bindIframe = {
        init: function(element, valueAccessor) {
            function bindIframe() {
                try {
                    var iframeInit = element.contentWindow.initChildFrame, iframedoc = element.contentDocument.body;
                } catch (e) {}
                iframeInit ? iframeInit(ko, valueAccessor()) : iframedoc && ko.applyBindings(valueAccessor(), iframedoc);
            }
            bindIframe(), ko.utils.registerEventHandler(element, "load", bindIframe);
        }
    }, ko.bindingHandlers.enableTextInput = {
        init: function(element, valueAccessor) {
            $(element).prop("readOnly", !0);
        },
        update: function(element, valueAccessor) {
            $(element).prop("readOnly", !ko.utils.unwrapObservable(valueAccessor()));
        }
    }, ko.bindingHandlers.fadeVisible = {
        init: function(element, valueAccessor) {
            var value = valueAccessor();
            $(element).toggle(ko.utils.unwrapObservable(value));
        },
        update: function(element, valueAccessor) {
            var value = valueAccessor();
            ko.utils.unwrapObservable(value) ? $(element).show().animate({
                opacity: 1
            }, 250) : $(element).animate({
                opacity: 0
            }, 250, function() {
                $(this).hide();
            });
        }
    }, ko.bindingHandlers.fadeAndSlideVisible = {
        init: function(element, valueAccessor) {
            var value = valueAccessor();
            $(element).toggle(ko.unwrap(value));
        },
        update: function(element, valueAccessor) {
            var value = valueAccessor();
            ko.unwrap(value) ? $(element).slideDown(500).animate({
                opacity: 1
            }, {
                queue: !1,
                duration: 350
            }) : $(element).slideUp(500).animate({
                opacity: 0
            }, {
                queue: !1,
                duration: 350
            });
        }
    }, ko.bindingHandlers.initFiles = {
        init: function(element, valueAccessor) {
            $(element).draggable({
                cursor: "move",
                cursorAt: {
                    left: 5,
                    top: 5
                },
                scroll: !0,
                start: function(event, ui) {
                    ui.helper.appendTo($("body"));
                },
                helper: function() {
                    var newElement = $("<div></div>");
                    return newElement.addClass("helper"), newElement.text($("folder.selected").length),
                    $(newElement);
                }
            });
        },
        update: function(element, valueAccessor, allBindings) {}
    }, ko.bindingHandlers.initFolders = {
        init: function(element, valueAccessor) {
            $(element).droppable({
                accept: ".file, .folder-ul",
                over: function(event, ui) {
                    $(this).css("background-color", "#F7F7E1");
                },
                out: function(event, ui) {
                    $(this).css("background-color", "");
                },
                drop: function(event, ui) {
                    $(this).delay(100).fadeOut().fadeIn("slow");
                    var targetFolder = $(this);
                    $(".folder-selected").each(function() {
                        moveDropboxItem($(this), targetFolder);
                    });
                }
            }).draggable({
                cursor: "move",
                cursorAt: {
                    left: 5,
                    top: 5
                },
                scroll: !0,
                start: function(event, ui) {
                    ui.helper.appendTo($("body"));
                },
                helper: function() {
                    var newElement = $("<div></div>");
                    return newElement.addClass("helper"), $(newElement);
                }
            });
        },
        update: function(element, valueAccessor, allBindings) {}
    }, usingNode, !usingNode) {
        var fileBrowser = new fileBrowser();
        ko.applyBindings(fileBrowser, $("#file-browser-canvas")[0]), self.webFileBrowserClosed = ko.computed(function() {
            return !fileBrowser.isVisible();
        });
    }
    var fileMenuOptions = ko.observableArray([ new menuOption("Open Scene", function(menu) {
        menu.getTarget().open();
    }) ]), folderMenuOptions = ko.observableArray([ new menuOption("Open Folder", function(menu) {
        menu.getTarget().open();
    }) ]);
    if ("mac_os" !== platform) {
        var toolbarMenus = ko.observableArray([ new toolbarMenu({
            title: "<span title='Project' class='fa fa-folder-open-o '>",
            active: self.getSelectedProject,
            options: ko.computed(function() {
                return new contextMenu(selectedProject(), projectMenuOptions).getOptions();
            }, this),
            target: ko.computed(function() {
                return selectedProject();
            }, this)
        }), new toolbarMenu({
            title: "<span title='Scene' class='fa fa-file-text-o'>",
            active: self.getSelectedScene,
            options: ko.computed(function() {
                return new contextMenu(selectedScene(), sceneMenuOptions).getOptions();
            }, this),
            target: ko.computed(function() {
                return selectedScene();
            }, this)
        }) ]);
        self.getToolbarMenus = ko.computed(function() {
            return toolbarMenus();
        }, this);
    }
    var myContextMenuViewModel = new CSIDE_ContextMenu();
    ko.applyBindings(myContextMenuViewModel, $("#context-menu")[0]);
}

function Scene(name, stats, nav, options) {
    name || (name = ""), stats || (stats = {
        implicit_control_flow: !1
    }), void 0 === stats.implicit_control_flow && (stats.implicit_control_flow = !1),
    this.name = name, this.stats = stats, this.temps = {
        choice_reuse: "allow",
        choice_user_restored: !1,
        _choiceEnds: {}
    }, this.nav = nav, options = options || {}, this.debugMode = options.debugMode || !1,
    this.secondaryMode = options.secondaryMode, this.saveSlot = options.saveSlot || "",
    this.lines = [], this.lineNum = 0, this.rollbackLineCoverage(), this.finished = !1,
    this.labels = {}, this.indent = 0, this.prevLine = "empty", this.screenEmpty = !0,
    this.initialCommands = !0, this.stats.sceneName = name, this.stats.scene = this,
    this.target = null, this.accumulatedParagraph = [];
}

function SceneNavigator(sceneList) {
    this.setSceneList(sceneList), this.startingStats = {
        implicit_control_flow: !1
    };
}

function callIos(scheme, path) {
    _global.isIosApp && (path = path ? encodeURIComponent(path).replace(/[!~*')(]/g, function(match) {
        return "%" + match.charCodeAt(0).toString(16);
    }) : "", setTimeout(function() {
        var iframe = document.createElement("IFRAME");
        iframe.setAttribute("src", scheme + "://" + path), iframe.setAttribute("style", "display:none"),
        document.documentElement.appendChild(iframe), iframe.parentNode.removeChild(iframe),
        iframe = null;
    }, 0));
}

function safeCall(obj, fn) {
    if (fn) {
        var isHeadless = "undefined" == typeof window, debug = !isHeadless && window.debug;
        if (isIE || isHeadless) "undefined" != typeof MSApp ? obj ? MSApp.execUnsafeLocalFunction(function() {
            fn.call(obj);
        }) : MSApp.execUnsafeLocalFunction(fn) : obj ? fn.call(obj) : fn.call(); else try {
            obj ? fn.call(obj) : fn.call();
        } catch (e) {
            if (e.message ? window.onerror(e.message, e.fileName, e.lineNumber, e.stack) : e.stack ? window.onerror(e.stack, e.fileName, e.lineNumber, e.stack) : window.onerror(toJson(e, "\n")),
            window.console && (window.console.error(e), e.message && window.console.error("Message: " + e.message),
            e.stack && window.console.error("Stack: " + e.stack)), debug) throw e;
        }
    }
}

function safeCallback(callback) {
    return function() {
        safeCall(null, callback);
    };
}

function safeTimeout(fn, time) {
    setTimeout(function() {
        safeCall(null, fn);
    }, time);
}

function isDefined(x) {
    return void 0 !== x;
}

function jsonStringifyAscii(obj) {
    return JSON.stringify(obj, function(key, value) {
        if ("scene" != key) return value;
    }).replace(/(.)/g, function(x) {
        var code = x.charCodeAt(0);
        if (code > 127 || code < 32) {
            var outCode = code.toString(16);
            switch (outCode.length) {
              case 4:
                return "\\u" + outCode;

              case 3:
                return "\\u0" + outCode;

              case 2:
                return "\\u00" + outCode;

              case 1:
                return "\\u000" + outCode;

              default:
                return x;
            }
        }
        return x;
    });
}

function toJson(obj, standardized) {
    if ("undefined" != typeof JSON && JSON.stringify) return jsonStringifyAscii(obj);
    switch (typeof obj) {
      case "object":
        if (obj) {
            var list = [];
            if (obj instanceof Array) {
                for (var i = 0; i < obj.length; i++) list.push(toJson(obj[i], standardized));
                return "[" + list.join(",") + "]";
            }
            for (var prop in obj) "scene" != prop && (standardized || !/^[a-zA-Z][a-zA-Z_0-9]\w+$/.test(prop) || /\b(abstract|boolean|break|byte|case|catch|char|class|comment|const|continue|debugger|default|delete|do|double|else|enum|export|extends|false|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|label|long|native|new|null|package|private|protected|public|return|short|static|super|switch|synchronized|this|throws|transient|true|try|typeof|var|void|volatile|while|with)\b/.test(prop) ? list.push('"' + prop + '":' + toJson(obj[prop], standardized)) : list.push(prop + ":" + toJson(obj[prop], standardized)));
            return "{" + list.join(",") + "}";
        }
        return "null";

      case "string":
        return '"' + obj.replace(/(.)/g, function(x) {
            if ("'" == x || '"' == x || "\\" == x) return "\\" + x;
            var code = x.charCodeAt(0);
            if (code > 127 || code < 32) {
                var outCode = code.toString(16);
                switch (outCode.length) {
                  case 4:
                    return "\\u" + outCode;

                  case 3:
                    return "\\u0" + outCode;

                  case 2:
                    return "\\u00" + outCode;

                  case 1:
                    return "\\u000" + outCode;

                  default:
                    return x;
                }
            }
            return x;
        }) + '"';

      case "number":
      case "boolean":
        return String(obj);

      case "function":
        return "badfunction";

      case "undefined":
        return "undefined";

      default:
        throw new Error("invalid type: " + typeof obj);
    }
}

function xhrAuthRequest(method, endpoint, callback) {
    for (var paramBuilder = new Array(3 * arguments.length), i = 3; i < arguments.length; i += 2) i > 3 && paramBuilder.push("&"),
    paramBuilder.push(arguments[i]), paramBuilder.push("="), paramBuilder.push(arguments[i + 1]);
    var params = paramBuilder.join(""), xhr = findXhr();
    "POST" == method ? (xhr.open(method, loginUrlBase + endpoint + ".php", !0), xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")) : xhr.open(method, loginUrlBase + endpoint + ".php?" + params, !0);
    var done = !1;
    xhr.onreadystatechange = function() {
        if (!done && 4 == xhr.readyState) {
            done = !0;
            var ok = 200 == xhr.status, response = {};
            try {
                xhr.responseText && (response = JSON.parse(xhr.responseText));
            } catch (e) {
                ok = !1;
            }
            ok || response.error || (response.error = "unknown error"), callback && safeCall(null, function() {
                callback(ok, response);
            });
        }
    }, xhr.send(params);
}

function login(email, password, register, subscribe, callback) {
    xhrAuthRequest("POST", "login", callback, "email", encodeURIComponent(email), "password", encodeURIComponent(password), "register", register, "subscribe", subscribe);
}

function forgotPassword(email, callback) {
    xhrAuthRequest("POST", "forgot", callback, "email", encodeURIComponent(email));
}

function logout(callback) {
    document.cookie = "login=0;path=/;expires=Thu, 01 Jan 1970 00:00:01 GMT;", xhrAuthRequest("GET", "logout", callback),
    recordLogin(!1), window.knownPurchases = null, "undefined" != typeof FB && FB.logout && FB.logout(),
    "undefined" != typeof gapi && gapi.auth && gapi.auth.signOut && gapi.auth.signOut();
}

function recordLogin(registered, email, callback) {
    initStore() ? (registered && recordEmail(email), window.store.set("login", registered, function() {
        safeCall(null, callback);
    }), window.registered = registered) : safeTimeout(callback, 0);
}

function getRemoteEmail(callback) {
    xhrAuthRequest("GET", "getuser", callback);
}

function saveCookie(callback, slot, stats, temps, lineNum, indent) {
    return writeCookie(computeCookie(stats, temps, lineNum, indent), slot, callback);
}

function computeCookie(stats, temps, lineNum, indent) {
    var scene = stats.scene;
    delete stats.scene, scene && (stats.sceneName = scene.name);
    var version = "UNKNOWN";
    "undefined" != typeof window && window && window.version && (version = window.version);
    var value = toJson({
        version: version,
        stats: stats,
        temps: temps,
        lineNum: lineNum,
        indent: indent
    });
    return stats.scene = scene, value;
}

function writeCookie(value, slot, callback) {
    if (window.pseudoSave || (window.pseudoSave = {}), slot || (slot = ""), window.pseudoSave[slot] = value,
    !initStore()) return void (callback && safeTimeout(callback, 0));
    window.store.set("state" + slot, value, safeCallback(callback));
}

function clearCookie(callback, slot) {
    writeCookie("", slot, safeCallback(callback));
}

function areSaveSlotsSupported() {
    return !(!initStore() || "cookie" == window.Persist.type);
}

function recordSave(slot, callback) {
    if (!areSaveSlotsSupported()) return void safeTimeout(callback, 0);
    restoreObject(initStore(), "save_list", [], function(saveList) {
        saveList.push(slot), window.store.set("save_list", toJson(saveList), safeCallback(callback));
    });
}

function recordDirtySlots(slots, callback) {
    if (!areSaveSlotsSupported()) return void safeTimeout(callback, 0);
    restoreObject(initStore(), "dirty_save_list", [], function(saveList) {
        saveSet = {};
        for (var i = 0; i < saveList.length; i++) saveSet[saveList[i]] = 1;
        for (i = 0; i < slots.length; i++) saveSet[slots[i]] || saveList.push(slots[i]);
        window.store.set("dirty_save_list", toJson(saveList), safeCallback(callback));
    });
}

function recordEmail(email, callback) {
    initStore() ? (window.recordedEmail = email, window.store.set("email", email, safeCallback(callback))) : safeTimeout(callback, 0);
}

function fetchEmail(callback) {
    if (!initStore()) return void safeTimeout(function() {
        callback("");
    }, 0);
    window.store.get("email", function(ok, value) {
        safeCall(null, function() {
            if (ok && (window.recordedEmail = value), callback) {
                var temp = callback;
                callback = null, temp(ok && value ? value : "");
            }
        });
    }), safeTimeout(function() {
        if (callback) {
            var temp = callback;
            callback = null, temp("");
        }
    }, 1e3);
}

function restoreObject(store, key, defaultValue, callback) {
    if (!store) return void safeTimeout(function() {
        callback(defaultValue);
    }, 0);
    store.get(key, function(ok, value) {
        var result = defaultValue;
        if (ok && value) try {
            result = jsonParse(value);
        } catch (e) {}
        safeCall(null, function() {
            callback(result);
        });
    });
}

function getDirtySaveList(callback) {
    restoreObject(initStore(), "dirty_save_list", [], function(slotList) {
        callback(slotList);
    });
}

function remoteSaveMerger(i, callback) {
    var remoteStore = new Persist.Store(window.remoteStoreNames[i]);
    restoreObject(remoteStore, "save_list", [], function(remoteSlotList) {
        fetchSavesFromSlotList(remoteStore, remoteSlotList, 0, [], function(remoteSaveList) {
            mergeRemoteSaves(remoteSaveList, 0, function() {
                i++, i < window.remoteStoreNames.length ? remoteSaveMerger(i, callback) : callback.apply(null, arguments);
            });
        });
    });
}

function getSaves(callback) {
    if (window.remoteStoreNames && window.remoteStoreNames.length) remoteSaveMerger(0, callback); else if (window.remoteStoreName && window.storeName != window.remoteStoreName) {
        var remoteStore = new Persist.Store(window.remoteStoreName);
        restoreObject(remoteStore, "save_list", [], function(remoteSlotList) {
            fetchSavesFromSlotList(remoteStore, remoteSlotList, 0, [], function(remoteSaveList) {
                mergeRemoteSaves(remoteSaveList, 0, callback);
            });
        });
    } else restoreObject(initStore(), "save_list", [], function(localSlotList) {
        fetchSavesFromSlotList(initStore(), localSlotList, 0, [], callback);
    });
}

function fetchSavesFromSlotList(store, slotList, i, saveList, callback) {
    if (i >= slotList.length) return safeCall(null, function() {
        callback(saveList);
    });
    restoreObject(store, "state" + slotList[i], null, function(saveState) {
        saveState && (saveState.timestamp = slotList[i].substring(4), saveList.push(saveState)),
        fetchSavesFromSlotList(store, slotList, i + 1, saveList, callback);
    });
}

function isWebSavePossible() {
    return !!initStore() && (!/^http/.test(window.location.protocol) || (document.domain == window.webSaveDomain || "localhost" == document.domain));
}

function submitRemoteSave(slot, email, subscribe, callback) {
    if (!isWebSavePossible()) return safeTimeout(function() {
        callback(!1);
    });
    window.store.get("state" + slot, function(ok, value) {
        if (ok) {
            var timestamp = slot.substring(4), xhr = findXhr(), gameName = window.remoteStoreName || window.storeName, params = "email=" + email + "&game=" + gameName + "&realGame=" + window.storeName + "&json=" + encodeURIComponent(value) + "&timestamp=" + timestamp + "&subscribe=" + subscribe;
            xhr.open("POST", webSaveUrl, !0), xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            var done = !1;
            xhr.onreadystatechange = function() {
                if (!done && 4 == xhr.readyState) {
                    done = !0;
                    200 == xhr.status ? safeCall(null, function() {
                        callback(!0);
                    }) : recordDirtySlots([ slot ], function() {
                        safeCall(null, function() {
                            callback(!1);
                        });
                    });
                }
            }, xhr.send(params);
        } else recordDirtySlots([ slot ], function() {
            asyncAlert("There was a problem uploading the saved game. This is probably a bug; please contact support@choiceofgames.com with code 17891.", function() {
                safeCall(null, function() {
                    callback(!1);
                });
            });
        });
    });
}

function submitDirtySaves(dirtySaveList, email, callback) {
    function submitDirtySave(i) {
        dirtySaveList[i] ? submitRemoteSave(dirtySaveList[i], email, !1, function(ok) {
            ok ? submitDirtySave(i + 1) : safeCall(null, function() {
                callback(!1);
            });
        }) : window.store.remove("dirty_save_list", function() {
            safeCall(null, function() {
                callback(!0);
            });
        });
    }
    submitDirtySave(0);
}

function submitAnyDirtySaves(callback) {
    callback || (callback = function(ok) {});
    try {
        getDirtySaveList(function(dirtySaveList) {
            if (dirtySaveList && dirtySaveList.length) try {
                fetchEmail(function(email) {
                    email ? submitDirtySaves(dirtySaveList, email, callback) : callback(!1);
                });
            } catch (e) {
                callback(!1);
            }
        });
    } catch (e) {
        callback(!1);
    }
}

function getRemoteSaves(email, callback) {
    if (!isWebSavePossible()) return void safeTimeout(function() {
        callback([]);
    }, 0);
    var xhr = findXhr(), gameName = window.remoteStoreName || window.storeName;
    xhr.open("GET", webSaveUrl + "?email=" + email + "&game=" + gameName, !0);
    var done = !1;
    xhr.onreadystatechange = function() {
        if (!done && 4 == xhr.readyState) if (done = !0, 200 != xhr.status) window.console && console.log("Couldn't load remote saves. " + xhr.status + ": " + xhr.responseText),
        safeCall(null, function() {
            callback(null);
        }); else {
            var result = xhr.responseText;
            result = jsonParse(result);
            for (var remoteSaveList = [], i = 0; i < result.length; i++) {
                var save = result[i].json;
                save.timestamp = result[i].timestamp, remoteSaveList.push(save);
            }
            safeCall(null, function() {
                callback(remoteSaveList);
            });
        }
    }, xhr.send();
}

function mergeRemoteSaves(remoteSaveList, recordDirty, callback) {
    if (!isWebSavePossible()) return void safeTimeout(function() {
        callback([], 0, []);
    }, 0);
    restoreObject(initStore(), "save_list", [], function(localSlotList) {
        fetchSavesFromSlotList(initStore(), localSlotList, 0, [], function(localSaveList) {
            function finale() {
                newRemoteSaves ? window.store.set("save_list", toJson(localSlotList), function() {
                    safeCall(null, function() {
                        callback(localSaveList, newRemoteSaves, dirtySaveList);
                    });
                }) : safeCall(null, function() {
                    callback(localSaveList, newRemoteSaves, dirtySaveList);
                });
            }
            for (var localSlotMap = {}, i = 0; i < localSlotList.length; i++) localSlotMap[localSlotList[i]] = 1;
            var remoteSlotMap = {};
            for (i = 0; i < remoteSaveList.length; i++) remoteSlotMap["save" + remoteSaveList[i].timestamp] = 1;
            var newRemoteSaves = 0;
            for (i = 0; i < remoteSaveList.length; i++) {
                var remoteSave = remoteSaveList[i], slot = "save" + remoteSave.timestamp;
                localSlotMap[slot] || (saveCookie(null, slot, remoteSave.stats, remoteSave.temps, remoteSave.lineNum, remoteSave.indent),
                localSlotList.push(slot), localSaveList.push(remoteSave), newRemoteSaves++);
            }
            var dirtySaveList = [];
            for (i = 0; i < localSlotList.length; i++) remoteSlotMap[localSlotList[i]] || dirtySaveList.push(localSlotList[i]);
            recordDirty ? window.store.set("dirty_save_list", toJson(dirtySaveList), finale) : finale();
        });
    });
}

function delayBreakStart(callback) {
    var nowInSeconds = Math.floor(new Date().getTime() / 1e3);
    if (!initStore()) return void safeTimeout(function() {
        callback(nowInSeconds);
    }, 0);
    window.store.get("delayBreakStart", function(ok, value) {
        var valueNum = 1 * value;
        safeCall(null, function() {
            ok && value && !isNaN(valueNum) ? callback(valueNum) : (window.store.set("delayBreakStart", nowInSeconds),
            callback(nowInSeconds));
        });
    });
}

function delayBreakEnd() {
    initStore() && window.store.remove("delayBreakStart");
}

function initStore() {
    if (!window.storeName) return !1;
    if (window.store) return window.store;
    try {
        window.store = new Persist.Store(window.storeName);
    } catch (e) {}
    return window.store;
}

function loadAndRestoreGame(slot, forcedScene) {
    function valueLoaded(ok, value) {
        safeCall(null, function() {
            var state = null;
            if (ok && value && "" + value) state = jsonParse(value); else if ("androidStorage" == window.Persist.type && document.cookie) return upgradeAndroidCookies(slot, forcedScene);
            restoreGame(state, forcedScene);
        });
    }
    return slot || (slot = ""), window.pseudoSave && pseudoSave[""] ? valueLoaded(!0, pseudoSave[""]) : initStore() ? void window.store.get("state" + slot, valueLoaded) : restoreGame(null, forcedScene);
}

function upgradeAndroidCookies(slot, forcedScene) {
    function upgradeComponent(i) {
        if (!components[i]) return void loadAndRestoreGame(slot, forcedScene);
        var parts = components[i].split("="), key = parts[0], deletion = key + "=x; path=/; domain=localhost; expires=Thu, 01-Jan-1970 00:00:01 GMT";
        document.cookie = deletion, key = unescape(key).substring(window.storeName.length + 1);
        var value = unescape(parts[1]);
        window.store.set(key, value, function() {
            upgradeComponent(i + 1);
        });
    }
    var ck = document.cookie, components = ck.split("; ");
    safeCall(this, function() {
        upgradeComponent(0);
    });
}

function isStateValid(state) {
    return !!state && (!!state.stats && !!state.stats.sceneName);
}

function restartGame(shouldPrompt) {
    function actuallyRestart(result) {
        result && (submitAnyDirtySaves(), clearCookie(function() {}, "temp"), clearCookie(function() {
            window.nav.resetStats(window.stats), clearScreen(restoreGame);
        }, ""));
    }
    if (window.blockRestart) return void asyncAlert("Please wait until the timer has run out.");
    shouldPrompt ? asyncConfirm("Start over from the beginning?", actuallyRestart) : actuallyRestart(!0);
}

function restoreGame(state, forcedScene, userRestored) {
    var scene, secondaryMode = null, saveSlot = "", forcedSceneLabel = null;
    if (/\|/.test(forcedScene)) {
        var parts = forcedScene.split("|");
        forcedScene = parts[0], forcedSceneLabel = parts[1];
    }
    if ("choicescript_stats" == forcedScene ? (secondaryMode = "stats", saveSlot = "temp") : "choicescript_upgrade" == forcedScene && (secondaryMode = "upgrade",
    saveSlot = "temp"), isStateValid(state)) forcedScene && (state.stats.sceneName = forcedScene),
    window.stats = state.stats, scene = new Scene(state.stats.sceneName, state.stats, window.nav, {
        debugMode: state.debug || window.debug,
        secondaryMode: secondaryMode,
        saveSlot: saveSlot
    }), forcedScene || (scene.temps = state.temps, scene.lineNum = state.lineNum, scene.indent = state.indent),
    userRestored && (scene.temps.choice_user_restored = !0); else {
        scene = new Scene(forcedScene || window.nav.getStartupScene(), window.stats, window.nav, {
            debugMode: window.debug,
            secondaryMode: secondaryMode,
            saveSlot: saveSlot
        });
    }
    null !== forcedSceneLabel && (scene.targetLabel = {
        label: forcedSceneLabel,
        origin: "url",
        originLine: 0
    }), safeCall(scene, scene.execute);
}

function redirectScene(sceneName, label, originLine) {
    var scene = new Scene(sceneName, window.stats, window.nav, {
        debugMode: window.debug
    });
    label && (scene.targetLabel = {
        label: label,
        origin: "choicescript_stats",
        originLine: originLine
    }), clearScreen(function() {
        scene.execute();
    });
}

function transferTempStatWrites() {
    _global.isIosApp && callIos("transferwrites", JSON.stringify(tempStatWrites));
}

function getCookieByName(cookieName, ck) {
    if (ck || (ck = window.document.cookie), !ck) return null;
    for (var ckPairs = ck.split(/;/), i = 0; i < ckPairs.length; i++) {
        var ckPair = trim(ckPairs[i]), ckNameValue = ckPair.split(/=/);
        if (decodeURIComponent(ckNameValue[0]) === cookieName) return decodeURIComponent(ckNameValue[1]);
    }
    return null;
}

function parseQueryString(str) {
    if (!str) return null;
    for (var map = {}, pairs = String(str).substring(1).split("&"), i = pairs.length; i--; ) {
        var pair = pairs[i], parts = pair.split("=");
        map[parts[0]] = parts[1];
    }
    return map;
}

function trim(str) {
    return null === str || void 0 === str ? null : str.replace(/^\s+/g, "").replace(/\s+$/g, "");
}

function findOptimalDomain(docDomain) {
    if (docDomain || (docDomain = document.domain), "localhost" == docDomain || "127.0.0.1" == docDomain) return null;
    if (/^\d+\.\d+\.\d+\.\d+$/.test(docDomain)) return null;
    var result = docDomain.match(/(\w+\.\w{3}$)/);
    return result ? result[1] : null;
}

function num(x, line) {
    line || (line = "UNKNOWN");
    var x_num = parseFloat(x);
    if (isNaN(x_num)) throw new Error("line " + line + ": Not a number: " + x);
    if (!isFinite(x_num)) throw new Error("line " + line + ": Not finite " + x);
    return x_num;
}

function bool(x, line) {
    if (line || (line = "UNKNOWN"), "boolean" == typeof x) return x;
    if ("true" === x) return !0;
    if ("false" === x) return !1;
    throw new Error("line " + line + ": Neither true nor false: " + x);
}

function findXhr() {
    var ieFile = isIE && isFile;
    if (window.XMLHttpRequest && !ieFile) return new window.XMLHttpRequest();
    for (var ids = [ "Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0" ], i = 0; i < 3; i++) try {
        return new ActiveXObject(ids[i]);
    } catch (e) {}
    throw new Error("Couldn't create XHR object");
}

function crc32(str, crc) {
    crc || (crc = 0);
    var n = 0, x = 0;
    crc ^= -1;
    for (var i = 0, iTop = str.length; i < iTop; i++) n = 255 & (crc ^ str.charCodeAt(i)),
    x = "0x" + crcTable.substr(9 * n, 8), crc = crc >>> 8 ^ x;
    return -1 ^ crc;
}

function simpleDateTimeFormat(date) {
    var day = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ][date.getDay()], month = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ][date.getMonth()], minutes = date.getMinutes();
    minutes < 10 && (minutes = "0" + minutes);
    var millisAgo = new Date().getTime() - date.getTime(), yearString = "";
    return millisAgo > 31536e6 && (yearString = ", " + date.getFullYear()), day + ", " + month + " " + date.getDate() + yearString + ", " + date.getHours() + ":" + minutes;
}

function jsonParse(str) {
    if ("undefined" == typeof JSON) return eval("(" + str + ")");
    try {
        return JSON.parse(str);
    } catch (e) {
        try {
            return eval("(" + str + ")");
        } catch (e2) {
            try {
                eval("1");
            } catch (e3) {
                var str2 = (str + "").replace(/([,\{])\s*(\w+)\s*\:/g, '$1"$2":');
                try {
                    return JSON.parse(str2);
                } catch (e4) {}
            }
            return JSON.parse(str);
        }
    }
}

function cefQuerySimple(method) {
    cefQuery({
        request: method,
        onSuccess: function(response) {
            console.log(method + " success");
        },
        onFailure: function(error_code, error_message) {
            console.error(method + " error: " + error_message);
        }
    });
}

function parseDateStringInCurrentTimezone(YYYY_MM_DD, line) {
    var result = /^(\d{4})-(\d{2})-(\d{2})$/.exec(YYYY_MM_DD);
    if (!result) throw new Error("line " + line + ": invalid date string " + YYYY_MM_DD);
    var fullYear = result[1], oneBasedMonthNumber = parseInt(result[2], 10), dayOfMonth = parseInt(result[3], 10), shortMonthString = shortMonthStrings[oneBasedMonthNumber];
    return new Date(shortMonthString + " " + dayOfMonth + ", " + fullYear);
}

function matchBracket(line, brackets, startIndex) {
    for (var openBracket = brackets[0], closeBracket = brackets[1], brackets = 0, i = startIndex; i < line.length; i++) {
        var c = line.charAt(i);
        if (c === openBracket) brackets++; else if (c === closeBracket) {
            if (!brackets) return i;
            brackets--;
        }
    }
    return -1;
}

function autotester(sceneText, nav, sceneName, extraLabels) {
    function log(msg) {
        "undefined" != typeof console && console.log(msg);
    }
    function dojoClone(o) {
        if (!o) return o;
        if (o instanceof Array || "array" == typeof o) {
            for (var r = [], i = 0; i < o.length; ++i) r.push(dojoClone(o[i]));
            return r;
        }
        if ("object" != typeof o && "function" != typeof o) return o;
        if (o.nodeType && o.cloneNode) return o.cloneNode(!0);
        if (o instanceof Date) return new Date(o.getTime());
        r = "function" == typeof o.constructor ? new o.constructor() : {};
        for (i in o) i in r && r[i] == o[i] || (r[i] = dojoClone(o[i]));
        return r;
    }
    var coverage = [];
    printx = printParagraph = function(msg, parent) {};
    var sceneList = [];
    Scene.prototype.oldSceneList || (Scene.prototype.oldSceneList = Scene.prototype.scene_list),
    Scene.prototype.scene_list = function() {
        if ("startup" != this.name || !this.screenEmpty || !this.initialCommands) throw new Error(this.lineMsg() + "Invalid scene_list instruction, only allowed at the top of startup.txt");
        for (var scenes = this.parseSceneList(), i = 0; i < scenes.length; i++) this.verifySceneFile(scenes[i]);
    }, Scene.prototype.quicktest = !0, Scene.prototype.finish = function(buttonName) {
        this.paragraph(), this.finished = !0, buttonName || (buttonName = "Next Chapter"),
        buttonName = this.replaceVariables(buttonName), this.testFinish && this.testFinish();
    }, Scene.prototype.bug = function() {
        this.finished = !0;
    }, Scene.prototype.page_break = function(buttonName) {
        this.replaceVariables(buttonName), this.resetCheckedPurchases();
    }, Scene.prototype.subscribe = function() {}, Scene.prototype.feedback = function() {},
    Scene.prototype.save = function() {}, Scene.prototype.restore_purchases = function() {},
    Scene.prototype.purchase = function(data) {
        var result = /^(\w+)\s+(\S+)\s+(.*)/.exec(data);
        if (!result) throw new Error(this.lineMsg() + "invalid line; can't parse purchaseable product: " + data);
        var product = result[1], label = (trim(result[2]), trim(result[3]));
        if (void 0 === this.temps["choice_purchased_" + product]) throw new Error(this.lineMsg() + "Didn't check_purchases on this page");
        if (!seen[label]) {
            var scene = this.clone();
            scene.testPath.push(","), scene.testPath.push(this.lineNum + 1), scene.testPath.push("$"),
            scene.lineNum = this.lineNum, scene.rollbackLineCoverage(), scene.indent = this.indent,
            scene.goto(label), scene.rollbackLineCoverage(), scene.resume = function() {
                this.lineNum = this.lineNum, scene.printLoop();
            }, sceneList.push(scene);
        }
    }, Scene.prototype.delay_break = function() {}, Scene.prototype.delay_ending = function(data) {
        var args = data.split(/ /), durationInSeconds = args[0], price = args[1];
        if (isNaN(1 * durationInSeconds)) throw new Error(this.lineMsg() + "invalid duration");
        if (!/^\$/.test(price)) throw new Error(this.lineMsg() + "invalid price");
        this.paragraph(), this.finished = !0;
    }, Scene.prototype.check_purchase = function(data) {
        for (var products = data.split(/ /), i = 0; i < products.length; i++) this.temps["choice_purchased_" + products[i]] = !0,
        this.nav.products && this.nav.products[products[i]] || "adfree" == products[i] || this.warning("The product " + products[i] + " wasn't declared in a *product command");
        this.temps.choice_purchase_supported = !1, this.temps.choice_purchased_everything = !0;
    };
    var inputCallback;
    printInput = function(target, inputType, callback, minimum) {
        inputCallback = function() {
            callback("text" == inputType ? "blah blah" : minimum);
        };
    }, Scene.prototype.oldInputText || (Scene.prototype.oldInputText = Scene.prototype.input_text),
    Scene.prototype.oldInputNumber || (Scene.prototype.oldInputNumber = Scene.prototype.input_number),
    Scene.prototype.input_text = function(data) {
        this.oldInputText(data), this.lineNum++, inputCallback();
    }, Scene.prototype.input_number = function(data) {
        this.oldInputNumber(data), this.lineNum++, inputCallback();
    }, Scene.prototype.goto_random_scene = function(data) {
        for (var parsed = this.parseGotoRandomScene(data), i = 0; i < parsed.length; i++) {
            var name = parsed[i].name;
            this.verifySceneFile(name);
        }
        /\ballow_no_selection\b/.test(data) || (this.finished = !0);
    }, Scene.prototype.save_game = function(destinationSceneName) {
        if (!destinationSceneName) throw new Error(this.lineMsg() + "*save_game requires a destination file name, e.g. *save_game Episode2");
        this.verifySceneFile(destinationSceneName);
    }, Scene.prototype.restore_game = function(data) {
        if (this.parseRestoreGame(!1), data) {
            var result = /^cancel=(\S+)$/.exec(data);
            if (!result) throw new Error(this.lineMsg() + "invalid restore_game line: " + data);
            cancel = result[1], this.goto(cancel);
        }
    }, Scene.prototype.rollbackLineCoverage = function(lineNum) {
        lineNum || (lineNum = this.lineNum), coverage[lineNum]--;
    };
    try {
        Scene.prototype.__defineGetter__("lineNum", function() {
            return this._lineNum;
        }), Scene.prototype.__defineSetter__("lineNum", function(val) {
            coverage[val] ? coverage[val]++ : coverage[val] = 1, this._lineNum = val;
        });
    } catch (e) {}
    Scene.prototype.choice = function(data) {
        function flattenOptions(list, options, flattenedOption) {
            flattenedOption || (flattenedOption = {});
            for (var i = 0; i < options.length; i++) {
                var option = options[i];
                flattenedOption[option.group] = i, option.suboptions ? flattenOptions(list, option.suboptions, flattenedOption) : (flattenedOption.ultimateOption = option,
                list.push(dojoClone(flattenedOption)));
            }
        }
        var groups = [ "choice" ];
        if (data) {
            groups = data.split(/ /);
            for (var i = 0; i < groups.length; i++) if (!/^\w*$/.test(groups[i])) throw new Error(this.lineMsg() + "invalid choice group name: " + groups[i]);
        }
        var choiceLine = this.lineNum, options = this.parseOptions(this.indent, groups);
        for (this.temps._choiceEnds || (this.temps._choiceEnds = {}), i = 0; i < options.length; i++) this.temps._choiceEnds[options[i].line - 1] = this.lineNum;
        var flattenedOptions = [];
        flattenOptions(flattenedOptions, options);
        for (var index = 0; index < flattenedOptions.length; index++) {
            var item = flattenedOptions[index];
            this.printLine(item.ultimateOption.name);
            var scene = this.clone();
            scene.testOption = item, scene.testChoiceLine = choiceLine, scene.testPath.push(","),
            scene.testPath.push(choiceLine + 1), scene.testPath.push("#"), scene.testPath.push(index + 1),
            scene.testPath.push(" ("), scene.testPath.push(item.ultimateOption.line), scene.testPath.push(")"),
            scene.resume = function() {
                this.standardResolution(this.testOption.ultimateOption);
            }, sceneList.push(scene);
        }
        this.finished = !0;
    }, Scene.prototype.clone = function() {
        this.stats.scene = null;
        var clonedStats = dojoClone(this.stats), scene = new Scene(this.name, clonedStats, this.nav, {
            secondaryMode: this.secondaryMode
        });
        return scene.lines = this.lines, scene.labels = this.labels, scene.temps = dojoClone(this.temps),
        scene.loaded = !0, scene.testPath = dojoClone(this.testPath), scene.firstTab = this.firstTab,
        scene.firstSpace = this.firstSpace, this.stats.scene = this, scene;
    }, Scene.prototype.conflictingOptions = function() {}, Scene.prototype.oldRunCommand || (Scene.prototype.oldRunCommand = Scene.prototype.runCommand),
    Scene.prototype.runCommand = function(line) {
        return coverage[this._lineNum] > 1 ? /^\s*\*else/i.test(line) ? this.oldRunCommand(line) : seenInChoice[this.lineNum] ? this.oldRunCommand(line) : (this.return(),
        !0) : this.oldRunCommand(line);
    }, Scene.prototype.oldGoto || (Scene.prototype.oldGoto = Scene.prototype.goto);
    var seen = {};
    Scene.prototype.goto = function(label, inChoice) {
        if (inChoice) return void this.oldGoto(label, !0);
        var key = label.toLowerCase();
        if (seen[key]) return void this.return();
        seen[key] = 1, this.oldGoto(label);
    }, Scene.prototype.oldGosub || (Scene.prototype.oldGosub = Scene.prototype.gosub),
    Scene.prototype.gosub = function(label, inChoice) {
        seen[label.toLowerCase()] || this.oldGosub(label);
    }, Scene.prototype.ending = function() {
        this.finished = !0;
    }, Scene.prototype.restart = Scene.prototype.ending, Scene.prototype.goto_scene = function(data) {
        var result = this.parseGotoScene(data);
        this.verifySceneFile(result.sceneName), this.finished = !0;
    }, Scene.prototype.redirect_scene = function(data) {
        if ("stats" != this.secondaryMode) throw new Error(this.lineMsg() + "The *redirect_scene command can only be used from the stats screen.");
        this.goto_scene(data);
    }, Scene.prototype.gosub_scene = function(data) {
        var result = this.parseGotoScene(data);
        this.verifySceneFile(result.sceneName);
    }, Scene.prototype.return = function() {
        var stackFrame;
        this.temps.choice_substack && this.temps.choice_substack.length ? (stackFrame = this.temps.choice_substack.pop(),
        this.lineNum = stackFrame.lineNum, this.indent = stackFrame.indent) : this.finished = !0;
    }, Scene.prototype.oldElse || (Scene.prototype.oldElse = Scene.prototype.else),
    Scene.prototype.else = function(data, inChoice) {
        inChoice ? this.oldIf("true") : this.oldElse();
    }, Scene.prototype.elseif = Scene.prototype.elsif = function(data, inChoice) {
        var stack = this.tokenizeExpr(data), result = this.evaluateExpr(stack);
        if ("boolean" != typeof result) throw new Error(this.lineMsg() + "Invalid boolean expression; this isn't a boolean: " + result);
        this.else(data, inChoice);
    }, Scene.prototype.oldIf || (Scene.prototype.oldIf = Scene.prototype.if);
    var seenInChoice = {};
    Scene.prototype.if = function(line, inChoice) {
        var stack = this.tokenizeExpr(line), result = this.evaluateExpr(stack);
        if ("boolean" != typeof result) throw new Error(this.lineMsg() + "Invalid boolean expression; this isn't a boolean: " + result);
        if (inChoice) return seenInChoice[this.lineNum] = 1, void this.oldIf("true");
        var scene = this.clone();
        scene.testPath.push(","), scene.testPath.push(this.lineNum + 1), scene.testPath.push("F"),
        scene.lineNum = this.lineNum, scene.rollbackLineCoverage(), scene.indent = this.indent,
        scene.skipTrueBranch(), scene.lineNum++, scene.rollbackLineCoverage(), scene.resume = function() {
            this.lineNum = this.lineNum, scene.printLoop();
        }, sceneList.push(scene), this.oldIf("true");
    }, Scene.prototype.stat_chart = function() {
        this.parseStatChart();
    }, Scene.operators["/"] = function(v1, v2, line) {
        return v2 = num(v2, line), 0 === v2 ? 9007199254740991 : num(v1, line) / num(v2, line);
    }, sceneName || (sceneName = "test");
    var startingStats = {};
    nav || (nav = {
        repairStats: function() {},
        resetStats: function() {},
        startingStats: {},
        bugLog: []
    }), nav.resetStats(startingStats);
    var secondaryMode = void 0;
    "choicescript_stats" == sceneName ? secondaryMode = "stats" : "choicescript_upgrade" == sceneName && (secondaryMode = "upgrade");
    var scene = new Scene(sceneName, startingStats, nav, {
        secondaryMode: secondaryMode
    }), originalScene = scene;
    if (scene.testPath = [ sceneName ], scene.loadLines(sceneText), log("executing"),
    scene.execute(), extraLabels) for (var i = 0; i < extraLabels.length; i++) {
        var extraLabel = extraLabels[i];
        scene = new Scene(sceneName, startingStats, nav, {
            secondaryMode: secondaryMode
        }), scene.lines = originalScene.lines, scene.labels = originalScene.labels, scene.loaded = !0,
        scene.targetLabel = extraLabel, scene.testPath = [ sceneName, ",", "goto " + extraLabel.label ],
        log(scene.testPath.join("")), scene.execute();
    }
    for (;scene = sceneList.shift(); ) log(scene.testPath.join("")), scene.resume();
    for (var uncovered = [], startRange = null, i = 0; i < coverage.length; i++) if (line = trim(originalScene.lines[i]),
    coverage[i]) startRange == i ? (uncovered.push(startRange), startRange = null) : startRange && (uncovered.push(startRange + "-" + i),
    startRange = null); else if (null === startRange) {
        if (!line || /\*(comment|bug)\b/.test(line)) continue;
        startRange = i + 1;
    }
    return startRange && uncovered.push(startRange + "-" + (i - 1)), uncovered.length ? (log("UNCOVERED:"),
    log(uncovered.join("\n")), [ coverage, uncovered ]) : [ coverage ];
}

!function(a, b) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
        if (!a.document) throw new Error("jQuery requires a window with a document");
        return b(a);
    } : b(a);
}("undefined" != typeof window ? window : this, function(a, b) {
    function r(a) {
        var b = "length" in a && a.length, c = m.type(a);
        return "function" !== c && !m.isWindow(a) && (!(1 !== a.nodeType || !b) || ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a));
    }
    function w(a, b, c) {
        if (m.isFunction(b)) return m.grep(a, function(a, d) {
            return !!b.call(a, d, a) !== c;
        });
        if (b.nodeType) return m.grep(a, function(a) {
            return a === b !== c;
        });
        if ("string" == typeof b) {
            if (v.test(b)) return m.filter(b, a, c);
            b = m.filter(b, a);
        }
        return m.grep(a, function(a) {
            return m.inArray(a, b) >= 0 !== c;
        });
    }
    function D(a, b) {
        do {
            a = a[b];
        } while (a && 1 !== a.nodeType);
        return a;
    }
    function G(a) {
        var b = F[a] = {};
        return m.each(a.match(E) || [], function(a, c) {
            b[c] = !0;
        }), b;
    }
    function I() {
        y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J),
        a.detachEvent("onload", J));
    }
    function J() {
        (y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I(),
        m.ready());
    }
    function O(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(N, "-$1").toLowerCase();
            if ("string" == typeof (c = a.getAttribute(d))) {
                try {
                    c = "true" === c || "false" !== c && ("null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c);
                } catch (e) {}
                m.data(a, b, c);
            } else c = void 0;
        }
        return c;
    }
    function P(a) {
        var b;
        for (b in a) if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b) return !1;
        return !0;
    }
    function Q(a, b, d, e) {
        if (m.acceptData(a)) {
            var f, g, h = m.expando, i = a.nodeType, j = i ? m.cache : a, k = i ? a[h] : a[h] && h;
            if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || m.guid++ : h),
            j[k] || (j[k] = i ? {} : {
                toJSON: m.noop
            }), ("object" == typeof b || "function" == typeof b) && (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)),
            g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[m.camelCase(b)] = d),
            "string" == typeof b ? null == (f = g[b]) && (f = g[m.camelCase(b)]) : f = g, f;
        }
    }
    function R(a, b, c) {
        if (m.acceptData(a)) {
            var d, e, f = a.nodeType, g = f ? m.cache : a, h = f ? a[m.expando] : m.expando;
            if (g[h]) {
                if (b && (d = c ? g[h] : g[h].data)) {
                    m.isArray(b) ? b = b.concat(m.map(b, m.camelCase)) : b in d ? b = [ b ] : (b = m.camelCase(b),
                    b = b in d ? [ b ] : b.split(" ")), e = b.length;
                    for (;e--; ) delete d[b[e]];
                    if (c ? !P(d) : !m.isEmptyObject(d)) return;
                }
                (c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([ a ], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
            }
        }
    }
    function aa() {
        return !0;
    }
    function ba() {
        return !1;
    }
    function ca() {
        try {
            return y.activeElement;
        } catch (a) {}
    }
    function da(a) {
        var b = ea.split("|"), c = a.createDocumentFragment();
        if (c.createElement) for (;b.length; ) c.createElement(b.pop());
        return c;
    }
    function ua(a, b) {
        var c, d, e = 0, f = typeof a.getElementsByTagName !== K ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== K ? a.querySelectorAll(b || "*") : void 0;
        if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ua(d, b));
        return void 0 === b || b && m.nodeName(a, b) ? m.merge([ a ], f) : f;
    }
    function va(a) {
        W.test(a.type) && (a.defaultChecked = a.checked);
    }
    function wa(a, b) {
        return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
    }
    function xa(a) {
        return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a;
    }
    function ya(a) {
        var b = pa.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"), a;
    }
    function za(a, b) {
        for (var c, d = 0; null != (c = a[d]); d++) m._data(c, "globalEval", !b || m._data(b[d], "globalEval"));
    }
    function Aa(a, b) {
        if (1 === b.nodeType && m.hasData(a)) {
            var c, d, e, f = m._data(a), g = m._data(b, f), h = f.events;
            if (h) {
                delete g.handle, g.events = {};
                for (c in h) for (d = 0, e = h[c].length; e > d; d++) m.event.add(b, c, h[c][d]);
            }
            g.data && (g.data = m.extend({}, g.data));
        }
    }
    function Ba(a, b) {
        var c, d, e;
        if (1 === b.nodeType) {
            if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) {
                e = m._data(b);
                for (d in e.events) m.removeEvent(b, d, e.handle);
                b.removeAttribute(m.expando);
            }
            "script" === c && b.text !== a.text ? (xa(b).text = a.text, ya(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML),
            k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked,
            b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
        }
    }
    function Ea(b, c) {
        var d, e = m(c.createElement(b)).appendTo(c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : m.css(e[0], "display");
        return e.detach(), f;
    }
    function Fa(a) {
        var b = y, c = Da[a];
        return c || (c = Ea(a, b), "none" !== c && c || (Ca = (Ca || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),
        b = (Ca[0].contentWindow || Ca[0].contentDocument).document, b.write(), b.close(),
        c = Ea(a, b), Ca.detach()), Da[a] = c), c;
    }
    function La(a, b) {
        return {
            get: function() {
                var c = a();
                if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments);
            }
        };
    }
    function Ua(a, b) {
        if (b in a) return b;
        for (var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = Ta.length; e--; ) if ((b = Ta[e] + c) in a) return b;
        return d;
    }
    function Va(a, b) {
        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = m._data(d, "olddisplay"),
        c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fa(d.nodeName)))) : (e = U(d),
        (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display"))));
        for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
        return a;
    }
    function Wa(a, b, c) {
        var d = Pa.exec(b);
        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
    }
    function Xa(a, b, c, d, e) {
        for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += m.css(a, c + T[f], !0, e)),
        d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e),
        "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e)));
        return g;
    }
    function Ya(a, b, c) {
        var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ia(a), g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f);
        if (0 >= e || null == e) {
            if (e = Ja(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ha.test(e)) return e;
            d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
        }
        return e + Xa(a, b, c || (g ? "border" : "content"), d, f) + "px";
    }
    function Za(a, b, c, d, e) {
        return new Za.prototype.init(a, b, c, d, e);
    }
    function fb() {
        return setTimeout(function() {
            $a = void 0;
        }), $a = m.now();
    }
    function gb(a, b) {
        var c, d = {
            height: a
        }, e = 0;
        for (b = b ? 1 : 0; 4 > e; e += 2 - b) c = T[e], d["margin" + c] = d["padding" + c] = a;
        return b && (d.opacity = d.width = a), d;
    }
    function hb(a, b, c) {
        for (var d, e = (eb[b] || []).concat(eb["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d;
    }
    function ib(a, b, c) {
        var d, e, f, g, h, i, j, n = this, o = {}, p = a.style, q = a.nodeType && U(a), r = m._data(a, "fxshow");
        c.queue || (h = m._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire,
        h.empty.fire = function() {
            h.unqueued || i();
        }), h.unqueued++, n.always(function() {
            n.always(function() {
                h.unqueued--, m.queue(a, "fx").length || h.empty.fire();
            });
        })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [ p.overflow, p.overflowX, p.overflowY ],
        j = m.css(a, "display"), "inline" === ("none" === j ? m._data(a, "olddisplay") || Fa(a.nodeName) : j) && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fa(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")),
        c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function() {
            p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2];
        }));
        for (d in b) if (e = b[d], ab.exec(e)) {
            if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
                if ("show" !== e || !r || void 0 === r[d]) continue;
                q = !0;
            }
            o[d] = r && r[d] || m.style(a, d);
        } else j = void 0;
        if (m.isEmptyObject(o)) "inline" === ("none" === j ? Fa(a.nodeName) : j) && (p.display = j); else {
            r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), f && (r.hidden = !q),
            q ? m(a).show() : n.done(function() {
                m(a).hide();
            }), n.done(function() {
                var b;
                m._removeData(a, "fxshow");
                for (b in o) m.style(a, b, o[b]);
            });
            for (d in o) g = hb(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start,
            g.start = "width" === d || "height" === d ? 1 : 0));
        }
    }
    function jb(a, b) {
        var c, d, e, f, g;
        for (c in a) if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1],
        f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), (g = m.cssHooks[d]) && "expand" in g) {
            f = g.expand(f), delete a[d];
            for (c in f) c in a || (a[c] = f[c], b[c] = e);
        } else b[d] = e;
    }
    function kb(a, b, c) {
        var d, e, f = 0, g = db.length, h = m.Deferred().always(function() {
            delete i.elem;
        }), i = function() {
            if (e) return !1;
            for (var b = $a || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
            return h.notifyWith(a, [ j, f, c ]), 1 > f && i ? c : (h.resolveWith(a, [ j ]),
            !1);
        }, j = h.promise({
            elem: a,
            props: m.extend({}, b),
            opts: m.extend(!0, {
                specialEasing: {}
            }, c),
            originalProperties: b,
            originalOptions: c,
            startTime: $a || fb(),
            duration: c.duration,
            tweens: [],
            createTween: function(b, c) {
                var d = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                return j.tweens.push(d), d;
            },
            stop: function(b) {
                var c = 0, d = b ? j.tweens.length : 0;
                if (e) return this;
                for (e = !0; d > c; c++) j.tweens[c].run(1);
                return b ? h.resolveWith(a, [ j, b ]) : h.rejectWith(a, [ j, b ]), this;
            }
        }), k = j.props;
        for (jb(k, j.opts.specialEasing); g > f; f++) if (d = db[f].call(j, a, k, j.opts)) return d;
        return m.map(k, hb, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), m.fx.timer(m.extend(i, {
            elem: a,
            anim: j,
            queue: j.opts.queue
        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
    }
    function Lb(a) {
        return function(b, c) {
            "string" != typeof b && (c = b, b = "*");
            var d, e = 0, f = b.toLowerCase().match(E) || [];
            if (m.isFunction(c)) for (;d = f[e++]; ) "+" === d.charAt(0) ? (d = d.slice(1) || "*",
            (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
        };
    }
    function Mb(a, b, c, d) {
        function g(h) {
            var i;
            return e[h] = !0, m.each(a[h] || [], function(a, h) {
                var j = h(b, c, d);
                return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j),
                g(j), !1);
            }), i;
        }
        var e = {}, f = a === Ib;
        return g(b.dataTypes[0]) || !e["*"] && g("*");
    }
    function Nb(a, b) {
        var c, d, e = m.ajaxSettings.flatOptions || {};
        for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
        return c && m.extend(!0, a, c), a;
    }
    function Ob(a, b, c) {
        for (var d, e, f, g, h = a.contents, i = a.dataTypes; "*" === i[0]; ) i.shift(),
        void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
        if (e) for (g in h) if (h[g] && h[g].test(e)) {
            i.unshift(g);
            break;
        }
        if (i[0] in c) f = i[0]; else {
            for (g in c) {
                if (!i[0] || a.converters[g + " " + i[0]]) {
                    f = g;
                    break;
                }
                d || (d = g);
            }
            f = f || d;
        }
        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
    }
    function Pb(a, b, c, d) {
        var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
        if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
        for (f = k.shift(); f; ) if (a.responseFields[f] && (c[a.responseFields[f]] = b),
        !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) {
            if (!(g = j[i + " " + f] || j["* " + f])) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                !0 === g ? g = j[e] : !0 !== j[e] && (f = h[0], k.unshift(h[1]));
                break;
            }
            if (!0 !== g) if (g && a.throws) b = g(b); else try {
                b = g(b);
            } catch (l) {
                return {
                    state: "parsererror",
                    error: g ? l : "No conversion from " + i + " to " + f
                };
            }
        }
        return {
            state: "success",
            data: b
        };
    }
    function Vb(a, b, c, d) {
        var e;
        if (m.isArray(b)) m.each(b, function(b, e) {
            c || Rb.test(a) ? d(a, e) : Vb(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
        }); else if (c || "object" !== m.type(b)) d(a, b); else for (e in b) Vb(a + "[" + e + "]", b[e], c, d);
    }
    function Zb() {
        try {
            return new a.XMLHttpRequest();
        } catch (b) {}
    }
    function $b() {
        try {
            return new a.ActiveXObject("Microsoft.XMLHTTP");
        } catch (b) {}
    }
    function dc(a) {
        return m.isWindow(a) ? a : 9 === a.nodeType && (a.defaultView || a.parentWindow);
    }
    var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = {}, l = "1.11.3", m = function(a, b) {
        return new m.fn.init(a, b);
    }, n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /^-ms-/, p = /-([\da-z])/gi, q = function(a, b) {
        return b.toUpperCase();
    };
    m.fn = m.prototype = {
        jquery: l,
        constructor: m,
        selector: "",
        length: 0,
        toArray: function() {
            return d.call(this);
        },
        get: function(a) {
            return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this);
        },
        pushStack: function(a) {
            var b = m.merge(this.constructor(), a);
            return b.prevObject = this, b.context = this.context, b;
        },
        each: function(a, b) {
            return m.each(this, a, b);
        },
        map: function(a) {
            return this.pushStack(m.map(this, function(b, c) {
                return a.call(b, c, b);
            }));
        },
        slice: function() {
            return this.pushStack(d.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(a) {
            var b = this.length, c = +a + (0 > a ? b : 0);
            return this.pushStack(c >= 0 && b > c ? [ this[c] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: f,
        sort: c.sort,
        splice: c.splice
    }, m.extend = m.fn.extend = function() {
        var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
        for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || m.isFunction(g) || (g = {}),
        h === i && (g = this, h--); i > h; h++) if (null != (e = arguments[h])) for (d in e) a = g[d],
        c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (b ? (b = !1,
        f = a && m.isArray(a) ? a : []) : f = a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, f, c)) : void 0 !== c && (g[d] = c));
        return g;
    }, m.extend({
        expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(a) {
            throw new Error(a);
        },
        noop: function() {},
        isFunction: function(a) {
            return "function" === m.type(a);
        },
        isArray: Array.isArray || function(a) {
            return "array" === m.type(a);
        },
        isWindow: function(a) {
            return null != a && a == a.window;
        },
        isNumeric: function(a) {
            return !m.isArray(a) && a - parseFloat(a) + 1 >= 0;
        },
        isEmptyObject: function(a) {
            var b;
            for (b in a) return !1;
            return !0;
        },
        isPlainObject: function(a) {
            var b;
            if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a)) return !1;
            try {
                if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (c) {
                return !1;
            }
            if (k.ownLast) for (b in a) return j.call(a, b);
            for (b in a) ;
            return void 0 === b || j.call(a, b);
        },
        type: function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a;
        },
        globalEval: function(b) {
            b && m.trim(b) && (a.execScript || function(b) {
                a.eval.call(a, b);
            })(b);
        },
        camelCase: function(a) {
            return a.replace(o, "ms-").replace(p, q);
        },
        nodeName: function(a, b) {
            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
        },
        each: function(a, b, c) {
            var e = 0, f = a.length, g = r(a);
            if (c) {
                if (g) for (;f > e && !1 !== b.apply(a[e], c); e++) ; else for (e in a) if (!1 === b.apply(a[e], c)) break;
            } else if (g) for (;f > e && !1 !== b.call(a[e], e, a[e]); e++) ; else for (e in a) if (!1 === b.call(a[e], e, a[e])) break;
            return a;
        },
        trim: function(a) {
            return null == a ? "" : (a + "").replace(n, "");
        },
        makeArray: function(a, b) {
            var c = b || [];
            return null != a && (r(Object(a)) ? m.merge(c, "string" == typeof a ? [ a ] : a) : f.call(c, a)),
            c;
        },
        inArray: function(a, b, c) {
            var d;
            if (b) {
                if (g) return g.call(b, a, c);
                for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) if (c in b && b[c] === a) return c;
            }
            return -1;
        },
        merge: function(a, b) {
            for (var c = +b.length, d = 0, e = a.length; c > d; ) a[e++] = b[d++];
            if (c !== c) for (;void 0 !== b[d]; ) a[e++] = b[d++];
            return a.length = e, a;
        },
        grep: function(a, b, c) {
            for (var e = [], f = 0, g = a.length, h = !c; g > f; f++) !b(a[f], f) !== h && e.push(a[f]);
            return e;
        },
        map: function(a, b, c) {
            var d, f = 0, g = a.length, h = r(a), i = [];
            if (h) for (;g > f; f++) null != (d = b(a[f], f, c)) && i.push(d); else for (f in a) null != (d = b(a[f], f, c)) && i.push(d);
            return e.apply([], i);
        },
        guid: 1,
        proxy: function(a, b) {
            var c, e, f;
            return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2),
            e = function() {
                return a.apply(b || this, c.concat(d.call(arguments)));
            }, e.guid = a.guid = a.guid || m.guid++, e) : void 0;
        },
        now: function() {
            return +new Date();
        },
        support: k
    }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
        h["[object " + b + "]"] = b.toLowerCase();
    });
    var s = function(a) {
        function ga(a, b, d, e) {
            var f, h, j, k, l, o, r, s, w, x;
            if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], k = b.nodeType,
            "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k) return d;
            if (!e && p) {
                if (11 !== k && (f = _.exec(a))) if (j = f[1]) {
                    if (9 === k) {
                        if (!(h = b.getElementById(j)) || !h.parentNode) return d;
                        if (h.id === j) return d.push(h), d;
                    } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h),
                    d;
                } else {
                    if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
                    if ((j = f[3]) && c.getElementsByClassName) return H.apply(d, b.getElementsByClassName(j)),
                    d;
                }
                if (c.qsa && (!q || !q.test(a))) {
                    if (s = r = u, w = b, x = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
                        for (o = g(a), (r = b.getAttribute("id")) ? s = r.replace(ba, "\\$&") : b.setAttribute("id", s),
                        s = "[id='" + s + "'] ", l = o.length; l--; ) o[l] = s + ra(o[l]);
                        w = aa.test(a) && pa(b.parentNode) || b, x = o.join(",");
                    }
                    if (x) try {
                        return H.apply(d, w.querySelectorAll(x)), d;
                    } catch (y) {} finally {
                        r || b.removeAttribute("id");
                    }
                }
            }
            return i(a.replace(R, "$1"), b, d, e);
        }
        function ha() {
            function b(c, e) {
                return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e;
            }
            var a = [];
            return b;
        }
        function ia(a) {
            return a[u] = !0, a;
        }
        function ja(a) {
            var b = n.createElement("div");
            try {
                return !!a(b);
            } catch (c) {
                return !1;
            } finally {
                b.parentNode && b.parentNode.removeChild(b), b = null;
            }
        }
        function ka(a, b) {
            for (var c = a.split("|"), e = a.length; e--; ) d.attrHandle[c[e]] = b;
        }
        function la(a, b) {
            var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
            if (d) return d;
            if (c) for (;c = c.nextSibling; ) if (c === b) return -1;
            return a ? 1 : -1;
        }
        function oa(a) {
            return ia(function(b) {
                return b = +b, ia(function(c, d) {
                    for (var e, f = a([], c.length, b), g = f.length; g--; ) c[e = f[g]] && (c[e] = !(d[e] = c[e]));
                });
            });
        }
        function pa(a) {
            return a && void 0 !== a.getElementsByTagName && a;
        }
        function qa() {}
        function ra(a) {
            for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
            return d;
        }
        function sa(a, b, c) {
            var d = b.dir, e = c && "parentNode" === d, f = x++;
            return b.first ? function(b, c, f) {
                for (;b = b[d]; ) if (1 === b.nodeType || e) return a(b, c, f);
            } : function(b, c, g) {
                var h, i, j = [ w, f ];
                if (g) {
                    for (;b = b[d]; ) if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
                } else for (;b = b[d]; ) if (1 === b.nodeType || e) {
                    if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2];
                    if (i[d] = j, j[2] = a(b, c, g)) return !0;
                }
            };
        }
        function ta(a) {
            return a.length > 1 ? function(b, c, d) {
                for (var e = a.length; e--; ) if (!a[e](b, c, d)) return !1;
                return !0;
            } : a[0];
        }
        function ua(a, b, c) {
            for (var d = 0, e = b.length; e > d; d++) ga(a, b[d], c);
            return c;
        }
        function va(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (!c || c(f, d, e)) && (g.push(f),
            j && b.push(h));
            return g;
        }
        function wa(a, b, c, d, e, f) {
            return d && !d[u] && (d = wa(d)), e && !e[u] && (e = wa(e, f)), ia(function(f, g, h, i) {
                var j, k, l, m = [], n = [], o = g.length, p = f || ua(b || "*", h.nodeType ? [ h ] : h, []), q = !a || !f && b ? p : va(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
                if (c && c(q, r, h, i), d) for (j = va(r, n), d(j, [], h, i), k = j.length; k--; ) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
                if (f) {
                    if (e || a) {
                        if (e) {
                            for (j = [], k = r.length; k--; ) (l = r[k]) && j.push(q[k] = l);
                            e(null, r = [], j, i);
                        }
                        for (k = r.length; k--; ) (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));
                    }
                } else r = va(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);
            });
        }
        function xa(a) {
            for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sa(function(a) {
                return a === b;
            }, h, !0), l = sa(function(a) {
                return J(b, a) > -1;
            }, h, !0), m = [ function(a, c, d) {
                var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
                return b = null, e;
            } ]; f > i; i++) if (c = d.relative[a[i].type]) m = [ sa(ta(m), c) ]; else {
                if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
                    for (e = ++i; f > e && !d.relative[a[e].type]; e++) ;
                    return wa(i > 1 && ta(m), i > 1 && ra(a.slice(0, i - 1).concat({
                        value: " " === a[i - 2].type ? "*" : ""
                    })).replace(R, "$1"), c, e > i && xa(a.slice(i, e)), f > e && xa(a = a.slice(e)), f > e && ra(a));
                }
                m.push(c);
            }
            return ta(m);
        }
        function ya(a, b) {
            var c = b.length > 0, e = a.length > 0, f = function(f, g, h, i, k) {
                var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k), v = w += null == t ? 1 : Math.random() || .1, x = u.length;
                for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
                    if (e && l) {
                        for (m = 0; o = a[m++]; ) if (o(l, g, h)) {
                            i.push(l);
                            break;
                        }
                        k && (w = v);
                    }
                    c && ((l = !o && l) && p--, f && r.push(l));
                }
                if (p += q, c && q !== p) {
                    for (m = 0; o = b[m++]; ) o(r, s, g, h);
                    if (f) {
                        if (p > 0) for (;q--; ) r[q] || s[q] || (s[q] = F.call(i));
                        s = va(s);
                    }
                    H.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && ga.uniqueSort(i);
                }
                return k && (w = v, j = t), r;
            };
            return c ? ia(f) : f;
        }
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date(), v = a.document, w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function(a, b) {
            return a === b && (l = !0), 0;
        }, C = 1 << 31, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = function(a, b) {
            for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c;
            return -1;
        }, K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = M.replace("w", "w#"), O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]", P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)", Q = new RegExp(L + "+", "g"), R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"), S = new RegExp("^" + L + "*," + L + "*"), T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), V = new RegExp(P), W = new RegExp("^" + N + "$"), X = {
            ID: new RegExp("^#(" + M + ")"),
            CLASS: new RegExp("^\\.(" + M + ")"),
            TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + O),
            PSEUDO: new RegExp("^" + P),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + K + ")$", "i"),
            needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
        }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/, _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, aa = /[+~]/, ba = /'|\\/g, ca = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"), da = function(a, b, c) {
            var d = "0x" + b - 65536;
            return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
        }, ea = function() {
            m();
        };
        try {
            H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;
        } catch (fa) {
            H = {
                apply: E.length ? function(a, b) {
                    G.apply(a, I.call(b));
                } : function(a, b) {
                    for (var c = a.length, d = 0; a[c++] = b[d++]; ) ;
                    a.length = c - 1;
                }
            };
        }
        c = ga.support = {}, f = ga.isXML = function(a) {
            var b = a && (a.ownerDocument || a).documentElement;
            return !!b && "HTML" !== b.nodeName;
        }, m = ga.setDocument = function(a) {
            var b, e, g = a ? a.ownerDocument || a : v;
            return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = g.documentElement,
            e = g.defaultView, e && e !== e.top && (e.addEventListener ? e.addEventListener("unload", ea, !1) : e.attachEvent && e.attachEvent("onunload", ea)),
            p = !f(g), c.attributes = ja(function(a) {
                return a.className = "i", !a.getAttribute("className");
            }), c.getElementsByTagName = ja(function(a) {
                return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length;
            }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = ja(function(a) {
                return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length;
            }), c.getById ? (d.find.ID = function(a, b) {
                if (void 0 !== b.getElementById && p) {
                    var c = b.getElementById(a);
                    return c && c.parentNode ? [ c ] : [];
                }
            }, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    return a.getAttribute("id") === b;
                };
            }) : (delete d.find.ID, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    var c = void 0 !== a.getAttributeNode && a.getAttributeNode("id");
                    return c && c.value === b;
                };
            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
                return void 0 !== b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;
            } : function(a, b) {
                var c, d = [], e = 0, f = b.getElementsByTagName(a);
                if ("*" === a) {
                    for (;c = f[e++]; ) 1 === c.nodeType && d.push(c);
                    return d;
                }
                return f;
            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
                return p ? b.getElementsByClassName(a) : void 0;
            }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (ja(function(a) {
                o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>",
                a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"),
                a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"),
                a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"),
                a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]");
            }), ja(function(a) {
                var b = g.createElement("input");
                b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="),
                a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"),
                q.push(",.*:");
            })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function(a) {
                c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", P);
            }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")),
            b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function(a, b) {
                var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, B = b ? function(a, b) {
                if (a === b) return l = !0, 0;
                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return d || (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1,
                1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);
            } : function(a, b) {
                if (a === b) return l = !0, 0;
                var c, d = 0, e = a.parentNode, f = b.parentNode, h = [ a ], i = [ b ];
                if (!e || !f) return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
                if (e === f) return la(a, b);
                for (c = a; c = c.parentNode; ) h.unshift(c);
                for (c = b; c = c.parentNode; ) i.unshift(c);
                for (;h[d] === i[d]; ) d++;
                return d ? la(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0;
            }, g) : n;
        }, ga.matches = function(a, b) {
            return ga(a, null, null, b);
        }, ga.matchesSelector = function(a, b) {
            if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
                var d = s.call(a, b);
                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
            } catch (e) {}
            return ga(b, n, null, [ a ]).length > 0;
        }, ga.contains = function(a, b) {
            return (a.ownerDocument || a) !== n && m(a), t(a, b);
        }, ga.attr = function(a, b) {
            (a.ownerDocument || a) !== n && m(a);
            var e = d.attrHandle[b.toLowerCase()], f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
            return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;
        }, ga.error = function(a) {
            throw new Error("Syntax error, unrecognized expression: " + a);
        }, ga.uniqueSort = function(a) {
            var b, d = [], e = 0, f = 0;
            if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
                for (;b = a[f++]; ) b === a[f] && (e = d.push(f));
                for (;e--; ) a.splice(d[e], 1);
            }
            return k = null, a;
        }, e = ga.getText = function(a) {
            var b, c = "", d = 0, f = a.nodeType;
            if (f) {
                if (1 === f || 9 === f || 11 === f) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a);
                } else if (3 === f || 4 === f) return a.nodeValue;
            } else for (;b = a[d++]; ) c += e(b);
            return c;
        }, d = ga.selectors = {
            cacheLength: 50,
            createPseudo: ia,
            match: X,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(a) {
                    return a[1] = a[1].replace(ca, da), a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da),
                    "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
                },
                CHILD: function(a) {
                    return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]),
                    a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]),
                    a;
                },
                PSEUDO: function(a) {
                    var b, c = !a[6] && a[2];
                    return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b),
                    a[2] = c.slice(0, b)), a.slice(0, 3));
                }
            },
            filter: {
                TAG: function(a) {
                    var b = a.replace(ca, da).toLowerCase();
                    return "*" === a ? function() {
                        return !0;
                    } : function(a) {
                        return a.nodeName && a.nodeName.toLowerCase() === b;
                    };
                },
                CLASS: function(a) {
                    var b = y[a + " "];
                    return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function(a) {
                        return b.test("string" == typeof a.className && a.className || void 0 !== a.getAttribute && a.getAttribute("class") || "");
                    });
                },
                ATTR: function(a, b, c) {
                    return function(d) {
                        var e = ga.attr(d, a);
                        return null == e ? "!=" === b : !b || (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1 : "|=" === b && (e === c || e.slice(0, c.length + 1) === c + "-"));
                    };
                },
                CHILD: function(a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                    return 1 === d && 0 === e ? function(a) {
                        return !!a.parentNode;
                    } : function(b, c, i) {
                        var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h;
                        if (q) {
                            if (f) {
                                for (;p; ) {
                                    for (l = b; l = l[p]; ) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                                    o = p = "only" === a && !o && "nextSibling";
                                }
                                return !0;
                            }
                            if (o = [ g ? q.firstChild : q.lastChild ], g && s) {
                                for (k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2],
                                l = n && q.childNodes[n]; l = ++n && l && l[p] || (m = n = 0) || o.pop(); ) if (1 === l.nodeType && ++m && l === b) {
                                    k[a] = [ w, n, m ];
                                    break;
                                }
                            } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1]; else for (;(l = ++n && l && l[p] || (m = n = 0) || o.pop()) && ((h ? l.nodeName.toLowerCase() !== r : 1 !== l.nodeType) || !++m || (s && ((l[u] || (l[u] = {}))[a] = [ w, m ]),
                            l !== b)); ) ;
                            return (m -= e) === d || m % d == 0 && m / d >= 0;
                        }
                    };
                },
                PSEUDO: function(a, b) {
                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
                    return e[u] ? e(b) : e.length > 1 ? (c = [ a, a, "", b ], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function(a, c) {
                        for (var d, f = e(a, b), g = f.length; g--; ) d = J(a, f[g]), a[d] = !(c[d] = f[g]);
                    }) : function(a) {
                        return e(a, 0, c);
                    }) : e;
                }
            },
            pseudos: {
                not: ia(function(a) {
                    var b = [], c = [], d = h(a.replace(R, "$1"));
                    return d[u] ? ia(function(a, b, c, e) {
                        for (var f, g = d(a, null, e, []), h = a.length; h--; ) (f = g[h]) && (a[h] = !(b[h] = f));
                    }) : function(a, e, f) {
                        return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();
                    };
                }),
                has: ia(function(a) {
                    return function(b) {
                        return ga(a, b).length > 0;
                    };
                }),
                contains: ia(function(a) {
                    return a = a.replace(ca, da), function(b) {
                        return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;
                    };
                }),
                lang: ia(function(a) {
                    return W.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(ca, da).toLowerCase(),
                    function(b) {
                        var c;
                        do {
                            if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return (c = c.toLowerCase()) === a || 0 === c.indexOf(a + "-");
                        } while ((b = b.parentNode) && 1 === b.nodeType);
                        return !1;
                    };
                }),
                target: function(b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id;
                },
                root: function(a) {
                    return a === o;
                },
                focus: function(a) {
                    return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
                },
                enabled: function(a) {
                    return !1 === a.disabled;
                },
                disabled: function(a) {
                    return !0 === a.disabled;
                },
                checked: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && !!a.checked || "option" === b && !!a.selected;
                },
                selected: function(a) {
                    return a.parentNode && a.parentNode.selectedIndex, !0 === a.selected;
                },
                empty: function(a) {
                    for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(a) {
                    return !d.pseudos.empty(a);
                },
                header: function(a) {
                    return Z.test(a.nodeName);
                },
                input: function(a) {
                    return Y.test(a.nodeName);
                },
                button: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b;
                },
                text: function(a) {
                    var b;
                    return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());
                },
                first: oa(function() {
                    return [ 0 ];
                }),
                last: oa(function(a, b) {
                    return [ b - 1 ];
                }),
                eq: oa(function(a, b, c) {
                    return [ 0 > c ? c + b : c ];
                }),
                even: oa(function(a, b) {
                    for (var c = 0; b > c; c += 2) a.push(c);
                    return a;
                }),
                odd: oa(function(a, b) {
                    for (var c = 1; b > c; c += 2) a.push(c);
                    return a;
                }),
                lt: oa(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; --d >= 0; ) a.push(d);
                    return a;
                }),
                gt: oa(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; ++d < b; ) a.push(d);
                    return a;
                })
            }
        }, d.pseudos.nth = d.pseudos.eq;
        for (b in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) d.pseudos[b] = function(a) {
            return function(b) {
                return "input" === b.nodeName.toLowerCase() && b.type === a;
            };
        }(b);
        for (b in {
            submit: !0,
            reset: !0
        }) d.pseudos[b] = function(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a;
            };
        }(b);
        return qa.prototype = d.filters = d.pseudos, d.setFilters = new qa(), g = ga.tokenize = function(a, b) {
            var c, e, f, g, h, i, j, k = z[a + " "];
            if (k) return b ? 0 : k.slice(0);
            for (h = a, i = [], j = d.preFilter; h; ) {
                (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])),
                c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
                    value: c,
                    type: e[0].replace(R, " ")
                }), h = h.slice(c.length));
                for (g in d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(),
                f.push({
                    value: c,
                    type: g,
                    matches: e
                }), h = h.slice(c.length));
                if (!c) break;
            }
            return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);
        }, h = ga.compile = function(a, b) {
            var c, d = [], e = [], f = A[a + " "];
            if (!f) {
                for (b || (b = g(a)), c = b.length; c--; ) f = xa(b[c]), f[u] ? d.push(f) : e.push(f);
                f = A(a, ya(e, d)), f.selector = a;
            }
            return f;
        }, i = ga.select = function(a, b, e, f) {
            var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a);
            if (e = e || [], 1 === o.length) {
                if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
                    if (!(b = (d.find.ID(k.matches[0].replace(ca, da), b) || [])[0])) return e;
                    n && (b = b.parentNode), a = a.slice(j.shift().value.length);
                }
                for (i = X.needsContext.test(a) ? 0 : j.length; i-- && (k = j[i], !d.relative[l = k.type]); ) if ((m = d.find[l]) && (f = m(k.matches[0].replace(ca, da), aa.test(j[0].type) && pa(b.parentNode) || b))) {
                    if (j.splice(i, 1), !(a = f.length && ra(j))) return H.apply(e, f), e;
                    break;
                }
            }
            return (n || h(a, o))(f, b, !p, e, aa.test(a) && pa(b.parentNode) || b), e;
        }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l,
        m(), c.sortDetached = ja(function(a) {
            return 1 & a.compareDocumentPosition(n.createElement("div"));
        }), ja(function(a) {
            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
        }) || ka("type|href|height|width", function(a, b, c) {
            return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
        }), c.attributes && ja(function(a) {
            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");
        }) || ka("value", function(a, b, c) {
            return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
        }), ja(function(a) {
            return null == a.getAttribute("disabled");
        }) || ka(K, function(a, b, c) {
            var d;
            return c ? void 0 : !0 === a[b] ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
        }), ga;
    }(a);
    m.find = s, m.expr = s.selectors, m.expr[":"] = m.expr.pseudos, m.unique = s.uniqueSort,
    m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains;
    var t = m.expr.match.needsContext, u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v = /^.[^:#\[\.,]*$/;
    m.filter = function(a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [ d ] : [] : m.find.matches(a, m.grep(b, function(a) {
            return 1 === a.nodeType;
        }));
    }, m.fn.extend({
        find: function(a) {
            var b, c = [], d = this, e = d.length;
            if ("string" != typeof a) return this.pushStack(m(a).filter(function() {
                for (b = 0; e > b; b++) if (m.contains(d[b], this)) return !0;
            }));
            for (b = 0; e > b; b++) m.find(a, d[b], c);
            return c = this.pushStack(e > 1 ? m.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a,
            c;
        },
        filter: function(a) {
            return this.pushStack(w(this, a || [], !1));
        },
        not: function(a) {
            return this.pushStack(w(this, a || [], !0));
        },
        is: function(a) {
            return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length;
        }
    });
    var x, y = a.document, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;
    (m.fn.init = function(a, b) {
        var c, d;
        if (!a) return this;
        if ("string" == typeof a) {
            if (!(c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [ null, a, null ] : z.exec(a)) || !c[1] && b) return !b || b.jquery ? (b || x).find(a) : this.constructor(b).find(a);
            if (c[1]) {
                if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)),
                u.test(c[1]) && m.isPlainObject(b)) for (c in b) m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                return this;
            }
            if ((d = y.getElementById(c[2])) && d.parentNode) {
                if (d.id !== c[2]) return x.find(a);
                this.length = 1, this[0] = d;
            }
            return this.context = y, this.selector = a, this;
        }
        return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : m.isFunction(a) ? void 0 !== x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector,
        this.context = a.context), m.makeArray(a, this));
    }).prototype = m.fn, x = m(y);
    var B = /^(?:parents|prev(?:Until|All))/, C = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    m.extend({
        dir: function(a, b, c) {
            for (var d = [], e = a[b]; e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c)); ) 1 === e.nodeType && d.push(e),
            e = e[b];
            return d;
        },
        sibling: function(a, b) {
            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
            return c;
        }
    }), m.fn.extend({
        has: function(a) {
            var b, c = m(a, this), d = c.length;
            return this.filter(function() {
                for (b = 0; d > b; b++) if (m.contains(this, c[b])) return !0;
            });
        },
        closest: function(a, b) {
            for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && m.find.matchesSelector(c, a))) {
                f.push(c);
                break;
            }
            return this.pushStack(f.length > 1 ? m.unique(f) : f);
        },
        index: function(a) {
            return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(a, b) {
            return this.pushStack(m.unique(m.merge(this.get(), m(a, b))));
        },
        addBack: function(a) {
            return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
        }
    }), m.each({
        parent: function(a) {
            var b = a.parentNode;
            return b && 11 !== b.nodeType ? b : null;
        },
        parents: function(a) {
            return m.dir(a, "parentNode");
        },
        parentsUntil: function(a, b, c) {
            return m.dir(a, "parentNode", c);
        },
        next: function(a) {
            return D(a, "nextSibling");
        },
        prev: function(a) {
            return D(a, "previousSibling");
        },
        nextAll: function(a) {
            return m.dir(a, "nextSibling");
        },
        prevAll: function(a) {
            return m.dir(a, "previousSibling");
        },
        nextUntil: function(a, b, c) {
            return m.dir(a, "nextSibling", c);
        },
        prevUntil: function(a, b, c) {
            return m.dir(a, "previousSibling", c);
        },
        siblings: function(a) {
            return m.sibling((a.parentNode || {}).firstChild, a);
        },
        children: function(a) {
            return m.sibling(a.firstChild);
        },
        contents: function(a) {
            return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes);
        }
    }, function(a, b) {
        m.fn[a] = function(c, d) {
            var e = m.map(this, b, c);
            return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = m.filter(d, e)),
            this.length > 1 && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())),
            this.pushStack(e);
        };
    });
    var E = /\S+/g, F = {};
    m.Callbacks = function(a) {
        a = "string" == typeof a ? F[a] || G(a) : m.extend({}, a);
        var b, c, d, e, f, g, h = [], i = !a.once && [], j = function(l) {
            for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && e > f; f++) if (!1 === h[f].apply(l[0], l[1]) && a.stopOnFalse) {
                c = !1;
                break;
            }
            b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable());
        }, k = {
            add: function() {
                if (h) {
                    var d = h.length;
                    !function f(b) {
                        m.each(b, function(b, c) {
                            var d = m.type(c);
                            "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c);
                        });
                    }(arguments), b ? e = h.length : c && (g = d, j(c));
                }
                return this;
            },
            remove: function() {
                return h && m.each(arguments, function(a, c) {
                    for (var d; (d = m.inArray(c, h, d)) > -1; ) h.splice(d, 1), b && (e >= d && e--,
                    f >= d && f--);
                }), this;
            },
            has: function(a) {
                return a ? m.inArray(a, h) > -1 : !(!h || !h.length);
            },
            empty: function() {
                return h = [], e = 0, this;
            },
            disable: function() {
                return h = i = c = void 0, this;
            },
            disabled: function() {
                return !h;
            },
            lock: function() {
                return i = void 0, c || k.disable(), this;
            },
            locked: function() {
                return !i;
            },
            fireWith: function(a, c) {
                return !h || d && !i || (c = c || [], c = [ a, c.slice ? c.slice() : c ], b ? i.push(c) : j(c)),
                this;
            },
            fire: function() {
                return k.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!d;
            }
        };
        return k;
    }, m.extend({
        Deferred: function(a) {
            var b = [ [ "resolve", "done", m.Callbacks("once memory"), "resolved" ], [ "reject", "fail", m.Callbacks("once memory"), "rejected" ], [ "notify", "progress", m.Callbacks("memory") ] ], c = "pending", d = {
                state: function() {
                    return c;
                },
                always: function() {
                    return e.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var a = arguments;
                    return m.Deferred(function(c) {
                        m.each(b, function(b, f) {
                            var g = m.isFunction(a[b]) && a[b];
                            e[f[1]](function() {
                                var a = g && g.apply(this, arguments);
                                a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [ a ] : arguments);
                            });
                        }), a = null;
                    }).promise();
                },
                promise: function(a) {
                    return null != a ? m.extend(a, d) : d;
                }
            }, e = {};
            return d.pipe = d.then, m.each(b, function(a, f) {
                var g = f[2], h = f[3];
                d[f[1]] = g.add, h && g.add(function() {
                    c = h;
                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
                    return e[f[0] + "With"](this === e ? d : this, arguments), this;
                }, e[f[0] + "With"] = g.fireWith;
            }), d.promise(e), a && a.call(e, e), e;
        },
        when: function(a) {
            var i, j, k, b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && m.isFunction(a.promise) ? e : 0, g = 1 === f ? a : m.Deferred(), h = function(a, b, c) {
                return function(e) {
                    b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
                };
            };
            if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
            return f || g.resolveWith(k, c), g.promise();
        }
    });
    var H;
    m.fn.ready = function(a) {
        return m.ready.promise().done(a), this;
    }, m.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(a) {
            a ? m.readyWait++ : m.ready(!0);
        },
        ready: function(a) {
            if (!0 === a ? !--m.readyWait : !m.isReady) {
                if (!y.body) return setTimeout(m.ready);
                m.isReady = !0, !0 !== a && --m.readyWait > 0 || (H.resolveWith(y, [ m ]), m.fn.triggerHandler && (m(y).triggerHandler("ready"),
                m(y).off("ready")));
            }
        }
    }), m.ready.promise = function(b) {
        if (!H) if (H = m.Deferred(), "complete" === y.readyState) setTimeout(m.ready); else if (y.addEventListener) y.addEventListener("DOMContentLoaded", J, !1),
        a.addEventListener("load", J, !1); else {
            y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J);
            var c = !1;
            try {
                c = null == a.frameElement && y.documentElement;
            } catch (d) {}
            c && c.doScroll && function e() {
                if (!m.isReady) {
                    try {
                        c.doScroll("left");
                    } catch (a) {
                        return setTimeout(e, 50);
                    }
                    I(), m.ready();
                }
            }();
        }
        return H.promise(b);
    };
    var L, K = "undefined";
    for (L in m(k)) break;
    k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function() {
        var a, b, c, d;
        (c = y.getElementsByTagName("body")[0]) && c.style && (b = y.createElement("div"),
        d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px",
        c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",
        k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(d));
    }), function() {
        var a = y.createElement("div");
        if (null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete a.test;
            } catch (b) {
                k.deleteExpando = !1;
            }
        }
        a = null;
    }(), m.acceptData = function(a) {
        var b = m.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1;
        return (1 === c || 9 === c) && (!b || !0 !== b && a.getAttribute("classid") === b);
    };
    var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, N = /([A-Z])/g;
    m.extend({
        cache: {},
        noData: {
            "applet ": !0,
            "embed ": !0,
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(a) {
            return !!(a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando]) && !P(a);
        },
        data: function(a, b, c) {
            return Q(a, b, c);
        },
        removeData: function(a, b) {
            return R(a, b);
        },
        _data: function(a, b, c) {
            return Q(a, b, c, !0);
        },
        _removeData: function(a, b) {
            return R(a, b, !0);
        }
    }), m.fn.extend({
        data: function(a, b) {
            var c, d, e, f = this[0], g = f && f.attributes;
            if (void 0 === a) {
                if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) {
                    for (c = g.length; c--; ) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = m.camelCase(d.slice(5)),
                    O(f, d, e[d])));
                    m._data(f, "parsedAttrs", !0);
                }
                return e;
            }
            return "object" == typeof a ? this.each(function() {
                m.data(this, a);
            }) : arguments.length > 1 ? this.each(function() {
                m.data(this, a, b);
            }) : f ? O(f, a, m.data(f, a)) : void 0;
        },
        removeData: function(a) {
            return this.each(function() {
                m.removeData(this, a);
            });
        }
    }), m.extend({
        queue: function(a, b, c) {
            var d;
            return a ? (b = (b || "fx") + "queue", d = m._data(a, b), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)),
            d || []) : void 0;
        },
        dequeue: function(a, b) {
            b = b || "fx";
            var c = m.queue(a, b), d = c.length, e = c.shift(), f = m._queueHooks(a, b), g = function() {
                m.dequeue(a, b);
            };
            "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"),
            delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
        },
        _queueHooks: function(a, b) {
            var c = b + "queueHooks";
            return m._data(a, c) || m._data(a, c, {
                empty: m.Callbacks("once memory").add(function() {
                    m._removeData(a, b + "queue"), m._removeData(a, c);
                })
            });
        }
    }), m.fn.extend({
        queue: function(a, b) {
            var c = 2;
            return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                var c = m.queue(this, a, b);
                m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a);
            });
        },
        dequeue: function(a) {
            return this.each(function() {
                m.dequeue(this, a);
            });
        },
        clearQueue: function(a) {
            return this.queue(a || "fx", []);
        },
        promise: function(a, b) {
            var c, d = 1, e = m.Deferred(), f = this, g = this.length, h = function() {
                --d || e.resolveWith(f, [ f ]);
            };
            for ("string" != typeof a && (b = a, a = void 0), a = a || "fx"; g--; ) (c = m._data(f[g], a + "queueHooks")) && c.empty && (d++,
            c.empty.add(h));
            return h(), e.promise(b);
        }
    });
    var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = [ "Top", "Right", "Bottom", "Left" ], U = function(a, b) {
        return a = b || a, "none" === m.css(a, "display") || !m.contains(a.ownerDocument, a);
    }, V = m.access = function(a, b, c, d, e, f, g) {
        var h = 0, i = a.length, j = null == c;
        if ("object" === m.type(c)) {
            e = !0;
            for (h in c) m.access(a, b, h, c[h], !0, f, g);
        } else if (void 0 !== d && (e = !0, m.isFunction(d) || (g = !0), j && (g ? (b.call(a, d),
        b = null) : (j = b, b = function(a, b, c) {
            return j.call(m(a), c);
        })), b)) for (;i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
    }, W = /^(?:checkbox|radio)$/i;
    !function() {
        var a = y.createElement("input"), b = y.createElement("div"), c = y.createDocumentFragment();
        if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",
        k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length,
        k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML,
        a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked,
        b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue,
        c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>",
        k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0,
        b.attachEvent && (b.attachEvent("onclick", function() {
            k.noCloneEvent = !1;
        }), b.cloneNode(!0).click()), null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete b.test;
            } catch (d) {
                k.deleteExpando = !1;
            }
        }
    }(), function() {
        var b, c, d = y.createElement("div");
        for (b in {
            submit: !0,
            change: !0,
            focusin: !0
        }) c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), k[b + "Bubbles"] = !1 === d.attributes[c].expando);
        d = null;
    }();
    var X = /^(?:input|select|textarea)$/i, Y = /^key/, Z = /^(?:mouse|pointer|contextmenu)|click/, $ = /^(?:focusinfocus|focusoutblur)$/, _ = /^([^.]*)(?:\.(.+)|)$/;
    m.event = {
        global: {},
        add: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m._data(a);
            if (r) {
                for (c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = m.guid++),
                (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function(a) {
                    return typeof m === K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments);
                }, k.elem = a), b = (b || "").match(E) || [ "" ], h = b.length; h--; ) f = _.exec(b[h]) || [],
                o = q = f[1], p = (f[2] || "").split(".").sort(), o && (j = m.event.special[o] || {},
                o = (e ? j.delegateType : j.bindType) || o, j = m.event.special[o] || {}, l = m.extend({
                    type: o,
                    origType: q,
                    data: d,
                    handler: c,
                    guid: c.guid,
                    selector: e,
                    needsContext: e && m.expr.match.needsContext.test(e),
                    namespace: p.join(".")
                }, i), (n = g[o]) || (n = g[o] = [], n.delegateCount = 0, j.setup && !1 !== j.setup.call(a, d, p, k) || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))),
                j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? n.splice(n.delegateCount++, 0, l) : n.push(l),
                m.event.global[o] = !0);
                a = null;
            }
        },
        remove: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m.hasData(a) && m._data(a);
            if (r && (k = r.events)) {
                for (b = (b || "").match(E) || [ "" ], j = b.length; j--; ) if (h = _.exec(b[j]) || [],
                o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
                    for (l = m.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, n = k[o] || [],
                    h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = n.length; f--; ) g = n[f],
                    !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1),
                    g.selector && n.delegateCount--, l.remove && l.remove.call(a, g));
                    i && !n.length && (l.teardown && !1 !== l.teardown.call(a, p, r.handle) || m.removeEvent(a, o, r.handle),
                    delete k[o]);
                } else for (o in k) m.event.remove(a, o + b[j], c, d, !0);
                m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events"));
            }
        },
        trigger: function(b, c, d, e) {
            var f, g, h, i, k, l, n, o = [ d || y ], p = j.call(b, "type") ? b.type : b, q = j.call(b, "namespace") ? b.namespace.split(".") : [];
            if (h = l = d = d || y, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."),
            p = q.shift(), q.sort()), g = p.indexOf(":") < 0 && "on" + p, b = b[m.expando] ? b : new m.Event(p, "object" == typeof b && b),
            b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
            b.result = void 0, b.target || (b.target = d), c = null == c ? [ b ] : m.makeArray(c, [ b ]),
            k = m.event.special[p] || {}, e || !k.trigger || !1 !== k.trigger.apply(d, c))) {
                if (!e && !k.noBubble && !m.isWindow(d)) {
                    for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h),
                    l = h;
                    l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a);
                }
                for (n = 0; (h = o[n++]) && !b.isPropagationStopped(); ) b.type = n > 1 ? i : k.bindType || p,
                f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle"), f && f.apply(h, c),
                (f = g && h[g]) && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), !1 === b.result && b.preventDefault());
                if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || !1 === k._default.apply(o.pop(), c)) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) {
                    l = d[g], l && (d[g] = null), m.event.triggered = p;
                    try {
                        d[p]();
                    } catch (r) {}
                    m.event.triggered = void 0, l && (d[g] = l);
                }
                return b.result;
            }
        },
        dispatch: function(a) {
            a = m.event.fix(a);
            var b, c, e, f, g, h = [], i = d.call(arguments), j = (m._data(this, "events") || {})[a.type] || [], k = m.event.special[a.type] || {};
            if (i[0] = a, a.delegateTarget = this, !k.preDispatch || !1 !== k.preDispatch.call(this, a)) {
                for (h = m.event.handlers.call(this, a, j), b = 0; (f = h[b++]) && !a.isPropagationStopped(); ) for (a.currentTarget = f.elem,
                g = 0; (e = f.handlers[g++]) && !a.isImmediatePropagationStopped(); ) (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e,
                a.data = e.data, void 0 !== (c = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i)) && !1 === (a.result = c) && (a.preventDefault(),
                a.stopPropagation()));
                return k.postDispatch && k.postDispatch.call(this, a), a.result;
            }
        },
        handlers: function(a, b) {
            var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type)) for (;i != this; i = i.parentNode || this) if (1 === i.nodeType && (!0 !== i.disabled || "click" !== a.type)) {
                for (e = [], f = 0; h > f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? m(c, this).index(i) >= 0 : m.find(c, this, null, [ i ]).length),
                e[c] && e.push(d);
                e.length && g.push({
                    elem: i,
                    handlers: e
                });
            }
            return h < b.length && g.push({
                elem: this,
                handlers: b.slice(h)
            }), g;
        },
        fix: function(a) {
            if (a[m.expando]) return a;
            var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
            for (g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}),
            d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), b = d.length; b--; ) c = d[b],
            a[c] = f[c];
            return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode),
            a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(a, b) {
                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode),
                a;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(a, b) {
                var c, d, e, f = b.button, g = b.fromElement;
                return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || y,
                e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0),
                a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)),
                !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0),
                a;
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== ca() && this.focus) try {
                        return this.focus(), !1;
                    } catch (a) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === ca() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(),
                    !1) : void 0;
                },
                _default: function(a) {
                    return m.nodeName(a.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(a) {
                    void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
                }
            }
        },
        simulate: function(a, b, c, d) {
            var e = m.extend(new m.Event(), c, {
                type: a,
                isSimulated: !0,
                originalEvent: {}
            });
            d ? m.event.trigger(e, null, b) : m.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
        }
    }, m.removeEvent = y.removeEventListener ? function(a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c, !1);
    } : function(a, b, c) {
        var d = "on" + b;
        a.detachEvent && (typeof a[d] === K && (a[d] = null), a.detachEvent(d, c));
    }, m.Event = function(a, b) {
        return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type,
        this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && !1 === a.returnValue ? aa : ba) : this.type = a,
        b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void (this[m.expando] = !0)) : new m.Event(a, b);
    }, m.Event.prototype = {
        isDefaultPrevented: ba,
        isPropagationStopped: ba,
        isImmediatePropagationStopped: ba,
        preventDefault: function() {
            var a = this.originalEvent;
            this.isDefaultPrevented = aa, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
        },
        stopPropagation: function() {
            var a = this.originalEvent;
            this.isPropagationStopped = aa, a && (a.stopPropagation && a.stopPropagation(),
            a.cancelBubble = !0);
        },
        stopImmediatePropagation: function() {
            var a = this.originalEvent;
            this.isImmediatePropagationStopped = aa, a && a.stopImmediatePropagation && a.stopImmediatePropagation(),
            this.stopPropagation();
        }
    }, m.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(a, b) {
        m.event.special[a] = {
            delegateType: b,
            bindType: b,
            handle: function(a) {
                var c, d = this, e = a.relatedTarget, f = a.handleObj;
                return (!e || e !== d && !m.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments),
                a.type = b), c;
            }
        };
    }), k.submitBubbles || (m.event.special.submit = {
        setup: function() {
            return !m.nodeName(this, "form") && void m.event.add(this, "click._submit keypress._submit", function(a) {
                var b = a.target, c = m.nodeName(b, "input") || m.nodeName(b, "button") ? b.form : void 0;
                c && !m._data(c, "submitBubbles") && (m.event.add(c, "submit._submit", function(a) {
                    a._submit_bubble = !0;
                }), m._data(c, "submitBubbles", !0));
            });
        },
        postDispatch: function(a) {
            a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0));
        },
        teardown: function() {
            return !m.nodeName(this, "form") && void m.event.remove(this, "._submit");
        }
    }), k.changeBubbles || (m.event.special.change = {
        setup: function() {
            return X.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (m.event.add(this, "propertychange._change", function(a) {
                "checked" === a.originalEvent.propertyName && (this._just_changed = !0);
            }), m.event.add(this, "click._change", function(a) {
                this._just_changed && !a.isTrigger && (this._just_changed = !1), m.event.simulate("change", this, a, !0);
            })), !1) : void m.event.add(this, "beforeactivate._change", function(a) {
                var b = a.target;
                X.test(b.nodeName) && !m._data(b, "changeBubbles") && (m.event.add(b, "change._change", function(a) {
                    !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0);
                }), m._data(b, "changeBubbles", !0));
            });
        },
        handle: function(a) {
            var b = a.target;
            return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0;
        },
        teardown: function() {
            return m.event.remove(this, "._change"), !X.test(this.nodeName);
        }
    }), k.focusinBubbles || m.each({
        focus: "focusin",
        blur: "focusout"
    }, function(a, b) {
        var c = function(a) {
            m.event.simulate(b, a.target, m.event.fix(a), !0);
        };
        m.event.special[b] = {
            setup: function() {
                var d = this.ownerDocument || this, e = m._data(d, b);
                e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1);
            },
            teardown: function() {
                var d = this.ownerDocument || this, e = m._data(d, b) - 1;
                e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b));
            }
        };
    }), m.fn.extend({
        on: function(a, b, c, d, e) {
            var f, g;
            if ("object" == typeof a) {
                "string" != typeof b && (c = c || b, b = void 0);
                for (f in a) this.on(f, b, c, a[f], e);
                return this;
            }
            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c,
            c = void 0) : (d = c, c = b, b = void 0)), !1 === d) d = ba; else if (!d) return this;
            return 1 === e && (g = d, d = function(a) {
                return m().off(a), g.apply(this, arguments);
            }, d.guid = g.guid || (g.guid = m.guid++)), this.each(function() {
                m.event.add(this, a, d, c, b);
            });
        },
        one: function(a, b, c, d) {
            return this.on(a, b, c, d, 1);
        },
        off: function(a, b, c) {
            var d, e;
            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler),
            this;
            if ("object" == typeof a) {
                for (e in a) this.off(e, b, a[e]);
                return this;
            }
            return (!1 === b || "function" == typeof b) && (c = b, b = void 0), !1 === c && (c = ba),
            this.each(function() {
                m.event.remove(this, a, c, b);
            });
        },
        trigger: function(a, b) {
            return this.each(function() {
                m.event.trigger(a, b, this);
            });
        },
        triggerHandler: function(a, b) {
            var c = this[0];
            return c ? m.event.trigger(a, b, c, !0) : void 0;
        }
    });
    var ea = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", fa = / jQuery\d+="(?:null|\d+)"/g, ga = new RegExp("<(?:" + ea + ")[\\s/>]", "i"), ha = /^\s+/, ia = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, ja = /<([\w:]+)/, ka = /<tbody/i, la = /<|&#?\w+;/, ma = /<(?:script|style|link)/i, na = /checked\s*(?:[^=]|=\s*.checked.)/i, oa = /^$|\/(?:java|ecma)script/i, pa = /^true\/(.*)/, qa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, ra = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: k.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, sa = da(y), ta = sa.appendChild(y.createElement("div"));
    ra.optgroup = ra.option, ra.tbody = ra.tfoot = ra.colgroup = ra.caption = ra.thead,
    ra.th = ra.td, m.extend({
        clone: function(a, b, c) {
            var d, e, f, g, h, i = m.contains(a.ownerDocument, a);
            if (k.html5Clone || m.isXMLDoc(a) || !ga.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (ta.innerHTML = a.outerHTML,
            ta.removeChild(f = ta.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a))) for (d = ua(f),
            h = ua(a), g = 0; null != (e = h[g]); ++g) d[g] && Ba(e, d[g]);
            if (b) if (c) for (h = h || ua(a), d = d || ua(f), g = 0; null != (e = h[g]); g++) Aa(e, d[g]); else Aa(a, f);
            return d = ua(f, "script"), d.length > 0 && za(d, !i && ua(a, "script")), d = h = e = null,
            f;
        },
        buildFragment: function(a, b, c, d) {
            for (var e, f, g, h, i, j, l, n = a.length, o = da(b), p = [], q = 0; n > q; q++) if ((f = a[q]) || 0 === f) if ("object" === m.type(f)) m.merge(p, f.nodeType ? [ f ] : f); else if (la.test(f)) {
                for (h = h || o.appendChild(b.createElement("div")), i = (ja.exec(f) || [ "", "" ])[1].toLowerCase(),
                l = ra[i] || ra._default, h.innerHTML = l[1] + f.replace(ia, "<$1></$2>") + l[2],
                e = l[0]; e--; ) h = h.lastChild;
                if (!k.leadingWhitespace && ha.test(f) && p.push(b.createTextNode(ha.exec(f)[0])),
                !k.tbody) for (f = "table" !== i || ka.test(f) ? "<table>" !== l[1] || ka.test(f) ? 0 : h : h.firstChild,
                e = f && f.childNodes.length; e--; ) m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
                for (m.merge(p, h.childNodes), h.textContent = ""; h.firstChild; ) h.removeChild(h.firstChild);
                h = o.lastChild;
            } else p.push(b.createTextNode(f));
            for (h && o.removeChild(h), k.appendChecked || m.grep(ua(p, "input"), va), q = 0; f = p[q++]; ) if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f),
            h = ua(o.appendChild(f), "script"), g && za(h), c)) for (e = 0; f = h[e++]; ) oa.test(f.type || "") && c.push(f);
            return h = null, o;
        },
        cleanData: function(a, b) {
            for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++) if ((b || m.acceptData(d)) && (f = d[i],
            g = f && j[f])) {
                if (g.events) for (e in g.events) n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle);
                j[f] && (delete j[f], l ? delete d[i] : typeof d.removeAttribute !== K ? d.removeAttribute(i) : d[i] = null,
                c.push(f));
            }
        }
    }), m.fn.extend({
        text: function(a) {
            return V(this, function(a) {
                return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a));
            }, null, a, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    wa(this, a).appendChild(a);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = wa(this, a);
                    b.insertBefore(a, b.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
            });
        },
        remove: function(a, b) {
            for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || m.cleanData(ua(c)),
            c.parentNode && (b && m.contains(c.ownerDocument, c) && za(ua(c, "script")), c.parentNode.removeChild(c));
            return this;
        },
        empty: function() {
            for (var a, b = 0; null != (a = this[b]); b++) {
                for (1 === a.nodeType && m.cleanData(ua(a, !1)); a.firstChild; ) a.removeChild(a.firstChild);
                a.options && m.nodeName(a, "select") && (a.options.length = 0);
            }
            return this;
        },
        clone: function(a, b) {
            return a = null != a && a, b = null == b ? a : b, this.map(function() {
                return m.clone(this, a, b);
            });
        },
        html: function(a) {
            return V(this, function(a) {
                var b = this[0] || {}, c = 0, d = this.length;
                if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(fa, "") : void 0;
                if (!("string" != typeof a || ma.test(a) || !k.htmlSerialize && ga.test(a) || !k.leadingWhitespace && ha.test(a) || ra[(ja.exec(a) || [ "", "" ])[1].toLowerCase()])) {
                    a = a.replace(ia, "<$1></$2>");
                    try {
                        for (;d > c; c++) b = this[c] || {}, 1 === b.nodeType && (m.cleanData(ua(b, !1)),
                        b.innerHTML = a);
                        b = 0;
                    } catch (e) {}
                }
                b && this.empty().append(a);
            }, null, a, arguments.length);
        },
        replaceWith: function() {
            var a = arguments[0];
            return this.domManip(arguments, function(b) {
                a = this.parentNode, m.cleanData(ua(this)), a && a.replaceChild(b, this);
            }), a && (a.length || a.nodeType) ? this : this.remove();
        },
        detach: function(a) {
            return this.remove(a, !0);
        },
        domManip: function(a, b) {
            a = e.apply([], a);
            var c, d, f, g, h, i, j = 0, l = this.length, n = this, o = l - 1, p = a[0], q = m.isFunction(p);
            if (q || l > 1 && "string" == typeof p && !k.checkClone && na.test(p)) return this.each(function(c) {
                var d = n.eq(c);
                q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
            });
            if (l && (i = m.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild,
            1 === i.childNodes.length && (i = c), c)) {
                for (g = m.map(ua(i, "script"), xa), f = g.length; l > j; j++) d = i, j !== o && (d = m.clone(d, !0, !0),
                f && m.merge(g, ua(d, "script"))), b.call(this[j], d, j);
                if (f) for (h = g[g.length - 1].ownerDocument, m.map(g, ya), j = 0; f > j; j++) d = g[j],
                oa.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qa, "")));
                i = c = null;
            }
            return this;
        }
    }), m.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(a, b) {
        m.fn[a] = function(a) {
            for (var c, d = 0, e = [], g = m(a), h = g.length - 1; h >= d; d++) c = d === h ? this : this.clone(!0),
            m(g[d])[b](c), f.apply(e, c.get());
            return this.pushStack(e);
        };
    });
    var Ca, Da = {};
    !function() {
        var a;
        k.shrinkWrapBlocks = function() {
            if (null != a) return a;
            a = !1;
            var b, c, d;
            return c = y.getElementsByTagName("body")[0], c && c.style ? (b = y.createElement("div"),
            d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px",
            c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",
            b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth),
            c.removeChild(d), a) : void 0;
        };
    }();
    var Ia, Ja, Ga = /^margin/, Ha = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"), Ka = /^(top|right|bottom|left)$/;
    a.getComputedStyle ? (Ia = function(b) {
        return b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView.getComputedStyle(b, null) : a.getComputedStyle(b, null);
    }, Ja = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Ia(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)),
        Ha.test(g) && Ga.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g,
        g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + "";
    }) : y.documentElement.currentStyle && (Ia = function(a) {
        return a.currentStyle;
    }, Ja = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Ia(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]),
        Ha.test(g) && !Ka.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left),
        h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)),
        void 0 === g ? g : g + "" || "auto";
    }), !function() {
        function i() {
            var b, c, d, i;
            (c = y.getElementsByTagName("body")[0]) && c.style && (b = y.createElement("div"),
            d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px",
            c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",
            e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top,
            f = "4px" === (a.getComputedStyle(b, null) || {
                width: "4px"
            }).width, i = b.appendChild(y.createElement("div")), i.style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",
            i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight),
            b.removeChild(i)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>",
            i = b.getElementsByTagName("td"), i[0].style.cssText = "margin:0;border:0;padding:0;display:none",
            g = 0 === i[0].offsetHeight, g && (i[0].style.display = "", i[1].style.display = "none",
            g = 0 === i[0].offsetHeight), c.removeChild(d));
        }
        var b, c, d, e, f, g, h;
        b = y.createElement("div"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",
        d = b.getElementsByTagName("a")[0], (c = d && d.style) && (c.cssText = "float:left;opacity:.5",
        k.opacity = "0.5" === c.opacity, k.cssFloat = !!c.cssFloat, b.style.backgroundClip = "content-box",
        b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip,
        k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing,
        m.extend(k, {
            reliableHiddenOffsets: function() {
                return null == g && i(), g;
            },
            boxSizingReliable: function() {
                return null == f && i(), f;
            },
            pixelPosition: function() {
                return null == e && i(), e;
            },
            reliableMarginRight: function() {
                return null == h && i(), h;
            }
        }));
    }(), m.swap = function(a, b, c, d) {
        var e, f, g = {};
        for (f in b) g[f] = a.style[f], a.style[f] = b[f];
        e = c.apply(a, d || []);
        for (f in b) a.style[f] = g[f];
        return e;
    };
    var Ma = /alpha\([^)]*\)/i, Na = /opacity\s*=\s*([^)]*)/, Oa = /^(none|table(?!-c[ea]).+)/, Pa = new RegExp("^(" + S + ")(.*)$", "i"), Qa = new RegExp("^([+-])=(" + S + ")", "i"), Ra = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Sa = {
        letterSpacing: "0",
        fontWeight: "400"
    }, Ta = [ "Webkit", "O", "Moz", "ms" ];
    m.extend({
        cssHooks: {
            opacity: {
                get: function(a, b) {
                    if (b) {
                        var c = Ja(a, "opacity");
                        return "" === c ? "1" : c;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: k.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = m.camelCase(b), i = a.style;
                if (b = m.cssProps[h] || (m.cssProps[h] = Ua(i, h)), g = m.cssHooks[b] || m.cssHooks[h],
                void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                if (f = typeof c, "string" === f && (e = Qa.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)),
                f = "number"), null != c && c === c && ("number" !== f || m.cssNumber[h] || (c += "px"),
                k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"),
                !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
                    i[b] = c;
                } catch (j) {}
            }
        },
        css: function(a, b, c, d) {
            var e, f, g, h = m.camelCase(b);
            return b = m.cssProps[h] || (m.cssProps[h] = Ua(a.style, h)), g = m.cssHooks[b] || m.cssHooks[h],
            g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Ja(a, b, d)), "normal" === f && b in Sa && (f = Sa[b]),
            "" === c || c ? (e = parseFloat(f), !0 === c || m.isNumeric(e) ? e || 0 : f) : f;
        }
    }), m.each([ "height", "width" ], function(a, b) {
        m.cssHooks[b] = {
            get: function(a, c, d) {
                return c ? Oa.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Ra, function() {
                    return Ya(a, b, d);
                }) : Ya(a, b, d) : void 0;
            },
            set: function(a, c, d) {
                var e = d && Ia(a);
                return Wa(a, c, d ? Xa(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0);
            }
        };
    }), k.opacity || (m.cssHooks.opacity = {
        get: function(a, b) {
            return Na.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "";
        },
        set: function(a, b) {
            var c = a.style, d = a.currentStyle, e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || "";
            c.zoom = 1, (b >= 1 || "" === b) && "" === m.trim(f.replace(Ma, "")) && c.removeAttribute && (c.removeAttribute("filter"),
            "" === b || d && !d.filter) || (c.filter = Ma.test(f) ? f.replace(Ma, e) : f + " " + e);
        }
    }), m.cssHooks.marginRight = La(k.reliableMarginRight, function(a, b) {
        return b ? m.swap(a, {
            display: "inline-block"
        }, Ja, [ a, "marginRight" ]) : void 0;
    }), m.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(a, b) {
        m.cssHooks[a + b] = {
            expand: function(c) {
                for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [ c ]; 4 > d; d++) e[a + T[d] + b] = f[d] || f[d - 2] || f[0];
                return e;
            }
        }, Ga.test(a) || (m.cssHooks[a + b].set = Wa);
    }), m.fn.extend({
        css: function(a, b) {
            return V(this, function(a, b, c) {
                var d, e, f = {}, g = 0;
                if (m.isArray(b)) {
                    for (d = Ia(a), e = b.length; e > g; g++) f[b[g]] = m.css(a, b[g], !1, d);
                    return f;
                }
                return void 0 !== c ? m.style(a, b, c) : m.css(a, b);
            }, a, b, arguments.length > 1);
        },
        show: function() {
            return Va(this, !0);
        },
        hide: function() {
            return Va(this);
        },
        toggle: function(a) {
            return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                U(this) ? m(this).show() : m(this).hide();
            });
        }
    }), m.Tween = Za, Za.prototype = {
        constructor: Za,
        init: function(a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(),
            this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px");
        },
        cur: function() {
            var a = Za.propHooks[this.prop];
            return a && a.get ? a.get(this) : Za.propHooks._default.get(this);
        },
        run: function(a) {
            var b, c = Za.propHooks[this.prop];
            return this.options.duration ? this.pos = b = m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a,
            this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this),
            c && c.set ? c.set(this) : Za.propHooks._default.set(this), this;
        }
    }, Za.prototype.init.prototype = Za.prototype, Za.propHooks = {
        _default: {
            get: function(a) {
                var b;
                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, ""),
                b && "auto" !== b ? b : 0) : a.elem[a.prop];
            },
            set: function(a) {
                m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
            }
        }
    }, Za.propHooks.scrollTop = Za.propHooks.scrollLeft = {
        set: function(a) {
            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
        }
    }, m.easing = {
        linear: function(a) {
            return a;
        },
        swing: function(a) {
            return .5 - Math.cos(a * Math.PI) / 2;
        }
    }, m.fx = Za.prototype.init, m.fx.step = {};
    var $a, _a, ab = /^(?:toggle|show|hide)$/, bb = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"), cb = /queueHooks$/, db = [ ib ], eb = {
        "*": [ function(a, b) {
            var c = this.createTween(a, b), d = c.cur(), e = bb.exec(b), f = e && e[3] || (m.cssNumber[a] ? "" : "px"), g = (m.cssNumber[a] || "px" !== f && +d) && bb.exec(m.css(c.elem, a)), h = 1, i = 20;
            if (g && g[3] !== f) {
                f = f || g[3], e = e || [], g = +d || 1;
                do {
                    h = h || ".5", g /= h, m.style(c.elem, a, g + f);
                } while (h !== (h = c.cur() / d) && 1 !== h && --i);
            }
            return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]),
            c;
        } ]
    };
    m.Animation = m.extend(kb, {
        tweener: function(a, b) {
            m.isFunction(a) ? (b = a, a = [ "*" ]) : a = a.split(" ");
            for (var c, d = 0, e = a.length; e > d; d++) c = a[d], eb[c] = eb[c] || [], eb[c].unshift(b);
        },
        prefilter: function(a, b) {
            b ? db.unshift(a) : db.push(a);
        }
    }), m.speed = function(a, b, c) {
        var d = a && "object" == typeof a ? m.extend({}, a) : {
            complete: c || !c && b || m.isFunction(a) && a,
            duration: a,
            easing: c && b || b && !m.isFunction(b) && b
        };
        return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default,
        (null == d.queue || !0 === d.queue) && (d.queue = "fx"), d.old = d.complete, d.complete = function() {
            m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue);
        }, d;
    }, m.fn.extend({
        fadeTo: function(a, b, c, d) {
            return this.filter(U).css("opacity", 0).show().end().animate({
                opacity: b
            }, a, c, d);
        },
        animate: function(a, b, c, d) {
            var e = m.isEmptyObject(a), f = m.speed(b, c, d), g = function() {
                var b = kb(this, m.extend({}, a), f);
                (e || m._data(this, "finish")) && b.stop(!0);
            };
            return g.finish = g, e || !1 === f.queue ? this.each(g) : this.queue(f.queue, g);
        },
        stop: function(a, b, c) {
            var d = function(a) {
                var b = a.stop;
                delete a.stop, b(c);
            };
            return "string" != typeof a && (c = b, b = a, a = void 0), b && !1 !== a && this.queue(a || "fx", []),
            this.each(function() {
                var b = !0, e = null != a && a + "queueHooks", f = m.timers, g = m._data(this);
                if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && cb.test(e) && d(g[e]);
                for (e = f.length; e--; ) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c),
                b = !1, f.splice(e, 1));
                (b || !c) && m.dequeue(this, a);
            });
        },
        finish: function(a) {
            return !1 !== a && (a = a || "fx"), this.each(function() {
                var b, c = m._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = m.timers, g = d ? d.length : 0;
                for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0),
                b = f.length; b--; ) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0),
                f.splice(b, 1));
                for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
                delete c.finish;
            });
        }
    }), m.each([ "toggle", "show", "hide" ], function(a, b) {
        var c = m.fn[b];
        m.fn[b] = function(a, d, e) {
            return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e);
        };
    }), m.each({
        slideDown: gb("show"),
        slideUp: gb("hide"),
        slideToggle: gb("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(a, b) {
        m.fn[a] = function(a, c, d) {
            return this.animate(b, a, c, d);
        };
    }), m.timers = [], m.fx.tick = function() {
        var a, b = m.timers, c = 0;
        for ($a = m.now(); c < b.length; c++) (a = b[c])() || b[c] !== a || b.splice(c--, 1);
        b.length || m.fx.stop(), $a = void 0;
    }, m.fx.timer = function(a) {
        m.timers.push(a), a() ? m.fx.start() : m.timers.pop();
    }, m.fx.interval = 13, m.fx.start = function() {
        _a || (_a = setInterval(m.fx.tick, m.fx.interval));
    }, m.fx.stop = function() {
        clearInterval(_a), _a = null;
    }, m.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, m.fn.delay = function(a, b) {
        return a = m.fx ? m.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
            var d = setTimeout(b, a);
            c.stop = function() {
                clearTimeout(d);
            };
        });
    }, function() {
        var a, b, c, d, e;
        b = y.createElement("div"), b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",
        d = b.getElementsByTagName("a")[0], c = y.createElement("select"), e = c.appendChild(y.createElement("option")),
        a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className,
        k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"),
        k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype,
        c.disabled = !0, k.optDisabled = !e.disabled, a = y.createElement("input"), a.setAttribute("value", ""),
        k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"),
        k.radioValue = "t" === a.value;
    }();
    var lb = /\r/g;
    m.fn.extend({
        val: function(a) {
            var b, c, d, e = this[0];
            return arguments.length ? (d = m.isFunction(a), this.each(function(c) {
                var e;
                1 === this.nodeType && (e = d ? a.call(this, c, m(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : m.isArray(e) && (e = m.map(e, function(a) {
                    return null == a ? "" : a + "";
                })), (b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()]) && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
            })) : e ? (b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value,
            "string" == typeof c ? c.replace(lb, "") : null == c ? "" : c)) : void 0;
        }
    }), m.extend({
        valHooks: {
            option: {
                get: function(a) {
                    var b = m.find.attr(a, "value");
                    return null != b ? b : m.trim(m.text(a));
                }
            },
            select: {
                get: function(a) {
                    for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i],
                    !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) {
                        if (b = m(c).val(), f) return b;
                        g.push(b);
                    }
                    return g;
                },
                set: function(a, b) {
                    for (var c, d, e = a.options, f = m.makeArray(b), g = e.length; g--; ) if (d = e[g],
                    m.inArray(m.valHooks.option.get(d), f) >= 0) try {
                        d.selected = c = !0;
                    } catch (h) {
                        d.scrollHeight;
                    } else d.selected = !1;
                    return c || (a.selectedIndex = -1), e;
                }
            }
        }
    }), m.each([ "radio", "checkbox" ], function() {
        m.valHooks[this] = {
            set: function(a, b) {
                return m.isArray(b) ? a.checked = m.inArray(m(a).val(), b) >= 0 : void 0;
            }
        }, k.checkOn || (m.valHooks[this].get = function(a) {
            return null === a.getAttribute("value") ? "on" : a.value;
        });
    });
    var mb, nb, ob = m.expr.attrHandle, pb = /^(?:checked|selected)$/i, qb = k.getSetAttribute, rb = k.input;
    m.fn.extend({
        attr: function(a, b) {
            return V(this, m.attr, a, b, arguments.length > 1);
        },
        removeAttr: function(a) {
            return this.each(function() {
                m.removeAttr(this, a);
            });
        }
    }), m.extend({
        attr: function(a, b, c) {
            var d, e, f = a.nodeType;
            if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(),
            d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nb : mb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = m.find.attr(a, b),
            null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""),
            c) : void m.removeAttr(a, b));
        },
        removeAttr: function(a, b) {
            var c, d, e = 0, f = b && b.match(E);
            if (f && 1 === a.nodeType) for (;c = f[e++]; ) d = m.propFix[c] || c, m.expr.match.bool.test(c) ? rb && qb || !pb.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""),
            a.removeAttribute(qb ? c : d);
        },
        attrHooks: {
            type: {
                set: function(a, b) {
                    if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) {
                        var c = a.value;
                        return a.setAttribute("type", b), c && (a.value = c), b;
                    }
                }
            }
        }
    }), nb = {
        set: function(a, b, c) {
            return !1 === b ? m.removeAttr(a, c) : rb && qb || !pb.test(c) ? a.setAttribute(!qb && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0,
            c;
        }
    }, m.each(m.expr.match.bool.source.match(/\w+/g), function(a, b) {
        var c = ob[b] || m.find.attr;
        ob[b] = rb && qb || !pb.test(b) ? function(a, b, d) {
            var e, f;
            return d || (f = ob[b], ob[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null,
            ob[b] = f), e;
        } : function(a, b, c) {
            return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null;
        };
    }), rb && qb || (m.attrHooks.value = {
        set: function(a, b, c) {
            return m.nodeName(a, "input") ? void (a.defaultValue = b) : mb && mb.set(a, b, c);
        }
    }), qb || (mb = {
        set: function(a, b, c) {
            var d = a.getAttributeNode(c);
            return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "",
            "value" === c || b === a.getAttribute(c) ? b : void 0;
        }
    }, ob.id = ob.name = ob.coords = function(a, b, c) {
        var d;
        return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null;
    }, m.valHooks.button = {
        get: function(a, b) {
            var c = a.getAttributeNode(b);
            return c && c.specified ? c.value : void 0;
        },
        set: mb.set
    }, m.attrHooks.contenteditable = {
        set: function(a, b, c) {
            mb.set(a, "" !== b && b, c);
        }
    }, m.each([ "width", "height" ], function(a, b) {
        m.attrHooks[b] = {
            set: function(a, c) {
                return "" === c ? (a.setAttribute(b, "auto"), c) : void 0;
            }
        };
    })), k.style || (m.attrHooks.style = {
        get: function(a) {
            return a.style.cssText || void 0;
        },
        set: function(a, b) {
            return a.style.cssText = b + "";
        }
    });
    var sb = /^(?:input|select|textarea|button|object)$/i, tb = /^(?:a|area)$/i;
    m.fn.extend({
        prop: function(a, b) {
            return V(this, m.prop, a, b, arguments.length > 1);
        },
        removeProp: function(a) {
            return a = m.propFix[a] || a, this.each(function() {
                try {
                    this[a] = void 0, delete this[a];
                } catch (b) {}
            });
        }
    }), m.extend({
        propFix: {
            for: "htmlFor",
            class: "className"
        },
        prop: function(a, b, c) {
            var d, e, f, g = a.nodeType;
            if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !m.isXMLDoc(a), f && (b = m.propFix[b] || b,
            e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];
        },
        propHooks: {
            tabIndex: {
                get: function(a) {
                    var b = m.find.attr(a, "tabindex");
                    return b ? parseInt(b, 10) : sb.test(a.nodeName) || tb.test(a.nodeName) && a.href ? 0 : -1;
                }
            }
        }
    }), k.hrefNormalized || m.each([ "href", "src" ], function(a, b) {
        m.propHooks[b] = {
            get: function(a) {
                return a.getAttribute(b, 4);
            }
        };
    }), k.optSelected || (m.propHooks.selected = {
        get: function(a) {
            var b = a.parentNode;
            return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null;
        }
    }), m.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        m.propFix[this.toLowerCase()] = this;
    }), k.enctype || (m.propFix.enctype = "encoding");
    var ub = /[\t\r\n\f]/g;
    m.fn.extend({
        addClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).addClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : " ")) {
                for (f = 0; e = b[f++]; ) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                g = m.trim(d), c.className !== g && (c.className = g);
            }
            return this;
        },
        removeClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).removeClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : "")) {
                for (f = 0; e = b[f++]; ) for (;d.indexOf(" " + e + " ") >= 0; ) d = d.replace(" " + e + " ", " ");
                g = a ? m.trim(d) : "", c.className !== g && (c.className = g);
            }
            return this;
        },
        toggleClass: function(a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function(c) {
                m(this).toggleClass(a.call(this, c, this.className, b), b);
            } : function() {
                if ("string" === c) for (var b, d = 0, e = m(this), f = a.match(E) || []; b = f[d++]; ) e.hasClass(b) ? e.removeClass(b) : e.addClass(b); else (c === K || "boolean" === c) && (this.className && m._data(this, "__className__", this.className),
                this.className = this.className || !1 === a ? "" : m._data(this, "__className__") || "");
            });
        },
        hasClass: function(a) {
            for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ub, " ").indexOf(b) >= 0) return !0;
            return !1;
        }
    }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
        m.fn[b] = function(a, c) {
            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
        };
    }), m.fn.extend({
        hover: function(a, b) {
            return this.mouseenter(a).mouseleave(b || a);
        },
        bind: function(a, b, c) {
            return this.on(a, null, b, c);
        },
        unbind: function(a, b) {
            return this.off(a, null, b);
        },
        delegate: function(a, b, c, d) {
            return this.on(b, a, c, d);
        },
        undelegate: function(a, b, c) {
            return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
        }
    });
    var vb = m.now(), wb = /\?/, xb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    m.parseJSON = function(b) {
        if (a.JSON && a.JSON.parse) return a.JSON.parse(b + "");
        var c, d = null, e = m.trim(b + "");
        return e && !m.trim(e.replace(xb, function(a, b, e, f) {
            return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "");
        })) ? Function("return " + e)() : m.error("Invalid JSON: " + b);
    }, m.parseXML = function(b) {
        var c, d;
        if (!b || "string" != typeof b) return null;
        try {
            a.DOMParser ? (d = new DOMParser(), c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"),
            c.async = "false", c.loadXML(b));
        } catch (e) {
            c = void 0;
        }
        return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b),
        c;
    };
    var yb, zb, Ab = /#.*$/, Bb = /([?&])_=[^&]*/, Cb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Db = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Eb = /^(?:GET|HEAD)$/, Fb = /^\/\//, Gb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Hb = {}, Ib = {}, Jb = "*/".concat("*");
    try {
        zb = location.href;
    } catch (Kb) {
        zb = y.createElement("a"), zb.href = "", zb = zb.href;
    }
    yb = Gb.exec(zb.toLowerCase()) || [], m.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: zb,
            type: "GET",
            isLocal: Db.test(yb[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Jb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": m.parseJSON,
                "text xml": m.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(a, b) {
            return b ? Nb(Nb(a, m.ajaxSettings), b) : Nb(m.ajaxSettings, a);
        },
        ajaxPrefilter: Lb(Hb),
        ajaxTransport: Lb(Ib),
        ajax: function(a, b) {
            function x(a, b, c, d) {
                var j, r, s, u, w, x = b;
                2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", v.readyState = a > 0 ? 4 : 0,
                j = a >= 200 && 300 > a || 304 === a, c && (u = Ob(k, v, c)), u = Pb(k, u, v, j),
                j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (m.lastModified[e] = w),
                (w = v.getResponseHeader("etag")) && (m.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state,
                r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))),
                v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [ r, x, v ]) : o.rejectWith(l, [ v, x, s ]),
                v.statusCode(q), q = void 0, h && n.trigger(j ? "ajaxSuccess" : "ajaxError", [ v, k, j ? r : s ]),
                p.fireWith(l, [ v, x ]), h && (n.trigger("ajaxComplete", [ v, k ]), --m.active || m.event.trigger("ajaxStop")));
            }
            "object" == typeof a && (b = a, a = void 0), b = b || {};
            var c, d, e, f, g, h, i, j, k = m.ajaxSetup({}, b), l = k.context || k, n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event, o = m.Deferred(), p = m.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                readyState: 0,
                getResponseHeader: function(a) {
                    var b;
                    if (2 === t) {
                        if (!j) for (j = {}; b = Cb.exec(f); ) j[b[1].toLowerCase()] = b[2];
                        b = j[a.toLowerCase()];
                    }
                    return null == b ? null : b;
                },
                getAllResponseHeaders: function() {
                    return 2 === t ? f : null;
                },
                setRequestHeader: function(a, b) {
                    var c = a.toLowerCase();
                    return t || (a = s[c] = s[c] || a, r[a] = b), this;
                },
                overrideMimeType: function(a) {
                    return t || (k.mimeType = a), this;
                },
                statusCode: function(a) {
                    var b;
                    if (a) if (2 > t) for (b in a) q[b] = [ q[b], a[b] ]; else v.always(a[v.status]);
                    return this;
                },
                abort: function(a) {
                    var b = a || u;
                    return i && i.abort(b), x(0, b), this;
                }
            };
            if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || zb) + "").replace(Ab, "").replace(Fb, yb[1] + "//"),
            k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [ "" ],
            null == k.crossDomain && (c = Gb.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === yb[1] && c[2] === yb[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (yb[3] || ("http:" === yb[1] ? "80" : "443")))),
            k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)),
            Mb(Hb, k, b, v), 2 === t) return v;
            h = m.event && k.global, h && 0 == m.active++ && m.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(),
            k.hasContent = !Eb.test(k.type), e = k.url, k.hasContent || (k.data && (e = k.url += (wb.test(e) ? "&" : "?") + k.data,
            delete k.data), !1 === k.cache && (k.url = Bb.test(e) ? e.replace(Bb, "$1_=" + vb++) : e + (wb.test(e) ? "&" : "?") + "_=" + vb++)),
            k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]),
            m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && !1 !== k.contentType || b.contentType) && v.setRequestHeader("Content-Type", k.contentType),
            v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jb + "; q=0.01" : "") : k.accepts["*"]);
            for (d in k.headers) v.setRequestHeader(d, k.headers[d]);
            if (k.beforeSend && (!1 === k.beforeSend.call(l, v, k) || 2 === t)) return v.abort();
            u = "abort";
            for (d in {
                success: 1,
                error: 1,
                complete: 1
            }) v[d](k[d]);
            if (i = Mb(Ib, k, b, v)) {
                v.readyState = 1, h && n.trigger("ajaxSend", [ v, k ]), k.async && k.timeout > 0 && (g = setTimeout(function() {
                    v.abort("timeout");
                }, k.timeout));
                try {
                    t = 1, i.send(r, x);
                } catch (w) {
                    if (!(2 > t)) throw w;
                    x(-1, w);
                }
            } else x(-1, "No Transport");
            return v;
        },
        getJSON: function(a, b, c) {
            return m.get(a, b, c, "json");
        },
        getScript: function(a, b) {
            return m.get(a, void 0, b, "script");
        }
    }), m.each([ "get", "post" ], function(a, b) {
        m[b] = function(a, c, d, e) {
            return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({
                url: a,
                type: b,
                dataType: e,
                data: c,
                success: d
            });
        };
    }), m._evalUrl = function(a) {
        return m.ajax({
            url: a,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            throws: !0
        });
    }, m.fn.extend({
        wrapAll: function(a) {
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).wrapAll(a.call(this, b));
            });
            if (this[0]) {
                var b = m(a, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                    for (var a = this; a.firstChild && 1 === a.firstChild.nodeType; ) a = a.firstChild;
                    return a;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(a) {
            return this.each(m.isFunction(a) ? function(b) {
                m(this).wrapInner(a.call(this, b));
            } : function() {
                var b = m(this), c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a);
            });
        },
        wrap: function(a) {
            var b = m.isFunction(a);
            return this.each(function(c) {
                m(this).wrapAll(b ? a.call(this, c) : a);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                m.nodeName(this, "body") || m(this).replaceWith(this.childNodes);
            }).end();
        }
    }), m.expr.filters.hidden = function(a) {
        return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display"));
    }, m.expr.filters.visible = function(a) {
        return !m.expr.filters.hidden(a);
    };
    var Qb = /%20/g, Rb = /\[\]$/, Sb = /\r?\n/g, Tb = /^(?:submit|button|image|reset|file)$/i, Ub = /^(?:input|select|textarea|keygen)/i;
    m.param = function(a, b) {
        var c, d = [], e = function(a, b) {
            b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
        };
        if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray(a) || a.jquery && !m.isPlainObject(a)) m.each(a, function() {
            e(this.name, this.value);
        }); else for (c in a) Vb(c, a[c], b, e);
        return d.join("&").replace(Qb, "+");
    }, m.fn.extend({
        serialize: function() {
            return m.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var a = m.prop(this, "elements");
                return a ? m.makeArray(a) : this;
            }).filter(function() {
                var a = this.type;
                return this.name && !m(this).is(":disabled") && Ub.test(this.nodeName) && !Tb.test(a) && (this.checked || !W.test(a));
            }).map(function(a, b) {
                var c = m(this).val();
                return null == c ? null : m.isArray(c) ? m.map(c, function(a) {
                    return {
                        name: b.name,
                        value: a.replace(Sb, "\r\n")
                    };
                }) : {
                    name: b.name,
                    value: c.replace(Sb, "\r\n")
                };
            }).get();
        }
    }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zb() || $b();
    } : Zb;
    var Wb = 0, Xb = {}, Yb = m.ajaxSettings.xhr();
    a.attachEvent && a.attachEvent("onunload", function() {
        for (var a in Xb) Xb[a](void 0, !0);
    }), k.cors = !!Yb && "withCredentials" in Yb, (Yb = k.ajax = !!Yb) && m.ajaxTransport(function(a) {
        if (!a.crossDomain || k.cors) {
            var b;
            return {
                send: function(c, d) {
                    var e, f = a.xhr(), g = ++Wb;
                    if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
                    a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                    for (e in c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                    f.send(a.hasContent && a.data || null), b = function(c, e) {
                        var h, i, j;
                        if (b && (e || 4 === f.readyState)) if (delete Xb[g], b = void 0, f.onreadystatechange = m.noop,
                        e) 4 !== f.readyState && f.abort(); else {
                            j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                            try {
                                i = f.statusText;
                            } catch (k) {
                                i = "";
                            }
                            h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
                        }
                        j && d(h, i, j, f.getAllResponseHeaders());
                    }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Xb[g] = b : b();
                },
                abort: function() {
                    b && b(void 0, !0);
                }
            };
        }
    }), m.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(a) {
                return m.globalEval(a), a;
            }
        }
    }), m.ajaxPrefilter("script", function(a) {
        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1);
    }), m.ajaxTransport("script", function(a) {
        if (a.crossDomain) {
            var b, c = y.head || m("head")[0] || y.documentElement;
            return {
                send: function(d, e) {
                    b = y.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset),
                    b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
                        (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null,
                        b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"));
                    }, c.insertBefore(b, c.firstChild);
                },
                abort: function() {
                    b && b.onload(void 0, !0);
                }
            };
        }
    });
    var _b = [], ac = /(=)\?(?=&|$)|\?\?/;
    m.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var a = _b.pop() || m.expando + "_" + vb++;
            return this[a] = !0, a;
        }
    }), m.ajaxPrefilter("json jsonp", function(b, c, d) {
        var e, f, g, h = !1 !== b.jsonp && (ac.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ac.test(b.data) && "data");
        return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback,
        h ? b[h] = b[h].replace(ac, "$1" + e) : !1 !== b.jsonp && (b.url += (wb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e),
        b.converters["script json"] = function() {
            return g || m.error(e + " was not called"), g[0];
        }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
            g = arguments;
        }, d.always(function() {
            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _b.push(e)), g && m.isFunction(f) && f(g[0]),
            g = f = void 0;
        }), "script") : void 0;
    }), m.parseHTML = function(a, b, c) {
        if (!a || "string" != typeof a) return null;
        "boolean" == typeof b && (c = b, b = !1), b = b || y;
        var d = u.exec(a), e = !c && [];
        return d ? [ b.createElement(d[1]) ] : (d = m.buildFragment([ a ], b, e), e && e.length && m(e).remove(),
        m.merge([], d.childNodes));
    };
    var bc = m.fn.load;
    m.fn.load = function(a, b, c) {
        if ("string" != typeof a && bc) return bc.apply(this, arguments);
        var d, e, f, g = this, h = a.indexOf(" ");
        return h >= 0 && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), m.isFunction(b) ? (c = b,
        b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && m.ajax({
            url: a,
            type: f,
            dataType: "html",
            data: b
        }).done(function(a) {
            e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a);
        }).complete(c && function(a, b) {
            g.each(c, e || [ a.responseText, b, a ]);
        }), this;
    }, m.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(a, b) {
        m.fn[b] = function(a) {
            return this.on(b, a);
        };
    }), m.expr.filters.animated = function(a) {
        return m.grep(m.timers, function(b) {
            return a === b.elem;
        }).length;
    };
    var cc = a.document.documentElement;
    m.offset = {
        setOffset: function(a, b, c) {
            var d, e, f, g, h, i, j, k = m.css(a, "position"), l = m(a), n = {};
            "static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"),
            i = m.css(a, "left"), j = ("absolute" === k || "fixed" === k) && m.inArray("auto", [ f, i ]) > -1,
            j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0),
            m.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (n.top = b.top - h.top + g),
            null != b.left && (n.left = b.left - h.left + e), "using" in b ? b.using.call(a, n) : l.css(n);
        }
    }, m.fn.extend({
        offset: function(a) {
            if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                m.offset.setOffset(this, a, b);
            });
            var b, c, d = {
                top: 0,
                left: 0
            }, e = this[0], f = e && e.ownerDocument;
            return f ? (b = f.documentElement, m.contains(b, e) ? (typeof e.getBoundingClientRect !== K && (d = e.getBoundingClientRect()),
            c = dc(f), {
                top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
            }) : d) : void 0;
        },
        position: function() {
            if (this[0]) {
                var a, b, c = {
                    top: 0,
                    left: 0
                }, d = this[0];
                return "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(),
                b = this.offset(), m.nodeName(a[0], "html") || (c = a.offset()), c.top += m.css(a[0], "borderTopWidth", !0),
                c.left += m.css(a[0], "borderLeftWidth", !0)), {
                    top: b.top - c.top - m.css(d, "marginTop", !0),
                    left: b.left - c.left - m.css(d, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var a = this.offsetParent || cc; a && !m.nodeName(a, "html") && "static" === m.css(a, "position"); ) a = a.offsetParent;
                return a || cc;
            });
        }
    }), m.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(a, b) {
        var c = /Y/.test(b);
        m.fn[a] = function(d) {
            return V(this, function(a, d, e) {
                var f = dc(a);
                return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e);
            }, a, d, arguments.length, null);
        };
    }), m.each([ "top", "left" ], function(a, b) {
        m.cssHooks[b] = La(k.pixelPosition, function(a, c) {
            return c ? (c = Ja(a, b), Ha.test(c) ? m(a).position()[b] + "px" : c) : void 0;
        });
    }), m.each({
        Height: "height",
        Width: "width"
    }, function(a, b) {
        m.each({
            padding: "inner" + a,
            content: b,
            "": "outer" + a
        }, function(c, d) {
            m.fn[d] = function(d, e) {
                var f = arguments.length && (c || "boolean" != typeof d), g = c || (!0 === d || !0 === e ? "margin" : "border");
                return V(this, function(b, c, d) {
                    var e;
                    return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement,
                    Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g);
                }, b, f ? d : void 0, f, null);
            };
        });
    }), m.fn.size = function() {
        return this.length;
    }, m.fn.andSelf = m.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return m;
    });
    var ec = a.jQuery, fc = a.$;
    return m.noConflict = function(b) {
        return a.$ === m && (a.$ = fc), b && a.jQuery === m && (a.jQuery = ec), m;
    }, typeof b === K && (a.jQuery = a.$ = m), m;
}), function(e) {
    "function" == typeof define && define.amd ? define([ "jquery" ], e) : e(jQuery);
}(function(e) {
    function t(t, s) {
        var n, a, o, r = t.nodeName.toLowerCase();
        return "area" === r ? (n = t.parentNode, a = n.name, !(!t.href || !a || "map" !== n.nodeName.toLowerCase()) && (!!(o = e("img[usemap='#" + a + "']")[0]) && i(o))) : (/^(input|select|textarea|button|object)$/.test(r) ? !t.disabled : "a" === r ? t.href || s : s) && i(t);
    }
    function i(t) {
        return e.expr.filters.visible(t) && !e(t).parents().addBack().filter(function() {
            return "hidden" === e.css(this, "visibility");
        }).length;
    }
    e.ui = e.ui || {}, e.extend(e.ui, {
        version: "1.11.4",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), e.fn.extend({
        scrollParent: function(t) {
            var i = this.css("position"), s = "absolute" === i, n = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/, a = this.parents().filter(function() {
                var t = e(this);
                return (!s || "static" !== t.css("position")) && n.test(t.css("overflow") + t.css("overflow-y") + t.css("overflow-x"));
            }).eq(0);
            return "fixed" !== i && a.length ? a : e(this[0].ownerDocument || document);
        },
        uniqueId: function() {
            var e = 0;
            return function() {
                return this.each(function() {
                    this.id || (this.id = "ui-id-" + ++e);
                });
            };
        }(),
        removeUniqueId: function() {
            return this.each(function() {
                /^ui-id-\d+$/.test(this.id) && e(this).removeAttr("id");
            });
        }
    }), e.extend(e.expr[":"], {
        data: e.expr.createPseudo ? e.expr.createPseudo(function(t) {
            return function(i) {
                return !!e.data(i, t);
            };
        }) : function(t, i, s) {
            return !!e.data(t, s[3]);
        },
        focusable: function(i) {
            return t(i, !isNaN(e.attr(i, "tabindex")));
        },
        tabbable: function(i) {
            var s = e.attr(i, "tabindex"), n = isNaN(s);
            return (n || s >= 0) && t(i, !n);
        }
    }), e("<a>").outerWidth(1).jquery || e.each([ "Width", "Height" ], function(t, i) {
        function s(t, i, s, a) {
            return e.each(n, function() {
                i -= parseFloat(e.css(t, "padding" + this)) || 0, s && (i -= parseFloat(e.css(t, "border" + this + "Width")) || 0),
                a && (i -= parseFloat(e.css(t, "margin" + this)) || 0);
            }), i;
        }
        var n = "Width" === i ? [ "Left", "Right" ] : [ "Top", "Bottom" ], a = i.toLowerCase(), o = {
            innerWidth: e.fn.innerWidth,
            innerHeight: e.fn.innerHeight,
            outerWidth: e.fn.outerWidth,
            outerHeight: e.fn.outerHeight
        };
        e.fn["inner" + i] = function(t) {
            return void 0 === t ? o["inner" + i].call(this) : this.each(function() {
                e(this).css(a, s(this, t) + "px");
            });
        }, e.fn["outer" + i] = function(t, n) {
            return "number" != typeof t ? o["outer" + i].call(this, t) : this.each(function() {
                e(this).css(a, s(this, t, !0, n) + "px");
            });
        };
    }), e.fn.addBack || (e.fn.addBack = function(e) {
        return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
    }), e("<a>").data("a-b", "a").removeData("a-b").data("a-b") && (e.fn.removeData = function(t) {
        return function(i) {
            return arguments.length ? t.call(this, e.camelCase(i)) : t.call(this);
        };
    }(e.fn.removeData)), e.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),
    e.fn.extend({
        focus: function(t) {
            return function(i, s) {
                return "number" == typeof i ? this.each(function() {
                    var t = this;
                    setTimeout(function() {
                        e(t).focus(), s && s.call(t);
                    }, i);
                }) : t.apply(this, arguments);
            };
        }(e.fn.focus),
        disableSelection: function() {
            var e = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
            return function() {
                return this.bind(e + ".ui-disableSelection", function(e) {
                    e.preventDefault();
                });
            };
        }(),
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        },
        zIndex: function(t) {
            if (void 0 !== t) return this.css("zIndex", t);
            if (this.length) for (var i, s, n = e(this[0]); n.length && n[0] !== document; ) {
                if (("absolute" === (i = n.css("position")) || "relative" === i || "fixed" === i) && (s = parseInt(n.css("zIndex"), 10),
                !isNaN(s) && 0 !== s)) return s;
                n = n.parent();
            }
            return 0;
        }
    }), e.ui.plugin = {
        add: function(t, i, s) {
            var n, a = e.ui[t].prototype;
            for (n in s) a.plugins[n] = a.plugins[n] || [], a.plugins[n].push([ i, s[n] ]);
        },
        call: function(e, t, i, s) {
            var n, a = e.plugins[t];
            if (a && (s || e.element[0].parentNode && 11 !== e.element[0].parentNode.nodeType)) for (n = 0; a.length > n; n++) e.options[a[n][0]] && a[n][1].apply(e.element, i);
        }
    };
    var s = 0, n = Array.prototype.slice;
    e.cleanData = function(t) {
        return function(i) {
            var s, n, a;
            for (a = 0; null != (n = i[a]); a++) try {
                (s = e._data(n, "events")) && s.remove && e(n).triggerHandler("remove");
            } catch (o) {}
            t(i);
        };
    }(e.cleanData), e.widget = function(t, i, s) {
        var n, a, o, r, h = {}, l = t.split(".")[0];
        return t = t.split(".")[1], n = l + "-" + t, s || (s = i, i = e.Widget), e.expr[":"][n.toLowerCase()] = function(t) {
            return !!e.data(t, n);
        }, e[l] = e[l] || {}, a = e[l][t], o = e[l][t] = function(e, t) {
            return this._createWidget ? void (arguments.length && this._createWidget(e, t)) : new o(e, t);
        }, e.extend(o, a, {
            version: s.version,
            _proto: e.extend({}, s),
            _childConstructors: []
        }), r = new i(), r.options = e.widget.extend({}, r.options), e.each(s, function(t, s) {
            return e.isFunction(s) ? void (h[t] = function() {
                var e = function() {
                    return i.prototype[t].apply(this, arguments);
                }, n = function(e) {
                    return i.prototype[t].apply(this, e);
                };
                return function() {
                    var t, i = this._super, a = this._superApply;
                    return this._super = e, this._superApply = n, t = s.apply(this, arguments), this._super = i,
                    this._superApply = a, t;
                };
            }()) : void (h[t] = s);
        }), o.prototype = e.widget.extend(r, {
            widgetEventPrefix: a ? r.widgetEventPrefix || t : t
        }, h, {
            constructor: o,
            namespace: l,
            widgetName: t,
            widgetFullName: n
        }), a ? (e.each(a._childConstructors, function(t, i) {
            var s = i.prototype;
            e.widget(s.namespace + "." + s.widgetName, o, i._proto);
        }), delete a._childConstructors) : i._childConstructors.push(o), e.widget.bridge(t, o),
        o;
    }, e.widget.extend = function(t) {
        for (var i, s, a = n.call(arguments, 1), o = 0, r = a.length; r > o; o++) for (i in a[o]) s = a[o][i],
        a[o].hasOwnProperty(i) && void 0 !== s && (t[i] = e.isPlainObject(s) ? e.isPlainObject(t[i]) ? e.widget.extend({}, t[i], s) : e.widget.extend({}, s) : s);
        return t;
    }, e.widget.bridge = function(t, i) {
        var s = i.prototype.widgetFullName || t;
        e.fn[t] = function(a) {
            var o = "string" == typeof a, r = n.call(arguments, 1), h = this;
            return o ? this.each(function() {
                var i, n = e.data(this, s);
                return "instance" === a ? (h = n, !1) : n ? e.isFunction(n[a]) && "_" !== a.charAt(0) ? (i = n[a].apply(n, r),
                i !== n && void 0 !== i ? (h = i && i.jquery ? h.pushStack(i.get()) : i, !1) : void 0) : e.error("no such method '" + a + "' for " + t + " widget instance") : e.error("cannot call methods on " + t + " prior to initialization; attempted to call method '" + a + "'");
            }) : (r.length && (a = e.widget.extend.apply(null, [ a ].concat(r))), this.each(function() {
                var t = e.data(this, s);
                t ? (t.option(a || {}), t._init && t._init()) : e.data(this, s, new i(a, this));
            })), h;
        };
    }, e.Widget = function() {}, e.Widget._childConstructors = [], e.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: !1,
            create: null
        },
        _createWidget: function(t, i) {
            i = e(i || this.defaultElement || this)[0], this.element = e(i), this.uuid = s++,
            this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = e(), this.hoverable = e(),
            this.focusable = e(), i !== this && (e.data(i, this.widgetFullName, this), this._on(!0, this.element, {
                remove: function(e) {
                    e.target === i && this.destroy();
                }
            }), this.document = e(i.style ? i.ownerDocument : i.document || i), this.window = e(this.document[0].defaultView || this.document[0].parentWindow)),
            this.options = e.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(),
            this._trigger("create", null, this._getCreateEventData()), this._init();
        },
        _getCreateOptions: e.noop,
        _getCreateEventData: e.noop,
        _create: e.noop,
        _init: e.noop,
        destroy: function() {
            this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),
            this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"),
            this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"),
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: e.noop,
        widget: function() {
            return this.element;
        },
        option: function(t, i) {
            var s, n, a, o = t;
            if (0 === arguments.length) return e.widget.extend({}, this.options);
            if ("string" == typeof t) if (o = {}, s = t.split("."), t = s.shift(), s.length) {
                for (n = o[t] = e.widget.extend({}, this.options[t]), a = 0; s.length - 1 > a; a++) n[s[a]] = n[s[a]] || {},
                n = n[s[a]];
                if (t = s.pop(), 1 === arguments.length) return void 0 === n[t] ? null : n[t];
                n[t] = i;
            } else {
                if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
                o[t] = i;
            }
            return this._setOptions(o), this;
        },
        _setOptions: function(e) {
            var t;
            for (t in e) this._setOption(t, e[t]);
            return this;
        },
        _setOption: function(e, t) {
            return this.options[e] = t, "disabled" === e && (this.widget().toggleClass(this.widgetFullName + "-disabled", !!t),
            t && (this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus"))),
            this;
        },
        enable: function() {
            return this._setOptions({
                disabled: !1
            });
        },
        disable: function() {
            return this._setOptions({
                disabled: !0
            });
        },
        _on: function(t, i, s) {
            var n, a = this;
            "boolean" != typeof t && (s = i, i = t, t = !1), s ? (i = n = e(i), this.bindings = this.bindings.add(i)) : (s = i,
            i = this.element, n = this.widget()), e.each(s, function(s, o) {
                function r() {
                    return t || !0 !== a.options.disabled && !e(this).hasClass("ui-state-disabled") ? ("string" == typeof o ? a[o] : o).apply(a, arguments) : void 0;
                }
                "string" != typeof o && (r.guid = o.guid = o.guid || r.guid || e.guid++);
                var h = s.match(/^([\w:-]*)\s*(.*)$/), l = h[1] + a.eventNamespace, u = h[2];
                u ? n.delegate(u, l, r) : i.bind(l, r);
            });
        },
        _off: function(t, i) {
            i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace,
            t.unbind(i).undelegate(i), this.bindings = e(this.bindings.not(t).get()), this.focusable = e(this.focusable.not(t).get()),
            this.hoverable = e(this.hoverable.not(t).get());
        },
        _delay: function(e, t) {
            function i() {
                return ("string" == typeof e ? s[e] : e).apply(s, arguments);
            }
            var s = this;
            return setTimeout(i, t || 0);
        },
        _hoverable: function(t) {
            this.hoverable = this.hoverable.add(t), this._on(t, {
                mouseenter: function(t) {
                    e(t.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(t) {
                    e(t.currentTarget).removeClass("ui-state-hover");
                }
            });
        },
        _focusable: function(t) {
            this.focusable = this.focusable.add(t), this._on(t, {
                focusin: function(t) {
                    e(t.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(t) {
                    e(t.currentTarget).removeClass("ui-state-focus");
                }
            });
        },
        _trigger: function(t, i, s) {
            var n, a, o = this.options[t];
            if (s = s || {}, i = e.Event(i), i.type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(),
            i.target = this.element[0], a = i.originalEvent) for (n in a) n in i || (i[n] = a[n]);
            return this.element.trigger(i, s), !(e.isFunction(o) && !1 === o.apply(this.element[0], [ i ].concat(s)) || i.isDefaultPrevented());
        }
    }, e.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(t, i) {
        e.Widget.prototype["_" + t] = function(s, n, a) {
            "string" == typeof n && (n = {
                effect: n
            });
            var o, r = n ? !0 === n || "number" == typeof n ? i : n.effect || i : t;
            n = n || {}, "number" == typeof n && (n = {
                duration: n
            }), o = !e.isEmptyObject(n), n.complete = a, n.delay && s.delay(n.delay), o && e.effects && e.effects.effect[r] ? s[t](n) : r !== t && s[r] ? s[r](n.duration, n.easing, a) : s.queue(function(i) {
                e(this)[t](), a && a.call(s[0]), i();
            });
        };
    }), e.widget;
    var a = !1;
    e(document).mouseup(function() {
        a = !1;
    }), e.widget("ui.mouse", {
        version: "1.11.4",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var t = this;
            this.element.bind("mousedown." + this.widgetName, function(e) {
                return t._mouseDown(e);
            }).bind("click." + this.widgetName, function(i) {
                return !0 === e.data(i.target, t.widgetName + ".preventClickEvent") ? (e.removeData(i.target, t.widgetName + ".preventClickEvent"),
                i.stopImmediatePropagation(), !1) : void 0;
            }), this.started = !1;
        },
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
        },
        _mouseDown: function(t) {
            if (!a) {
                this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
                var i = this, s = 1 === t.which, n = !("string" != typeof this.options.cancel || !t.target.nodeName) && e(t.target).closest(this.options.cancel).length;
                return !(s && !n && this._mouseCapture(t)) || (this.mouseDelayMet = !this.options.delay,
                this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function() {
                    i.mouseDelayMet = !0;
                }, this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(t),
                !this._mouseStarted) ? (t.preventDefault(), !0) : (!0 === e.data(t.target, this.widgetName + ".preventClickEvent") && e.removeData(t.target, this.widgetName + ".preventClickEvent"),
                this._mouseMoveDelegate = function(e) {
                    return i._mouseMove(e);
                }, this._mouseUpDelegate = function(e) {
                    return i._mouseUp(e);
                }, this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate),
                t.preventDefault(), a = !0, !0));
            }
        },
        _mouseMove: function(t) {
            if (this._mouseMoved) {
                if (e.ui.ie && (!document.documentMode || 9 > document.documentMode) && !t.button) return this._mouseUp(t);
                if (!t.which) return this._mouseUp(t);
            }
            return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t),
            t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, t),
            this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted);
        },
        _mouseUp: function(t) {
            return this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate),
            this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && e.data(t.target, this.widgetName + ".preventClickEvent", !0),
            this._mouseStop(t)), a = !1, !1;
        },
        _mouseDistanceMet: function(e) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return !0;
        }
    }), e.widget("ui.draggable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "drag",
        options: {
            addClasses: !0,
            appendTo: "parent",
            axis: !1,
            connectToSortable: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            iframeFix: !1,
            opacity: !1,
            refreshPositions: !1,
            revert: !1,
            revertDuration: 500,
            scope: "default",
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: !1,
            snapMode: "both",
            snapTolerance: 20,
            stack: !1,
            zIndex: !1,
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
            "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this.element.addClass("ui-draggable"),
            this.options.disabled && this.element.addClass("ui-draggable-disabled"), this._setHandleClassName(),
            this._mouseInit();
        },
        _setOption: function(e, t) {
            this._super(e, t), "handle" === e && (this._removeHandleClassName(), this._setHandleClassName());
        },
        _destroy: function() {
            return (this.helper || this.element).is(".ui-draggable-dragging") ? void (this.destroyOnClear = !0) : (this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),
            this._removeHandleClassName(), void this._mouseDestroy());
        },
        _mouseCapture: function(t) {
            var i = this.options;
            return this._blurActiveElement(t), !(this.helper || i.disabled || e(t.target).closest(".ui-resizable-handle").length > 0) && (this.handle = this._getHandle(t),
            !!this.handle && (this._blockFrames(!0 === i.iframeFix ? "iframe" : i.iframeFix),
            !0));
        },
        _blockFrames: function(t) {
            this.iframeBlocks = this.document.find(t).map(function() {
                var t = e(this);
                return e("<div>").css("position", "absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0];
            });
        },
        _unblockFrames: function() {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
        },
        _blurActiveElement: function(t) {
            var i = this.document[0];
            if (this.handleElement.is(t.target)) try {
                i.activeElement && "body" !== i.activeElement.nodeName.toLowerCase() && e(i.activeElement).blur();
            } catch (s) {}
        },
        _mouseStart: function(t) {
            var i = this.options;
            return this.helper = this._createHelper(t), this.helper.addClass("ui-draggable-dragging"),
            this._cacheHelperProportions(), e.ui.ddmanager && (e.ui.ddmanager.current = this),
            this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0),
            this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = this.helper.parents().filter(function() {
                return "fixed" === e(this).css("position");
            }).length > 0, this.positionAbs = this.element.offset(), this._refreshOffsets(t),
            this.originalPosition = this.position = this._generatePosition(t, !1), this.originalPageX = t.pageX,
            this.originalPageY = t.pageY, i.cursorAt && this._adjustOffsetFromHelper(i.cursorAt),
            this._setContainment(), !1 === this._trigger("start", t) ? (this._clear(), !1) : (this._cacheHelperProportions(),
            e.ui.ddmanager && !i.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this._normalizeRightBottom(),
            this._mouseDrag(t, !0), e.ui.ddmanager && e.ui.ddmanager.dragStart(this, t), !0);
        },
        _refreshOffsets: function(e) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: !1,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }, this.offset.click = {
                left: e.pageX - this.offset.left,
                top: e.pageY - this.offset.top
            };
        },
        _mouseDrag: function(t, i) {
            if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(t, !0),
            this.positionAbs = this._convertPositionTo("absolute"), !i) {
                var s = this._uiHash();
                if (!1 === this._trigger("drag", t, s)) return this._mouseUp({}), !1;
                this.position = s.position;
            }
            return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px",
            e.ui.ddmanager && e.ui.ddmanager.drag(this, t), !1;
        },
        _mouseStop: function(t) {
            var i = this, s = !1;
            return e.ui.ddmanager && !this.options.dropBehaviour && (s = e.ui.ddmanager.drop(this, t)),
            this.dropped && (s = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !s || "valid" === this.options.revert && s || !0 === this.options.revert || e.isFunction(this.options.revert) && this.options.revert.call(this.element, s) ? e(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                !1 !== i._trigger("stop", t) && i._clear();
            }) : !1 !== this._trigger("stop", t) && this._clear(), !1;
        },
        _mouseUp: function(t) {
            return this._unblockFrames(), e.ui.ddmanager && e.ui.ddmanager.dragStop(this, t),
            this.handleElement.is(t.target) && this.element.focus(), e.ui.mouse.prototype._mouseUp.call(this, t);
        },
        cancel: function() {
            return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(),
            this;
        },
        _getHandle: function(t) {
            return !this.options.handle || !!e(t.target).closest(this.element.find(this.options.handle)).length;
        },
        _setHandleClassName: function() {
            this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element,
            this.handleElement.addClass("ui-draggable-handle");
        },
        _removeHandleClassName: function() {
            this.handleElement.removeClass("ui-draggable-handle");
        },
        _createHelper: function(t) {
            var i = this.options, s = e.isFunction(i.helper), n = s ? e(i.helper.apply(this.element[0], [ t ])) : "clone" === i.helper ? this.element.clone().removeAttr("id") : this.element;
            return n.parents("body").length || n.appendTo("parent" === i.appendTo ? this.element[0].parentNode : i.appendTo),
            s && n[0] === this.element[0] && this._setPositionRelative(), n[0] === this.element[0] || /(fixed|absolute)/.test(n.css("position")) || n.css("position", "absolute"),
            n;
        },
        _setPositionRelative: function() {
            /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative");
        },
        _adjustOffsetFromHelper: function(t) {
            "string" == typeof t && (t = t.split(" ")), e.isArray(t) && (t = {
                left: +t[0],
                top: +t[1] || 0
            }), "left" in t && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left),
            "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top);
        },
        _isRootNode: function(e) {
            return /(html|body)/i.test(e.tagName) || e === this.document[0];
        },
        _getParentOffset: function() {
            var t = this.offsetParent.offset(), i = this.document[0];
            return "absolute" === this.cssPosition && this.scrollParent[0] !== i && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(),
            t.top += this.scrollParent.scrollTop()), this._isRootNode(this.offsetParent[0]) && (t = {
                top: 0,
                left: 0
            }), {
                top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if ("relative" !== this.cssPosition) return {
                top: 0,
                left: 0
            };
            var e = this.element.position(), t = this._isRootNode(this.scrollParent[0]);
            return {
                top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + (t ? 0 : this.scrollParent.scrollTop()),
                left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + (t ? 0 : this.scrollParent.scrollLeft())
            };
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var t, i, s, n = this.options, a = this.document[0];
            return this.relativeContainer = null, n.containment ? "window" === n.containment ? void (this.containment = [ e(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, e(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, e(window).scrollLeft() + e(window).width() - this.helperProportions.width - this.margins.left, e(window).scrollTop() + (e(window).height() || a.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]) : "document" === n.containment ? void (this.containment = [ 0, 0, e(a).width() - this.helperProportions.width - this.margins.left, (e(a).height() || a.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]) : n.containment.constructor === Array ? void (this.containment = n.containment) : ("parent" === n.containment && (n.containment = this.helper[0].parentNode),
            i = e(n.containment), void ((s = i[0]) && (t = /(scroll|auto)/.test(i.css("overflow")),
            this.containment = [ (parseInt(i.css("borderLeftWidth"), 10) || 0) + (parseInt(i.css("paddingLeft"), 10) || 0), (parseInt(i.css("borderTopWidth"), 10) || 0) + (parseInt(i.css("paddingTop"), 10) || 0), (t ? Math.max(s.scrollWidth, s.offsetWidth) : s.offsetWidth) - (parseInt(i.css("borderRightWidth"), 10) || 0) - (parseInt(i.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (t ? Math.max(s.scrollHeight, s.offsetHeight) : s.offsetHeight) - (parseInt(i.css("borderBottomWidth"), 10) || 0) - (parseInt(i.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ],
            this.relativeContainer = i))) : void (this.containment = null);
        },
        _convertPositionTo: function(e, t) {
            t || (t = this.position);
            var i = "absolute" === e ? 1 : -1, s = this._isRootNode(this.scrollParent[0]);
            return {
                top: t.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.offset.scroll.top : s ? 0 : this.offset.scroll.top) * i,
                left: t.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.offset.scroll.left : s ? 0 : this.offset.scroll.left) * i
            };
        },
        _generatePosition: function(e, t) {
            var i, s, n, a, o = this.options, r = this._isRootNode(this.scrollParent[0]), h = e.pageX, l = e.pageY;
            return r && this.offset.scroll || (this.offset.scroll = {
                top: this.scrollParent.scrollTop(),
                left: this.scrollParent.scrollLeft()
            }), t && (this.containment && (this.relativeContainer ? (s = this.relativeContainer.offset(),
            i = [ this.containment[0] + s.left, this.containment[1] + s.top, this.containment[2] + s.left, this.containment[3] + s.top ]) : i = this.containment,
            e.pageX - this.offset.click.left < i[0] && (h = i[0] + this.offset.click.left),
            e.pageY - this.offset.click.top < i[1] && (l = i[1] + this.offset.click.top), e.pageX - this.offset.click.left > i[2] && (h = i[2] + this.offset.click.left),
            e.pageY - this.offset.click.top > i[3] && (l = i[3] + this.offset.click.top)), o.grid && (n = o.grid[1] ? this.originalPageY + Math.round((l - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY,
            l = i ? n - this.offset.click.top >= i[1] || n - this.offset.click.top > i[3] ? n : n - this.offset.click.top >= i[1] ? n - o.grid[1] : n + o.grid[1] : n,
            a = o.grid[0] ? this.originalPageX + Math.round((h - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX,
            h = i ? a - this.offset.click.left >= i[0] || a - this.offset.click.left > i[2] ? a : a - this.offset.click.left >= i[0] ? a - o.grid[0] : a + o.grid[0] : a),
            "y" === o.axis && (h = this.originalPageX), "x" === o.axis && (l = this.originalPageY)),
            {
                top: l - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : r ? 0 : this.offset.scroll.top),
                left: h - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : r ? 0 : this.offset.scroll.left)
            };
        },
        _clear: function() {
            this.helper.removeClass("ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(),
            this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy();
        },
        _normalizeRightBottom: function() {
            "y" !== this.options.axis && "auto" !== this.helper.css("right") && (this.helper.width(this.helper.width()),
            this.helper.css("right", "auto")), "x" !== this.options.axis && "auto" !== this.helper.css("bottom") && (this.helper.height(this.helper.height()),
            this.helper.css("bottom", "auto"));
        },
        _trigger: function(t, i, s) {
            return s = s || this._uiHash(), e.ui.plugin.call(this, t, [ i, s, this ], !0), /^(drag|start|stop)/.test(t) && (this.positionAbs = this._convertPositionTo("absolute"),
            s.offset = this.positionAbs), e.Widget.prototype._trigger.call(this, t, i, s);
        },
        plugins: {},
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }
    }), e.ui.plugin.add("draggable", "connectToSortable", {
        start: function(t, i, s) {
            var n = e.extend({}, i, {
                item: s.element
            });
            s.sortables = [], e(s.options.connectToSortable).each(function() {
                var i = e(this).sortable("instance");
                i && !i.options.disabled && (s.sortables.push(i), i.refreshPositions(), i._trigger("activate", t, n));
            });
        },
        stop: function(t, i, s) {
            var n = e.extend({}, i, {
                item: s.element
            });
            s.cancelHelperRemoval = !1, e.each(s.sortables, function() {
                var e = this;
                e.isOver ? (e.isOver = 0, s.cancelHelperRemoval = !0, e.cancelHelperRemoval = !1,
                e._storedCSS = {
                    position: e.placeholder.css("position"),
                    top: e.placeholder.css("top"),
                    left: e.placeholder.css("left")
                }, e._mouseStop(t), e.options.helper = e.options._helper) : (e.cancelHelperRemoval = !0,
                e._trigger("deactivate", t, n));
            });
        },
        drag: function(t, i, s) {
            e.each(s.sortables, function() {
                var n = !1, a = this;
                a.positionAbs = s.positionAbs, a.helperProportions = s.helperProportions, a.offset.click = s.offset.click,
                a._intersectsWith(a.containerCache) && (n = !0, e.each(s.sortables, function() {
                    return this.positionAbs = s.positionAbs, this.helperProportions = s.helperProportions,
                    this.offset.click = s.offset.click, this !== a && this._intersectsWith(this.containerCache) && e.contains(a.element[0], this.element[0]) && (n = !1),
                    n;
                })), n ? (a.isOver || (a.isOver = 1, s._parent = i.helper.parent(), a.currentItem = i.helper.appendTo(a.element).data("ui-sortable-item", !0),
                a.options._helper = a.options.helper, a.options.helper = function() {
                    return i.helper[0];
                }, t.target = a.currentItem[0], a._mouseCapture(t, !0), a._mouseStart(t, !0, !0),
                a.offset.click.top = s.offset.click.top, a.offset.click.left = s.offset.click.left,
                a.offset.parent.left -= s.offset.parent.left - a.offset.parent.left, a.offset.parent.top -= s.offset.parent.top - a.offset.parent.top,
                s._trigger("toSortable", t), s.dropped = a.element, e.each(s.sortables, function() {
                    this.refreshPositions();
                }), s.currentItem = s.element, a.fromOutside = s), a.currentItem && (a._mouseDrag(t),
                i.position = a.position)) : a.isOver && (a.isOver = 0, a.cancelHelperRemoval = !0,
                a.options._revert = a.options.revert, a.options.revert = !1, a._trigger("out", t, a._uiHash(a)),
                a._mouseStop(t, !0), a.options.revert = a.options._revert, a.options.helper = a.options._helper,
                a.placeholder && a.placeholder.remove(), i.helper.appendTo(s._parent), s._refreshOffsets(t),
                i.position = s._generatePosition(t, !0), s._trigger("fromSortable", t), s.dropped = !1,
                e.each(s.sortables, function() {
                    this.refreshPositions();
                }));
            });
        }
    }), e.ui.plugin.add("draggable", "cursor", {
        start: function(t, i, s) {
            var n = e("body"), a = s.options;
            n.css("cursor") && (a._cursor = n.css("cursor")), n.css("cursor", a.cursor);
        },
        stop: function(t, i, s) {
            var n = s.options;
            n._cursor && e("body").css("cursor", n._cursor);
        }
    }), e.ui.plugin.add("draggable", "opacity", {
        start: function(t, i, s) {
            var n = e(i.helper), a = s.options;
            n.css("opacity") && (a._opacity = n.css("opacity")), n.css("opacity", a.opacity);
        },
        stop: function(t, i, s) {
            var n = s.options;
            n._opacity && e(i.helper).css("opacity", n._opacity);
        }
    }), e.ui.plugin.add("draggable", "scroll", {
        start: function(e, t, i) {
            i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)),
            i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset());
        },
        drag: function(t, i, s) {
            var n = s.options, a = !1, o = s.scrollParentNotHidden[0], r = s.document[0];
            o !== r && "HTML" !== o.tagName ? (n.axis && "x" === n.axis || (s.overflowOffset.top + o.offsetHeight - t.pageY < n.scrollSensitivity ? o.scrollTop = a = o.scrollTop + n.scrollSpeed : t.pageY - s.overflowOffset.top < n.scrollSensitivity && (o.scrollTop = a = o.scrollTop - n.scrollSpeed)),
            n.axis && "y" === n.axis || (s.overflowOffset.left + o.offsetWidth - t.pageX < n.scrollSensitivity ? o.scrollLeft = a = o.scrollLeft + n.scrollSpeed : t.pageX - s.overflowOffset.left < n.scrollSensitivity && (o.scrollLeft = a = o.scrollLeft - n.scrollSpeed))) : (n.axis && "x" === n.axis || (t.pageY - e(r).scrollTop() < n.scrollSensitivity ? a = e(r).scrollTop(e(r).scrollTop() - n.scrollSpeed) : e(window).height() - (t.pageY - e(r).scrollTop()) < n.scrollSensitivity && (a = e(r).scrollTop(e(r).scrollTop() + n.scrollSpeed))),
            n.axis && "y" === n.axis || (t.pageX - e(r).scrollLeft() < n.scrollSensitivity ? a = e(r).scrollLeft(e(r).scrollLeft() - n.scrollSpeed) : e(window).width() - (t.pageX - e(r).scrollLeft()) < n.scrollSensitivity && (a = e(r).scrollLeft(e(r).scrollLeft() + n.scrollSpeed)))),
            !1 !== a && e.ui.ddmanager && !n.dropBehaviour && e.ui.ddmanager.prepareOffsets(s, t);
        }
    }), e.ui.plugin.add("draggable", "snap", {
        start: function(t, i, s) {
            var n = s.options;
            s.snapElements = [], e(n.snap.constructor !== String ? n.snap.items || ":data(ui-draggable)" : n.snap).each(function() {
                var t = e(this), i = t.offset();
                this !== s.element[0] && s.snapElements.push({
                    item: this,
                    width: t.outerWidth(),
                    height: t.outerHeight(),
                    top: i.top,
                    left: i.left
                });
            });
        },
        drag: function(t, i, s) {
            var n, a, o, r, h, l, u, d, c, p, f = s.options, m = f.snapTolerance, g = i.offset.left, v = g + s.helperProportions.width, y = i.offset.top, b = y + s.helperProportions.height;
            for (c = s.snapElements.length - 1; c >= 0; c--) h = s.snapElements[c].left - s.margins.left,
            l = h + s.snapElements[c].width, u = s.snapElements[c].top - s.margins.top, d = u + s.snapElements[c].height,
            h - m > v || g > l + m || u - m > b || y > d + m || !e.contains(s.snapElements[c].item.ownerDocument, s.snapElements[c].item) ? (s.snapElements[c].snapping && s.options.snap.release && s.options.snap.release.call(s.element, t, e.extend(s._uiHash(), {
                snapItem: s.snapElements[c].item
            })), s.snapElements[c].snapping = !1) : ("inner" !== f.snapMode && (n = m >= Math.abs(u - b),
            a = m >= Math.abs(d - y), o = m >= Math.abs(h - v), r = m >= Math.abs(l - g), n && (i.position.top = s._convertPositionTo("relative", {
                top: u - s.helperProportions.height,
                left: 0
            }).top), a && (i.position.top = s._convertPositionTo("relative", {
                top: d,
                left: 0
            }).top), o && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: h - s.helperProportions.width
            }).left), r && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: l
            }).left)), p = n || a || o || r, "outer" !== f.snapMode && (n = m >= Math.abs(u - y),
            a = m >= Math.abs(d - b), o = m >= Math.abs(h - g), r = m >= Math.abs(l - v), n && (i.position.top = s._convertPositionTo("relative", {
                top: u,
                left: 0
            }).top), a && (i.position.top = s._convertPositionTo("relative", {
                top: d - s.helperProportions.height,
                left: 0
            }).top), o && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: h
            }).left), r && (i.position.left = s._convertPositionTo("relative", {
                top: 0,
                left: l - s.helperProportions.width
            }).left)), !s.snapElements[c].snapping && (n || a || o || r || p) && s.options.snap.snap && s.options.snap.snap.call(s.element, t, e.extend(s._uiHash(), {
                snapItem: s.snapElements[c].item
            })), s.snapElements[c].snapping = n || a || o || r || p);
        }
    }), e.ui.plugin.add("draggable", "stack", {
        start: function(t, i, s) {
            var n, a = s.options, o = e.makeArray(e(a.stack)).sort(function(t, i) {
                return (parseInt(e(t).css("zIndex"), 10) || 0) - (parseInt(e(i).css("zIndex"), 10) || 0);
            });
            o.length && (n = parseInt(e(o[0]).css("zIndex"), 10) || 0, e(o).each(function(t) {
                e(this).css("zIndex", n + t);
            }), this.css("zIndex", n + o.length));
        }
    }), e.ui.plugin.add("draggable", "zIndex", {
        start: function(t, i, s) {
            var n = e(i.helper), a = s.options;
            n.css("zIndex") && (a._zIndex = n.css("zIndex")), n.css("zIndex", a.zIndex);
        },
        stop: function(t, i, s) {
            var n = s.options;
            n._zIndex && e(i.helper).css("zIndex", n._zIndex);
        }
    }), e.ui.draggable, e.widget("ui.droppable", {
        version: "1.11.4",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: !1,
            addClasses: !0,
            greedy: !1,
            hoverClass: !1,
            scope: "default",
            tolerance: "intersect",
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
            var t, i = this.options, s = i.accept;
            this.isover = !1, this.isout = !0, this.accept = e.isFunction(s) ? s : function(e) {
                return e.is(s);
            }, this.proportions = function() {
                return arguments.length ? void (t = arguments[0]) : t || (t = {
                    width: this.element[0].offsetWidth,
                    height: this.element[0].offsetHeight
                });
            }, this._addToManager(i.scope), i.addClasses && this.element.addClass("ui-droppable");
        },
        _addToManager: function(t) {
            e.ui.ddmanager.droppables[t] = e.ui.ddmanager.droppables[t] || [], e.ui.ddmanager.droppables[t].push(this);
        },
        _splice: function(e) {
            for (var t = 0; e.length > t; t++) e[t] === this && e.splice(t, 1);
        },
        _destroy: function() {
            var t = e.ui.ddmanager.droppables[this.options.scope];
            this._splice(t), this.element.removeClass("ui-droppable ui-droppable-disabled");
        },
        _setOption: function(t, i) {
            if ("accept" === t) this.accept = e.isFunction(i) ? i : function(e) {
                return e.is(i);
            }; else if ("scope" === t) {
                var s = e.ui.ddmanager.droppables[this.options.scope];
                this._splice(s), this._addToManager(i);
            }
            this._super(t, i);
        },
        _activate: function(t) {
            var i = e.ui.ddmanager.current;
            this.options.activeClass && this.element.addClass(this.options.activeClass), i && this._trigger("activate", t, this.ui(i));
        },
        _deactivate: function(t) {
            var i = e.ui.ddmanager.current;
            this.options.activeClass && this.element.removeClass(this.options.activeClass),
            i && this._trigger("deactivate", t, this.ui(i));
        },
        _over: function(t) {
            var i = e.ui.ddmanager.current;
            i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(this.element[0], i.currentItem || i.element) && (this.options.hoverClass && this.element.addClass(this.options.hoverClass),
            this._trigger("over", t, this.ui(i)));
        },
        _out: function(t) {
            var i = e.ui.ddmanager.current;
            i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(this.element[0], i.currentItem || i.element) && (this.options.hoverClass && this.element.removeClass(this.options.hoverClass),
            this._trigger("out", t, this.ui(i)));
        },
        _drop: function(t, i) {
            var s = i || e.ui.ddmanager.current, n = !1;
            return !(!s || (s.currentItem || s.element)[0] === this.element[0]) && (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                var i = e(this).droppable("instance");
                return i.options.greedy && !i.options.disabled && i.options.scope === s.options.scope && i.accept.call(i.element[0], s.currentItem || s.element) && e.ui.intersect(s, e.extend(i, {
                    offset: i.element.offset()
                }), i.options.tolerance, t) ? (n = !0, !1) : void 0;
            }), !n && (!!this.accept.call(this.element[0], s.currentItem || s.element) && (this.options.activeClass && this.element.removeClass(this.options.activeClass),
            this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("drop", t, this.ui(s)),
            this.element)));
        },
        ui: function(e) {
            return {
                draggable: e.currentItem || e.element,
                helper: e.helper,
                position: e.position,
                offset: e.positionAbs
            };
        }
    }), e.ui.intersect = function() {
        function e(e, t, i) {
            return e >= t && t + i > e;
        }
        return function(t, i, s, n) {
            if (!i.offset) return !1;
            var a = (t.positionAbs || t.position.absolute).left + t.margins.left, o = (t.positionAbs || t.position.absolute).top + t.margins.top, r = a + t.helperProportions.width, h = o + t.helperProportions.height, l = i.offset.left, u = i.offset.top, d = l + i.proportions().width, c = u + i.proportions().height;
            switch (s) {
              case "fit":
                return a >= l && d >= r && o >= u && c >= h;

              case "intersect":
                return a + t.helperProportions.width / 2 > l && d > r - t.helperProportions.width / 2 && o + t.helperProportions.height / 2 > u && c > h - t.helperProportions.height / 2;

              case "pointer":
                return e(n.pageY, u, i.proportions().height) && e(n.pageX, l, i.proportions().width);

              case "touch":
                return (o >= u && c >= o || h >= u && c >= h || u > o && h > c) && (a >= l && d >= a || r >= l && d >= r || l > a && r > d);

              default:
                return !1;
            }
        };
    }(), e.ui.ddmanager = {
        current: null,
        droppables: {
            default: []
        },
        prepareOffsets: function(t, i) {
            var s, n, a = e.ui.ddmanager.droppables[t.options.scope] || [], o = i ? i.type : null, r = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            e: for (s = 0; a.length > s; s++) if (!(a[s].options.disabled || t && !a[s].accept.call(a[s].element[0], t.currentItem || t.element))) {
                for (n = 0; r.length > n; n++) if (r[n] === a[s].element[0]) {
                    a[s].proportions().height = 0;
                    continue e;
                }
                a[s].visible = "none" !== a[s].element.css("display"), a[s].visible && ("mousedown" === o && a[s]._activate.call(a[s], i),
                a[s].offset = a[s].element.offset(), a[s].proportions({
                    width: a[s].element[0].offsetWidth,
                    height: a[s].element[0].offsetHeight
                }));
            }
        },
        drop: function(t, i) {
            var s = !1;
            return e.each((e.ui.ddmanager.droppables[t.options.scope] || []).slice(), function() {
                this.options && (!this.options.disabled && this.visible && e.ui.intersect(t, this, this.options.tolerance, i) && (s = this._drop.call(this, i) || s),
                !this.options.disabled && this.visible && this.accept.call(this.element[0], t.currentItem || t.element) && (this.isout = !0,
                this.isover = !1, this._deactivate.call(this, i)));
            }), s;
        },
        dragStart: function(t, i) {
            t.element.parentsUntil("body").bind("scroll.droppable", function() {
                t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, i);
            });
        },
        drag: function(t, i) {
            t.options.refreshPositions && e.ui.ddmanager.prepareOffsets(t, i), e.each(e.ui.ddmanager.droppables[t.options.scope] || [], function() {
                if (!this.options.disabled && !this.greedyChild && this.visible) {
                    var s, n, a, o = e.ui.intersect(t, this, this.options.tolerance, i), r = !o && this.isover ? "isout" : o && !this.isover ? "isover" : null;
                    r && (this.options.greedy && (n = this.options.scope, a = this.element.parents(":data(ui-droppable)").filter(function() {
                        return e(this).droppable("instance").options.scope === n;
                    }), a.length && (s = e(a[0]).droppable("instance"), s.greedyChild = "isover" === r)),
                    s && "isover" === r && (s.isover = !1, s.isout = !0, s._out.call(s, i)), this[r] = !0,
                    this["isout" === r ? "isover" : "isout"] = !1, this["isover" === r ? "_over" : "_out"].call(this, i),
                    s && "isout" === r && (s.isout = !1, s.isover = !0, s._over.call(s, i)));
                }
            });
        },
        dragStop: function(t, i) {
            t.element.parentsUntil("body").unbind("scroll.droppable"), t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, i);
        }
    }, e.ui.droppable, e.widget("ui.resizable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: !1,
            animate: !1,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: !1,
            autoHide: !1,
            containment: !1,
            ghost: !1,
            grid: !1,
            handles: "e,s,se",
            helper: !1,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 90,
            resize: null,
            start: null,
            stop: null
        },
        _num: function(e) {
            return parseInt(e, 10) || 0;
        },
        _isNumber: function(e) {
            return !isNaN(parseInt(e, 10));
        },
        _hasScroll: function(t, i) {
            if ("hidden" === e(t).css("overflow")) return !1;
            var s = i && "left" === i ? "scrollLeft" : "scrollTop", n = !1;
            return t[s] > 0 || (t[s] = 1, n = t[s] > 0, t[s] = 0, n);
        },
        _create: function() {
            var t, i, s, n, a, o = this, r = this.options;
            if (this.element.addClass("ui-resizable"), e.extend(this, {
                _aspectRatio: !!r.aspectRatio,
                aspectRatio: r.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: r.helper || r.ghost || r.animate ? r.helper || "ui-resizable-helper" : null
            }), this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(e("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                position: this.element.css("position"),
                width: this.element.outerWidth(),
                height: this.element.outerHeight(),
                top: this.element.css("top"),
                left: this.element.css("left")
            })), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")),
            this.elementIsWrapper = !0, this.element.css({
                marginLeft: this.originalElement.css("marginLeft"),
                marginTop: this.originalElement.css("marginTop"),
                marginRight: this.originalElement.css("marginRight"),
                marginBottom: this.originalElement.css("marginBottom")
            }), this.originalElement.css({
                marginLeft: 0,
                marginTop: 0,
                marginRight: 0,
                marginBottom: 0
            }), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"),
            this._proportionallyResizeElements.push(this.originalElement.css({
                position: "static",
                zoom: 1,
                display: "block"
            })), this.originalElement.css({
                margin: this.originalElement.css("margin")
            }), this._proportionallyResize()), this.handles = r.handles || (e(".ui-resizable-handle", this.element).length ? {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            } : "e,s,se"), this._handles = e(), this.handles.constructor === String) for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"),
            t = this.handles.split(","), this.handles = {}, i = 0; t.length > i; i++) s = e.trim(t[i]),
            a = "ui-resizable-" + s, n = e("<div class='ui-resizable-handle " + a + "'></div>"),
            n.css({
                zIndex: r.zIndex
            }), "se" === s && n.addClass("ui-icon ui-icon-gripsmall-diagonal-se"), this.handles[s] = ".ui-resizable-" + s,
            this.element.append(n);
            this._renderAxis = function(t) {
                var i, s, n, a;
                t = t || this.element;
                for (i in this.handles) this.handles[i].constructor === String ? this.handles[i] = this.element.children(this.handles[i]).first().show() : (this.handles[i].jquery || this.handles[i].nodeType) && (this.handles[i] = e(this.handles[i]),
                this._on(this.handles[i], {
                    mousedown: o._mouseDown
                })), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (s = e(this.handles[i], this.element),
                a = /sw|ne|nw|se|n|s/.test(i) ? s.outerHeight() : s.outerWidth(), n = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join(""),
                t.css(n, a), this._proportionallyResize()), this._handles = this._handles.add(this.handles[i]);
            }, this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")),
            this._handles.disableSelection(), this._handles.mouseover(function() {
                o.resizing || (this.className && (n = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),
                o.axis = n && n[1] ? n[1] : "se");
            }), r.autoHide && (this._handles.hide(), e(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
                r.disabled || (e(this).removeClass("ui-resizable-autohide"), o._handles.show());
            }).mouseleave(function() {
                r.disabled || o.resizing || (e(this).addClass("ui-resizable-autohide"), o._handles.hide());
            })), this._mouseInit();
        },
        _destroy: function() {
            this._mouseDestroy();
            var t, i = function(t) {
                e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
            };
            return this.elementIsWrapper && (i(this.element), t = this.element, this.originalElement.css({
                position: t.css("position"),
                width: t.outerWidth(),
                height: t.outerHeight(),
                top: t.css("top"),
                left: t.css("left")
            }).insertAfter(t), t.remove()), this.originalElement.css("resize", this.originalResizeStyle),
            i(this.originalElement), this;
        },
        _mouseCapture: function(t) {
            var i, s, n = !1;
            for (i in this.handles) ((s = e(this.handles[i])[0]) === t.target || e.contains(s, t.target)) && (n = !0);
            return !this.options.disabled && n;
        },
        _mouseStart: function(t) {
            var i, s, n, a = this.options, o = this.element;
            return this.resizing = !0, this._renderProxy(), i = this._num(this.helper.css("left")),
            s = this._num(this.helper.css("top")), a.containment && (i += e(a.containment).scrollLeft() || 0,
            s += e(a.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
                left: i,
                top: s
            }, this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                width: o.width(),
                height: o.height()
            }, this.originalSize = this._helper ? {
                width: o.outerWidth(),
                height: o.outerHeight()
            } : {
                width: o.width(),
                height: o.height()
            }, this.sizeDiff = {
                width: o.outerWidth() - o.width(),
                height: o.outerHeight() - o.height()
            }, this.originalPosition = {
                left: i,
                top: s
            }, this.originalMousePosition = {
                left: t.pageX,
                top: t.pageY
            }, this.aspectRatio = "number" == typeof a.aspectRatio ? a.aspectRatio : this.originalSize.width / this.originalSize.height || 1,
            n = e(".ui-resizable-" + this.axis).css("cursor"), e("body").css("cursor", "auto" === n ? this.axis + "-resize" : n),
            o.addClass("ui-resizable-resizing"), this._propagate("start", t), !0;
        },
        _mouseDrag: function(t) {
            var i, s, n = this.originalMousePosition, a = this.axis, o = t.pageX - n.left || 0, r = t.pageY - n.top || 0, h = this._change[a];
            return this._updatePrevProperties(), !!h && (i = h.apply(this, [ t, o, r ]), this._updateVirtualBoundaries(t.shiftKey),
            (this._aspectRatio || t.shiftKey) && (i = this._updateRatio(i, t)), i = this._respectSize(i, t),
            this._updateCache(i), this._propagate("resize", t), s = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(),
            e.isEmptyObject(s) || (this._updatePrevProperties(), this._trigger("resize", t, this.ui()),
            this._applyChanges()), !1);
        },
        _mouseStop: function(t) {
            this.resizing = !1;
            var i, s, n, a, o, r, h, l = this.options, u = this;
            return this._helper && (i = this._proportionallyResizeElements, s = i.length && /textarea/i.test(i[0].nodeName),
            n = s && this._hasScroll(i[0], "left") ? 0 : u.sizeDiff.height, a = s ? 0 : u.sizeDiff.width,
            o = {
                width: u.helper.width() - a,
                height: u.helper.height() - n
            }, r = parseInt(u.element.css("left"), 10) + (u.position.left - u.originalPosition.left) || null,
            h = parseInt(u.element.css("top"), 10) + (u.position.top - u.originalPosition.top) || null,
            l.animate || this.element.css(e.extend(o, {
                top: h,
                left: r
            })), u.helper.height(u.size.height), u.helper.width(u.size.width), this._helper && !l.animate && this._proportionallyResize()),
            e("body").css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"),
            this._propagate("stop", t), this._helper && this.helper.remove(), !1;
        },
        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            }, this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },
        _applyChanges: function() {
            var e = {};
            return this.position.top !== this.prevPosition.top && (e.top = this.position.top + "px"),
            this.position.left !== this.prevPosition.left && (e.left = this.position.left + "px"),
            this.size.width !== this.prevSize.width && (e.width = this.size.width + "px"), this.size.height !== this.prevSize.height && (e.height = this.size.height + "px"),
            this.helper.css(e), e;
        },
        _updateVirtualBoundaries: function(e) {
            var t, i, s, n, a, o = this.options;
            a = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : 1 / 0,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : 1 / 0
            }, (this._aspectRatio || e) && (t = a.minHeight * this.aspectRatio, s = a.minWidth / this.aspectRatio,
            i = a.maxHeight * this.aspectRatio, n = a.maxWidth / this.aspectRatio, t > a.minWidth && (a.minWidth = t),
            s > a.minHeight && (a.minHeight = s), a.maxWidth > i && (a.maxWidth = i), a.maxHeight > n && (a.maxHeight = n)),
            this._vBoundaries = a;
        },
        _updateCache: function(e) {
            this.offset = this.helper.offset(), this._isNumber(e.left) && (this.position.left = e.left),
            this._isNumber(e.top) && (this.position.top = e.top), this._isNumber(e.height) && (this.size.height = e.height),
            this._isNumber(e.width) && (this.size.width = e.width);
        },
        _updateRatio: function(e) {
            var t = this.position, i = this.size, s = this.axis;
            return this._isNumber(e.height) ? e.width = e.height * this.aspectRatio : this._isNumber(e.width) && (e.height = e.width / this.aspectRatio),
            "sw" === s && (e.left = t.left + (i.width - e.width), e.top = null), "nw" === s && (e.top = t.top + (i.height - e.height),
            e.left = t.left + (i.width - e.width)), e;
        },
        _respectSize: function(e) {
            var t = this._vBoundaries, i = this.axis, s = this._isNumber(e.width) && t.maxWidth && t.maxWidth < e.width, n = this._isNumber(e.height) && t.maxHeight && t.maxHeight < e.height, a = this._isNumber(e.width) && t.minWidth && t.minWidth > e.width, o = this._isNumber(e.height) && t.minHeight && t.minHeight > e.height, r = this.originalPosition.left + this.originalSize.width, h = this.position.top + this.size.height, l = /sw|nw|w/.test(i), u = /nw|ne|n/.test(i);
            return a && (e.width = t.minWidth), o && (e.height = t.minHeight), s && (e.width = t.maxWidth),
            n && (e.height = t.maxHeight), a && l && (e.left = r - t.minWidth), s && l && (e.left = r - t.maxWidth),
            o && u && (e.top = h - t.minHeight), n && u && (e.top = h - t.maxHeight), e.width || e.height || e.left || !e.top ? e.width || e.height || e.top || !e.left || (e.left = null) : e.top = null,
            e;
        },
        _getPaddingPlusBorderDimensions: function(e) {
            for (var t = 0, i = [], s = [ e.css("borderTopWidth"), e.css("borderRightWidth"), e.css("borderBottomWidth"), e.css("borderLeftWidth") ], n = [ e.css("paddingTop"), e.css("paddingRight"), e.css("paddingBottom"), e.css("paddingLeft") ]; 4 > t; t++) i[t] = parseInt(s[t], 10) || 0,
            i[t] += parseInt(n[t], 10) || 0;
            return {
                height: i[0] + i[2],
                width: i[1] + i[3]
            };
        },
        _proportionallyResize: function() {
            if (this._proportionallyResizeElements.length) for (var e, t = 0, i = this.helper || this.element; this._proportionallyResizeElements.length > t; t++) e = this._proportionallyResizeElements[t],
            this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(e)),
            e.css({
                height: i.height() - this.outerDimensions.height || 0,
                width: i.width() - this.outerDimensions.width || 0
            });
        },
        _renderProxy: function() {
            var t = this.element, i = this.options;
            this.elementOffset = t.offset(), this._helper ? (this.helper = this.helper || e("<div style='overflow:hidden;'></div>"),
            this.helper.addClass(this._helper).css({
                width: this.element.outerWidth() - 1,
                height: this.element.outerHeight() - 1,
                position: "absolute",
                left: this.elementOffset.left + "px",
                top: this.elementOffset.top + "px",
                zIndex: ++i.zIndex
            }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element;
        },
        _change: {
            e: function(e, t) {
                return {
                    width: this.originalSize.width + t
                };
            },
            w: function(e, t) {
                var i = this.originalSize;
                return {
                    left: this.originalPosition.left + t,
                    width: i.width - t
                };
            },
            n: function(e, t, i) {
                var s = this.originalSize;
                return {
                    top: this.originalPosition.top + i,
                    height: s.height - i
                };
            },
            s: function(e, t, i) {
                return {
                    height: this.originalSize.height + i
                };
            },
            se: function(t, i, s) {
                return e.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ t, i, s ]));
            },
            sw: function(t, i, s) {
                return e.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ t, i, s ]));
            },
            ne: function(t, i, s) {
                return e.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ t, i, s ]));
            },
            nw: function(t, i, s) {
                return e.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ t, i, s ]));
            }
        },
        _propagate: function(t, i) {
            e.ui.plugin.call(this, t, [ i, this.ui() ]), "resize" !== t && this._trigger(t, i, this.ui());
        },
        plugins: {},
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }
    }), e.ui.plugin.add("resizable", "animate", {
        stop: function(t) {
            var i = e(this).resizable("instance"), s = i.options, n = i._proportionallyResizeElements, a = n.length && /textarea/i.test(n[0].nodeName), o = a && i._hasScroll(n[0], "left") ? 0 : i.sizeDiff.height, r = a ? 0 : i.sizeDiff.width, h = {
                width: i.size.width - r,
                height: i.size.height - o
            }, l = parseInt(i.element.css("left"), 10) + (i.position.left - i.originalPosition.left) || null, u = parseInt(i.element.css("top"), 10) + (i.position.top - i.originalPosition.top) || null;
            i.element.animate(e.extend(h, u && l ? {
                top: u,
                left: l
            } : {}), {
                duration: s.animateDuration,
                easing: s.animateEasing,
                step: function() {
                    var s = {
                        width: parseInt(i.element.css("width"), 10),
                        height: parseInt(i.element.css("height"), 10),
                        top: parseInt(i.element.css("top"), 10),
                        left: parseInt(i.element.css("left"), 10)
                    };
                    n && n.length && e(n[0]).css({
                        width: s.width,
                        height: s.height
                    }), i._updateCache(s), i._propagate("resize", t);
                }
            });
        }
    }), e.ui.plugin.add("resizable", "containment", {
        start: function() {
            var t, i, s, n, a, o, r, h = e(this).resizable("instance"), l = h.options, u = h.element, d = l.containment, c = d instanceof e ? d.get(0) : /parent/.test(d) ? u.parent().get(0) : d;
            c && (h.containerElement = e(c), /document/.test(d) || d === document ? (h.containerOffset = {
                left: 0,
                top: 0
            }, h.containerPosition = {
                left: 0,
                top: 0
            }, h.parentData = {
                element: e(document),
                left: 0,
                top: 0,
                width: e(document).width(),
                height: e(document).height() || document.body.parentNode.scrollHeight
            }) : (t = e(c), i = [], e([ "Top", "Right", "Left", "Bottom" ]).each(function(e, s) {
                i[e] = h._num(t.css("padding" + s));
            }), h.containerOffset = t.offset(), h.containerPosition = t.position(), h.containerSize = {
                height: t.innerHeight() - i[3],
                width: t.innerWidth() - i[1]
            }, s = h.containerOffset, n = h.containerSize.height, a = h.containerSize.width,
            o = h._hasScroll(c, "left") ? c.scrollWidth : a, r = h._hasScroll(c) ? c.scrollHeight : n,
            h.parentData = {
                element: c,
                left: s.left,
                top: s.top,
                width: o,
                height: r
            }));
        },
        resize: function(t) {
            var i, s, n, a, o = e(this).resizable("instance"), r = o.options, h = o.containerOffset, l = o.position, u = o._aspectRatio || t.shiftKey, d = {
                top: 0,
                left: 0
            }, c = o.containerElement, p = !0;
            c[0] !== document && /static/.test(c.css("position")) && (d = h), l.left < (o._helper ? h.left : 0) && (o.size.width = o.size.width + (o._helper ? o.position.left - h.left : o.position.left - d.left),
            u && (o.size.height = o.size.width / o.aspectRatio, p = !1), o.position.left = r.helper ? h.left : 0),
            l.top < (o._helper ? h.top : 0) && (o.size.height = o.size.height + (o._helper ? o.position.top - h.top : o.position.top),
            u && (o.size.width = o.size.height * o.aspectRatio, p = !1), o.position.top = o._helper ? h.top : 0),
            n = o.containerElement.get(0) === o.element.parent().get(0), a = /relative|absolute/.test(o.containerElement.css("position")),
            n && a ? (o.offset.left = o.parentData.left + o.position.left, o.offset.top = o.parentData.top + o.position.top) : (o.offset.left = o.element.offset().left,
            o.offset.top = o.element.offset().top), i = Math.abs(o.sizeDiff.width + (o._helper ? o.offset.left - d.left : o.offset.left - h.left)),
            s = Math.abs(o.sizeDiff.height + (o._helper ? o.offset.top - d.top : o.offset.top - h.top)),
            i + o.size.width >= o.parentData.width && (o.size.width = o.parentData.width - i,
            u && (o.size.height = o.size.width / o.aspectRatio, p = !1)), s + o.size.height >= o.parentData.height && (o.size.height = o.parentData.height - s,
            u && (o.size.width = o.size.height * o.aspectRatio, p = !1)), p || (o.position.left = o.prevPosition.left,
            o.position.top = o.prevPosition.top, o.size.width = o.prevSize.width, o.size.height = o.prevSize.height);
        },
        stop: function() {
            var t = e(this).resizable("instance"), i = t.options, s = t.containerOffset, n = t.containerPosition, a = t.containerElement, o = e(t.helper), r = o.offset(), h = o.outerWidth() - t.sizeDiff.width, l = o.outerHeight() - t.sizeDiff.height;
            t._helper && !i.animate && /relative/.test(a.css("position")) && e(this).css({
                left: r.left - n.left - s.left,
                width: h,
                height: l
            }), t._helper && !i.animate && /static/.test(a.css("position")) && e(this).css({
                left: r.left - n.left - s.left,
                width: h,
                height: l
            });
        }
    }), e.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
            var t = e(this).resizable("instance"), i = t.options;
            e(i.alsoResize).each(function() {
                var t = e(this);
                t.data("ui-resizable-alsoresize", {
                    width: parseInt(t.width(), 10),
                    height: parseInt(t.height(), 10),
                    left: parseInt(t.css("left"), 10),
                    top: parseInt(t.css("top"), 10)
                });
            });
        },
        resize: function(t, i) {
            var s = e(this).resizable("instance"), n = s.options, a = s.originalSize, o = s.originalPosition, r = {
                height: s.size.height - a.height || 0,
                width: s.size.width - a.width || 0,
                top: s.position.top - o.top || 0,
                left: s.position.left - o.left || 0
            };
            e(n.alsoResize).each(function() {
                var t = e(this), s = e(this).data("ui-resizable-alsoresize"), n = {}, a = t.parents(i.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                e.each(a, function(e, t) {
                    var i = (s[t] || 0) + (r[t] || 0);
                    i && i >= 0 && (n[t] = i || null);
                }), t.css(n);
            });
        },
        stop: function() {
            e(this).removeData("resizable-alsoresize");
        }
    }), e.ui.plugin.add("resizable", "ghost", {
        start: function() {
            var t = e(this).resizable("instance"), i = t.options, s = t.size;
            t.ghost = t.originalElement.clone(), t.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: s.height,
                width: s.width,
                margin: 0,
                left: 0,
                top: 0
            }).addClass("ui-resizable-ghost").addClass("string" == typeof i.ghost ? i.ghost : ""),
            t.ghost.appendTo(t.helper);
        },
        resize: function() {
            var t = e(this).resizable("instance");
            t.ghost && t.ghost.css({
                position: "relative",
                height: t.size.height,
                width: t.size.width
            });
        },
        stop: function() {
            var t = e(this).resizable("instance");
            t.ghost && t.helper && t.helper.get(0).removeChild(t.ghost.get(0));
        }
    }), e.ui.plugin.add("resizable", "grid", {
        resize: function() {
            var t, i = e(this).resizable("instance"), s = i.options, n = i.size, a = i.originalSize, o = i.originalPosition, r = i.axis, h = "number" == typeof s.grid ? [ s.grid, s.grid ] : s.grid, l = h[0] || 1, u = h[1] || 1, d = Math.round((n.width - a.width) / l) * l, c = Math.round((n.height - a.height) / u) * u, p = a.width + d, f = a.height + c, m = s.maxWidth && p > s.maxWidth, g = s.maxHeight && f > s.maxHeight, v = s.minWidth && s.minWidth > p, y = s.minHeight && s.minHeight > f;
            s.grid = h, v && (p += l), y && (f += u), m && (p -= l), g && (f -= u), /^(se|s|e)$/.test(r) ? (i.size.width = p,
            i.size.height = f) : /^(ne)$/.test(r) ? (i.size.width = p, i.size.height = f, i.position.top = o.top - c) : /^(sw)$/.test(r) ? (i.size.width = p,
            i.size.height = f, i.position.left = o.left - d) : ((0 >= f - u || 0 >= p - l) && (t = i._getPaddingPlusBorderDimensions(this)),
            f - u > 0 ? (i.size.height = f, i.position.top = o.top - c) : (f = u - t.height,
            i.size.height = f, i.position.top = o.top + a.height - f), p - l > 0 ? (i.size.width = p,
            i.position.left = o.left - d) : (p = l - t.width, i.size.width = p, i.position.left = o.left + a.width - p));
        }
    }), e.ui.resizable, e.widget("ui.selectable", e.ui.mouse, {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoRefresh: !0,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var t, i = this;
            this.element.addClass("ui-selectable"), this.dragged = !1, this.refresh = function() {
                t = e(i.options.filter, i.element[0]), t.addClass("ui-selectee"), t.each(function() {
                    var t = e(this), i = t.offset();
                    e.data(this, "selectable-item", {
                        element: this,
                        $element: t,
                        left: i.left,
                        top: i.top,
                        right: i.left + t.outerWidth(),
                        bottom: i.top + t.outerHeight(),
                        startselected: !1,
                        selected: t.hasClass("ui-selected"),
                        selecting: t.hasClass("ui-selecting"),
                        unselecting: t.hasClass("ui-unselecting")
                    });
                });
            }, this.refresh(), this.selectees = t.addClass("ui-selectee"), this._mouseInit(),
            this.helper = e("<div class='ui-selectable-helper'></div>");
        },
        _destroy: function() {
            this.selectees.removeClass("ui-selectee").removeData("selectable-item"), this.element.removeClass("ui-selectable ui-selectable-disabled"),
            this._mouseDestroy();
        },
        _mouseStart: function(t) {
            var i = this, s = this.options;
            this.opos = [ t.pageX, t.pageY ], this.options.disabled || (this.selectees = e(s.filter, this.element[0]),
            this._trigger("start", t), e(s.appendTo).append(this.helper), this.helper.css({
                left: t.pageX,
                top: t.pageY,
                width: 0,
                height: 0
            }), s.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function() {
                var s = e.data(this, "selectable-item");
                s.startselected = !0, t.metaKey || t.ctrlKey || (s.$element.removeClass("ui-selected"),
                s.selected = !1, s.$element.addClass("ui-unselecting"), s.unselecting = !0, i._trigger("unselecting", t, {
                    unselecting: s.element
                }));
            }), e(t.target).parents().addBack().each(function() {
                var s, n = e.data(this, "selectable-item");
                return n ? (s = !t.metaKey && !t.ctrlKey || !n.$element.hasClass("ui-selected"),
                n.$element.removeClass(s ? "ui-unselecting" : "ui-selected").addClass(s ? "ui-selecting" : "ui-unselecting"),
                n.unselecting = !s, n.selecting = s, n.selected = s, s ? i._trigger("selecting", t, {
                    selecting: n.element
                }) : i._trigger("unselecting", t, {
                    unselecting: n.element
                }), !1) : void 0;
            }));
        },
        _mouseDrag: function(t) {
            if (this.dragged = !0, !this.options.disabled) {
                var i, s = this, n = this.options, a = this.opos[0], o = this.opos[1], r = t.pageX, h = t.pageY;
                return a > r && (i = r, r = a, a = i), o > h && (i = h, h = o, o = i), this.helper.css({
                    left: a,
                    top: o,
                    width: r - a,
                    height: h - o
                }), this.selectees.each(function() {
                    var i = e.data(this, "selectable-item"), l = !1;
                    i && i.element !== s.element[0] && ("touch" === n.tolerance ? l = !(i.left > r || a > i.right || i.top > h || o > i.bottom) : "fit" === n.tolerance && (l = i.left > a && r > i.right && i.top > o && h > i.bottom),
                    l ? (i.selected && (i.$element.removeClass("ui-selected"), i.selected = !1), i.unselecting && (i.$element.removeClass("ui-unselecting"),
                    i.unselecting = !1), i.selecting || (i.$element.addClass("ui-selecting"), i.selecting = !0,
                    s._trigger("selecting", t, {
                        selecting: i.element
                    }))) : (i.selecting && ((t.metaKey || t.ctrlKey) && i.startselected ? (i.$element.removeClass("ui-selecting"),
                    i.selecting = !1, i.$element.addClass("ui-selected"), i.selected = !0) : (i.$element.removeClass("ui-selecting"),
                    i.selecting = !1, i.startselected && (i.$element.addClass("ui-unselecting"), i.unselecting = !0),
                    s._trigger("unselecting", t, {
                        unselecting: i.element
                    }))), i.selected && (t.metaKey || t.ctrlKey || i.startselected || (i.$element.removeClass("ui-selected"),
                    i.selected = !1, i.$element.addClass("ui-unselecting"), i.unselecting = !0, s._trigger("unselecting", t, {
                        unselecting: i.element
                    })))));
                }), !1;
            }
        },
        _mouseStop: function(t) {
            var i = this;
            return this.dragged = !1, e(".ui-unselecting", this.element[0]).each(function() {
                var s = e.data(this, "selectable-item");
                s.$element.removeClass("ui-unselecting"), s.unselecting = !1, s.startselected = !1,
                i._trigger("unselected", t, {
                    unselected: s.element
                });
            }), e(".ui-selecting", this.element[0]).each(function() {
                var s = e.data(this, "selectable-item");
                s.$element.removeClass("ui-selecting").addClass("ui-selected"), s.selecting = !1,
                s.selected = !0, s.startselected = !0, i._trigger("selected", t, {
                    selected: s.element
                });
            }), this._trigger("stop", t), this.helper.remove(), !1;
        }
    }), e.widget("ui.sortable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "sort",
        ready: !1,
        options: {
            appendTo: "parent",
            axis: !1,
            connectWith: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            dropOnEmpty: !0,
            forcePlaceholderSize: !1,
            forceHelperSize: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            items: "> *",
            opacity: !1,
            placeholder: !1,
            revert: !1,
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _isOverAxis: function(e, t, i) {
            return e >= t && t + i > e;
        },
        _isFloating: function(e) {
            return /left|right/.test(e.css("float")) || /inline|table-cell/.test(e.css("display"));
        },
        _create: function() {
            this.containerCache = {}, this.element.addClass("ui-sortable"), this.refresh(),
            this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(),
            this.ready = !0;
        },
        _setOption: function(e, t) {
            this._super(e, t), "handle" === e && this._setHandleClassName();
        },
        _setHandleClassName: function() {
            this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"), e.each(this.items, function() {
                (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle");
            });
        },
        _destroy: function() {
            this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"),
            this._mouseDestroy();
            for (var e = this.items.length - 1; e >= 0; e--) this.items[e].item.removeData(this.widgetName + "-item");
            return this;
        },
        _mouseCapture: function(t, i) {
            var s = null, n = !1, a = this;
            return !this.reverting && (!this.options.disabled && "static" !== this.options.type && (this._refreshItems(t),
            e(t.target).parents().each(function() {
                return e.data(this, a.widgetName + "-item") === a ? (s = e(this), !1) : void 0;
            }), e.data(t.target, a.widgetName + "-item") === a && (s = e(t.target)), !!s && (!(this.options.handle && !i && (e(this.options.handle, s).find("*").addBack().each(function() {
                this === t.target && (n = !0);
            }), !n)) && (this.currentItem = s, this._removeCurrentsFromItems(), !0))));
        },
        _mouseStart: function(t, i, s) {
            var n, a, o = this.options;
            if (this.currentContainer = this, this.refreshPositions(), this.helper = this._createHelper(t),
            this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(),
            this.offset = this.currentItem.offset(), this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            }, e.extend(this.offset, {
                click: {
                    left: t.pageX - this.offset.left,
                    top: t.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"),
            this.originalPosition = this._generatePosition(t), this.originalPageX = t.pageX,
            this.originalPageY = t.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt),
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(),
            o.containment && this._setContainment(), o.cursor && "auto" !== o.cursor && (a = this.document.find("body"),
            this.storedCursor = a.css("cursor"), a.css("cursor", o.cursor), this.storedStylesheet = e("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(a)),
            o.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")),
            this.helper.css("opacity", o.opacity)), o.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")),
            this.helper.css("zIndex", o.zIndex)), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()),
            this._trigger("start", t, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(),
            !s) for (n = this.containers.length - 1; n >= 0; n--) this.containers[n]._trigger("activate", t, this._uiHash(this));
            return e.ui.ddmanager && (e.ui.ddmanager.current = this), e.ui.ddmanager && !o.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t),
            this.dragging = !0, this.helper.addClass("ui-sortable-helper"), this._mouseDrag(t),
            !0;
        },
        _mouseDrag: function(t) {
            var i, s, n, a, o = this.options, r = !1;
            for (this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute"),
            this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), this.options.scroll && (this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t.pageY < o.scrollSensitivity ? this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop + o.scrollSpeed : t.pageY - this.overflowOffset.top < o.scrollSensitivity && (this.scrollParent[0].scrollTop = r = this.scrollParent[0].scrollTop - o.scrollSpeed),
            this.overflowOffset.left + this.scrollParent[0].offsetWidth - t.pageX < o.scrollSensitivity ? this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft + o.scrollSpeed : t.pageX - this.overflowOffset.left < o.scrollSensitivity && (this.scrollParent[0].scrollLeft = r = this.scrollParent[0].scrollLeft - o.scrollSpeed)) : (t.pageY - this.document.scrollTop() < o.scrollSensitivity ? r = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed) : this.window.height() - (t.pageY - this.document.scrollTop()) < o.scrollSensitivity && (r = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed)),
            t.pageX - this.document.scrollLeft() < o.scrollSensitivity ? r = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed) : this.window.width() - (t.pageX - this.document.scrollLeft()) < o.scrollSensitivity && (r = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed))),
            !1 !== r && e.ui.ddmanager && !o.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t)),
            this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"),
            this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"),
            i = this.items.length - 1; i >= 0; i--) if (s = this.items[i], n = s.item[0], (a = this._intersectsWithPointer(s)) && s.instance === this.currentContainer && n !== this.currentItem[0] && this.placeholder[1 === a ? "next" : "prev"]()[0] !== n && !e.contains(this.placeholder[0], n) && ("semi-dynamic" !== this.options.type || !e.contains(this.element[0], n))) {
                if (this.direction = 1 === a ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(s)) break;
                this._rearrange(t, s), this._trigger("change", t, this._uiHash());
                break;
            }
            return this._contactContainers(t), e.ui.ddmanager && e.ui.ddmanager.drag(this, t),
            this._trigger("sort", t, this._uiHash()), this.lastPositionAbs = this.positionAbs,
            !1;
        },
        _mouseStop: function(t, i) {
            if (t) {
                if (e.ui.ddmanager && !this.options.dropBehaviour && e.ui.ddmanager.drop(this, t),
                this.options.revert) {
                    var s = this, n = this.placeholder.offset(), a = this.options.axis, o = {};
                    a && "x" !== a || (o.left = n.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)),
                    a && "y" !== a || (o.top = n.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)),
                    this.reverting = !0, e(this.helper).animate(o, parseInt(this.options.revert, 10) || 500, function() {
                        s._clear(t);
                    });
                } else this._clear(t, i);
                return !1;
            }
        },
        cancel: function() {
            if (this.dragging) {
                this._mouseUp({
                    target: null
                }), "original" === this.options.helper ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();
                for (var t = this.containers.length - 1; t >= 0; t--) this.containers[t]._trigger("deactivate", null, this._uiHash(this)),
                this.containers[t].containerCache.over && (this.containers[t]._trigger("out", null, this._uiHash(this)),
                this.containers[t].containerCache.over = 0);
            }
            return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]),
            "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(),
            e.extend(this, {
                helper: null,
                dragging: !1,
                reverting: !1,
                _noFinalSort: null
            }), this.domPosition.prev ? e(this.domPosition.prev).after(this.currentItem) : e(this.domPosition.parent).prepend(this.currentItem)),
            this;
        },
        serialize: function(t) {
            var i = this._getItemsAsjQuery(t && t.connected), s = [];
            return t = t || {}, e(i).each(function() {
                var i = (e(t.item || this).attr(t.attribute || "id") || "").match(t.expression || /(.+)[\-=_](.+)/);
                i && s.push((t.key || i[1] + "[]") + "=" + (t.key && t.expression ? i[1] : i[2]));
            }), !s.length && t.key && s.push(t.key + "="), s.join("&");
        },
        toArray: function(t) {
            var i = this._getItemsAsjQuery(t && t.connected), s = [];
            return t = t || {}, i.each(function() {
                s.push(e(t.item || this).attr(t.attribute || "id") || "");
            }), s;
        },
        _intersectsWith: function(e) {
            var t = this.positionAbs.left, i = t + this.helperProportions.width, s = this.positionAbs.top, n = s + this.helperProportions.height, a = e.left, o = a + e.width, r = e.top, h = r + e.height, l = this.offset.click.top, u = this.offset.click.left, d = "x" === this.options.axis || s + l > r && h > s + l, c = "y" === this.options.axis || t + u > a && o > t + u, p = d && c;
            return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > e[this.floating ? "width" : "height"] ? p : t + this.helperProportions.width / 2 > a && o > i - this.helperProportions.width / 2 && s + this.helperProportions.height / 2 > r && h > n - this.helperProportions.height / 2;
        },
        _intersectsWithPointer: function(e) {
            var t = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, e.top, e.height), i = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, e.left, e.width), s = t && i, n = this._getDragVerticalDirection(), a = this._getDragHorizontalDirection();
            return !!s && (this.floating ? a && "right" === a || "down" === n ? 2 : 1 : n && ("down" === n ? 2 : 1));
        },
        _intersectsWithSides: function(e) {
            var t = this._isOverAxis(this.positionAbs.top + this.offset.click.top, e.top + e.height / 2, e.height), i = this._isOverAxis(this.positionAbs.left + this.offset.click.left, e.left + e.width / 2, e.width), s = this._getDragVerticalDirection(), n = this._getDragHorizontalDirection();
            return this.floating && n ? "right" === n && i || "left" === n && !i : s && ("down" === s && t || "up" === s && !t);
        },
        _getDragVerticalDirection: function() {
            var e = this.positionAbs.top - this.lastPositionAbs.top;
            return 0 !== e && (e > 0 ? "down" : "up");
        },
        _getDragHorizontalDirection: function() {
            var e = this.positionAbs.left - this.lastPositionAbs.left;
            return 0 !== e && (e > 0 ? "right" : "left");
        },
        refresh: function(e) {
            return this._refreshItems(e), this._setHandleClassName(), this.refreshPositions(),
            this;
        },
        _connectWith: function() {
            var e = this.options;
            return e.connectWith.constructor === String ? [ e.connectWith ] : e.connectWith;
        },
        _getItemsAsjQuery: function(t) {
            function i() {
                r.push(this);
            }
            var s, n, a, o, r = [], h = [], l = this._connectWith();
            if (l && t) for (s = l.length - 1; s >= 0; s--) for (a = e(l[s], this.document[0]),
            n = a.length - 1; n >= 0; n--) (o = e.data(a[n], this.widgetFullName)) && o !== this && !o.options.disabled && h.push([ e.isFunction(o.options.items) ? o.options.items.call(o.element) : e(o.options.items, o.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), o ]);
            for (h.push([ e.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : e(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this ]),
            s = h.length - 1; s >= 0; s--) h[s][0].each(i);
            return e(r);
        },
        _removeCurrentsFromItems: function() {
            var t = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = e.grep(this.items, function(e) {
                for (var i = 0; t.length > i; i++) if (t[i] === e.item[0]) return !1;
                return !0;
            });
        },
        _refreshItems: function(t) {
            this.items = [], this.containers = [ this ];
            var i, s, n, a, o, r, h, l, u = this.items, d = [ [ e.isFunction(this.options.items) ? this.options.items.call(this.element[0], t, {
                item: this.currentItem
            }) : e(this.options.items, this.element), this ] ], c = this._connectWith();
            if (c && this.ready) for (i = c.length - 1; i >= 0; i--) for (n = e(c[i], this.document[0]),
            s = n.length - 1; s >= 0; s--) (a = e.data(n[s], this.widgetFullName)) && a !== this && !a.options.disabled && (d.push([ e.isFunction(a.options.items) ? a.options.items.call(a.element[0], t, {
                item: this.currentItem
            }) : e(a.options.items, a.element), a ]), this.containers.push(a));
            for (i = d.length - 1; i >= 0; i--) for (o = d[i][1], r = d[i][0], s = 0, l = r.length; l > s; s++) h = e(r[s]),
            h.data(this.widgetName + "-item", o), u.push({
                item: h,
                instance: o,
                width: 0,
                height: 0,
                left: 0,
                top: 0
            });
        },
        refreshPositions: function(t) {
            this.floating = !!this.items.length && ("x" === this.options.axis || this._isFloating(this.items[0].item)),
            this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());
            var i, s, n, a;
            for (i = this.items.length - 1; i >= 0; i--) s = this.items[i], s.instance !== this.currentContainer && this.currentContainer && s.item[0] !== this.currentItem[0] || (n = this.options.toleranceElement ? e(this.options.toleranceElement, s.item) : s.item,
            t || (s.width = n.outerWidth(), s.height = n.outerHeight()), a = n.offset(), s.left = a.left,
            s.top = a.top);
            if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this); else for (i = this.containers.length - 1; i >= 0; i--) a = this.containers[i].element.offset(),
            this.containers[i].containerCache.left = a.left, this.containers[i].containerCache.top = a.top,
            this.containers[i].containerCache.width = this.containers[i].element.outerWidth(),
            this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
            return this;
        },
        _createPlaceholder: function(t) {
            t = t || this;
            var i, s = t.options;
            s.placeholder && s.placeholder.constructor !== String || (i = s.placeholder, s.placeholder = {
                element: function() {
                    var s = t.currentItem[0].nodeName.toLowerCase(), n = e("<" + s + ">", t.document[0]).addClass(i || t.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                    return "tbody" === s ? t._createTrPlaceholder(t.currentItem.find("tr").eq(0), e("<tr>", t.document[0]).appendTo(n)) : "tr" === s ? t._createTrPlaceholder(t.currentItem, n) : "img" === s && n.attr("src", t.currentItem.attr("src")),
                    i || n.css("visibility", "hidden"), n;
                },
                update: function(e, n) {
                    (!i || s.forcePlaceholderSize) && (n.height() || n.height(t.currentItem.innerHeight() - parseInt(t.currentItem.css("paddingTop") || 0, 10) - parseInt(t.currentItem.css("paddingBottom") || 0, 10)),
                    n.width() || n.width(t.currentItem.innerWidth() - parseInt(t.currentItem.css("paddingLeft") || 0, 10) - parseInt(t.currentItem.css("paddingRight") || 0, 10)));
                }
            }), t.placeholder = e(s.placeholder.element.call(t.element, t.currentItem)), t.currentItem.after(t.placeholder),
            s.placeholder.update(t, t.placeholder);
        },
        _createTrPlaceholder: function(t, i) {
            var s = this;
            t.children().each(function() {
                e("<td>&#160;</td>", s.document[0]).attr("colspan", e(this).attr("colspan") || 1).appendTo(i);
            });
        },
        _contactContainers: function(t) {
            var i, s, n, a, o, r, h, l, u, d, c = null, p = null;
            for (i = this.containers.length - 1; i >= 0; i--) if (!e.contains(this.currentItem[0], this.containers[i].element[0])) if (this._intersectsWith(this.containers[i].containerCache)) {
                if (c && e.contains(this.containers[i].element[0], c.element[0])) continue;
                c = this.containers[i], p = i;
            } else this.containers[i].containerCache.over && (this.containers[i]._trigger("out", t, this._uiHash(this)),
            this.containers[i].containerCache.over = 0);
            if (c) if (1 === this.containers.length) this.containers[p].containerCache.over || (this.containers[p]._trigger("over", t, this._uiHash(this)),
            this.containers[p].containerCache.over = 1); else {
                for (n = 1e4, a = null, u = c.floating || this._isFloating(this.currentItem), o = u ? "left" : "top",
                r = u ? "width" : "height", d = u ? "clientX" : "clientY", s = this.items.length - 1; s >= 0; s--) e.contains(this.containers[p].element[0], this.items[s].item[0]) && this.items[s].item[0] !== this.currentItem[0] && (h = this.items[s].item.offset()[o],
                l = !1, t[d] - h > this.items[s][r] / 2 && (l = !0), n > Math.abs(t[d] - h) && (n = Math.abs(t[d] - h),
                a = this.items[s], this.direction = l ? "up" : "down"));
                if (!a && !this.options.dropOnEmpty) return;
                if (this.currentContainer === this.containers[p]) return void (this.currentContainer.containerCache.over || (this.containers[p]._trigger("over", t, this._uiHash()),
                this.currentContainer.containerCache.over = 1));
                a ? this._rearrange(t, a, null, !0) : this._rearrange(t, null, this.containers[p].element, !0),
                this._trigger("change", t, this._uiHash()), this.containers[p]._trigger("change", t, this._uiHash(this)),
                this.currentContainer = this.containers[p], this.options.placeholder.update(this.currentContainer, this.placeholder),
                this.containers[p]._trigger("over", t, this._uiHash(this)), this.containers[p].containerCache.over = 1;
            }
        },
        _createHelper: function(t) {
            var i = this.options, s = e.isFunction(i.helper) ? e(i.helper.apply(this.element[0], [ t, this.currentItem ])) : "clone" === i.helper ? this.currentItem.clone() : this.currentItem;
            return s.parents("body").length || e("parent" !== i.appendTo ? i.appendTo : this.currentItem[0].parentNode)[0].appendChild(s[0]),
            s[0] === this.currentItem[0] && (this._storedCSS = {
                width: this.currentItem[0].style.width,
                height: this.currentItem[0].style.height,
                position: this.currentItem.css("position"),
                top: this.currentItem.css("top"),
                left: this.currentItem.css("left")
            }), (!s[0].style.width || i.forceHelperSize) && s.width(this.currentItem.width()),
            (!s[0].style.height || i.forceHelperSize) && s.height(this.currentItem.height()),
            s;
        },
        _adjustOffsetFromHelper: function(t) {
            "string" == typeof t && (t = t.split(" ")), e.isArray(t) && (t = {
                left: +t[0],
                top: +t[1] || 0
            }), "left" in t && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left),
            "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top);
        },
        _getParentOffset: function() {
            this.offsetParent = this.helper.offsetParent();
            var t = this.offsetParent.offset();
            return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(),
            t.top += this.scrollParent.scrollTop()), (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && e.ui.ie) && (t = {
                top: 0,
                left: 0
            }), {
                top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if ("relative" === this.cssPosition) {
                var e = this.currentItem.position();
                return {
                    top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            }
            return {
                top: 0,
                left: 0
            };
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var t, i, s, n = this.options;
            "parent" === n.containment && (n.containment = this.helper[0].parentNode), ("document" === n.containment || "window" === n.containment) && (this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === n.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === n.containment ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]),
            /^(document|window|parent)$/.test(n.containment) || (t = e(n.containment)[0], i = e(n.containment).offset(),
            s = "hidden" !== e(t).css("overflow"), this.containment = [ i.left + (parseInt(e(t).css("borderLeftWidth"), 10) || 0) + (parseInt(e(t).css("paddingLeft"), 10) || 0) - this.margins.left, i.top + (parseInt(e(t).css("borderTopWidth"), 10) || 0) + (parseInt(e(t).css("paddingTop"), 10) || 0) - this.margins.top, i.left + (s ? Math.max(t.scrollWidth, t.offsetWidth) : t.offsetWidth) - (parseInt(e(t).css("borderLeftWidth"), 10) || 0) - (parseInt(e(t).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, i.top + (s ? Math.max(t.scrollHeight, t.offsetHeight) : t.offsetHeight) - (parseInt(e(t).css("borderTopWidth"), 10) || 0) - (parseInt(e(t).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top ]);
        },
        _convertPositionTo: function(t, i) {
            i || (i = this.position);
            var s = "absolute" === t ? 1 : -1, n = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, a = /(html|body)/i.test(n[0].tagName);
            return {
                top: i.top + this.offset.relative.top * s + this.offset.parent.top * s - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : a ? 0 : n.scrollTop()) * s,
                left: i.left + this.offset.relative.left * s + this.offset.parent.left * s - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : a ? 0 : n.scrollLeft()) * s
            };
        },
        _generatePosition: function(t) {
            var i, s, n = this.options, a = t.pageX, o = t.pageY, r = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, h = /(html|body)/i.test(r[0].tagName);
            return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()),
            this.originalPosition && (this.containment && (t.pageX - this.offset.click.left < this.containment[0] && (a = this.containment[0] + this.offset.click.left),
            t.pageY - this.offset.click.top < this.containment[1] && (o = this.containment[1] + this.offset.click.top),
            t.pageX - this.offset.click.left > this.containment[2] && (a = this.containment[2] + this.offset.click.left),
            t.pageY - this.offset.click.top > this.containment[3] && (o = this.containment[3] + this.offset.click.top)),
            n.grid && (i = this.originalPageY + Math.round((o - this.originalPageY) / n.grid[1]) * n.grid[1],
            o = this.containment ? i - this.offset.click.top >= this.containment[1] && i - this.offset.click.top <= this.containment[3] ? i : i - this.offset.click.top >= this.containment[1] ? i - n.grid[1] : i + n.grid[1] : i,
            s = this.originalPageX + Math.round((a - this.originalPageX) / n.grid[0]) * n.grid[0],
            a = this.containment ? s - this.offset.click.left >= this.containment[0] && s - this.offset.click.left <= this.containment[2] ? s : s - this.offset.click.left >= this.containment[0] ? s - n.grid[0] : s + n.grid[0] : s)),
            {
                top: o - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : h ? 0 : r.scrollTop()),
                left: a - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : h ? 0 : r.scrollLeft())
            };
        },
        _rearrange: function(e, t, i, s) {
            i ? i[0].appendChild(this.placeholder[0]) : t.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? t.item[0] : t.item[0].nextSibling),
            this.counter = this.counter ? ++this.counter : 1;
            var n = this.counter;
            this._delay(function() {
                n === this.counter && this.refreshPositions(!s);
            });
        },
        _clear: function(e, t) {
            function i(e, t, i) {
                return function(s) {
                    i._trigger(e, s, t._uiHash(t));
                };
            }
            this.reverting = !1;
            var s, n = [];
            if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem),
            this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
                for (s in this._storedCSS) ("auto" === this._storedCSS[s] || "static" === this._storedCSS[s]) && (this._storedCSS[s] = "");
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else this.currentItem.show();
            for (this.fromOutside && !t && n.push(function(e) {
                this._trigger("receive", e, this._uiHash(this.fromOutside));
            }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || t || n.push(function(e) {
                this._trigger("update", e, this._uiHash());
            }), this !== this.currentContainer && (t || (n.push(function(e) {
                this._trigger("remove", e, this._uiHash());
            }), n.push(function(e) {
                return function(t) {
                    e._trigger("receive", t, this._uiHash(this));
                };
            }.call(this, this.currentContainer)), n.push(function(e) {
                return function(t) {
                    e._trigger("update", t, this._uiHash(this));
                };
            }.call(this, this.currentContainer)))), s = this.containers.length - 1; s >= 0; s--) t || n.push(i("deactivate", this, this.containers[s])),
            this.containers[s].containerCache.over && (n.push(i("out", this, this.containers[s])),
            this.containers[s].containerCache.over = 0);
            if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor),
            this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity),
            this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex),
            this.dragging = !1, t || this._trigger("beforeStop", e, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]),
            this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(),
            this.helper = null), !t) {
                for (s = 0; n.length > s; s++) n[s].call(this, e);
                this._trigger("stop", e, this._uiHash());
            }
            return this.fromOutside = !1, !this.cancelHelperRemoval;
        },
        _trigger: function() {
            !1 === e.Widget.prototype._trigger.apply(this, arguments) && this.cancel();
        },
        _uiHash: function(t) {
            var i = t || this;
            return {
                helper: i.helper,
                placeholder: i.placeholder || e([]),
                position: i.position,
                originalPosition: i.originalPosition,
                offset: i.positionAbs,
                item: i.currentItem,
                sender: t ? t.element : null
            };
        }
    }), e.widget("ui.tabs", {
        version: "1.11.4",
        delay: 300,
        options: {
            active: null,
            collapsible: !1,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _isLocal: function() {
            var e = /#.*$/;
            return function(t) {
                var i, s;
                t = t.cloneNode(!1), i = t.href.replace(e, ""), s = location.href.replace(e, "");
                try {
                    i = decodeURIComponent(i);
                } catch (n) {}
                try {
                    s = decodeURIComponent(s);
                } catch (n) {}
                return t.hash.length > 1 && i === s;
            };
        }(),
        _create: function() {
            var t = this, i = this.options;
            this.running = !1, this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", i.collapsible),
            this._processTabs(), i.active = this._initialActive(), e.isArray(i.disabled) && (i.disabled = e.unique(i.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"), function(e) {
                return t.tabs.index(e);
            }))).sort()), this.active = !1 !== this.options.active && this.anchors.length ? this._findActive(i.active) : e(),
            this._refresh(), this.active.length && this.load(i.active);
        },
        _initialActive: function() {
            var t = this.options.active, i = this.options.collapsible, s = location.hash.substring(1);
            return null === t && (s && this.tabs.each(function(i, n) {
                return e(n).attr("aria-controls") === s ? (t = i, !1) : void 0;
            }), null === t && (t = this.tabs.index(this.tabs.filter(".ui-tabs-active"))), (null === t || -1 === t) && (t = !!this.tabs.length && 0)),
            !1 !== t && -1 === (t = this.tabs.index(this.tabs.eq(t))) && (t = !i && 0), !i && !1 === t && this.anchors.length && (t = 0),
            t;
        },
        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: this.active.length ? this._getPanelForTab(this.active) : e()
            };
        },
        _tabKeydown: function(t) {
            var i = e(this.document[0].activeElement).closest("li"), s = this.tabs.index(i), n = !0;
            if (!this._handlePageNav(t)) {
                switch (t.keyCode) {
                  case e.ui.keyCode.RIGHT:
                  case e.ui.keyCode.DOWN:
                    s++;
                    break;

                  case e.ui.keyCode.UP:
                  case e.ui.keyCode.LEFT:
                    n = !1, s--;
                    break;

                  case e.ui.keyCode.END:
                    s = this.anchors.length - 1;
                    break;

                  case e.ui.keyCode.HOME:
                    s = 0;
                    break;

                  case e.ui.keyCode.SPACE:
                    return t.preventDefault(), clearTimeout(this.activating), void this._activate(s);

                  case e.ui.keyCode.ENTER:
                    return t.preventDefault(), clearTimeout(this.activating), void this._activate(s !== this.options.active && s);

                  default:
                    return;
                }
                t.preventDefault(), clearTimeout(this.activating), s = this._focusNextTab(s, n),
                t.ctrlKey || t.metaKey || (i.attr("aria-selected", "false"), this.tabs.eq(s).attr("aria-selected", "true"),
                this.activating = this._delay(function() {
                    this.option("active", s);
                }, this.delay));
            }
        },
        _panelKeydown: function(t) {
            this._handlePageNav(t) || t.ctrlKey && t.keyCode === e.ui.keyCode.UP && (t.preventDefault(),
            this.active.focus());
        },
        _handlePageNav: function(t) {
            return t.altKey && t.keyCode === e.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)),
            !0) : t.altKey && t.keyCode === e.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)),
            !0) : void 0;
        },
        _findNextTab: function(t, i) {
            for (var n = this.tabs.length - 1; -1 !== e.inArray(function() {
                return t > n && (t = 0), 0 > t && (t = n), t;
            }(), this.options.disabled); ) t = i ? t + 1 : t - 1;
            return t;
        },
        _focusNextTab: function(e, t) {
            return e = this._findNextTab(e, t), this.tabs.eq(e).focus(), e;
        },
        _setOption: function(e, t) {
            return "active" === e ? void this._activate(t) : "disabled" === e ? void this._setupDisabled(t) : (this._super(e, t),
            "collapsible" === e && (this.element.toggleClass("ui-tabs-collapsible", t), t || !1 !== this.options.active || this._activate(0)),
            "event" === e && this._setupEvents(t), void ("heightStyle" === e && this._setupHeightStyle(t)));
        },
        _sanitizeSelector: function(e) {
            return e ? e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },
        refresh: function() {
            var t = this.options, i = this.tablist.children(":has(a[href])");
            t.disabled = e.map(i.filter(".ui-state-disabled"), function(e) {
                return i.index(e);
            }), this._processTabs(), !1 !== t.active && this.anchors.length ? this.active.length && !e.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t.disabled.length ? (t.active = !1,
            this.active = e()) : this._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active = this.tabs.index(this.active) : (t.active = !1,
            this.active = e()), this._refresh();
        },
        _refresh: function() {
            this._setupDisabled(this.options.disabled), this._setupEvents(this.options.event),
            this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                "aria-hidden": "true"
            }), this.active.length ? (this.active.addClass("ui-tabs-active ui-state-active").attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            }), this._getPanelForTab(this.active).show().attr({
                "aria-hidden": "false"
            })) : this.tabs.eq(0).attr("tabIndex", 0);
        },
        _processTabs: function() {
            var t = this, i = this.tabs, s = this.anchors, n = this.panels;
            this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist").delegate("> li", "mousedown" + this.eventNamespace, function(t) {
                e(this).is(".ui-state-disabled") && t.preventDefault();
            }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                e(this).closest("li").is(".ui-state-disabled") && this.blur();
            }), this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                role: "tab",
                tabIndex: -1
            }), this.anchors = this.tabs.map(function() {
                return e("a", this)[0];
            }).addClass("ui-tabs-anchor").attr({
                role: "presentation",
                tabIndex: -1
            }), this.panels = e(), this.anchors.each(function(i, s) {
                var n, a, o, r = e(s).uniqueId().attr("id"), h = e(s).closest("li"), l = h.attr("aria-controls");
                t._isLocal(s) ? (n = s.hash, o = n.substring(1), a = t.element.find(t._sanitizeSelector(n))) : (o = h.attr("aria-controls") || e({}).uniqueId()[0].id,
                n = "#" + o, a = t.element.find(n), a.length || (a = t._createPanel(o), a.insertAfter(t.panels[i - 1] || t.tablist)),
                a.attr("aria-live", "polite")), a.length && (t.panels = t.panels.add(a)), l && h.data("ui-tabs-aria-controls", l),
                h.attr({
                    "aria-controls": o,
                    "aria-labelledby": r
                }), a.attr("aria-labelledby", r);
            }), this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel"),
            i && (this._off(i.not(this.tabs)), this._off(s.not(this.anchors)), this._off(n.not(this.panels)));
        },
        _getList: function() {
            return this.tablist || this.element.find("ol,ul").eq(0);
        },
        _createPanel: function(t) {
            return e("<div>").attr("id", t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0);
        },
        _setupDisabled: function(t) {
            e.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) : t = !1);
            for (var i, s = 0; i = this.tabs[s]; s++) !0 === t || -1 !== e.inArray(s, t) ? e(i).addClass("ui-state-disabled").attr("aria-disabled", "true") : e(i).removeClass("ui-state-disabled").removeAttr("aria-disabled");
            this.options.disabled = t;
        },
        _setupEvents: function(t) {
            var i = {};
            t && e.each(t.split(" "), function(e, t) {
                i[t] = "_eventHandler";
            }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(!0, this.anchors, {
                click: function(e) {
                    e.preventDefault();
                }
            }), this._on(this.anchors, i), this._on(this.tabs, {
                keydown: "_tabKeydown"
            }), this._on(this.panels, {
                keydown: "_panelKeydown"
            }), this._focusable(this.tabs), this._hoverable(this.tabs);
        },
        _setupHeightStyle: function(t) {
            var i, s = this.element.parent();
            "fill" === t ? (i = s.height(), i -= this.element.outerHeight() - this.element.height(),
            this.element.siblings(":visible").each(function() {
                var t = e(this), s = t.css("position");
                "absolute" !== s && "fixed" !== s && (i -= t.outerHeight(!0));
            }), this.element.children().not(this.panels).each(function() {
                i -= e(this).outerHeight(!0);
            }), this.panels.each(function() {
                e(this).height(Math.max(0, i - e(this).innerHeight() + e(this).height()));
            }).css("overflow", "auto")) : "auto" === t && (i = 0, this.panels.each(function() {
                i = Math.max(i, e(this).height("").height());
            }).height(i));
        },
        _eventHandler: function(t) {
            var i = this.options, s = this.active, n = e(t.currentTarget), a = n.closest("li"), o = a[0] === s[0], r = o && i.collapsible, h = r ? e() : this._getPanelForTab(a), l = s.length ? this._getPanelForTab(s) : e(), u = {
                oldTab: s,
                oldPanel: l,
                newTab: r ? e() : a,
                newPanel: h
            };
            t.preventDefault(), a.hasClass("ui-state-disabled") || a.hasClass("ui-tabs-loading") || this.running || o && !i.collapsible || !1 === this._trigger("beforeActivate", t, u) || (i.active = !r && this.tabs.index(a),
            this.active = o ? e() : a, this.xhr && this.xhr.abort(), l.length || h.length || e.error("jQuery UI Tabs: Mismatching fragment identifier."),
            h.length && this.load(this.tabs.index(a), t), this._toggle(t, u));
        },
        _toggle: function(t, i) {
            function s() {
                a.running = !1, a._trigger("activate", t, i);
            }
            function n() {
                i.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), o.length && a.options.show ? a._show(o, a.options.show, s) : (o.show(),
                s());
            }
            var a = this, o = i.newPanel, r = i.oldPanel;
            this.running = !0, r.length && this.options.hide ? this._hide(r, this.options.hide, function() {
                i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), n();
            }) : (i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), r.hide(),
            n()), r.attr("aria-hidden", "true"), i.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            }), o.length && r.length ? i.oldTab.attr("tabIndex", -1) : o.length && this.tabs.filter(function() {
                return 0 === e(this).attr("tabIndex");
            }).attr("tabIndex", -1), o.attr("aria-hidden", "false"), i.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },
        _activate: function(t) {
            var i, s = this._findActive(t);
            s[0] !== this.active[0] && (s.length || (s = this.active), i = s.find(".ui-tabs-anchor")[0],
            this._eventHandler({
                target: i,
                currentTarget: i,
                preventDefault: e.noop
            }));
        },
        _findActive: function(t) {
            return !1 === t ? e() : this.tabs.eq(t);
        },
        _getIndex: function(e) {
            return "string" == typeof e && (e = this.anchors.index(this.anchors.filter("[href$='" + e + "']"))),
            e;
        },
        _destroy: function() {
            this.xhr && this.xhr.abort(), this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"),
            this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"),
            this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(),
            this.tablist.unbind(this.eventNamespace), this.tabs.add(this.panels).each(function() {
                e.data(this, "ui-tabs-destroy") ? e(this).remove() : e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
            }), this.tabs.each(function() {
                var t = e(this), i = t.data("ui-tabs-aria-controls");
                i ? t.attr("aria-controls", i).removeData("ui-tabs-aria-controls") : t.removeAttr("aria-controls");
            }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "");
        },
        enable: function(t) {
            var i = this.options.disabled;
            !1 !== i && (void 0 === t ? i = !1 : (t = this._getIndex(t), i = e.isArray(i) ? e.map(i, function(e) {
                return e !== t ? e : null;
            }) : e.map(this.tabs, function(e, i) {
                return i !== t ? i : null;
            })), this._setupDisabled(i));
        },
        disable: function(t) {
            var i = this.options.disabled;
            if (!0 !== i) {
                if (void 0 === t) i = !0; else {
                    if (t = this._getIndex(t), -1 !== e.inArray(t, i)) return;
                    i = e.isArray(i) ? e.merge([ t ], i).sort() : [ t ];
                }
                this._setupDisabled(i);
            }
        },
        load: function(t, i) {
            t = this._getIndex(t);
            var s = this, n = this.tabs.eq(t), a = n.find(".ui-tabs-anchor"), o = this._getPanelForTab(n), r = {
                tab: n,
                panel: o
            }, h = function(e, t) {
                "abort" === t && s.panels.stop(!1, !0), n.removeClass("ui-tabs-loading"), o.removeAttr("aria-busy"),
                e === s.xhr && delete s.xhr;
            };
            this._isLocal(a[0]) || (this.xhr = e.ajax(this._ajaxSettings(a, i, r)), this.xhr && "canceled" !== this.xhr.statusText && (n.addClass("ui-tabs-loading"),
            o.attr("aria-busy", "true"), this.xhr.done(function(e, t, n) {
                setTimeout(function() {
                    o.html(e), s._trigger("load", i, r), h(n, t);
                }, 1);
            }).fail(function(e, t) {
                setTimeout(function() {
                    h(e, t);
                }, 1);
            })));
        },
        _ajaxSettings: function(t, i, s) {
            var n = this;
            return {
                url: t.attr("href"),
                beforeSend: function(t, a) {
                    return n._trigger("beforeLoad", i, e.extend({
                        jqXHR: t,
                        ajaxSettings: a
                    }, s));
                }
            };
        },
        _getPanelForTab: function(t) {
            var i = e(t).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + i));
        }
    });
}), "function" != typeof Object.create && (Object.create = function(e) {
    function t() {}
    return t.prototype = e, new t();
}), function(e) {
    var t = {
        init: function(t) {
            return this.options = e.extend({}, e.noty.defaults, t), this.options.layout = this.options.custom ? e.noty.layouts.inline : e.noty.layouts[this.options.layout],
            e.noty.themes[this.options.theme] ? this.options.theme = e.noty.themes[this.options.theme] : t.themeClassName = this.options.theme,
            delete t.layout, delete t.theme, this.options = e.extend({}, this.options, this.options.layout.options),
            this.options.id = "noty_" + new Date().getTime() * Math.floor(1e6 * Math.random()),
            this.options = e.extend({}, this.options, t), this._build(), this;
        },
        _build: function() {
            var t = e('<div class="noty_bar noty_type_' + this.options.type + '"></div>').attr("id", this.options.id);
            if (t.append(this.options.template).find(".noty_text").html(this.options.text),
            this.$bar = null !== this.options.layout.parent.object ? e(this.options.layout.parent.object).css(this.options.layout.parent.css).append(t) : t,
            this.options.themeClassName && this.$bar.addClass(this.options.themeClassName).addClass("noty_container_type_" + this.options.type),
            this.options.buttons) {
                this.options.closeWith = [], this.options.timeout = !1;
                var n = e("<div/>").addClass("noty_buttons");
                null !== this.options.layout.parent.object ? this.$bar.find(".noty_bar").append(n) : this.$bar.append(n);
                var r = this;
                e.each(this.options.buttons, function(t, n) {
                    var i = e("<button/>").addClass(n.addClass ? n.addClass : "gray").html(n.text).attr("id", n.id ? n.id : "button-" + t).appendTo(r.$bar.find(".noty_buttons")).bind("click", function() {
                        e.isFunction(n.onClick) && n.onClick.call(i, r);
                    });
                });
            }
            this.$message = this.$bar.find(".noty_message"), this.$closeButton = this.$bar.find(".noty_close"),
            this.$buttons = this.$bar.find(".noty_buttons"), e.noty.store[this.options.id] = this;
        },
        show: function() {
            var t = this;
            return t.options.custom ? t.options.custom.find(t.options.layout.container.selector).append(t.$bar) : e(t.options.layout.container.selector).append(t.$bar),
            t.options.theme && t.options.theme.style && t.options.theme.style.apply(t), "function" === e.type(t.options.layout.css) ? this.options.layout.css.apply(t.$bar) : t.$bar.css(this.options.layout.css || {}),
            t.$bar.addClass(t.options.layout.addClass), t.options.layout.container.style.apply(e(t.options.layout.container.selector)),
            t.showing = !0, t.options.theme && t.options.theme.style && t.options.theme.callback.onShow.apply(this),
            e.inArray("click", t.options.closeWith) > -1 && t.$bar.css("cursor", "pointer").one("click", function(e) {
                t.stopPropagation(e), t.options.callback.onCloseClick && t.options.callback.onCloseClick.apply(t),
                t.close();
            }), e.inArray("hover", t.options.closeWith) > -1 && t.$bar.one("mouseenter", function() {
                t.close();
            }), e.inArray("button", t.options.closeWith) > -1 && t.$closeButton.one("click", function(e) {
                t.stopPropagation(e), t.close();
            }), -1 == e.inArray("button", t.options.closeWith) && t.$closeButton.remove(), t.options.callback.onShow && t.options.callback.onShow.apply(t),
            t.$bar.animate(t.options.animation.open, t.options.animation.speed, t.options.animation.easing, function() {
                t.options.callback.afterShow && t.options.callback.afterShow.apply(t), t.showing = !1,
                t.shown = !0;
            }), t.options.timeout && t.$bar.delay(t.options.timeout).promise().done(function() {
                t.close();
            }), this;
        },
        close: function() {
            if (!(this.closed || this.$bar && this.$bar.hasClass("i-am-closing-now"))) {
                var t = this;
                if (this.showing) return void t.$bar.queue(function() {
                    t.close.apply(t);
                });
                if (!this.shown && !this.showing) {
                    var n = [];
                    return e.each(e.noty.queue, function(e, r) {
                        r.options.id != t.options.id && n.push(r);
                    }), void (e.noty.queue = n);
                }
                t.$bar.addClass("i-am-closing-now"), t.options.callback.onClose && t.options.callback.onClose.apply(t),
                t.$bar.clearQueue().stop().animate(t.options.animation.close, t.options.animation.speed, t.options.animation.easing, function() {
                    t.options.callback.afterClose && t.options.callback.afterClose.apply(t);
                }).promise().done(function() {
                    t.options.modal && (e.notyRenderer.setModalCount(-1), 0 == e.notyRenderer.getModalCount() && e(".noty_modal").fadeOut("fast", function() {
                        e(this).remove();
                    })), e.notyRenderer.setLayoutCountFor(t, -1), 0 == e.notyRenderer.getLayoutCountFor(t) && e(t.options.layout.container.selector).remove(),
                    void 0 !== t.$bar && null !== t.$bar && (t.$bar.remove(), t.$bar = null, t.closed = !0),
                    delete e.noty.store[t.options.id], t.options.theme.callback && t.options.theme.callback.onClose && t.options.theme.callback.onClose.apply(t),
                    t.options.dismissQueue || (e.noty.ontap = !0, e.notyRenderer.render()), t.options.maxVisible > 0 && t.options.dismissQueue && e.notyRenderer.render();
                });
            }
        },
        setText: function(e) {
            return this.closed || (this.options.text = e, this.$bar.find(".noty_text").html(e)),
            this;
        },
        setType: function(e) {
            return this.closed || (this.options.type = e, this.options.theme.style.apply(this),
            this.options.theme.callback.onShow.apply(this)), this;
        },
        setTimeout: function(e) {
            if (!this.closed) {
                var t = this;
                this.options.timeout = e, t.$bar.delay(t.options.timeout).promise().done(function() {
                    t.close();
                });
            }
            return this;
        },
        stopPropagation: function(e) {
            e = e || window.event, void 0 !== e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
        },
        closed: !1,
        showing: !1,
        shown: !1
    };
    e.notyRenderer = {}, e.notyRenderer.init = function(n) {
        var r = Object.create(t).init(n);
        return r.options.killer && e.noty.closeAll(), r.options.force ? e.noty.queue.unshift(r) : e.noty.queue.push(r),
        e.notyRenderer.render(), "object" == e.noty.returns ? r : r.options.id;
    }, e.notyRenderer.render = function() {
        var t = e.noty.queue[0];
        "object" === e.type(t) ? t.options.dismissQueue ? t.options.maxVisible > 0 ? e(t.options.layout.container.selector + " li").length < t.options.maxVisible && e.notyRenderer.show(e.noty.queue.shift()) : e.notyRenderer.show(e.noty.queue.shift()) : e.noty.ontap && (e.notyRenderer.show(e.noty.queue.shift()),
        e.noty.ontap = !1) : e.noty.ontap = !0;
    }, e.notyRenderer.show = function(t) {
        t.options.modal && (e.notyRenderer.createModalFor(t), e.notyRenderer.setModalCount(1)),
        t.options.custom ? 0 == t.options.custom.find(t.options.layout.container.selector).length ? t.options.custom.append(e(t.options.layout.container.object).addClass("i-am-new")) : t.options.custom.find(t.options.layout.container.selector).removeClass("i-am-new") : 0 == e(t.options.layout.container.selector).length ? e("body").append(e(t.options.layout.container.object).addClass("i-am-new")) : e(t.options.layout.container.selector).removeClass("i-am-new"),
        e.notyRenderer.setLayoutCountFor(t, 1), t.show();
    }, e.notyRenderer.createModalFor = function(t) {
        0 == e(".noty_modal").length && e("<div/>").addClass("noty_modal").data("noty_modal_count", 0).css(t.options.theme.modal.css).prependTo(e("body")).fadeIn("fast");
    }, e.notyRenderer.getLayoutCountFor = function(t) {
        return e(t.options.layout.container.selector).data("noty_layout_count") || 0;
    }, e.notyRenderer.setLayoutCountFor = function(t, n) {
        return e(t.options.layout.container.selector).data("noty_layout_count", e.notyRenderer.getLayoutCountFor(t) + n);
    }, e.notyRenderer.getModalCount = function() {
        return e(".noty_modal").data("noty_modal_count") || 0;
    }, e.notyRenderer.setModalCount = function(t) {
        return e(".noty_modal").data("noty_modal_count", e.notyRenderer.getModalCount() + t);
    }, e.fn.noty = function(t) {
        return t.custom = e(this), e.notyRenderer.init(t);
    }, e.noty = {}, e.noty.queue = [], e.noty.ontap = !0, e.noty.layouts = {}, e.noty.themes = {},
    e.noty.returns = "object", e.noty.store = {}, e.noty.get = function(t) {
        return !!e.noty.store.hasOwnProperty(t) && e.noty.store[t];
    }, e.noty.close = function(t) {
        return !!e.noty.get(t) && e.noty.get(t).close();
    }, e.noty.setText = function(t, n) {
        return !!e.noty.get(t) && e.noty.get(t).setText(n);
    }, e.noty.setType = function(t, n) {
        return !!e.noty.get(t) && e.noty.get(t).setType(n);
    }, e.noty.clearQueue = function() {
        e.noty.queue = [];
    }, e.noty.closeAll = function() {
        e.noty.clearQueue(), e.each(e.noty.store, function(e, t) {
            t.close();
        });
    };
    var n = window.alert;
    e.noty.consumeAlert = function(t) {
        window.alert = function(n) {
            t ? t.text = n : t = {
                text: n
            }, e.notyRenderer.init(t);
        };
    }, e.noty.stopConsumeAlert = function() {
        window.alert = n;
    }, e.noty.defaults = {
        layout: "bottomRight",
        theme: "defaultTheme",
        type: "alert",
        text: "",
        dismissQueue: !0,
        template: '<div class="noty_message"><span class="noty_text"></span><div class="noty_close"></div></div>',
        animation: {
            open: {
                height: "toggle"
            },
            close: {
                height: "toggle"
            },
            easing: "swing",
            speed: 250
        },
        timeout: 5e3,
        force: !1,
        modal: !1,
        maxVisible: 10,
        killer: !1,
        closeWith: [ "click" ],
        callback: {
            onShow: function() {},
            afterShow: function() {},
            onClose: function() {},
            afterClose: function() {},
            onCloseClick: function() {}
        },
        buttons: !1
    }, e(window).resize(function() {
        e.each(e.noty.layouts, function(t, n) {
            n.container.style.apply(e(n.container.selector));
        });
    });
}(jQuery), window.noty = function(e) {
    return jQuery.notyRenderer.init(e);
}, function(e) {
    e.noty.layouts.bottom = {
        name: "bottom",
        options: {},
        container: {
            object: '<ul id="noty_bottom_layout_container" />',
            selector: "ul#noty_bottom_layout_container",
            style: function() {
                e(this).css({
                    bottom: 0,
                    left: "5%",
                    position: "fixed",
                    width: "90%",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 9999999
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.bottomCenter = {
        name: "bottomCenter",
        options: {},
        container: {
            object: '<ul id="noty_bottomCenter_layout_container" />',
            selector: "ul#noty_bottomCenter_layout_container",
            style: function() {
                e(this).css({
                    bottom: 20,
                    left: 0,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), e(this).css({
                    left: (e(window).width() - e(this).outerWidth(!1)) / 2 + "px"
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.bottomLeft = {
        name: "bottomLeft",
        options: {},
        container: {
            object: '<ul id="noty_bottomLeft_layout_container" />',
            selector: "ul#noty_bottomLeft_layout_container",
            style: function() {
                e(this).css({
                    bottom: 20,
                    left: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), window.innerWidth < 600 && e(this).css({
                    left: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.bottomRight = {
        name: "bottomRight",
        options: {},
        container: {
            object: '<ul id="noty_bottomRight_layout_container" />',
            selector: "ul#noty_bottomRight_layout_container",
            style: function() {
                e(this).css({
                    bottom: 20,
                    right: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), window.innerWidth < 600 && e(this).css({
                    right: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.center = {
        name: "center",
        options: {},
        container: {
            object: '<ul id="noty_center_layout_container" />',
            selector: "ul#noty_center_layout_container",
            style: function() {
                e(this).css({
                    position: "fixed",
                    width: "500px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                });
                var t = e(this).clone().css({
                    visibility: "hidden",
                    display: "block",
                    position: "absolute",
                    top: 0,
                    left: 0
                }).attr("id", "dupe");
                e("body").append(t), t.find(".i-am-closing-now").remove(), t.find("li").css("display", "block");
                var n = t.height();
                t.remove(), e(this).hasClass("i-am-new") ? e(this).css({
                    left: (e(window).width() - e(this).outerWidth(!1)) / 2 + "px",
                    top: (e(window).height() - n) / 2 + "px"
                }) : e(this).animate({
                    left: (e(window).width() - e(this).outerWidth(!1)) / 2 + "px",
                    top: (e(window).height() - n) / 2 + "px"
                }, 500);
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "500px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.centerLeft = {
        name: "centerLeft",
        options: {},
        container: {
            object: '<ul id="noty_centerLeft_layout_container" />',
            selector: "ul#noty_centerLeft_layout_container",
            style: function() {
                e(this).css({
                    left: 20,
                    position: "fixed",
                    width: "500px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                });
                var t = e(this).clone().css({
                    visibility: "hidden",
                    display: "block",
                    position: "absolute",
                    top: 0,
                    left: 0
                }).attr("id", "dupe");
                e("body").append(t), t.find(".i-am-closing-now").remove(), t.find("li").css("display", "block");
                var n = t.height();
                t.remove(), e(this).hasClass("i-am-new") ? e(this).css({
                    top: (e(window).height() - n) / 2 + "px"
                }) : e(this).animate({
                    top: (e(window).height() - n) / 2 + "px"
                }, 500), window.innerWidth < 600 && e(this).css({
                    left: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.centerRight = {
        name: "centerRight",
        options: {},
        container: {
            object: '<ul id="noty_centerRight_layout_container" />',
            selector: "ul#noty_centerRight_layout_container",
            style: function() {
                e(this).css({
                    right: 20,
                    position: "fixed",
                    width: "500px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                });
                var t = e(this).clone().css({
                    visibility: "hidden",
                    display: "block",
                    position: "absolute",
                    top: 0,
                    left: 0
                }).attr("id", "dupe");
                e("body").append(t), t.find(".i-am-closing-now").remove(), t.find("li").css("display", "block");
                var n = t.height();
                t.remove(), e(this).hasClass("i-am-new") ? e(this).css({
                    top: (e(window).height() - n) / 2 + "px"
                }) : e(this).animate({
                    top: (e(window).height() - n) / 2 + "px"
                }, 500), window.innerWidth < 600 && e(this).css({
                    right: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.inline = {
        name: "inline",
        options: {},
        container: {
            object: '<ul class="noty_inline_layout_container" />',
            selector: "ul.noty_inline_layout_container",
            style: function() {
                e(this).css({
                    width: "100%",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 9999999
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.top = {
        name: "top",
        options: {},
        container: {
            object: '<ul id="noty_top_layout_container" />',
            selector: "ul#noty_top_layout_container",
            style: function() {
                e(this).css({
                    top: 0,
                    left: "5%",
                    position: "fixed",
                    width: "90%",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 9999999
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.topCenter = {
        name: "topCenter",
        options: {},
        container: {
            object: '<ul id="noty_topCenter_layout_container" />',
            selector: "ul#noty_topCenter_layout_container",
            style: function() {
                e(this).css({
                    top: 20,
                    left: 0,
                    position: "fixed",
                    width: "500px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), e(this).css({
                    left: (e(window).width() - e(this).outerWidth(!1)) / 2 + "px"
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "500px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.topLeft = {
        name: "topLeft",
        options: {},
        container: {
            object: '<ul id="noty_topLeft_layout_container" />',
            selector: "ul#noty_topLeft_layout_container",
            style: function() {
                e(this).css({
                    top: 20,
                    left: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), window.innerWidth < 600 && e(this).css({
                    left: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.topRight = {
        name: "topRight",
        options: {},
        container: {
            object: '<ul id="noty_topRight_layout_container" />',
            selector: "ul#noty_topRight_layout_container",
            style: function() {
                e(this).css({
                    top: 20,
                    right: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), window.innerWidth < 600 && e(this).css({
                    right: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.themes.defaultTheme = {
        name: "defaultTheme",
        helpers: {
            borderFix: function() {
                if (this.options.dismissQueue) {
                    var t = this.options.layout.container.selector + " " + this.options.layout.parent.selector;
                    switch (this.options.layout.name) {
                      case "top":
                        e(t).css({
                            borderRadius: "0px 0px 0px 0px"
                        }), e(t).last().css({
                            borderRadius: "0px 0px 0px 0px"
                        });
                        break;

                      case "topCenter":
                      case "topLeft":
                      case "topRight":
                      case "bottomCenter":
                      case "bottomLeft":
                      case "bottomRight":
                      case "center":
                      case "centerLeft":
                      case "centerRight":
                      case "inline":
                        e(t).css({
                            borderRadius: "0px 0px 0px 0px"
                        }), e(t).first().css({
                            "border-top-left-radius": "0px",
                            "border-top-right-radius": "0px"
                        }), e(t).last().css({
                            "border-bottom-left-radius": "0px",
                            "border-bottom-right-radius": "0px"
                        });
                        break;

                      case "bottom":
                        e(t).css({
                            borderRadius: "0px 0px 0px 0px"
                        }), e(t).first().css({
                            borderRadius: "0px 0px 0px 0px"
                        });
                    }
                }
            }
        },
        modal: {
            css: {
                position: "fixed",
                width: "100%",
                height: "100%",
                backgroundColor: "#000",
                zIndex: 1e4,
                opacity: .6,
                display: "none",
                left: 0,
                top: 0
            }
        },
        style: function() {
            switch (this.$bar.css({
                overflow: "hidden"
            }), this.$message.css({
                fontSize: "13px",
                lineHeight: "16px",
                textAlign: "center",
                padding: "8px 10px 9px",
                width: "auto",
                position: "relative"
            }), this.$closeButton.css({
                position: "absolute",
                top: 4,
                right: 4,
                width: 10,
                height: 10,
                display: "none",
                cursor: "pointer"
            }), this.$buttons.css({
                padding: 5,
                textAlign: "right",
                borderTop: "1px solid #ccc",
                backgroundColor: "#fff"
            }), this.$buttons.find("button").css({
                marginLeft: 5
            }), this.$buttons.find("button:first").css({
                marginLeft: 0
            }), this.$bar.bind({
                mouseenter: function() {
                    e(this).find(".noty_close").stop().fadeTo("normal", 1);
                },
                mouseleave: function() {
                    e(this).find(".noty_close").stop().fadeTo("normal", 0);
                }
            }), this.options.layout.name) {
              case "top":
                this.$bar.css({
                    borderRadius: "0px 0px 0px 0px",
                    borderBottom: "2px solid #eee",
                    borderLeft: "2px solid #eee",
                    borderRight: "2px solid #eee",
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                });
                break;

              case "topCenter":
              case "center":
              case "bottomCenter":
              case "inline":
                this.$bar.css({
                    borderRadius: "0px",
                    border: "1px solid #eee",
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                }), this.$message.css({
                    fontSize: "13px",
                    textAlign: "center"
                });
                break;

              case "topLeft":
              case "topRight":
              case "bottomLeft":
              case "bottomRight":
              case "centerLeft":
              case "centerRight":
                this.$bar.css({
                    borderRadius: "0px",
                    border: "1px solid #eee",
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                }), this.$message.css({
                    fontSize: "13px",
                    textAlign: "left"
                });
                break;

              case "bottom":
                this.$bar.css({
                    borderRadius: "0px 0px 0px 0px",
                    borderTop: "2px solid #eee",
                    borderLeft: "2px solid #eee",
                    borderRight: "2px solid #eee",
                    boxShadow: "0 -2px 4px rgba(0, 0, 0, 0.1)"
                });
                break;

              default:
                this.$bar.css({
                    border: "2px solid #eee",
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                });
            }
            switch (this.options.type) {
              case "alert":
              case "notification":
                this.$bar.css({
                    backgroundColor: "#ECECEC",
                    borderColor: "#CCC",
                    color: "#444"
                });
                break;

              case "warning":
                this.$bar.css({
                    backgroundColor: "#FFEAA8",
                    borderColor: "#FFC237",
                    color: "#826200"
                }), this.$buttons.css({
                    borderTop: "1px solid #FFC237"
                });
                break;

              case "error":
                this.$bar.css({
                    backgroundColor: "#d9534f",
                    borderColor: "#d43f3a",
                    color: "#FFF"
                }), this.$message.css({
                    fontWeight: "normal"
                }), this.$buttons.css({
                    borderTop: "1px solid #d43f3a"
                });
                break;

              case "information":
                this.$bar.css({
                    backgroundColor: "#57B7E2",
                    borderColor: "#0B90C4",
                    color: "#FFF"
                }), this.$buttons.css({
                    borderTop: "1px solid #0B90C4"
                });
                break;

              case "success":
                this.$bar.css({
                    backgroundColor: "lightgreen",
                    borderColor: "#50C24E",
                    color: "darkgreen"
                }), this.$buttons.css({
                    borderTop: "1px solid #50C24E"
                });
                break;

              default:
                this.$bar.css({
                    backgroundColor: "#ECECEC",
                    borderColor: "#CCC",
                    color: "#444"
                });
            }
        },
        callback: {
            onShow: function() {
                e.noty.themes.defaultTheme.helpers.borderFix.apply(this);
            },
            onClose: function() {
                e.noty.themes.defaultTheme.helpers.borderFix.apply(this);
            }
        }
    };
}(jQuery), "function" != typeof Object.create && (Object.create = function(e) {
    function t() {}
    return t.prototype = e, new t();
}), function(e) {
    var t = {
        init: function(t) {
            return this.options = e.extend({}, e.noty.defaults, t), this.options.layout = this.options.custom ? e.noty.layouts.inline : e.noty.layouts[this.options.layout],
            e.noty.themes[this.options.theme] ? this.options.theme = e.noty.themes[this.options.theme] : t.themeClassName = this.options.theme,
            delete t.layout, delete t.theme, this.options = e.extend({}, this.options, this.options.layout.options),
            this.options.id = "noty_" + new Date().getTime() * Math.floor(1e6 * Math.random()),
            this.options = e.extend({}, this.options, t), this._build(), this;
        },
        _build: function() {
            var t = e('<div class="noty_bar noty_type_' + this.options.type + '"></div>').attr("id", this.options.id);
            if (t.append(this.options.template).find(".noty_text").html(this.options.text),
            this.$bar = null !== this.options.layout.parent.object ? e(this.options.layout.parent.object).css(this.options.layout.parent.css).append(t) : t,
            this.options.themeClassName && this.$bar.addClass(this.options.themeClassName).addClass("noty_container_type_" + this.options.type),
            this.options.buttons) {
                this.options.closeWith = [], this.options.timeout = !1;
                var n = e("<div/>").addClass("noty_buttons");
                null !== this.options.layout.parent.object ? this.$bar.find(".noty_bar").append(n) : this.$bar.append(n);
                var r = this;
                e.each(this.options.buttons, function(t, n) {
                    var i = e("<button/>").addClass(n.addClass ? n.addClass : "gray").html(n.text).attr("id", n.id ? n.id : "button-" + t).appendTo(r.$bar.find(".noty_buttons")).bind("click", function() {
                        e.isFunction(n.onClick) && n.onClick.call(i, r);
                    });
                });
            }
            this.$message = this.$bar.find(".noty_message"), this.$closeButton = this.$bar.find(".noty_close"),
            this.$buttons = this.$bar.find(".noty_buttons"), e.noty.store[this.options.id] = this;
        },
        show: function() {
            var t = this;
            return t.options.custom ? t.options.custom.find(t.options.layout.container.selector).append(t.$bar) : e(t.options.layout.container.selector).append(t.$bar),
            t.options.theme && t.options.theme.style && t.options.theme.style.apply(t), "function" === e.type(t.options.layout.css) ? this.options.layout.css.apply(t.$bar) : t.$bar.css(this.options.layout.css || {}),
            t.$bar.addClass(t.options.layout.addClass), t.options.layout.container.style.apply(e(t.options.layout.container.selector)),
            t.showing = !0, t.options.theme && t.options.theme.style && t.options.theme.callback.onShow.apply(this),
            e.inArray("click", t.options.closeWith) > -1 && t.$bar.css("cursor", "pointer").one("click", function(e) {
                t.stopPropagation(e), t.options.callback.onCloseClick && t.options.callback.onCloseClick.apply(t),
                t.close();
            }), e.inArray("hover", t.options.closeWith) > -1 && t.$bar.one("mouseenter", function() {
                t.close();
            }), e.inArray("button", t.options.closeWith) > -1 && t.$closeButton.one("click", function(e) {
                t.stopPropagation(e), t.close();
            }), -1 == e.inArray("button", t.options.closeWith) && t.$closeButton.remove(), t.options.callback.onShow && t.options.callback.onShow.apply(t),
            t.$bar.animate(t.options.animation.open, t.options.animation.speed, t.options.animation.easing, function() {
                t.options.callback.afterShow && t.options.callback.afterShow.apply(t), t.showing = !1,
                t.shown = !0;
            }), t.options.timeout && t.$bar.delay(t.options.timeout).promise().done(function() {
                t.close();
            }), this;
        },
        close: function() {
            if (!(this.closed || this.$bar && this.$bar.hasClass("i-am-closing-now"))) {
                var t = this;
                if (this.showing) return void t.$bar.queue(function() {
                    t.close.apply(t);
                });
                if (!this.shown && !this.showing) {
                    var n = [];
                    return e.each(e.noty.queue, function(e, r) {
                        r.options.id != t.options.id && n.push(r);
                    }), void (e.noty.queue = n);
                }
                t.$bar.addClass("i-am-closing-now"), t.options.callback.onClose && t.options.callback.onClose.apply(t),
                t.$bar.clearQueue().stop().animate(t.options.animation.close, t.options.animation.speed, t.options.animation.easing, function() {
                    t.options.callback.afterClose && t.options.callback.afterClose.apply(t);
                }).promise().done(function() {
                    t.options.modal && (e.notyRenderer.setModalCount(-1), 0 == e.notyRenderer.getModalCount() && e(".noty_modal").fadeOut("fast", function() {
                        e(this).remove();
                    })), e.notyRenderer.setLayoutCountFor(t, -1), 0 == e.notyRenderer.getLayoutCountFor(t) && e(t.options.layout.container.selector).remove(),
                    void 0 !== t.$bar && null !== t.$bar && (t.$bar.remove(), t.$bar = null, t.closed = !0),
                    delete e.noty.store[t.options.id], t.options.theme.callback && t.options.theme.callback.onClose && t.options.theme.callback.onClose.apply(t),
                    t.options.dismissQueue || (e.noty.ontap = !0, e.notyRenderer.render()), t.options.maxVisible > 0 && t.options.dismissQueue && e.notyRenderer.render();
                });
            }
        },
        setText: function(e) {
            return this.closed || (this.options.text = e, this.$bar.find(".noty_text").html(e)),
            this;
        },
        setType: function(e) {
            return this.closed || (this.options.type = e, this.options.theme.style.apply(this),
            this.options.theme.callback.onShow.apply(this)), this;
        },
        setTimeout: function(e) {
            if (!this.closed) {
                var t = this;
                this.options.timeout = e, t.$bar.delay(t.options.timeout).promise().done(function() {
                    t.close();
                });
            }
            return this;
        },
        stopPropagation: function(e) {
            e = e || window.event, void 0 !== e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
        },
        closed: !1,
        showing: !1,
        shown: !1
    };
    e.notyRenderer = {}, e.notyRenderer.init = function(n) {
        var r = Object.create(t).init(n);
        return r.options.killer && e.noty.closeAll(), r.options.force ? e.noty.queue.unshift(r) : e.noty.queue.push(r),
        e.notyRenderer.render(), "object" == e.noty.returns ? r : r.options.id;
    }, e.notyRenderer.render = function() {
        var t = e.noty.queue[0];
        "object" === e.type(t) ? t.options.dismissQueue ? t.options.maxVisible > 0 ? e(t.options.layout.container.selector + " li").length < t.options.maxVisible && e.notyRenderer.show(e.noty.queue.shift()) : e.notyRenderer.show(e.noty.queue.shift()) : e.noty.ontap && (e.notyRenderer.show(e.noty.queue.shift()),
        e.noty.ontap = !1) : e.noty.ontap = !0;
    }, e.notyRenderer.show = function(t) {
        t.options.modal && (e.notyRenderer.createModalFor(t), e.notyRenderer.setModalCount(1)),
        t.options.custom ? 0 == t.options.custom.find(t.options.layout.container.selector).length ? t.options.custom.append(e(t.options.layout.container.object).addClass("i-am-new")) : t.options.custom.find(t.options.layout.container.selector).removeClass("i-am-new") : 0 == e(t.options.layout.container.selector).length ? e("body").append(e(t.options.layout.container.object).addClass("i-am-new")) : e(t.options.layout.container.selector).removeClass("i-am-new"),
        e.notyRenderer.setLayoutCountFor(t, 1), t.show();
    }, e.notyRenderer.createModalFor = function(t) {
        0 == e(".noty_modal").length && e("<div/>").addClass("noty_modal").data("noty_modal_count", 0).css(t.options.theme.modal.css).prependTo(e("body")).fadeIn("fast");
    }, e.notyRenderer.getLayoutCountFor = function(t) {
        return e(t.options.layout.container.selector).data("noty_layout_count") || 0;
    }, e.notyRenderer.setLayoutCountFor = function(t, n) {
        return e(t.options.layout.container.selector).data("noty_layout_count", e.notyRenderer.getLayoutCountFor(t) + n);
    }, e.notyRenderer.getModalCount = function() {
        return e(".noty_modal").data("noty_modal_count") || 0;
    }, e.notyRenderer.setModalCount = function(t) {
        return e(".noty_modal").data("noty_modal_count", e.notyRenderer.getModalCount() + t);
    }, e.fn.noty = function(t) {
        return t.custom = e(this), e.notyRenderer.init(t);
    }, e.noty = {}, e.noty.queue = [], e.noty.ontap = !0, e.noty.layouts = {}, e.noty.themes = {},
    e.noty.returns = "object", e.noty.store = {}, e.noty.get = function(t) {
        return !!e.noty.store.hasOwnProperty(t) && e.noty.store[t];
    }, e.noty.close = function(t) {
        return !!e.noty.get(t) && e.noty.get(t).close();
    }, e.noty.setText = function(t, n) {
        return !!e.noty.get(t) && e.noty.get(t).setText(n);
    }, e.noty.setType = function(t, n) {
        return !!e.noty.get(t) && e.noty.get(t).setType(n);
    }, e.noty.clearQueue = function() {
        e.noty.queue = [];
    }, e.noty.closeAll = function() {
        e.noty.clearQueue(), e.each(e.noty.store, function(e, t) {
            t.close();
        });
    };
    var n = window.alert;
    e.noty.consumeAlert = function(t) {
        window.alert = function(n) {
            t ? t.text = n : t = {
                text: n
            }, e.notyRenderer.init(t);
        };
    }, e.noty.stopConsumeAlert = function() {
        window.alert = n;
    }, e.noty.defaults = {
        layout: "bottomRight",
        theme: "defaultTheme",
        type: "alert",
        text: "",
        dismissQueue: !0,
        template: '<div class="noty_message"><span class="noty_text"></span><div class="noty_close"></div></div>',
        animation: {
            open: {
                height: "toggle"
            },
            close: {
                height: "toggle"
            },
            easing: "swing",
            speed: 250
        },
        timeout: 5e3,
        force: !1,
        modal: !1,
        maxVisible: 10,
        killer: !1,
        closeWith: [ "click" ],
        callback: {
            onShow: function() {},
            afterShow: function() {},
            onClose: function() {},
            afterClose: function() {},
            onCloseClick: function() {}
        },
        buttons: !1
    }, e(window).resize(function() {
        e.each(e.noty.layouts, function(t, n) {
            n.container.style.apply(e(n.container.selector));
        });
    });
}(jQuery), window.noty = function(e) {
    return jQuery.notyRenderer.init(e);
}, function(e) {
    e.noty.layouts.bottom = {
        name: "bottom",
        options: {},
        container: {
            object: '<ul id="noty_bottom_layout_container" />',
            selector: "ul#noty_bottom_layout_container",
            style: function() {
                e(this).css({
                    bottom: 0,
                    left: "5%",
                    position: "fixed",
                    width: "90%",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 9999999
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.bottomCenter = {
        name: "bottomCenter",
        options: {},
        container: {
            object: '<ul id="noty_bottomCenter_layout_container" />',
            selector: "ul#noty_bottomCenter_layout_container",
            style: function() {
                e(this).css({
                    bottom: 20,
                    left: 0,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), e(this).css({
                    left: (e(window).width() - e(this).outerWidth(!1)) / 2 + "px"
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.bottomLeft = {
        name: "bottomLeft",
        options: {},
        container: {
            object: '<ul id="noty_bottomLeft_layout_container" />',
            selector: "ul#noty_bottomLeft_layout_container",
            style: function() {
                e(this).css({
                    bottom: 20,
                    left: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), window.innerWidth < 600 && e(this).css({
                    left: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.bottomRight = {
        name: "bottomRight",
        options: {},
        container: {
            object: '<ul id="noty_bottomRight_layout_container" />',
            selector: "ul#noty_bottomRight_layout_container",
            style: function() {
                e(this).css({
                    bottom: 20,
                    right: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), window.innerWidth < 600 && e(this).css({
                    right: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.center = {
        name: "center",
        options: {},
        container: {
            object: '<ul id="noty_center_layout_container" />',
            selector: "ul#noty_center_layout_container",
            style: function() {
                e(this).css({
                    position: "fixed",
                    width: "500px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                });
                var t = e(this).clone().css({
                    visibility: "hidden",
                    display: "block",
                    position: "absolute",
                    top: 0,
                    left: 0
                }).attr("id", "dupe");
                e("body").append(t), t.find(".i-am-closing-now").remove(), t.find("li").css("display", "block");
                var n = t.height();
                t.remove(), e(this).hasClass("i-am-new") ? e(this).css({
                    left: (e(window).width() - e(this).outerWidth(!1)) / 2 + "px",
                    top: (e(window).height() - n) / 2 + "px"
                }) : e(this).animate({
                    left: (e(window).width() - e(this).outerWidth(!1)) / 2 + "px",
                    top: (e(window).height() - n) / 2 + "px"
                }, 500);
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "500px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.centerLeft = {
        name: "centerLeft",
        options: {},
        container: {
            object: '<ul id="noty_centerLeft_layout_container" />',
            selector: "ul#noty_centerLeft_layout_container",
            style: function() {
                e(this).css({
                    left: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                });
                var t = e(this).clone().css({
                    visibility: "hidden",
                    display: "block",
                    position: "absolute",
                    top: 0,
                    left: 0
                }).attr("id", "dupe");
                e("body").append(t), t.find(".i-am-closing-now").remove(), t.find("li").css("display", "block");
                var n = t.height();
                t.remove(), e(this).hasClass("i-am-new") ? e(this).css({
                    top: (e(window).height() - n) / 2 + "px"
                }) : e(this).animate({
                    top: (e(window).height() - n) / 2 + "px"
                }, 500), window.innerWidth < 600 && e(this).css({
                    left: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.centerRight = {
        name: "centerRight",
        options: {},
        container: {
            object: '<ul id="noty_centerRight_layout_container" />',
            selector: "ul#noty_centerRight_layout_container",
            style: function() {
                e(this).css({
                    right: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                });
                var t = e(this).clone().css({
                    visibility: "hidden",
                    display: "block",
                    position: "absolute",
                    top: 0,
                    left: 0
                }).attr("id", "dupe");
                e("body").append(t), t.find(".i-am-closing-now").remove(), t.find("li").css("display", "block");
                var n = t.height();
                t.remove(), e(this).hasClass("i-am-new") ? e(this).css({
                    top: (e(window).height() - n) / 2 + "px"
                }) : e(this).animate({
                    top: (e(window).height() - n) / 2 + "px"
                }, 500), window.innerWidth < 600 && e(this).css({
                    right: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.inline = {
        name: "inline",
        options: {},
        container: {
            object: '<ul class="noty_inline_layout_container" />',
            selector: "ul.noty_inline_layout_container",
            style: function() {
                e(this).css({
                    width: "100%",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 9999999
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.top = {
        name: "top",
        options: {},
        container: {
            object: '<ul id="noty_top_layout_container" />',
            selector: "ul#noty_top_layout_container",
            style: function() {
                e(this).css({
                    top: 0,
                    left: "5%",
                    position: "fixed",
                    width: "90%",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 9999999
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.topCenter = {
        name: "topCenter",
        options: {},
        container: {
            object: '<ul id="noty_topCenter_layout_container" />',
            selector: "ul#noty_topCenter_layout_container",
            style: function() {
                e(this).css({
                    top: 20,
                    left: 0,
                    position: "fixed",
                    width: "500px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), e(this).css({
                    left: (e(window).width() - e(this).outerWidth(!1)) / 2 + "px"
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "500px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.topLeft = {
        name: "topLeft",
        options: {},
        container: {
            object: '<ul id="noty_topLeft_layout_container" />',
            selector: "ul#noty_topLeft_layout_container",
            style: function() {
                e(this).css({
                    top: 20,
                    left: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), window.innerWidth < 600 && e(this).css({
                    left: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "310px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.layouts.topRight = {
        name: "topRight",
        options: {},
        container: {
            object: '<ul id="noty_topRight_layout_container" />',
            selector: "ul#noty_topRight_layout_container",
            style: function() {
                e(this).css({
                    top: 20,
                    right: 20,
                    position: "fixed",
                    width: "310px",
                    height: "auto",
                    margin: 0,
                    padding: 0,
                    listStyleType: "none",
                    zIndex: 1e7
                }), window.innerWidth < 600 && e(this).css({
                    right: 5
                });
            }
        },
        parent: {
            object: "<li />",
            selector: "li",
            css: {}
        },
        css: {
            display: "none",
            width: "500px"
        },
        addClass: ""
    };
}(jQuery), function(e) {
    e.noty.themes.defaultTheme = {
        name: "defaultTheme",
        helpers: {
            borderFix: function() {
                if (this.options.dismissQueue) {
                    var t = this.options.layout.container.selector + " " + this.options.layout.parent.selector;
                    switch (this.options.layout.name) {
                      case "top":
                        e(t).css({
                            borderRadius: "0px 0px 0px 0px"
                        }), e(t).last().css({
                            borderRadius: "0px 0px 0px 0px"
                        });
                        break;

                      case "topCenter":
                      case "topLeft":
                      case "topRight":
                      case "bottomCenter":
                      case "bottomLeft":
                      case "bottomRight":
                      case "center":
                      case "centerLeft":
                      case "centerRight":
                      case "inline":
                        e(t).css({
                            borderRadius: "0px 0px 0px 0px"
                        }), e(t).first().css({
                            "border-top-left-radius": "0px",
                            "border-top-right-radius": "0px"
                        }), e(t).last().css({
                            "border-bottom-left-radius": "0px",
                            "border-bottom-right-radius": "0px"
                        });
                        break;

                      case "bottom":
                        e(t).css({
                            borderRadius: "0px 0px 0px 0px"
                        }), e(t).first().css({
                            borderRadius: "0px 0px 0px 0px"
                        });
                    }
                }
            }
        },
        modal: {
            css: {
                position: "fixed",
                width: "100%",
                height: "100%",
                backgroundColor: "#000",
                zIndex: 1e4,
                opacity: .6,
                display: "none",
                left: 0,
                top: 0
            }
        },
        style: function() {
            switch (this.$bar.css({
                overflow: "hidden"
            }), this.$message.css({
                fontSize: "13px",
                lineHeight: "16px",
                textAlign: "center",
                padding: "8px 10px 9px",
                width: "auto",
                position: "relative"
            }), this.$closeButton.css({
                position: "absolute",
                top: 4,
                right: 4,
                width: 10,
                height: 10,
                display: "none",
                cursor: "pointer"
            }), this.$buttons.css({
                padding: 5,
                textAlign: "right",
                borderTop: "1px solid #ccc",
                backgroundColor: "#ECECEC"
            }), this.$buttons.find("button").css({
                marginLeft: 5
            }), this.$buttons.find("button:first").css({
                marginLeft: 0
            }), this.$bar.bind({
                mouseenter: function() {
                    e(this).find(".noty_close").stop().fadeTo("normal", 1);
                },
                mouseleave: function() {
                    e(this).find(".noty_close").stop().fadeTo("normal", 0);
                }
            }), this.options.layout.name) {
              case "top":
                this.$bar.css({
                    borderRadius: "0px 0px 0px 0px",
                    borderBottom: "2px solid #eee",
                    borderLeft: "2px solid #eee",
                    borderRight: "2px solid #eee",
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                });
                break;

              case "topCenter":
              case "center":
              case "bottomCenter":
              case "inline":
                this.$bar.css({
                    borderRadius: "0px",
                    border: "1px solid #eee",
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                }), this.$message.css({
                    fontSize: "13px",
                    textAlign: "center"
                });
                break;

              case "topLeft":
              case "topRight":
              case "bottomLeft":
              case "bottomRight":
              case "centerLeft":
              case "centerRight":
                this.$bar.css({
                    borderRadius: "0px",
                    border: "1px solid #eee",
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                }), this.$message.css({
                    fontSize: "13px",
                    textAlign: "left"
                });
                break;

              case "bottom":
                this.$bar.css({
                    borderRadius: "0px 0px 0px 0px",
                    borderTop: "2px solid #eee",
                    borderLeft: "2px solid #eee",
                    borderRight: "2px solid #eee",
                    boxShadow: "0 -2px 4px rgba(0, 0, 0, 0.1)"
                });
                break;

              default:
                this.$bar.css({
                    border: "2px solid #eee",
                    boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)"
                });
            }
            switch (this.options.type) {
              case "alert":
              case "notification":
                this.$bar.css({
                    backgroundColor: "#ECECEC",
                    borderColor: "#CCC",
                    color: "#444"
                });
                break;

              case "warning":
                this.$bar.css({
                    backgroundColor: "#FFEAA8",
                    borderColor: "#FFC237",
                    color: "#826200"
                }), this.$buttons.css({
                    borderTop: "1px solid #FFC237"
                });
                break;

              case "error":
                this.$bar.css({
                    backgroundColor: "#d9534f",
                    borderColor: "#d43f3a",
                    color: "#FFF"
                }), this.$message.css({
                    fontWeight: "normal"
                }), this.$buttons.css({
                    borderTop: "1px solid #d43f3a"
                });
                break;

              case "information":
                this.$bar.css({
                    backgroundColor: "#57B7E2",
                    borderColor: "#0B90C4",
                    color: "#FFF"
                }), this.$buttons.css({
                    borderTop: "1px solid #0B90C4"
                });
                break;

              case "success":
                this.$bar.css({
                    backgroundColor: "lightgreen",
                    borderColor: "#50C24E",
                    color: "darkgreen"
                }), this.$buttons.css({
                    borderTop: "1px solid #50C24E"
                });
                break;

              default:
                this.$bar.css({
                    backgroundColor: "#ECECEC",
                    borderColor: "#CCC",
                    color: "#444"
                });
            }
        },
        callback: {
            onShow: function() {
                e.noty.themes.defaultTheme.helpers.borderFix.apply(this);
            },
            onClose: function() {
                e.noty.themes.defaultTheme.helpers.borderFix.apply(this);
            }
        }
    };
}(jQuery), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.CodeMirror = factory();
}(this, function() {
    "use strict";
    function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
        return e;
    }
    function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
    }
    function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className && (e.className = className), style && (e.style.cssText = style),
        "string" == typeof content) e.appendChild(document.createTextNode(content)); else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
        return e;
    }
    function contains(parent, child) {
        if (3 == child.nodeType && (child = child.parentNode), parent.contains) return parent.contains(child);
        do {
            if (11 == child.nodeType && (child = child.host), child == parent) return !0;
        } while (child = child.parentNode);
    }
    function activeElt() {
        var activeElement;
        try {
            activeElement = document.activeElement;
        } catch (e) {
            activeElement = document.body || null;
        }
        for (;activeElement && activeElement.root && activeElement.root.activeElement; ) activeElement = activeElement.root.activeElement;
        return activeElement;
    }
    function addClass(node, cls) {
        var current = node.className;
        classTest(cls).test(current) || (node.className += (current ? " " : "") + cls);
    }
    function joinClasses(a, b) {
        for (var as = a.split(" "), i = 0; i < as.length; i++) as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
        return b;
    }
    function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
            return f.apply(null, args);
        };
    }
    function copyObj(obj, target, overwrite) {
        target || (target = {});
        for (var prop in obj) !obj.hasOwnProperty(prop) || !1 === overwrite && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
        return target;
    }
    function countColumn(string, end, tabSize, startIndex, startValue) {
        null == end && -1 == (end = string.search(/[^\s\u00a0]/)) && (end = string.length);
        for (var i = startIndex || 0, n = startValue || 0; ;) {
            var nextTab = string.indexOf("\t", i);
            if (nextTab < 0 || nextTab >= end) return n + (end - i);
            n += nextTab - i, n += tabSize - n % tabSize, i = nextTab + 1;
        }
    }
    function Delayed() {
        this.id = null;
    }
    function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i) if (array[i] == elt) return i;
        return -1;
    }
    function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0; ;) {
            var nextTab = string.indexOf("\t", pos);
            -1 == nextTab && (nextTab = string.length);
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal) return pos + Math.min(skipped, goal - col);
            if (col += nextTab - pos, col += tabSize - col % tabSize, pos = nextTab + 1, col >= goal) return pos;
        }
    }
    function spaceStr(n) {
        for (;spaceStrs.length <= n; ) spaceStrs.push(lst(spaceStrs) + " ");
        return spaceStrs[n];
    }
    function lst(arr) {
        return arr[arr.length - 1];
    }
    function map(array, f) {
        for (var out = [], i = 0; i < array.length; i++) out[i] = f(array[i], i);
        return out;
    }
    function insertSorted(array, value, score) {
        for (var pos = 0, priority = score(value); pos < array.length && score(array[pos]) <= priority; ) pos++;
        array.splice(pos, 0, value);
    }
    function nothing() {}
    function createObj(base, props) {
        var inst;
        return Object.create ? inst = Object.create(base) : (nothing.prototype = base, inst = new nothing()),
        props && copyObj(props, inst), inst;
    }
    function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    }
    function isWordChar(ch, helper) {
        return helper ? !!(helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) || helper.test(ch) : isWordCharBasic(ch);
    }
    function isEmpty(obj) {
        for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return !1;
        return !0;
    }
    function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }
    function Display(place, doc, input) {
        var d = this;
        this.input = input, d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"),
        d.scrollbarFiller.setAttribute("cm-not-content", "true"), d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"),
        d.gutterFiller.setAttribute("cm-not-content", "true"), d.lineDiv = elt("div", null, "CodeMirror-code"),
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"), d.cursorDiv = elt("div", null, "CodeMirror-cursors"),
        d.measure = elt("div", null, "CodeMirror-measure"), d.lineMeasure = elt("div", null, "CodeMirror-measure"),
        d.lineSpace = elt("div", [ d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv ], null, "position: relative; outline: none"),
        d.mover = elt("div", [ elt("div", [ d.lineSpace ], "CodeMirror-lines") ], null, "position: relative"),
        d.sizer = elt("div", [ d.mover ], "CodeMirror-sizer"), d.sizerWidth = null, d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"),
        d.gutters = elt("div", null, "CodeMirror-gutters"), d.lineGutter = null, d.scroller = elt("div", [ d.sizer, d.heightForcer, d.gutters ], "CodeMirror-scroll"),
        d.scroller.setAttribute("tabIndex", "-1"), d.wrapper = elt("div", [ d.scrollbarFiller, d.gutterFiller, d.scroller ], "CodeMirror"),
        ie && ie_version < 8 && (d.gutters.style.zIndex = -1, d.scroller.style.paddingRight = 0),
        webkit || gecko && mobile || (d.scroller.draggable = !0), place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper)),
        d.viewFrom = d.viewTo = doc.first, d.reportedViewFrom = d.reportedViewTo = doc.first,
        d.view = [], d.renderedView = null, d.externalMeasured = null, d.viewOffset = 0,
        d.lastWrapHeight = d.lastWrapWidth = 0, d.updateLineNumbers = null, d.nativeBarWidth = d.barHeight = d.barWidth = 0,
        d.scrollbarsClipped = !1, d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null,
        d.alignWidgets = !1, d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null,
        d.maxLine = null, d.maxLineLength = 0, d.maxLineChanged = !1, d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null,
        d.shift = !1, d.selForContextMenu = null, d.activeTouch = null, input.init(d);
    }
    function getLine(doc, n) {
        if ((n -= doc.first) < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
        for (var chunk = doc; !chunk.lines; ) for (var i = 0; ;++i) {
            var child = chunk.children[i], sz = child.chunkSize();
            if (n < sz) {
                chunk = child;
                break;
            }
            n -= sz;
        }
        return chunk.lines[n];
    }
    function getBetween(doc, start, end) {
        var out = [], n = start.line;
        return doc.iter(start.line, end.line + 1, function(line) {
            var text = line.text;
            n == end.line && (text = text.slice(0, end.ch)), n == start.line && (text = text.slice(start.ch)),
            out.push(text), ++n;
        }), out;
    }
    function getLines(doc, from, to) {
        var out = [];
        return doc.iter(from, to, function(line) {
            out.push(line.text);
        }), out;
    }
    function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff) for (var n = line; n; n = n.parent) n.height += diff;
    }
    function lineNo(line) {
        if (null == line.parent) return null;
        for (var cur = line.parent, no = indexOf(cur.lines, line), chunk = cur.parent; chunk; cur = chunk,
        chunk = chunk.parent) for (var i = 0; chunk.children[i] != cur; ++i) no += chunk.children[i].chunkSize();
        return no + cur.first;
    }
    function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
            for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
                var child = chunk.children[i$1], ch = child.height;
                if (h < ch) {
                    chunk = child;
                    continue outer;
                }
                h -= ch, n += child.chunkSize();
            }
            return n;
        } while (!chunk.lines);
        for (var i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i], lh = line.height;
            if (h < lh) break;
            h -= lh;
        }
        return n + i;
    }
    function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
    }
    function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
    }
    function Pos(line, ch) {
        if (!(this instanceof Pos)) return new Pos(line, ch);
        this.line = line, this.ch = ch;
    }
    function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
    }
    function copyPos(x) {
        return Pos(x.line, x.ch);
    }
    function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
    }
    function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
    }
    function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
        if (pos.line < doc.first) return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        return pos.line > last ? Pos(last, getLine(doc, last).text.length) : clipToLen(pos, getLine(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
        var ch = pos.ch;
        return null == ch || ch > linelen ? Pos(pos.line, linelen) : ch < 0 ? Pos(pos.line, 0) : pos;
    }
    function clipPosArray(doc, array) {
        for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
        return out;
    }
    function seeReadOnlySpans() {
        sawReadOnlySpans = !0;
    }
    function seeCollapsedSpans() {
        sawCollapsedSpans = !0;
    }
    function MarkedSpan(marker, from, to) {
        this.marker = marker, this.from = from, this.to = to;
    }
    function getMarkedSpanFor(spans, marker) {
        if (spans) for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if (span.marker == marker) return span;
        }
    }
    function removeMarkedSpan(spans, span) {
        for (var r, i = 0; i < spans.length; ++i) spans[i] != span && (r || (r = [])).push(spans[i]);
        return r;
    }
    function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([ span ]) : [ span ],
        span.marker.attachLine(line);
    }
    function markedSpansBefore(old, startCh, isInsert) {
        var nw;
        if (old) for (var i = 0; i < old.length; ++i) {
            var span = old[i], marker = span.marker, startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
            if (startsBefore || span.from == startCh && "bookmark" == marker.type && (!isInsert || !span.marker.insertLeft)) {
                var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
        }
        return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
        var nw;
        if (old) for (var i = 0; i < old.length; ++i) {
            var span = old[i], marker = span.marker, endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
            if (endsAfter || span.from == endCh && "bookmark" == marker.type && (!isInsert || span.marker.insertLeft)) {
                var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, null == span.to ? null : span.to - endCh));
            }
        }
        return nw;
    }
    function stretchSpansOverChange(doc, change) {
        if (change.full) return null;
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans, oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) return null;
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = 0 == cmp(change.from, change.to), first = markedSpansBefore(oldFirst, startCh, isInsert), last = markedSpansAfter(oldLast, endCh, isInsert), sameLine = 1 == change.text.length, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) for (var i = 0; i < first.length; ++i) {
            var span = first[i];
            if (null == span.to) {
                var found = getMarkedSpanFor(last, span.marker);
                found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh;
            }
        }
        if (last) for (var i$1 = 0; i$1 < last.length; ++i$1) {
            var span$1 = last[i$1];
            if (null != span$1.to && (span$1.to += offset), null == span$1.from) {
                var found$1 = getMarkedSpanFor(first, span$1.marker);
                found$1 || (span$1.from = offset, sameLine && (first || (first = [])).push(span$1));
            } else span$1.from += offset, sameLine && (first || (first = [])).push(span$1);
        }
        first && (first = clearEmptySpans(first)), last && last != first && (last = clearEmptySpans(last));
        var newMarkers = [ first ];
        if (!sameLine) {
            var gapMarkers, gap = change.text.length - 2;
            if (gap > 0 && first) for (var i$2 = 0; i$2 < first.length; ++i$2) null == first[i$2].to && (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
            for (var i$3 = 0; i$3 < gap; ++i$3) newMarkers.push(gapMarkers);
            newMarkers.push(last);
        }
        return newMarkers;
    }
    function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            null != span.from && span.from == span.to && !1 !== span.marker.clearWhenEmpty && spans.splice(i--, 1);
        }
        return spans.length ? spans : null;
    }
    function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        if (doc.iter(from.line, to.line + 1, function(line) {
            if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                var mark = line.markedSpans[i].marker;
                !mark.readOnly || markers && -1 != indexOf(markers, mark) || (markers || (markers = [])).push(mark);
            }
        }), !markers) return null;
        for (var parts = [ {
            from: from,
            to: to
        } ], i = 0; i < markers.length; ++i) for (var mk = markers[i], m = mk.find(0), j = 0; j < parts.length; ++j) {
            var p = parts[j];
            if (!(cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)) {
                var newParts = [ j, 1 ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                (dfrom < 0 || !mk.inclusiveLeft && !dfrom) && newParts.push({
                    from: p.from,
                    to: m.from
                }), (dto > 0 || !mk.inclusiveRight && !dto) && newParts.push({
                    from: m.to,
                    to: p.to
                }), parts.splice.apply(parts, newParts), j += newParts.length - 1;
            }
        }
        return parts;
    }
    function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (spans) {
            for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
            line.markedSpans = null;
        }
    }
    function attachMarkedSpans(line, spans) {
        if (spans) {
            for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
            line.markedSpans = spans;
        }
    }
    function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (0 != lenDiff) return lenDiff;
        var aPos = a.find(), bPos = b.find(), fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp) return -fromCmp;
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        return toCmp || b.id - a.id;
    }
    function collapsedSpanAtSide(line, start) {
        var found, sps = sawCollapsedSpans && line.markedSpans;
        if (sps) for (var sp = void 0, i = 0; i < sps.length; ++i) sp = sps[i], sp.marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
        return found;
    }
    function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, !0);
    }
    function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, !1);
    }
    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo), sps = sawCollapsedSpans && line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];
            if (sp.marker.collapsed) {
                var found = sp.marker.find(0), fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker), toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                if (!(fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) && (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))) return !0;
            }
        }
    }
    function visualLine(line) {
        for (var merged; merged = collapsedSpanAtStart(line); ) line = merged.find(-1, !0).line;
        return line;
    }
    function visualLineContinued(line) {
        for (var merged, lines; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line,
        (lines || (lines = [])).push(line);
        return lines;
    }
    function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN), vis = visualLine(line);
        return line == vis ? lineN : lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine()) return lineN;
        var merged, line = getLine(doc, lineN);
        if (!lineIsHidden(doc, line)) return lineN;
        for (;merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
        return lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) for (var sp = void 0, i = 0; i < sps.length; ++i) if (sp = sps[i], sp.marker.collapsed) {
            if (null == sp.from) return !0;
            if (!sp.marker.widgetNode && 0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return !0;
        }
    }
    function lineIsHiddenInner(doc, line, span) {
        if (null == span.to) {
            var end = span.marker.find(1, !0);
            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length) return !0;
        for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) if (sp = line.markedSpans[i],
        sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return !0;
    }
    function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        for (var h = 0, chunk = lineObj.parent, i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i];
            if (line == lineObj) break;
            h += line.height;
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
            var cur = p.children[i$1];
            if (cur == chunk) break;
            h += cur.height;
        }
        return h;
    }
    function lineLength(line) {
        if (0 == line.height) return 0;
        for (var merged, len = line.text.length, cur = line; merged = collapsedSpanAtStart(cur); ) {
            var found = merged.find(0, !0);
            cur = found.from.line, len += found.from.ch - found.to.ch;
        }
        for (cur = line; merged = collapsedSpanAtEnd(cur); ) {
            var found$1 = merged.find(0, !0);
            len -= cur.text.length - found$1.from.ch, cur = found$1.to.line, len += cur.text.length - found$1.to.ch;
        }
        return len;
    }
    function findMaxLine(cm) {
        var d = cm.display, doc = cm.doc;
        d.maxLine = getLine(doc, doc.first), d.maxLineLength = lineLength(d.maxLine), d.maxLineChanged = !0,
        doc.iter(function(line) {
            var len = lineLength(line);
            len > d.maxLineLength && (d.maxLineLength = len, d.maxLine = line);
        });
    }
    function iterateBidiSections(order, from, to, f) {
        if (!order) return f(from, to, "ltr");
        for (var found = !1, i = 0; i < order.length; ++i) {
            var part = order[i];
            (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr"),
            found = !0);
        }
        found || f(from, to, "ltr");
    }
    function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from;
    }
    function bidiRight(part) {
        return part.level % 2 ? part.from : part.to;
    }
    function lineLeft(line) {
        var order = getOrder(line);
        return order ? bidiLeft(order[0]) : 0;
    }
    function lineRight(line) {
        var order = getOrder(line);
        return order ? bidiRight(lst(order)) : line.text.length;
    }
    function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        return a == linedir || b != linedir && a < b;
    }
    function getBidiPartAt(order, pos) {
        var found;
        bidiOther = null;
        for (var i = 0; i < order.length; ++i) {
            var cur = order[i];
            if (cur.from < pos && cur.to > pos) return i;
            if (cur.from == pos || cur.to == pos) {
                if (null != found) return compareBidiLevel(order, cur.level, order[found].level) ? (cur.from != cur.to && (bidiOther = found),
                i) : (cur.from != cur.to && (bidiOther = i), found);
                found = i;
            }
        }
        return found;
    }
    function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit) return pos + dir;
        do {
            pos += dir;
        } while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
        return pos;
    }
    function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi) return moveLogically(line, start, dir, byUnit);
        for (var pos = getBidiPartAt(bidi, start), part = bidi[pos], target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit); ;) {
            if (target > part.from && target < part.to) return target;
            if (target == part.from || target == part.to) return getBidiPartAt(bidi, target) == pos ? target : (part = bidi[pos += dir],
            dir > 0 == part.level % 2 ? part.to : part.from);
            if (!(part = bidi[pos += dir])) return null;
            target = dir > 0 == part.level % 2 ? moveInLine(line, part.to, -1, byUnit) : moveInLine(line, part.from, 1, byUnit);
        }
    }
    function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit) for (;target > 0 && isExtendingChar(line.text.charAt(target)); ) target += dir;
        return target < 0 || target > line.text.length ? null : target;
    }
    function getOrder(line) {
        var order = line.order;
        return null == order && (order = line.order = bidiOrdering(line.text)), order;
    }
    function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers;
    }
    function off(emitter, type, f) {
        if (emitter.removeEventListener) emitter.removeEventListener(type, f, !1); else if (emitter.detachEvent) emitter.detachEvent("on" + type, f); else {
            var map = emitter._handlers, arr = map && map[type];
            if (arr) {
                var index = indexOf(arr, f);
                index > -1 && (map[type] = arr.slice(0, index).concat(arr.slice(index + 1)));
            }
        }
    }
    function signal(emitter, type) {
        var handlers = getHandlers(emitter, type);
        if (handlers.length) for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
    }
    function signalDOMEvent(cm, e, override) {
        return "string" == typeof e && (e = {
            type: e,
            preventDefault: function() {
                this.defaultPrevented = !0;
            }
        }), signal(cm, override || e.type, cm, e), e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (arr) for (var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []), i = 0; i < arr.length; ++i) -1 == indexOf(set, arr[i]) && set.push(arr[i]);
    }
    function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0;
    }
    function eventMixin(ctor) {
        ctor.prototype.on = function(type, f) {
            on(this, type, f);
        }, ctor.prototype.off = function(type, f) {
            off(this, type, f);
        };
    }
    function e_preventDefault(e) {
        e.preventDefault ? e.preventDefault() : e.returnValue = !1;
    }
    function e_stopPropagation(e) {
        e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
    }
    function e_defaultPrevented(e) {
        return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue;
    }
    function e_stop(e) {
        e_preventDefault(e), e_stopPropagation(e);
    }
    function e_target(e) {
        return e.target || e.srcElement;
    }
    function e_button(e) {
        var b = e.which;
        return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)),
        mac && e.ctrlKey && 1 == b && (b = 3), b;
    }
    function zeroWidthElement(measure) {
        if (null == zwspSupported) {
            var test = elt("span", "​");
            removeChildrenAndAdd(measure, elt("span", [ test, document.createTextNode("x") ])),
            0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8));
        }
        var node = zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
        return node.setAttribute("cm-text", ""), node;
    }
    function hasBadBidiRects(measure) {
        if (null != badBidiRects) return badBidiRects;
        var txt = removeChildrenAndAdd(measure, document.createTextNode("AخA")), r0 = range(txt, 0, 1).getBoundingClientRect(), r1 = range(txt, 1, 2).getBoundingClientRect();
        return removeChildren(measure), !(!r0 || r0.left == r0.right) && (badBidiRects = r1.right - r0.right < 3);
    }
    function hasBadZoomedRects(measure) {
        if (null != badZoomedRects) return badZoomedRects;
        var node = removeChildrenAndAdd(measure, elt("span", "x")), normal = node.getBoundingClientRect(), fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    function defineMode(name, mode) {
        arguments.length > 2 && (mode.dependencies = Array.prototype.slice.call(arguments, 2)),
        modes[name] = mode;
    }
    function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
    }
    function resolveMode(spec) {
        if ("string" == typeof spec && mimeModes.hasOwnProperty(spec)) spec = mimeModes[spec]; else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            "string" == typeof found && (found = {
                name: found
            }), spec = createObj(found, spec), spec.name = found.name;
        } else {
            if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) return resolveMode("application/xml");
            if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) return resolveMode("application/json");
        }
        return "string" == typeof spec ? {
            name: spec
        } : spec || {
            name: "null"
        };
    }
    function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) return getMode(options, "text/plain");
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop in exts) exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]),
            modeObj[prop] = exts[prop]);
        }
        if (modeObj.name = spec.name, spec.helperType && (modeObj.helperType = spec.helperType),
        spec.modeProps) for (var prop$1 in spec.modeProps) modeObj[prop$1] = spec.modeProps[prop$1];
        return modeObj;
    }
    function extendMode(mode, properties) {
        copyObj(properties, modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {});
    }
    function copyState(mode, state) {
        if (!0 === state) return state;
        if (mode.copyState) return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
            var val = state[n];
            val instanceof Array && (val = val.concat([])), nstate[n] = val;
        }
        return nstate;
    }
    function innerMode(mode, state) {
        for (var info; mode.innerMode && (info = mode.innerMode(state)) && info.mode != mode; ) state = info.state,
        mode = info.mode;
        return info || {
            mode: mode,
            state: state
        };
    }
    function startState(mode, a1, a2) {
        return !mode.startState || mode.startState(a1, a2);
    }
    function highlightLine(cm, line, state, forceToEnd) {
        var st = [ cm.state.modeGen ], lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
            return st.push(end, style);
        }, lineClasses, forceToEnd);
        for (var o = 0; o < cm.state.overlays.length; ++o) !function(o) {
            var overlay = cm.state.overlays[o], i = 1, at = 0;
            runMode(cm, line.text, overlay.mode, !0, function(end, style) {
                for (var start = i; at < end; ) {
                    var i_end = st[i];
                    i_end > end && st.splice(i, 1, end, st[i + 1], i_end), i += 2, at = Math.min(end, i_end);
                }
                if (style) if (overlay.opaque) st.splice(start, i - start, end, "overlay " + style),
                i = start + 2; else for (;start < i; start += 2) {
                    var cur = st[start + 1];
                    st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
                }
            }, lineClasses);
        }(o);
        return {
            styles: st,
            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
    }
    function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var state = getStateBefore(cm, lineNo(line)), result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
            line.stateAfter = state, line.styles = result.styles, result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null),
            updateFrontier === cm.doc.frontier && cm.doc.frontier++;
        }
        return line.styles;
    }
    function getStateBefore(cm, n, precise) {
        var doc = cm.doc, display = cm.display;
        if (!doc.mode.startState) return !0;
        var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        return state = state ? copyState(doc.mode, state) : startState(doc.mode), doc.iter(pos, n, function(line) {
            processLine(cm, line.text, state);
            var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
            line.stateAfter = save ? copyState(doc.mode, state) : null, ++pos;
        }), precise && (doc.frontier = pos), state;
    }
    function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode, stream = new StringStream(text, cm.options.tabSize);
        for (stream.start = stream.pos = startAt || 0, "" == text && callBlankLine(mode, state); !stream.eol(); ) readToken(mode, stream, state),
        stream.start = stream.pos;
    }
    function callBlankLine(mode, state) {
        if (mode.blankLine) return mode.blankLine(state);
        if (mode.innerMode) {
            var inner = innerMode(mode, state);
            return inner.mode.blankLine ? inner.mode.blankLine(inner.state) : void 0;
        }
    }
    function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
            inner && (inner[0] = innerMode(mode, state).mode);
            var style = mode.token(stream, state);
            if (stream.pos > stream.start) return style;
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
    }
    function takeToken(cm, pos, precise, asArray) {
        var style, getObj = function(copy) {
            return {
                start: stream.start,
                end: stream.pos,
                string: stream.current(),
                type: style || null,
                state: copy ? copyState(doc.mode, state) : state
            };
        }, doc = cm.doc, mode = doc.mode;
        pos = clipPos(doc, pos);
        var tokens, line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise), stream = new StringStream(line.text, cm.options.tabSize);
        for (asArray && (tokens = []); (asArray || stream.pos < pos.ch) && !stream.eol(); ) stream.start = stream.pos,
        style = readToken(mode, stream, state), asArray && tokens.push(getObj(!0));
        return asArray ? tokens : getObj();
    }
    function extractLineClasses(type, output) {
        if (type) for (;;) {
            var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!lineClass) break;
            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
            var prop = lineClass[1] ? "bgClass" : "textClass";
            null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(output[prop]) || (output[prop] += " " + lineClass[2]);
        }
        return type;
    }
    function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
        var style, curStart = 0, curStyle = null, stream = new StringStream(text, cm.options.tabSize), inner = cm.options.addModeClass && [ null ];
        for ("" == text && extractLineClasses(callBlankLine(mode, state), lineClasses); !stream.eol(); ) {
            if (stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1, forceToEnd && processLine(cm, text, state, stream.pos),
            stream.pos = text.length, style = null) : style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses),
            inner) {
                var mName = inner[0].name;
                mName && (style = "m-" + (style ? mName + " " + style : mName));
            }
            if (!flattenSpans || curStyle != style) {
                for (;curStart < stream.start; ) curStart = Math.min(stream.start, curStart + 5e3),
                f(curStart, curStyle);
                curStyle = style;
            }
            stream.start = stream.pos;
        }
        for (;curStart < stream.pos; ) {
            var pos = Math.min(stream.pos, curStart + 5e3);
            f(pos, curStyle), curStart = pos;
        }
    }
    function findStartLine(cm, n, precise) {
        for (var minindent, minline, doc = cm.doc, lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; search > lim; --search) {
            if (search <= doc.first) return doc.first;
            var line = getLine(doc, search - 1);
            if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
            var indented = countColumn(line.text, null, cm.options.tabSize);
            (null == minline || minindent > indented) && (minline = search - 1, minindent = indented);
        }
        return minline;
    }
    function Line(text, markedSpans, estimateHeight) {
        this.text = text, attachMarkedSpans(this, markedSpans), this.height = estimateHeight ? estimateHeight(this) : 1;
    }
    function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text, line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null),
        null != line.order && (line.order = null), detachMarkedSpans(line), attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        estHeight != line.height && updateLineHeight(line, estHeight);
    }
    function cleanUpLine(line) {
        line.parent = null, detachMarkedSpans(line);
    }
    function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) return null;
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
    }
    function buildLineContent(cm, lineView) {
        var content = elt("span", null, null, webkit ? "padding-right: .1px" : null), builder = {
            pre: elt("pre", [ content ], "CodeMirror-line"),
            content: content,
            col: 0,
            pos: 0,
            cm: cm,
            trailingSpace: !1,
            splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
        };
        content.setAttribute("role", "presentation"), builder.pre.setAttribute("role", "presentation"),
        lineView.measure = {};
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
            var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0;
            builder.pos = 0, builder.addToken = buildToken, hasBadBidiRects(cm.display.measure) && (order = getOrder(line)) && (builder.addToken = buildTokenBadBidi(builder.addToken, order)),
            builder.map = [];
            insertLineContent(line, builder, getLineStyles(cm, line, lineView != cm.display.externalMeasured && lineNo(line))),
            line.styleClasses && (line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "")),
            line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))),
            0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))),
            0 == i ? (lineView.measure.map = builder.map, lineView.measure.cache = {}) : ((lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map),
            (lineView.measure.caches || (lineView.measure.caches = [])).push({}));
        }
        if (webkit) {
            var last = builder.content.lastChild;
            (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) && (builder.content.className = "cm-tab-wrap-hack");
        }
        return signal(cm, "renderLine", cm, lineView.line, builder.pre), builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || "")),
        builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "•", "cm-invalidchar");
        return token.title = "\\u" + ch.charCodeAt(0).toString(16), token.setAttribute("aria-label", token.title),
        token;
    }
    function buildToken(builder, text, style, startStyle, endStyle, title, css) {
        if (text) {
            var content, displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text, special = builder.cm.state.specialChars, mustWrap = !1;
            if (special.test(text)) {
                content = document.createDocumentFragment();
                for (var pos = 0; ;) {
                    special.lastIndex = pos;
                    var m = special.exec(text), skipped = m ? m.index - pos : text.length - pos;
                    if (skipped) {
                        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                        ie && ie_version < 9 ? content.appendChild(elt("span", [ txt ])) : content.appendChild(txt),
                        builder.map.push(builder.pos, builder.pos + skipped, txt), builder.col += skipped,
                        builder.pos += skipped;
                    }
                    if (!m) break;
                    pos += skipped + 1;
                    var txt$1 = void 0;
                    if ("\t" == m[0]) {
                        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab")), txt$1.setAttribute("role", "presentation"),
                        txt$1.setAttribute("cm-text", "\t"), builder.col += tabWidth;
                    } else "\r" == m[0] || "\n" == m[0] ? (txt$1 = content.appendChild(elt("span", "\r" == m[0] ? "␍" : "␤", "cm-invalidchar")),
                    txt$1.setAttribute("cm-text", m[0]), builder.col += 1) : (txt$1 = builder.cm.options.specialCharPlaceholder(m[0]),
                    txt$1.setAttribute("cm-text", m[0]), ie && ie_version < 9 ? content.appendChild(elt("span", [ txt$1 ])) : content.appendChild(txt$1),
                    builder.col += 1);
                    builder.map.push(builder.pos, builder.pos + 1, txt$1), builder.pos++;
                }
            } else builder.col += text.length, content = document.createTextNode(displayText),
            builder.map.push(builder.pos, builder.pos + text.length, content), ie && ie_version < 9 && (mustWrap = !0),
            builder.pos += text.length;
            if (builder.trailingSpace = 32 == displayText.charCodeAt(text.length - 1), style || startStyle || endStyle || mustWrap || css) {
                var fullStyle = style || "";
                startStyle && (fullStyle += startStyle), endStyle && (fullStyle += endStyle);
                var token = elt("span", [ content ], fullStyle, css);
                return title && (token.title = title), builder.content.appendChild(token);
            }
            builder.content.appendChild(content);
        }
    }
    function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text)) return text;
        for (var spaceBefore = trailingBefore, result = "", i = 0; i < text.length; i++) {
            var ch = text.charAt(i);
            " " != ch || !spaceBefore || i != text.length - 1 && 32 != text.charCodeAt(i + 1) || (ch = " "),
            result += ch, spaceBefore = " " == ch;
        }
        return result;
    }
    function buildTokenBadBidi(inner, order) {
        return function(builder, text, style, startStyle, endStyle, title, css) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            for (var start = builder.pos, end = start + text.length; ;) {
                for (var part = void 0, i = 0; i < order.length && (part = order[i], !(part.to > start && part.from <= start)); i++) ;
                if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
                inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css),
                startStyle = null, text = text.slice(part.to - start), start = part.to;
            }
        };
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        widget && builder.map.push(builder.pos, builder.pos + size, widget), !ignoreWidget && builder.cm.display.input.needsContentAttribute && (widget || (widget = builder.content.appendChild(document.createElement("span"))),
        widget.setAttribute("cm-marker", marker.id)), widget && (builder.cm.display.input.setUneditable(widget),
        builder.content.appendChild(widget)), builder.pos += size, builder.trailingSpace = !1;
    }
    function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (spans) for (var style, css, spanStyle, spanEndStyle, spanStartStyle, title, collapsed, len = allText.length, pos = 0, i = 1, text = "", nextChange = 0; ;) {
            if (nextChange == pos) {
                spanStyle = spanEndStyle = spanStartStyle = title = css = "", collapsed = null,
                nextChange = 1 / 0;
                for (var foundBookmarks = [], endStyles = void 0, j = 0; j < spans.length; ++j) {
                    var sp = spans[j], m = sp.marker;
                    "bookmark" == m.type && sp.from == pos && m.widgetNode ? foundBookmarks.push(m) : sp.from <= pos && (null == sp.to || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos) ? (null != sp.to && sp.to != pos && nextChange > sp.to && (nextChange = sp.to,
                    spanEndStyle = ""), m.className && (spanStyle += " " + m.className), m.css && (css = (css ? css + ";" : "") + m.css),
                    m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle), m.endStyle && sp.to == nextChange && (endStyles || (endStyles = [])).push(m.endStyle, sp.to),
                    m.title && !title && (title = m.title), m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp)) : sp.from > pos && nextChange > sp.from && (nextChange = sp.from);
                }
                if (endStyles) for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) endStyles[j$1 + 1] == nextChange && (spanEndStyle += " " + endStyles[j$1]);
                if (!collapsed || collapsed.from == pos) for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                if (collapsed && (collapsed.from || 0) == pos) {
                    if (buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from),
                    null == collapsed.to) return;
                    collapsed.to == pos && (collapsed = !1);
                }
            }
            if (pos >= len) break;
            for (var upto = Math.min(len, nextChange); ;) {
                if (text) {
                    var end = pos + text.length;
                    if (!collapsed) {
                        var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                        builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
                    }
                    if (end >= upto) {
                        text = text.slice(upto - pos), pos = upto;
                        break;
                    }
                    pos = end, spanStartStyle = "";
                }
                text = allText.slice(at, at = styles[i++]), style = interpretTokenStyle(styles[i++], builder.cm.options);
            }
        } else for (var i$1 = 1; i$1 < styles.length; i$1 += 2) builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
    }
    function LineView(doc, line, lineN) {
        this.line = line, this.rest = visualLineContinued(line), this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1,
        this.node = this.text = null, this.hidden = lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
        for (var nextPos, array = [], pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size, array.push(view);
        }
        return array;
    }
    function pushOperation(op) {
        operationGroup ? operationGroup.ops.push(op) : op.ownsGroup = operationGroup = {
            ops: [ op ],
            delayedCallbacks: []
        };
    }
    function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks, i = 0;
        do {
            for (;i < callbacks.length; i++) callbacks[i].call(null);
            for (var j = 0; j < group.ops.length; j++) {
                var op = group.ops[j];
                if (op.cursorActivityHandlers) for (;op.cursorActivityCalled < op.cursorActivityHandlers.length; ) op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
            }
        } while (i < callbacks.length);
    }
    function finishOperation(op, endCb) {
        var group = op.ownsGroup;
        if (group) try {
            fireCallbacksForOps(group);
        } finally {
            operationGroup = null, endCb(group);
        }
    }
    function signalLater(emitter, type) {
        var arr = getHandlers(emitter, type);
        if (arr.length) {
            var list, args = Array.prototype.slice.call(arguments, 2);
            operationGroup ? list = operationGroup.delayedCallbacks : orphanDelayedCallbacks ? list = orphanDelayedCallbacks : (list = orphanDelayedCallbacks = [],
            setTimeout(fireOrphanDelayed, 0));
            for (var i = 0; i < arr.length; ++i) !function(i) {
                list.push(function() {
                    return arr[i].apply(null, args);
                });
            }(i);
        }
    }
    function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i) delayed[i]();
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            "text" == type ? updateLineText(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(lineView) : "widget" == type && updateLineWidgets(cm, lineView, dims);
        }
        lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
        return lineView.node == lineView.text && (lineView.node = elt("div", null, null, "position: relative"),
        lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text),
        lineView.node.appendChild(lineView.text), ie && ie_version < 8 && (lineView.node.style.zIndex = 2)),
        lineView.node;
    }
    function updateLineBackground(lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls && (cls += " CodeMirror-linebackground"), lineView.background) cls ? lineView.background.className = cls : (lineView.background.parentNode.removeChild(lineView.background),
        lineView.background = null); else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
        }
    }
    function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        return ext && ext.line == lineView.line ? (cm.display.externalMeasured = null, lineView.measure = ext.measure,
        ext.built) : buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
        var cls = lineView.text.className, built = getLineContent(cm, lineView);
        lineView.text == lineView.node && (lineView.node = built.pre), lineView.text.parentNode.replaceChild(built.pre, lineView.text),
        lineView.text = built.pre, built.bgClass != lineView.bgClass || built.textClass != lineView.textClass ? (lineView.bgClass = built.bgClass,
        lineView.textClass = built.textClass, updateLineClasses(lineView)) : cls && (lineView.text.className = cls);
    }
    function updateLineClasses(lineView) {
        updateLineBackground(lineView), lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter && (lineView.node.removeChild(lineView.gutter), lineView.gutter = null),
        lineView.gutterBackground && (lineView.node.removeChild(lineView.gutterBackground),
        lineView.gutterBackground = null), lineView.line.gutterClass) {
            var wrap = ensureLineWrapped(lineView);
            lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"),
            wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
            var wrap$1 = ensureLineWrapped(lineView), gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
            if (cm.display.input.setUneditable(gutterWrap), wrap$1.insertBefore(gutterWrap, lineView.text),
            lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass),
            !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"))),
            markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
                var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                found && gutterWrap.appendChild(elt("div", [ found ], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
            }
        }
    }
    function updateLineWidgets(cm, lineView, dims) {
        lineView.alignable && (lineView.alignable = null);
        for (var node = lineView.node.firstChild, next = void 0; node; node = next) next = node.nextSibling,
        "CodeMirror-linewidget" == node.className && lineView.node.removeChild(node);
        insertLineWidgets(cm, lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        return lineView.text = lineView.node = built.pre, built.bgClass && (lineView.bgClass = built.bgClass),
        built.textClass && (lineView.textClass = built.textClass), updateLineClasses(lineView),
        updateLineGutter(cm, lineView, lineN, dims), insertLineWidgets(cm, lineView, dims),
        lineView.node;
    }
    function insertLineWidgets(cm, lineView, dims) {
        if (insertLineWidgetsFor(cm, lineView.line, lineView, dims, !0), lineView.rest) for (var i = 0; i < lineView.rest.length; i++) insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, !1);
    }
    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (line.widgets) for (var wrap = ensureLineWrapped(lineView), i = 0, ws = line.widgets; i < ws.length; ++i) {
            var widget = ws[i], node = elt("div", [ widget.node ], "CodeMirror-linewidget");
            widget.handleMouseEvents || node.setAttribute("cm-ignore-events", "true"), positionLineWidget(widget, node, lineView, dims),
            cm.display.input.setUneditable(node), allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node),
            signalLater(widget, "redraw");
        }
    }
    function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px", widget.coverGutter || (width -= dims.gutterTotalWidth,
            node.style.paddingLeft = dims.gutterTotalWidth + "px"), node.style.width = width + "px";
        }
        widget.coverGutter && (node.style.zIndex = 5, node.style.position = "relative",
        widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"));
    }
    function widgetHeight(widget) {
        if (null != widget.height) return widget.height;
        var cm = widget.doc.cm;
        if (!cm) return 0;
        if (!contains(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            widget.coverGutter && (parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"),
            widget.noHScroll && (parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"),
            removeChildrenAndAdd(cm.display.measure, elt("div", [ widget.node ], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight;
    }
    function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == display.sizer && n != display.mover) return !0;
    }
    function paddingTop(display) {
        return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
        if (display.cachedPaddingH) return display.cachedPaddingH;
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x")), style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, data = {
            left: parseInt(style.paddingLeft),
            right: parseInt(style.paddingRight)
        };
        return isNaN(data.left) || isNaN(data.right) || (display.cachedPaddingH = data),
        data;
    }
    function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping, curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
                lineView.measure.width = curWidth;
                for (var rects = lineView.text.firstChild.getClientRects(), i = 0; i < rects.length - 1; i++) {
                    var cur = rects[i], next = rects[i + 1];
                    Math.abs(cur.bottom - next.bottom) > 2 && heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
            }
            heights.push(rect.bottom - rect.top);
        }
    }
    function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) return {
            map: lineView.measure.map,
            cache: lineView.measure.cache
        };
        for (var i = 0; i < lineView.rest.length; i++) if (lineView.rest[i] == line) return {
            map: lineView.measure.maps[i],
            cache: lineView.measure.caches[i]
        };
        for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) if (lineNo(lineView.rest[i$1]) > lineN) return {
            map: lineView.measure.maps[i$1],
            cache: lineView.measure.caches[i$1],
            before: !0
        };
    }
    function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line), view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        return view.text = built.pre, removeChildrenAndAdd(cm.display.lineMeasure, built.pre),
        view;
    }
    function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }
    function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) return cm.display.view[findViewIndex(cm, lineN)];
        var ext = cm.display.externalMeasured;
        return ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size ? ext : void 0;
    }
    function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line), view = findViewForLine(cm, lineN);
        view && !view.text ? view = null : view && view.changes && (updateLineForChanges(cm, view, lineN, getDimensions(cm)),
        cm.curOp.forceUpdate = !0), view || (view = updateExternalMeasurement(cm, line));
        var info = mapFromLineView(view, line, lineN);
        return {
            line: line,
            view: view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: !1
        };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        prepared.before && (ch = -1);
        var found, key = ch + (bias || "");
        return prepared.cache.hasOwnProperty(key) ? found = prepared.cache[key] : (prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect()),
        prepared.hasHeights || (ensureLineHeights(cm, prepared.view, prepared.rect), prepared.hasHeights = !0),
        found = measureCharInner(cm, prepared, ch, bias), found.bogus || (prepared.cache[key] = found)),
        {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
        };
    }
    function nodeAndOffsetInLineMap(map, ch, bias) {
        for (var node, start, end, collapse, mStart, mEnd, i = 0; i < map.length; i += 3) if (mStart = map[i],
        mEnd = map[i + 1], ch < mStart ? (start = 0, end = 1, collapse = "left") : ch < mEnd ? (start = ch - mStart,
        end = start + 1) : (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) && (end = mEnd - mStart,
        start = end - 1, ch >= mEnd && (collapse = "right")), null != start) {
            if (node = map[i + 2], mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias),
            "left" == bias && 0 == start) for (;i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft; ) node = map[2 + (i -= 3)],
            collapse = "left";
            if ("right" == bias && start == mEnd - mStart) for (;i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft; ) node = map[(i += 3) + 2],
            collapse = "right";
            break;
        }
        return {
            node: node,
            start: start,
            end: end,
            collapse: collapse,
            coverStart: mStart,
            coverEnd: mEnd
        };
    }
    function getUsefulRect(rects, bias) {
        var rect = nullRect;
        if ("left" == bias) for (var i = 0; i < rects.length && (rect = rects[i]).left == rect.right; i++) ; else for (var i$1 = rects.length - 1; i$1 >= 0 && (rect = rects[i$1]).left == rect.right; i$1--) ;
        return rect;
    }
    function measureCharInner(cm, prepared, ch, bias) {
        var rect, place = nodeAndOffsetInLineMap(prepared.map, ch, bias), node = place.node, start = place.start, end = place.end, collapse = place.collapse;
        if (3 == node.nodeType) {
            for (var i$1 = 0; i$1 < 4; i$1++) {
                for (;start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start)); ) --start;
                for (;place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end)); ) ++end;
                if (rect = ie && ie_version < 9 && 0 == start && end == place.coverEnd - place.coverStart ? node.parentNode.getBoundingClientRect() : getUsefulRect(range(node, start, end).getClientRects(), bias),
                rect.left || rect.right || 0 == start) break;
                end = start, start -= 1, collapse = "right";
            }
            ie && ie_version < 11 && (rect = maybeUpdateRectForZooming(cm.display.measure, rect));
        } else {
            start > 0 && (collapse = bias = "right");
            var rects;
            rect = cm.options.lineWrapping && (rects = node.getClientRects()).length > 1 ? rects["right" == bias ? rects.length - 1 : 0] : node.getBoundingClientRect();
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            rect = rSpan ? {
                left: rSpan.left,
                right: rSpan.left + charWidth(cm.display),
                top: rSpan.top,
                bottom: rSpan.bottom
            } : nullRect;
        }
        for (var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top, mid = (rtop + rbot) / 2, heights = prepared.view.measure.heights, i = 0; i < heights.length - 1 && !(mid < heights[i]); i++) ;
        var top = i ? heights[i - 1] : 0, bot = heights[i], result = {
            left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left,
            right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left,
            top: top,
            bottom: bot
        };
        return rect.left || rect.right || (result.bogus = !0), cm.options.singleCursorHeightPerLine || (result.rtop = rtop,
        result.rbottom = rbot), result;
    }
    function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) return rect;
        var scaleX = screen.logicalXDPI / screen.deviceXDPI, scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
        };
    }
    function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure && (lineView.measure.cache = {}, lineView.measure.heights = null,
        lineView.rest)) for (var i = 0; i < lineView.rest.length; i++) lineView.measure.caches[i] = {};
    }
    function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null, removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++) clearLineMeasurementCacheFor(cm.display.view[i]);
    }
    function clearCaches(cm) {
        clearLineMeasurementCache(cm), cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null,
        cm.options.lineWrapping || (cm.display.maxLineChanged = !0), cm.display.lineNumChars = null;
    }
    function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets && lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
            var size = widgetHeight(lineObj.widgets[i]);
            rect.top += size, rect.bottom += size;
        }
        if ("line" == context) return rect;
        context || (context = "local");
        var yOff = heightAtLine(lineObj);
        if ("local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset,
        "page" == context || "window" == context) {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
            var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
            rect.left += xOff, rect.right += xOff;
        }
        return rect.top += yOff, rect.bottom += yOff, rect;
    }
    function fromCoordSystem(cm, coords, context) {
        if ("div" == context) return coords;
        var left = coords.left, top = coords.top;
        if ("page" == context) left -= pageScrollX(), top -= pageScrollY(); else if ("local" == context || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left, top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
            left: left - lineSpaceBox.left,
            top: top - lineSpaceBox.top
        };
    }
    function charCoords(cm, pos, context, lineObj, bias) {
        return lineObj || (lineObj = getLine(cm.doc, pos.line)), intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        function get(ch, right) {
            var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
            return right ? m.left = m.right : m.right = m.left, intoCoordSystem(cm, lineObj, m, context);
        }
        function getBidi(ch, partPos) {
            var part = order[partPos], right = part.level % 2;
            return ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level ? (part = order[--partPos],
            ch = bidiRight(part) - (part.level % 2 ? 0 : 1), right = !0) : ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level && (part = order[++partPos],
            ch = bidiLeft(part) - part.level % 2, right = !1), right && ch == part.to && ch > part.from ? get(ch - 1) : get(ch, right);
        }
        lineObj = lineObj || getLine(cm.doc, pos.line), preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
        var order = getOrder(lineObj), ch = pos.ch;
        if (!order) return get(ch);
        var partPos = getBidiPartAt(order, ch), val = getBidi(ch, partPos);
        return null != bidiOther && (val.other = getBidi(ch, bidiOther)), val;
    }
    function estimateCoords(cm, pos) {
        var left = 0;
        pos = clipPos(cm.doc, pos), cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch);
        var lineObj = getLine(cm.doc, pos.line), top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {
            left: left,
            right: left,
            top: top,
            bottom: top + lineObj.height
        };
    }
    function PosWithInfo(line, ch, outside, xRel) {
        var pos = Pos(line, ch);
        return pos.xRel = xRel, outside && (pos.outside = !0), pos;
    }
    function coordsChar(cm, x, y) {
        var doc = cm.doc;
        if ((y += cm.display.viewOffset) < 0) return PosWithInfo(doc.first, 0, !0, -1);
        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (lineN > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, !0, 1);
        x < 0 && (x = 0);
        for (var lineObj = getLine(doc, lineN); ;) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y), merged = collapsedSpanAtEnd(lineObj), mergedPos = merged && merged.find(0, !0);
            if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) return found;
            lineN = lineNo(lineObj = mergedPos.to.line);
        }
    }
    function coordsCharInner(cm, lineObj, lineNo, x, y) {
        function getX(ch) {
            var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
            return wrongLine = !0, innerOff > sp.bottom ? sp.left - adjust : innerOff < sp.top ? sp.left + adjust : (wrongLine = !1,
            sp.left);
        }
        var innerOff = y - heightAtLine(lineObj), wrongLine = !1, adjust = 2 * cm.display.wrapper.clientWidth, preparedMeasure = prepareMeasureForLine(cm, lineObj), bidi = getOrder(lineObj), dist = lineObj.text.length, from = lineLeft(lineObj), to = lineRight(lineObj), fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
        if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
        for (;;) {
            if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
                var ch = x < fromX || x - fromX <= toX - x ? from : to, outside = ch == from ? fromOutside : toOutside, xDiff = x - (ch == from ? fromX : toX);
                if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 && ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
                    var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right");
                    innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff && (outside = !1,
                    ch++, xDiff = x - charSize.right);
                }
                for (;isExtendingChar(lineObj.text.charAt(ch)); ) ++ch;
                return PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
            }
            var step = Math.ceil(dist / 2), middle = from + step;
            if (bidi) {
                middle = from;
                for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
            }
            var middleX = getX(middle);
            middleX > x ? (to = middle, toX = middleX, (toOutside = wrongLine) && (toX += 1e3),
            dist = step) : (from = middle, fromX = middleX, fromOutside = wrongLine, dist -= step);
        }
    }
    function textHeight(display) {
        if (null != display.cachedTextHeight) return display.cachedTextHeight;
        if (null == measureText) {
            measureText = elt("pre");
            for (var i = 0; i < 49; ++i) measureText.appendChild(document.createTextNode("x")),
            measureText.appendChild(elt("br"));
            measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        return height > 3 && (display.cachedTextHeight = height), removeChildren(display.measure),
        height || 1;
    }
    function charWidth(display) {
        if (null != display.cachedCharWidth) return display.cachedCharWidth;
        var anchor = elt("span", "xxxxxxxxxx"), pre = elt("pre", [ anchor ]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        return width > 2 && (display.cachedCharWidth = width), width || 10;
    }
    function getDimensions(cm) {
        for (var d = cm.display, left = {}, width = {}, gutterLeft = d.gutters.clientLeft, n = d.gutters.firstChild, i = 0; n; n = n.nextSibling,
        ++i) left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft, width[cm.options.gutters[i]] = n.clientWidth;
        return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
        };
    }
    function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping, perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
            if (lineIsHidden(cm.doc, line)) return 0;
            var widgetsHeight = 0;
            if (line.widgets) for (var i = 0; i < line.widgets.length; i++) line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
            return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th;
        };
    }
    function estimateLineHeights(cm) {
        var doc = cm.doc, est = estimateHeight(cm);
        doc.iter(function(line) {
            var estHeight = est(line);
            estHeight != line.height && updateLineHeight(line, estHeight);
        });
    }
    function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && "true" == e_target(e).getAttribute("cm-not-content")) return null;
        var x, y, space = display.lineSpace.getBoundingClientRect();
        try {
            x = e.clientX - space.left, y = e.clientY - space.top;
        } catch (e) {
            return null;
        }
        var line, coords = coordsChar(cm, x, y);
        if (forRect && 1 == coords.xRel && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
    }
    function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) return null;
        if ((n -= cm.display.viewFrom) < 0) return null;
        for (var view = cm.display.view, i = 0; i < view.length; i++) if ((n -= view[i].size) < 0) return i;
    }
    function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary) {
        for (var doc = cm.doc, result = {}, curFragment = result.cursors = document.createDocumentFragment(), selFragment = result.selection = document.createDocumentFragment(), i = 0; i < doc.sel.ranges.length; i++) if (!1 !== primary || i != doc.sel.primIndex) {
            var range = doc.sel.ranges[i];
            if (!(range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom)) {
                var collapsed = range.empty();
                (collapsed || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range.head, curFragment),
                collapsed || drawSelectionRange(cm, range, selFragment);
            }
        }
        return result;
    }
    function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine), cursor = output.appendChild(elt("div", " ", "CodeMirror-cursor"));
        if (cursor.style.left = pos.left + "px", cursor.style.top = pos.top + "px", cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px",
        pos.other) {
            var otherCursor = output.appendChild(elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "", otherCursor.style.left = pos.other.left + "px",
            otherCursor.style.top = pos.other.top + "px", otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px";
        }
    }
    function drawSelectionRange(cm, range, output) {
        function add(left, top, width, bottom) {
            top < 0 && (top = 0), top = Math.round(top), bottom = Math.round(bottom), fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
        }
        function drawForLine(line, fromArg, toArg) {
            function coords(ch, bias) {
                return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
            }
            var start, end, lineObj = getLine(doc, line), lineLen = lineObj.text.length;
            return iterateBidiSections(getOrder(lineObj), fromArg || 0, null == toArg ? lineLen : toArg, function(from, to, dir) {
                var rightPos, left, right, leftPos = coords(from, "left");
                if (from == to) rightPos = leftPos, left = right = leftPos.left; else {
                    if (rightPos = coords(to - 1, "right"), "rtl" == dir) {
                        var tmp = leftPos;
                        leftPos = rightPos, rightPos = tmp;
                    }
                    left = leftPos.left, right = rightPos.right;
                }
                null == fromArg && 0 == from && (left = leftSide), rightPos.top - leftPos.top > 3 && (add(left, leftPos.top, null, leftPos.bottom),
                left = leftSide, leftPos.bottom < rightPos.top && add(left, leftPos.bottom, null, rightPos.top)),
                null == toArg && to == lineLen && (right = rightSide), (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) && (start = leftPos),
                (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) && (end = rightPos),
                left < leftSide + 1 && (left = leftSide), add(left, rightPos.top, right - left, rightPos.bottom);
            }), {
                start: start,
                end: end
            };
        }
        var display = cm.display, doc = cm.doc, fragment = document.createDocumentFragment(), padding = paddingH(cm.display), leftSide = padding.left, rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right, sFrom = range.from(), sTo = range.to();
        if (sFrom.line == sTo.line) drawForLine(sFrom.line, sFrom.ch, sTo.ch); else {
            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line), singleVLine = visualLine(fromLine) == visualLine(toLine), leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end, rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            singleVLine && (leftEnd.top < rightStart.top - 2 ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom),
            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)) : add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)),
            leftEnd.bottom < rightStart.top && add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
        output.appendChild(fragment);
    }
    function restartBlink(cm) {
        if (cm.state.focused) {
            var display = cm.display;
            clearInterval(display.blinker);
            var on = !0;
            display.cursorDiv.style.visibility = "", cm.options.cursorBlinkRate > 0 ? display.blinker = setInterval(function() {
                return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
            }, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden");
        }
    }
    function ensureFocus(cm) {
        cm.state.focused || (cm.display.input.focus(), onFocus(cm));
    }
    function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = !0, setTimeout(function() {
            cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1, onBlur(cm));
        }, 100);
    }
    function onFocus(cm, e) {
        cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1), "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm, e),
        cm.state.focused = !0, addClass(cm.display.wrapper, "CodeMirror-focused"), cm.curOp || cm.display.selForContextMenu == cm.doc.sel || (cm.display.input.reset(),
        webkit && setTimeout(function() {
            return cm.display.input.reset(!0);
        }, 20)), cm.display.input.receivedFocus()), restartBlink(cm));
    }
    function onBlur(cm, e) {
        cm.state.delayingBlurEvent || (cm.state.focused && (signal(cm, "blur", cm, e), cm.state.focused = !1,
        rmClass(cm.display.wrapper, "CodeMirror-focused")), clearInterval(cm.display.blinker),
        setTimeout(function() {
            cm.state.focused || (cm.display.shift = !1);
        }, 150));
    }
    function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
            for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, left = comp + "px", i = 0; i < view.length; i++) if (!view[i].hidden) {
                cm.options.fixedGutter && (view[i].gutter && (view[i].gutter.style.left = left),
                view[i].gutterBackground && (view[i].gutterBackground.style.left = left));
                var align = view[i].alignable;
                if (align) for (var j = 0; j < align.length; j++) align[j].style.left = left;
            }
            cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px");
        }
    }
    function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) return !1;
        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt("div", [ elt("div", last) ], "CodeMirror-linenumber CodeMirror-gutter-elt")), innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            return display.lineGutter.style.width = "", display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1,
            display.lineNumWidth = display.lineNumInnerWidth + padding, display.lineNumChars = display.lineNumInnerWidth ? last.length : -1,
            display.lineGutter.style.width = display.lineNumWidth + "px", updateGutterSpace(cm),
            !0;
        }
        return !1;
    }
    function updateHeightsInViewport(cm) {
        for (var display = cm.display, prevBottom = display.lineDiv.offsetTop, i = 0; i < display.view.length; i++) {
            var cur = display.view[i], height = void 0;
            if (!cur.hidden) {
                if (ie && ie_version < 8) {
                    var bot = cur.node.offsetTop + cur.node.offsetHeight;
                    height = bot - prevBottom, prevBottom = bot;
                } else {
                    var box = cur.node.getBoundingClientRect();
                    height = box.bottom - box.top;
                }
                var diff = cur.line.height - height;
                if (height < 2 && (height = textHeight(display)), (diff > .001 || diff < -.001) && (updateLineHeight(cur.line, height),
                updateWidgetHeight(cur.line), cur.rest)) for (var j = 0; j < cur.rest.length; j++) updateWidgetHeight(cur.rest[j]);
            }
        }
    }
    function updateWidgetHeight(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; ++i) line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
    }
    function visibleLines(display, doc, viewport) {
        var top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight, from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            ensureFrom < from ? (from = ensureFrom, to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)) : Math.min(ensureTo, doc.lastLine()) >= to && (from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),
            to = ensureTo);
        }
        return {
            from: from,
            to: Math.max(to, from + 1)
        };
    }
    function setScrollTop(cm, val) {
        Math.abs(cm.doc.scrollTop - val) < 2 || (cm.doc.scrollTop = val, gecko || updateDisplaySimple(cm, {
            top: val
        }), cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val),
        cm.display.scrollbars.setScrollTop(val), gecko && updateDisplaySimple(cm), startWorker(cm, 100));
    }
    function setScrollLeft(cm, val, isScroller) {
        (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) || (val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth),
        cm.doc.scrollLeft = val, alignHorizontally(cm), cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val),
        cm.display.scrollbars.setScrollLeft(val));
    }
    function wheelEventDelta(e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        return null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail),
        null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta),
        {
            x: dx,
            y: dy
        };
    }
    function wheelEventPixels(e) {
        var delta = wheelEventDelta(e);
        return delta.x *= wheelPixelsPerUnit, delta.y *= wheelPixelsPerUnit, delta;
    }
    function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y, display = cm.display, scroll = display.scroller, canScrollX = scroll.scrollWidth > scroll.clientWidth, canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (dx && canScrollX || dy && canScrollY) {
            if (dy && mac && webkit) outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) for (var i = 0; i < view.length; i++) if (view[i].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
            }
            if (dx && !gecko && !presto && null != wheelPixelsPerUnit) return dy && canScrollY && setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))),
            setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth))),
            (!dy || dy && canScrollY) && e_preventDefault(e), void (display.wheelStartX = null);
            if (dy && null != wheelPixelsPerUnit) {
                var pixels = dy * wheelPixelsPerUnit, top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
                pixels < 0 ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50),
                updateDisplaySimple(cm, {
                    top: top,
                    bottom: bot
                });
            }
            wheelSamples < 20 && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft,
            display.wheelStartY = scroll.scrollTop, display.wheelDX = dx, display.wheelDY = dy,
            setTimeout(function() {
                if (null != display.wheelStartX) {
                    var movedX = scroll.scrollLeft - display.wheelStartX, movedY = scroll.scrollTop - display.wheelStartY, sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                    display.wheelStartX = display.wheelStartY = null, sample && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1),
                    ++wheelSamples);
                }
            }, 200)) : (display.wheelDX += dx, display.wheelDY += dy));
        }
    }
    function measureForScrollbars(cm) {
        var d = cm.display, gutterW = d.gutters.offsetWidth, docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
        };
    }
    function updateScrollbars(cm, measure) {
        measure || (measure = measureForScrollbars(cm));
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) startWidth != cm.display.barWidth && cm.options.lineWrapping && updateHeightsInViewport(cm),
        updateScrollbarsInner(cm, measureForScrollbars(cm)), startWidth = cm.display.barWidth,
        startHeight = cm.display.barHeight;
    }
    function updateScrollbarsInner(cm, measure) {
        var d = cm.display, sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px", d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px",
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent", sizes.right && sizes.bottom ? (d.scrollbarFiller.style.display = "block",
        d.scrollbarFiller.style.height = sizes.bottom + "px", d.scrollbarFiller.style.width = sizes.right + "px") : d.scrollbarFiller.style.display = "",
        sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block",
        d.gutterFiller.style.height = sizes.bottom + "px", d.gutterFiller.style.width = measure.gutterWidth + "px") : d.gutterFiller.style.display = "";
    }
    function initScrollbars(cm) {
        cm.display.scrollbars && (cm.display.scrollbars.clear(), cm.display.scrollbars.addClass && rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)),
        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller), on(node, "mousedown", function() {
                cm.state.focused && setTimeout(function() {
                    return cm.display.input.focus();
                }, 0);
            }), node.setAttribute("cm-not-content", "true");
        }, function(pos, axis) {
            "horizontal" == axis ? setScrollLeft(cm, pos) : setScrollTop(cm, pos);
        }, cm), cm.display.scrollbars.addClass && addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
    function maybeScrollWindow(cm, coords) {
        if (!signalDOMEvent(cm, "scrollCursorIntoView")) {
            var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
            if (coords.top + box.top < 0 ? doScroll = !0 : coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1),
            null != doScroll && !phantom) {
                var scrollNode = elt("div", "​", null, "position: absolute;\n                         top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + coords.left + "px; width: 2px;");
                cm.display.lineSpace.appendChild(scrollNode), scrollNode.scrollIntoView(doScroll),
                cm.display.lineSpace.removeChild(scrollNode);
            }
        }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
        null == margin && (margin = 0);
        for (var coords, limit = 0; limit < 5; limit++) {
            var changed = !1;
            coords = cursorCoords(cm, pos);
            var endCoords = end && end != pos ? cursorCoords(cm, end) : coords, scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin), startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (null != scrollPos.scrollTop && (setScrollTop(cm, scrollPos.scrollTop), Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = !0)),
            null != scrollPos.scrollLeft && (setScrollLeft(cm, scrollPos.scrollLeft), Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = !0)),
            !changed) break;
        }
        return coords;
    }
    function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        null != scrollPos.scrollTop && setScrollTop(cm, scrollPos.scrollTop), null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft);
    }
    function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        y1 < 0 && (y1 = 0);
        var screentop = cm.curOp && null != cm.curOp.scrollTop ? cm.curOp.scrollTop : display.scroller.scrollTop, screen = displayHeight(cm), result = {};
        y2 - y1 > screen && (y2 = y1 + screen);
        var docBottom = cm.doc.height + paddingVert(display), atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop) result.scrollTop = atTop ? 0 : y1; else if (y2 > screentop + screen) {
            var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
            newTop != screentop && (result.scrollTop = newTop);
        }
        var screenleft = cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp.scrollLeft : display.scroller.scrollLeft, screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0), tooWide = x2 - x1 > screenw;
        return tooWide && (x2 = x1 + screenw), x1 < 10 ? result.scrollLeft = 0 : x1 < screenleft ? result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) : x2 > screenw + screenleft - 3 && (result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw),
        result;
    }
    function addToScrollPos(cm, left, top) {
        null == left && null == top || resolveScrollToPos(cm), null != left && (cm.curOp.scrollLeft = (null == cm.curOp.scrollLeft ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left),
        null != top && (cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc.scrollTop : cm.curOp.scrollTop) + top);
    }
    function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor(), from = cur, to = cur;
        cm.options.lineWrapping || (from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur, to = Pos(cur.line, cur.ch + 1)),
        cm.curOp.scrollToPos = {
            from: from,
            to: to,
            margin: cm.options.cursorScrollMargin,
            isCursor: !0
        };
    }
    function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to), sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
            cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
        }
    }
    function startOperation(cm) {
        cm.curOp = {
            cm: cm,
            viewChanged: !1,
            startHeight: cm.doc.height,
            forceUpdate: !1,
            updateInput: null,
            typing: !1,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: !1,
            updateMaxLine: !1,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: !1,
            id: ++nextOpId
        }, pushOperation(cm.curOp);
    }
    function endOperation(cm) {
        finishOperation(cm.curOp, function(group) {
            for (var i = 0; i < group.ops.length; i++) group.ops[i].cm.curOp = null;
            endOperations(group);
        });
    }
    function endOperations(group) {
        for (var ops = group.ops, i = 0; i < ops.length; i++) endOperation_R1(ops[i]);
        for (var i$1 = 0; i$1 < ops.length; i$1++) endOperation_W1(ops[i$1]);
        for (var i$2 = 0; i$2 < ops.length; i$2++) endOperation_R2(ops[i$2]);
        for (var i$3 = 0; i$3 < ops.length; i$3++) endOperation_W2(ops[i$3]);
        for (var i$4 = 0; i$4 < ops.length; i$4++) endOperation_finish(ops[i$4]);
    }
    function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        maybeClipScrollbars(cm), op.updateMaxLine && findMaxLine(cm), op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping,
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
            top: op.scrollTop,
            ensure: op.scrollToPos
        }, op.forceUpdate);
    }
    function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        op.updatedDisplay && updateHeightsInViewport(cm), op.barMeasure = measureForScrollbars(cm),
        display.maxLineChanged && !cm.options.lineWrapping && (op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3,
        cm.display.sizerWidth = op.adjustWidthTo, op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth),
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))),
        (op.updatedDisplay || op.selectionChanged) && (op.preparedSelection = display.input.prepareSelection(op.focus));
    }
    function endOperation_W2(op) {
        var cm = op.cm;
        null != op.adjustWidthTo && (cm.display.sizer.style.minWidth = op.adjustWidthTo + "px",
        op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), !0),
        cm.display.maxLineChanged = !1);
        var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());
        op.preparedSelection && cm.display.input.showSelection(op.preparedSelection, takeFocus),
        (op.updatedDisplay || op.startHeight != cm.doc.height) && updateScrollbars(cm, op.barMeasure),
        op.updatedDisplay && setDocumentHeight(cm, op.barMeasure), op.selectionChanged && restartBlink(cm),
        cm.state.focused && op.updateInput && cm.display.input.reset(op.typing), takeFocus && ensureFocus(op.cm);
    }
    function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc = cm.doc;
        if (op.updatedDisplay && postUpdateDisplay(cm, op.update), null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null),
        null == op.scrollTop || display.scroller.scrollTop == op.scrollTop && !op.forceScroll || (doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop)),
        display.scrollbars.setScrollTop(doc.scrollTop), display.scroller.scrollTop = doc.scrollTop),
        null == op.scrollLeft || display.scroller.scrollLeft == op.scrollLeft && !op.forceScroll || (doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft)),
        display.scrollbars.setScrollLeft(doc.scrollLeft), display.scroller.scrollLeft = doc.scrollLeft,
        alignHorizontally(cm)), op.scrollToPos) {
            var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            op.scrollToPos.isCursor && cm.state.focused && maybeScrollWindow(cm, coords);
        }
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden) for (var i = 0; i < hidden.length; ++i) hidden[i].lines.length || signal(hidden[i], "hide");
        if (unhidden) for (var i$1 = 0; i$1 < unhidden.length; ++i$1) unhidden[i$1].lines.length && signal(unhidden[i$1], "unhide");
        display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop),
        op.changeObjs && signal(cm, "changes", cm, op.changeObjs), op.update && op.update.finish();
    }
    function runInOp(cm, f) {
        if (cm.curOp) return f();
        startOperation(cm);
        try {
            return f();
        } finally {
            endOperation(cm);
        }
    }
    function operation(cm, f) {
        return function() {
            if (cm.curOp) return f.apply(cm, arguments);
            startOperation(cm);
            try {
                return f.apply(cm, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function methodOp(f) {
        return function() {
            if (this.curOp) return f.apply(this, arguments);
            startOperation(this);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(this);
            }
        };
    }
    function docMethodOp(f) {
        return function() {
            var cm = this.cm;
            if (!cm || cm.curOp) return f.apply(this, arguments);
            startOperation(cm);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function regChange(cm, from, to, lendiff) {
        null == from && (from = cm.doc.first), null == to && (to = cm.doc.first + cm.doc.size),
        lendiff || (lendiff = 0);
        var display = cm.display;
        if (lendiff && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from),
        cm.curOp.viewChanged = !0, from >= display.viewTo) sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm); else if (to <= display.viewFrom) sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom ? resetView(cm) : (display.viewFrom += lendiff,
        display.viewTo += lendiff); else if (from <= display.viewFrom && to >= display.viewTo) resetView(cm); else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            cut ? (display.view = display.view.slice(cut.index), display.viewFrom = cut.lineN,
            display.viewTo += lendiff) : resetView(cm);
        } else if (to >= display.viewTo) {
            var cut$1 = viewCuttingPoint(cm, from, from, -1);
            cut$1 ? (display.view = display.view.slice(0, cut$1.index), display.viewTo = cut$1.lineN) : resetView(cm);
        } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1), cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            cutTop && cutBot ? (display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index)),
            display.viewTo += lendiff) : resetView(cm);
        }
        var ext = display.externalMeasured;
        ext && (to < ext.lineN ? ext.lineN += lendiff : from < ext.lineN + ext.size && (display.externalMeasured = null));
    }
    function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = !0;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null),
        !(line < display.viewFrom || line >= display.viewTo)) {
            var lineView = display.view[findViewIndex(cm, line)];
            if (null != lineView.node) {
                var arr = lineView.changes || (lineView.changes = []);
                -1 == indexOf(arr, type) && arr.push(type);
            }
        }
    }
    function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first, cm.display.view = [], cm.display.viewOffset = 0;
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
        var diff, index = findViewIndex(cm, oldN), view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) return {
            index: index,
            lineN: newN
        };
        for (var n = cm.display.viewFrom, i = 0; i < index; i++) n += view[i].size;
        if (n != oldN) {
            if (dir > 0) {
                if (index == view.length - 1) return null;
                diff = n + view[index].size - oldN, index++;
            } else diff = n - oldN;
            oldN += diff, newN += diff;
        }
        for (;visualLineNo(cm.doc, newN) != newN; ) {
            if (index == (dir < 0 ? 0 : view.length - 1)) return null;
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size, index += dir;
        }
        return {
            index: index,
            lineN: newN
        };
    }
    function adjustView(cm, from, to) {
        var display = cm.display;
        0 == display.view.length || from >= display.viewTo || to <= display.viewFrom ? (display.view = buildViewArray(cm, from, to),
        display.viewFrom = from) : (display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from))),
        display.viewFrom = from, display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))),
        display.viewTo = to;
    }
    function countDirtyView(cm) {
        for (var view = cm.display.view, dirty = 0, i = 0; i < view.length; i++) {
            var lineView = view[i];
            lineView.hidden || lineView.node && !lineView.changes || ++dirty;
        }
        return dirty;
    }
    function startWorker(cm, time) {
        cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
    function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first && (doc.frontier = doc.first), !(doc.frontier >= cm.display.viewTo)) {
            var end = +new Date() + cm.options.workTime, state = copyState(doc.mode, getStateBefore(cm, doc.frontier)), changedLines = [];
            doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
                if (doc.frontier >= cm.display.viewFrom) {
                    var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength, highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, !0);
                    line.styles = highlighted.styles;
                    var oldCls = line.styleClasses, newCls = highlighted.classes;
                    newCls ? line.styleClasses = newCls : oldCls && (line.styleClasses = null);
                    for (var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass), i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
                    ischange && changedLines.push(doc.frontier), line.stateAfter = tooLong ? state : copyState(doc.mode, state);
                } else line.text.length <= cm.options.maxHighlightLength && processLine(cm, line.text, state),
                line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
                if (++doc.frontier, +new Date() > end) return startWorker(cm, cm.options.workDelay),
                !0;
            }), changedLines.length && runInOp(cm, function() {
                for (var i = 0; i < changedLines.length; i++) regLineChange(cm, changedLines[i], "text");
            });
        }
    }
    function maybeClipScrollbars(cm) {
        var display = cm.display;
        !display.scrollbarsClipped && display.scroller.offsetWidth && (display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth,
        display.heightForcer.style.height = scrollGap(cm) + "px", display.sizer.style.marginBottom = -display.nativeBarWidth + "px",
        display.sizer.style.borderRightWidth = scrollGap(cm) + "px", display.scrollbarsClipped = !0);
    }
    function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc = cm.doc;
        if (update.editorIsHidden) return resetView(cm), !1;
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && 0 == countDirtyView(cm)) return !1;
        maybeUpdateLineNumberWidth(cm) && (resetView(cm), update.dims = getDimensions(cm));
        var end = doc.first + doc.size, from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first), to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom)),
        display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo)),
        sawCollapsedSpans && (from = visualLineNo(cm.doc, from), to = visualLineEndNo(cm.doc, to));
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to), display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom)),
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && 0 == toUpdate && !update.force && display.renderedView == display.view && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo)) return !1;
        var focused = activeElt();
        return toUpdate > 4 && (display.lineDiv.style.display = "none"), patchDisplay(cm, display.updateLineNumbers, update.dims),
        toUpdate > 4 && (display.lineDiv.style.display = ""), display.renderedView = display.view,
        focused && activeElt() != focused && focused.offsetHeight && focused.focus(), removeChildren(display.cursorDiv),
        removeChildren(display.selectionDiv), display.gutters.style.height = display.sizer.style.minHeight = 0,
        different && (display.lastWrapHeight = update.wrapperHeight, display.lastWrapWidth = update.wrapperWidth,
        startWorker(cm, 400)), display.updateLineNumbers = null, !0;
    }
    function postUpdateDisplay(cm, update) {
        for (var viewport = update.viewport, first = !0; (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm) || (viewport && null != viewport.top && (viewport = {
            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
        }), update.visible = visibleLines(cm.display, cm.doc, viewport), !(update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo))) && updateDisplayIfNeeded(cm, update); first = !1) {
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure);
        }
        update.signal(cm, "update", cm), cm.display.viewFrom == cm.display.reportedViewFrom && cm.display.viewTo == cm.display.reportedViewTo || (update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo),
        cm.display.reportedViewFrom = cm.display.viewFrom, cm.display.reportedViewTo = cm.display.viewTo);
    }
    function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm), postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure),
            update.finish();
        }
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
        function rm(node) {
            var next = node.nextSibling;
            return webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node),
            next;
        }
        for (var display = cm.display, lineNumbers = cm.options.lineNumbers, container = display.lineDiv, cur = container.firstChild, view = display.view, lineN = display.viewFrom, i = 0; i < view.length; i++) {
            var lineView = view[i];
            if (lineView.hidden) ; else if (lineView.node && lineView.node.parentNode == container) {
                for (;cur != lineView.node; ) cur = rm(cur);
                var updateNumber = lineNumbers && null != updateNumbersFrom && updateNumbersFrom <= lineN && lineView.lineNumber;
                lineView.changes && (indexOf(lineView.changes, "gutter") > -1 && (updateNumber = !1),
                updateLineForChanges(cm, lineView, lineN, dims)), updateNumber && (removeChildren(lineView.lineNumber),
                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))),
                cur = lineView.node.nextSibling;
            } else {
                var node = buildLineElement(cm, lineView, lineN, dims);
                container.insertBefore(node, cur);
            }
            lineN += lineView.size;
        }
        for (;cur; ) cur = rm(cur);
    }
    function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + "px";
    }
    function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px", cm.display.heightForcer.style.top = measure.docHeight + "px",
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
    }
    function updateGutters(cm) {
        var gutters = cm.display.gutters, specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
            var gutterClass = specs[i], gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
            "CodeMirror-linenumbers" == gutterClass && (cm.display.lineGutter = gElt, gElt.style.width = (cm.display.lineNumWidth || 1) + "px");
        }
        gutters.style.display = i ? "" : "none", updateGutterSpace(cm);
    }
    function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        -1 == found && options.lineNumbers ? options.gutters = options.gutters.concat([ "CodeMirror-linenumbers" ]) : found > -1 && !options.lineNumbers && (options.gutters = options.gutters.slice(0),
        options.gutters.splice(found, 1));
    }
    function Selection(ranges, primIndex) {
        this.ranges = ranges, this.primIndex = primIndex;
    }
    function Range(anchor, head) {
        this.anchor = anchor, this.head = head;
    }
    function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function(a, b) {
            return cmp(a.from(), b.from());
        }), primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
            var cur = ranges[i], prev = ranges[i - 1];
            if (cmp(prev.to(), cur.from()) >= 0) {
                var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to()), inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                i <= primIndex && --primIndex, ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
            }
        }
        return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
        return new Selection([ new Range(anchor, head || anchor) ], 0);
    }
    function changeEnd(change) {
        return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to;
    }
    function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) return pos;
        if (cmp(pos, change.to) <= 0) return changeEnd(change);
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        return pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch),
        Pos(line, ch);
    }
    function computeSelAfterChange(doc, change) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return normalizeSelection(out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
        return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch);
    }
    function computeReplacedSel(doc, changes, hint) {
        for (var out = [], oldPrev = Pos(doc.first, 0), newPrev = oldPrev, i = 0; i < changes.length; i++) {
            var change = changes[i], from = offsetPos(change.from, oldPrev, newPrev), to = offsetPos(changeEnd(change), oldPrev, newPrev);
            if (oldPrev = change.to, newPrev = to, "around" == hint) {
                var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                out[i] = new Range(inv ? to : from, inv ? from : to);
            } else out[i] = new Range(from, from);
        }
        return new Selection(out, doc.sel.primIndex);
    }
    function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption), resetModeState(cm);
    }
    function resetModeState(cm) {
        cm.doc.iter(function(line) {
            line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null);
        }), cm.doc.frontier = cm.doc.first, startWorker(cm, 100), cm.state.modeGen++, cm.curOp && regChange(cm);
    }
    function isWholeLineUpdate(doc, change) {
        return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
            updateLine(line, text, spans, estimateHeight), signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
            for (var result = [], i = start; i < end; ++i) result.push(new Line(text[i], spansFor(i), estimateHeight));
            return result;
        }
        var from = change.from, to = change.to, text = change.text, firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line), lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
        if (change.full) doc.insert(0, linesFor(0, text.length)), doc.remove(text.length, doc.size - text.length); else if (isWholeLineUpdate(doc, change)) {
            var added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans), nlines && doc.remove(from.line, nlines),
            added.length && doc.insert(from.line, added);
        } else if (firstLine == lastLine) if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans); else {
            var added$1 = linesFor(1, text.length - 1);
            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight)),
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), doc.insert(from.line + 1, added$1);
        } else if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)),
        doc.remove(from.line + 1, nlines); else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            var added$2 = linesFor(1, text.length - 1);
            nlines > 1 && doc.remove(from.line + 1, nlines - 1), doc.insert(from.line + 1, added$2);
        }
        signalLater(doc, "change", doc, change);
    }
    function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
            if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
                var rel = doc.linked[i];
                if (rel.doc != skip) {
                    var shared = sharedHist && rel.sharedHist;
                    sharedHistOnly && !shared || (f(rel.doc, shared), propagate(rel.doc, doc, shared));
                }
            }
        }
        propagate(doc, null, !0);
    }
    function attachDoc(cm, doc) {
        if (doc.cm) throw new Error("This document is already in use.");
        cm.doc = doc, doc.cm = cm, estimateLineHeights(cm), loadMode(cm), cm.options.lineWrapping || findMaxLine(cm),
        cm.options.mode = doc.modeOption, regChange(cm);
    }
    function History(startGen) {
        this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0,
        this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null,
        this.generation = this.maxGeneration = startGen || 1;
    }
    function historyChangeFromChange(doc, change) {
        var histChange = {
            from: copyPos(change.from),
            to: changeEnd(change),
            text: getBetween(doc, change.from, change.to)
        };
        return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1),
        linkedDocs(doc, function(doc) {
            return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, !0), histChange;
    }
    function clearSelectionEvents(array) {
        for (;array.length; ) {
            if (!lst(array).ranges) break;
            array.pop();
        }
    }
    function lastChangeEvent(hist, force) {
        return force ? (clearSelectionEvents(hist.done), lst(hist.done)) : hist.done.length && !lst(hist.done).ranges ? lst(hist.done) : hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges ? (hist.done.pop(),
        lst(hist.done)) : void 0;
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var cur, last, time = +new Date();
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || "*" == change.origin.charAt(0))) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) last = lst(cur.changes),
        0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? last.to = changeEnd(change) : cur.changes.push(historyChangeFromChange(doc, change)); else {
            var before = lst(hist.done);
            for (before && before.ranges || pushSelectionToHistory(doc.sel, hist.done), cur = {
                changes: [ historyChangeFromChange(doc, change) ],
                generation: hist.generation
            }, hist.done.push(cur); hist.done.length > hist.undoDepth; ) hist.done.shift(),
            hist.done[0].ranges || hist.done.shift();
        }
        hist.done.push(selAfter), hist.generation = ++hist.maxGeneration, hist.lastModTime = hist.lastSelTime = time,
        hist.lastOp = hist.lastSelOp = opId, hist.lastOrigin = hist.lastSelOrigin = change.origin,
        last || signal(doc, "historyAdded");
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return "*" == ch || "+" == ch && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history, origin = options && options.origin;
        opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done),
        hist.lastSelTime = +new Date(), hist.lastSelOrigin = origin, hist.lastSelOp = opId,
        options && !1 !== options.clearRedo && clearSelectionEvents(hist.undone);
    }
    function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        top && top.ranges && top.equals(sel) || dest.push(sel);
    }
    function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
            line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans),
            ++n;
        });
    }
    function removeClearedSpans(spans) {
        if (!spans) return null;
        for (var out, i = 0; i < spans.length; ++i) spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
        return out ? out.length ? out : null : spans;
    }
    function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found) return null;
        for (var nw = [], i = 0; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
        return nw;
    }
    function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change), stretched = stretchSpansOverChange(doc, change);
        if (!old) return stretched;
        if (!stretched) return old;
        for (var i = 0; i < old.length; ++i) {
            var oldCur = old[i], stretchCur = stretched[i];
            if (oldCur && stretchCur) spans: for (var j = 0; j < stretchCur.length; ++j) {
                for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k) if (oldCur[k].marker == span.marker) continue spans;
                oldCur.push(span);
            } else stretchCur && (old[i] = stretchCur);
        }
        return old;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
        for (var copy = [], i = 0; i < events.length; ++i) {
            var event = events[i];
            if (event.ranges) copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event); else {
                var changes = event.changes, newChanges = [];
                copy.push({
                    changes: newChanges
                });
                for (var j = 0; j < changes.length; ++j) {
                    var change = changes[j], m = void 0;
                    if (newChanges.push({
                        from: change.from,
                        to: change.to,
                        text: change.text
                    }), newGroup) for (var prop in change) (m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1 && (lst(newChanges)[prop] = change[prop],
                    delete change[prop]);
                }
            }
        }
        return copy;
    }
    function extendRange(doc, range, head, other) {
        if (doc.cm && doc.cm.display.shift || doc.extend) {
            var anchor = range.anchor;
            if (other) {
                var posBefore = cmp(head, anchor) < 0;
                posBefore != cmp(other, anchor) < 0 ? (anchor = head, head = other) : posBefore != cmp(head, other) < 0 && (head = other);
            }
            return new Range(anchor, head);
        }
        return new Range(other || head, head);
    }
    function extendSelection(doc, head, other, options) {
        setSelection(doc, new Selection([ extendRange(doc, doc.sel.primary(), head, other) ], 0), options);
    }
    function extendSelections(doc, heads, options) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++) out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
        setSelection(doc, normalizeSelection(out, doc.sel.primIndex), options);
    }
    function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range, setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
    }
    function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
    }
    function filterSelectionChange(doc, sel, options) {
        var obj = {
            ranges: sel.ranges,
            update: function(ranges) {
                var this$1 = this;
                this.ranges = [];
                for (var i = 0; i < ranges.length; i++) this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
            },
            origin: options && options.origin
        };
        return signal(doc, "beforeSelectionChange", doc, obj), doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj),
        obj.ranges != sel.ranges ? normalizeSelection(obj.ranges, obj.ranges.length - 1) : sel;
    }
    function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done, last = lst(done);
        last && last.ranges ? (done[done.length - 1] = sel, setSelectionNoUndo(doc, sel, options)) : setSelection(doc, sel, options);
    }
    function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options), addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc, sel, options) {
        (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = filterSelectionChange(doc, sel, options)),
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1), !0)),
        options && !1 === options.scroll || !doc.cm || ensureCursorVisible(doc.cm);
    }
    function setSelectionInner(doc, sel) {
        sel.equals(doc.sel) || (doc.sel = sel, doc.cm && (doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = !0,
        signalCursorActivity(doc.cm)), signalLater(doc, "cursorActivity", doc));
    }
    function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, !1), sel_dontScroll);
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
        for (var out, i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i], old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i], newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear), newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
            (out || newAnchor != range.anchor || newHead != range.head) && (out || (out = sel.ranges.slice(0, i)),
            out[i] = new Range(newAnchor, newHead));
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel;
    }
    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);
        if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((null == sp.from || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                if (mayClear && (signal(m, "beforeCursorEnter"), m.explicitlyCleared)) {
                    if (line.markedSpans) {
                        --i;
                        continue;
                    }
                    break;
                }
                if (!m.atomic) continue;
                if (oldPos) {
                    var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
                    if ((dir < 0 ? m.inclusiveRight : m.inclusiveLeft) && (near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null)),
                    near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) return skipAtomicInner(doc, near, pos, dir, mayClear);
                }
                var far = m.find(dir < 0 ? -1 : 1);
                return (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) && (far = movePos(doc, far, dir, far.line == pos.line ? line : null)),
                far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
            }
        }
        return pos;
    }
    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        var dir = bias || 1, found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, !0) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, !0);
        return found || (doc.cantEdit = !0, Pos(doc.first, 0));
    }
    function movePos(doc, pos, dir, line) {
        return dir < 0 && 0 == pos.ch ? pos.line > doc.first ? clipPos(doc, Pos(pos.line - 1)) : null : dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length ? pos.line < doc.first + doc.size - 1 ? Pos(pos.line + 1, 0) : null : new Pos(pos.line, pos.ch + dir);
    }
    function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
    }
    function filterChange(doc, change, update) {
        var obj = {
            canceled: !1,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
                return obj.canceled = !0;
            }
        };
        return update && (obj.update = function(from, to, text, origin) {
            from && (obj.from = clipPos(doc, from)), to && (obj.to = clipPos(doc, to)), text && (obj.text = text),
            void 0 !== origin && (obj.origin = origin);
        }), signal(doc, "beforeChange", doc, obj), doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj),
        obj.canceled ? null : {
            from: obj.from,
            to: obj.to,
            text: obj.text,
            origin: obj.origin
        };
    }
    function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
            if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            if (doc.cm.state.suppressEdits) return;
        }
        if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
            var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
            if (split) for (var i = split.length - 1; i >= 0; --i) makeChangeInner(doc, {
                from: split[i].from,
                to: split[i].to,
                text: i ? [ "" ] : change.text
            }); else makeChangeInner(doc, change);
        }
    }
    function makeChangeInner(doc, change) {
        if (1 != change.text.length || "" != change.text[0] || 0 != cmp(change.from, change.to)) {
            var selAfter = computeSelAfterChange(doc, change);
            addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN), makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
            var rebased = [];
            linkedDocs(doc, function(doc, sharedHist) {
                sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change),
                rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
            });
        }
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (!doc.cm || !doc.cm.state.suppressEdits || allowSelectionOnly) {
            for (var event, hist = doc.history, selAfter = doc.sel, source = "undo" == type ? hist.done : hist.undone, dest = "undo" == type ? hist.undone : hist.done, i = 0; i < source.length && (event = source[i],
            allowSelectionOnly ? !event.ranges || event.equals(doc.sel) : event.ranges); i++) ;
            if (i != source.length) {
                for (hist.lastOrigin = hist.lastSelOrigin = null; event = source.pop(), event.ranges; ) {
                    if (pushSelectionToHistory(event, dest), allowSelectionOnly && !event.equals(doc.sel)) return void setSelection(doc, event, {
                        clearRedo: !1
                    });
                    selAfter = event;
                }
                var antiChanges = [];
                pushSelectionToHistory(selAfter, dest), dest.push({
                    changes: antiChanges,
                    generation: hist.generation
                }), hist.generation = event.generation || ++hist.maxGeneration;
                for (var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"), i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
                    var returned = function(i) {
                        var change = event.changes[i];
                        if (change.origin = type, filter && !filterChange(doc, change, !1)) return source.length = 0,
                        {};
                        antiChanges.push(historyChangeFromChange(doc, change));
                        var after = i ? computeSelAfterChange(doc, change) : lst(source);
                        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change)), !i && doc.cm && doc.cm.scrollIntoView({
                            from: change.from,
                            to: changeEnd(change)
                        });
                        var rebased = [];
                        linkedDocs(doc, function(doc, sharedHist) {
                            sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change),
                            rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
                        });
                    }(i$1);
                    if (returned) return returned.v;
                }
            }
        }
    }
    function shiftDoc(doc, distance) {
        if (0 != distance && (doc.first += distance, doc.sel = new Selection(map(doc.sel.ranges, function(range) {
            return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex), doc.cm)) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) regLineChange(doc.cm, l, "gutter");
        }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        if (change.to.line < doc.first) return void shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
        if (!(change.from.line > doc.lastLine())) {
            if (change.from.line < doc.first) {
                var shift = change.text.length - 1 - (doc.first - change.from.line);
                shiftDoc(doc, shift), change = {
                    from: Pos(doc.first, 0),
                    to: Pos(change.to.line + shift, change.to.ch),
                    text: [ lst(change.text) ],
                    origin: change.origin
                };
            }
            var last = doc.lastLine();
            change.to.line > last && (change = {
                from: change.from,
                to: Pos(last, getLine(doc, last).text.length),
                text: [ change.text[0] ],
                origin: change.origin
            }), change.removed = getBetween(doc, change.from, change.to), selAfter || (selAfter = computeSelAfterChange(doc, change)),
            doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans) : updateDoc(doc, change, spans),
            setSelectionNoUndo(doc, selAfter, sel_dontScroll);
        }
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc, display = cm.display, from = change.from, to = change.to, recomputeMaxLength = !1, checkWidthStart = from.line;
        cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(getLine(doc, from.line))),
        doc.iter(checkWidthStart, to.line + 1, function(line) {
            if (line == display.maxLine) return recomputeMaxLength = !0, !0;
        })), doc.sel.contains(change.from, change.to) > -1 && signalCursorActivity(cm),
        updateDoc(doc, change, spans, estimateHeight(cm)), cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
            var len = lineLength(line);
            len > display.maxLineLength && (display.maxLine = line, display.maxLineLength = len,
            display.maxLineChanged = !0, recomputeMaxLength = !1);
        }), recomputeMaxLength && (cm.curOp.updateMaxLine = !0)), doc.frontier = Math.min(doc.frontier, from.line),
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        change.full ? regChange(cm) : from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, lendiff) : regLineChange(cm, from.line, "text");
        var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
            var obj = {
                from: from,
                to: to,
                text: change.text,
                removed: change.removed,
                origin: change.origin
            };
            changeHandler && signalLater(cm, "change", cm, obj), changesHandler && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
        cm.display.selForContextMenu = null;
    }
    function replaceRange(doc, code, from, to, origin) {
        if (to || (to = from), cmp(to, from) < 0) {
            var tmp = to;
            to = from, from = tmp;
        }
        "string" == typeof code && (code = doc.splitLines(code)), makeChange(doc, {
            from: from,
            to: to,
            text: code,
            origin: origin
        });
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
        to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from, pos.ch = 0);
    }
    function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
            var sub = array[i], ok = !0;
            if (sub.ranges) {
                sub.copied || (sub = array[i] = sub.deepCopy(), sub.copied = !0);
                for (var j = 0; j < sub.ranges.length; j++) rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff),
                rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
            } else {
                for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
                    var cur = sub.changes[j$1];
                    if (to < cur.from.line) cur.from = Pos(cur.from.line + diff, cur.from.ch), cur.to = Pos(cur.to.line + diff, cur.to.ch); else if (from <= cur.to.line) {
                        ok = !1;
                        break;
                    }
                }
                ok || (array.splice(0, i + 1), i = 0);
            }
        }
    }
    function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff), rebaseHistArray(hist.undone, from, to, diff);
    }
    function changeLine(doc, handle, changeType, op) {
        var no = handle, line = handle;
        return "number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle),
        null == no ? null : (op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType),
        line);
    }
    function LeafChunk(lines) {
        var this$1 = this;
        this.lines = lines, this.parent = null;
        for (var height = 0, i = 0; i < lines.length; ++i) lines[i].parent = this$1, height += lines[i].height;
        this.height = height;
    }
    function BranchChunk(children) {
        var this$1 = this;
        this.children = children;
        for (var size = 0, height = 0, i = 0; i < children.length; ++i) {
            var ch = children[i];
            size += ch.chunkSize(), height += ch.height, ch.parent = this$1;
        }
        this.size = size, this.height = height, this.parent = null;
    }
    function LineWidget(doc, node, options) {
        var this$1 = this;
        if (options) for (var opt in options) options.hasOwnProperty(opt) && (this$1[opt] = options[opt]);
        this.doc = doc, this.node = node;
    }
    function adjustScrollWhenAboveVisible(cm, line, diff) {
        heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollPos(cm, null, diff);
    }
    function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options), cm = doc.cm;
        return cm && widget.noHScroll && (cm.display.alignWidgets = !0), changeLine(doc, handle, "widget", function(line) {
            var widgets = line.widgets || (line.widgets = []);
            if (null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget),
            widget.line = line, cm && !lineIsHidden(doc, line)) {
                var aboveVisible = heightAtLine(line) < doc.scrollTop;
                updateLineHeight(line, line.height + widgetHeight(widget)), aboveVisible && addToScrollPos(cm, null, widget.height),
                cm.curOp.forceUpdate = !0;
            }
            return !0;
        }), widget;
    }
    function TextMarker(doc, type) {
        this.lines = [], this.type = type, this.doc = doc, this.id = ++nextMarkerId;
    }
    function markText(doc, from, to, options, type) {
        if (options && options.shared) return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);
        var marker = new TextMarker(doc, type), diff = cmp(from, to);
        if (options && copyObj(options, marker, !1), diff > 0 || 0 == diff && !1 !== marker.clearWhenEmpty) return marker;
        if (marker.replacedWith && (marker.collapsed = !0, marker.widgetNode = elt("span", [ marker.replacedWith ], "CodeMirror-widget"),
        marker.widgetNode.setAttribute("role", "presentation"), options.handleMouseEvents || marker.widgetNode.setAttribute("cm-ignore-events", "true"),
        options.insertLeft && (marker.widgetNode.insertLeft = !0)), marker.collapsed) {
            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
            seeCollapsedSpans();
        }
        marker.addToHistory && addChangeToHistory(doc, {
            from: from,
            to: to,
            origin: "markText"
        }, doc.sel, NaN);
        var updateMaxLine, curLine = from.line, cm = doc.cm;
        if (doc.iter(curLine, to.line + 1, function(line) {
            cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = !0),
            marker.collapsed && curLine != from.line && updateLineHeight(line, 0), addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null)),
            ++curLine;
        }), marker.collapsed && doc.iter(from.line, to.line + 1, function(line) {
            lineIsHidden(doc, line) && updateLineHeight(line, 0);
        }), marker.clearOnEnter && on(marker, "beforeCursorEnter", function() {
            return marker.clear();
        }), marker.readOnly && (seeReadOnlySpans(), (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()),
        marker.collapsed && (marker.id = ++nextMarkerId, marker.atomic = !0), cm) {
            if (updateMaxLine && (cm.curOp.updateMaxLine = !0), marker.collapsed) regChange(cm, from.line, to.line + 1); else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
            marker.atomic && reCheckSelection(cm.doc), signalLater(cm, "markerAdded", cm, marker);
        }
        return marker;
    }
    function SharedTextMarker(markers, primary) {
        var this$1 = this;
        this.markers = markers, this.primary = primary;
        for (var i = 0; i < markers.length; ++i) markers[i].parent = this$1;
    }
    function markTextShared(doc, from, to, options, type) {
        options = copyObj(options), options.shared = !1;
        var markers = [ markText(doc, from, to, options, type) ], primary = markers[0], widget = options.widgetNode;
        return linkedDocs(doc, function(doc) {
            widget && (options.widgetNode = widget.cloneNode(!0)), markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
            for (var i = 0; i < doc.linked.length; ++i) if (doc.linked[i].isParent) return;
            primary = lst(markers);
        }), new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
            return m.parent;
        });
    }
    function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i], pos = marker.find(), mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
                var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                marker.markers.push(subMark), subMark.parent = marker;
            }
        }
    }
    function detachSharedMarkers(markers) {
        for (var i = 0; i < markers.length; i++) !function(i) {
            var marker = markers[i], linked = [ marker.primary.doc ];
            linkedDocs(marker.primary.doc, function(d) {
                return linked.push(d);
            });
            for (var j = 0; j < marker.markers.length; j++) {
                var subMarker = marker.markers[j];
                -1 == indexOf(linked, subMarker.doc) && (subMarker.parent = null, marker.markers.splice(j--, 1));
            }
        }(i);
    }
    function onDrop(e) {
        var cm = this;
        if (clearDragCursor(cm), !signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
            e_preventDefault(e), ie && (lastDrop = +new Date());
            var pos = posFromMouse(cm, e, !0), files = e.dataTransfer.files;
            if (pos && !cm.isReadOnly()) if (files && files.length && window.FileReader && window.File) for (var n = files.length, text = Array(n), read = 0, i = 0; i < n; ++i) !function(file, i) {
                if (!cm.options.allowDropFileTypes || -1 != indexOf(cm.options.allowDropFileTypes, file.type)) {
                    var reader = new FileReader();
                    reader.onload = operation(cm, function() {
                        var content = reader.result;
                        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content) && (content = ""), text[i] = content,
                        ++read == n) {
                            pos = clipPos(cm.doc, pos);
                            var change = {
                                from: pos,
                                to: pos,
                                text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                                origin: "paste"
                            };
                            makeChange(cm.doc, change), setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
                        }
                    }), reader.readAsText(file);
                }
            }(files[i], i); else {
                if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) return cm.state.draggingText(e),
                void setTimeout(function() {
                    return cm.display.input.focus();
                }, 20);
                try {
                    var text$1 = e.dataTransfer.getData("Text");
                    if (text$1) {
                        var selected;
                        if (cm.state.draggingText && !cm.state.draggingText.copy && (selected = cm.listSelections()),
                        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos)), selected) for (var i$1 = 0; i$1 < selected.length; ++i$1) replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                        cm.replaceSelection(text$1, "around", "paste"), cm.display.input.focus();
                    }
                } catch (e) {}
            }
        }
    }
    function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) return void e_stop(e);
        if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e) && (e.dataTransfer.setData("Text", cm.getSelection()),
        e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !safari)) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
            presto && (img.width = img.height = 1, cm.display.wrapper.appendChild(img), img._top = img.offsetTop),
            e.dataTransfer.setDragImage(img, 0, 0), presto && img.parentNode.removeChild(img);
        }
    }
    function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);
        if (pos) {
            var frag = document.createDocumentFragment();
            drawSelectionCursor(cm, pos, frag), cm.display.dragCursor || (cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors"),
            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)),
            removeChildrenAndAdd(cm.display.dragCursor, frag);
        }
    }
    function clearDragCursor(cm) {
        cm.display.dragCursor && (cm.display.lineSpace.removeChild(cm.display.dragCursor),
        cm.display.dragCursor = null);
    }
    function forEachCodeMirror(f) {
        if (document.body.getElementsByClassName) for (var byClass = document.body.getElementsByClassName("CodeMirror"), i = 0; i < byClass.length; i++) {
            var cm = byClass[i].CodeMirror;
            cm && f(cm);
        }
    }
    function ensureGlobalHandlers() {
        globalsRegistered || (registerGlobalHandlers(), globalsRegistered = !0);
    }
    function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function() {
            null == resizeTimer && (resizeTimer = setTimeout(function() {
                resizeTimer = null, forEachCodeMirror(onResize);
            }, 100));
        }), on(window, "blur", function() {
            return forEachCodeMirror(onBlur);
        });
    }
    function onResize(cm) {
        var d = cm.display;
        d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth || (d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null,
        d.scrollbarsClipped = !1, cm.setSize());
    }
    function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        for (var alt, ctrl, shift, cmd, i = 0; i < parts.length - 1; i++) {
            var mod = parts[i];
            if (/^(cmd|meta|m)$/i.test(mod)) cmd = !0; else if (/^a(lt)?$/i.test(mod)) alt = !0; else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = !0; else {
                if (!/^s(hift)?$/i.test(mod)) throw new Error("Unrecognized modifier name: " + mod);
                shift = !0;
            }
        }
        return alt && (name = "Alt-" + name), ctrl && (name = "Ctrl-" + name), cmd && (name = "Cmd-" + name),
        shift && (name = "Shift-" + name), name;
    }
    function normalizeKeyMap(keymap) {
        var copy = {};
        for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];
            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
            if ("..." == value) {
                delete keymap[keyname];
                continue;
            }
            for (var keys = map(keyname.split(" "), normalizeKeyName), i = 0; i < keys.length; i++) {
                var val = void 0, name = void 0;
                i == keys.length - 1 ? (name = keys.join(" "), val = value) : (name = keys.slice(0, i + 1).join(" "),
                val = "...");
                var prev = copy[name];
                if (prev) {
                    if (prev != val) throw new Error("Inconsistent bindings for " + name);
                } else copy[name] = val;
            }
            delete keymap[keyname];
        }
        for (var prop in copy) keymap[prop] = copy[prop];
        return keymap;
    }
    function lookupKey(key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];
        if (!1 === found) return "nothing";
        if ("..." === found) return "multi";
        if (null != found && handle(found)) return "handled";
        if (map.fallthrough) {
            if ("[object Array]" != Object.prototype.toString.call(map.fallthrough)) return lookupKey(key, map.fallthrough, handle, context);
            for (var i = 0; i < map.fallthrough.length; i++) {
                var result = lookupKey(key, map.fallthrough[i], handle, context);
                if (result) return result;
            }
        }
    }
    function isModifierKey(value) {
        var name = "string" == typeof value ? value : keyNames[value.keyCode];
        return "Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name;
    }
    function keyName(event, noShift) {
        if (presto && 34 == event.keyCode && event.char) return !1;
        var base = keyNames[event.keyCode], name = base;
        return null != name && !event.altGraphKey && (event.altKey && "Alt" != base && (name = "Alt-" + name),
        (flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name),
        (flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Cmd" != base && (name = "Cmd-" + name),
        !noShift && event.shiftKey && "Shift" != base && (name = "Shift-" + name), name);
    }
    function getKeyMap(val) {
        return "string" == typeof val ? keyMap[val] : val;
    }
    function deleteNearSelection(cm, compute) {
        for (var ranges = cm.doc.sel.ranges, kill = [], i = 0; i < ranges.length; i++) {
            for (var toKill = compute(ranges[i]); kill.length && cmp(toKill.from, lst(kill).to) <= 0; ) {
                var replaced = kill.pop();
                if (cmp(replaced.from, toKill.from) < 0) {
                    toKill.from = replaced.from;
                    break;
                }
            }
            kill.push(toKill);
        }
        runInOp(cm, function() {
            for (var i = kill.length - 1; i >= 0; i--) replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
            ensureCursorVisible(cm);
        });
    }
    function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN), visual = visualLine(line);
        visual != line && (lineN = lineNo(visual));
        var order = getOrder(visual);
        return Pos(lineN, order ? order[0].level % 2 ? lineRight(visual) : lineLeft(visual) : 0);
    }
    function lineEnd(cm, lineN) {
        for (var merged, line = getLine(cm.doc, lineN); merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line,
        lineN = null;
        var order = getOrder(line), ch = order ? order[0].level % 2 ? lineLeft(line) : lineRight(line) : line.text.length;
        return Pos(null == lineN ? lineNo(line) : lineN, ch);
    }
    function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line), line = getLine(cm.doc, start.line), order = getOrder(line);
        if (!order || 0 == order[0].level) {
            var firstNonWS = Math.max(0, line.text.search(/\S/)), inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
    }
    function doHandleBinding(cm, bound, dropShift) {
        if ("string" == typeof bound && !(bound = commands[bound])) return !1;
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift, done = !1;
        try {
            cm.isReadOnly() && (cm.state.suppressEdits = !0), dropShift && (cm.display.shift = !1),
            done = bound(cm) != Pass;
        } finally {
            cm.display.shift = prevShift, cm.state.suppressEdits = !1;
        }
        return done;
    }
    function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
            var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
            if (result) return result;
        }
        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
    }
    function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
            if (isModifierKey(name)) return "handled";
            stopSeq.set(50, function() {
                cm.state.keySeq == seq && (cm.state.keySeq = null, cm.display.input.reset());
            }), name = seq + " " + name;
        }
        var result = lookupKeyForEditor(cm, name, handle);
        return "multi" == result && (cm.state.keySeq = name), "handled" == result && signalLater(cm, "keyHandled", cm, name, e),
        "handled" != result && "multi" != result || (e_preventDefault(e), restartBlink(cm)),
        seq && !result && /\'$/.test(name) ? (e_preventDefault(e), !0) : !!result;
    }
    function handleKeyBinding(cm, e) {
        var name = keyName(e, !0);
        return !!name && (e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function(b) {
            return doHandleBinding(cm, b, !0);
        }) || dispatchKey(cm, name, e, function(b) {
            if ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b);
        }) : dispatchKey(cm, name, e, function(b) {
            return doHandleBinding(cm, b);
        }));
    }
    function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function(b) {
            return doHandleBinding(cm, b, !0);
        });
    }
    function onKeyDown(e) {
        var cm = this;
        if (cm.curOp.focus = activeElt(), !signalDOMEvent(cm, e)) {
            ie && ie_version < 11 && 27 == e.keyCode && (e.returnValue = !1);
            var code = e.keyCode;
            cm.display.shift = 16 == code || e.shiftKey;
            var handled = handleKeyBinding(cm, e);
            presto && (lastStoppedKey = handled ? code : null, !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")),
            18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || showCrossHair(cm);
        }
    }
    function showCrossHair(cm) {
        function up(e) {
            18 != e.keyCode && e.altKey || (rmClass(lineDiv, "CodeMirror-crosshair"), off(document, "keyup", up),
            off(document, "mouseover", up));
        }
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair"), on(document, "keyup", up), on(document, "mouseover", up);
    }
    function onKeyUp(e) {
        16 == e.keyCode && (this.doc.sel.shift = !1), signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
        var cm = this;
        if (!(eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)) {
            var keyCode = e.keyCode, charCode = e.charCode;
            if (presto && keyCode == lastStoppedKey) return lastStoppedKey = null, void e_preventDefault(e);
            if (!presto || e.which && !(e.which < 10) || !handleKeyBinding(cm, e)) {
                var ch = String.fromCharCode(null == charCode ? keyCode : charCode);
                "\b" != ch && (handleCharBinding(cm, e, ch) || cm.display.input.onKeyPress(e));
            }
        }
    }
    function onMouseDown(e) {
        var cm = this, display = cm.display;
        if (!(signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch())) {
            if (display.input.ensurePolled(), display.shift = e.shiftKey, eventInWidget(display, e)) return void (webkit || (display.scroller.draggable = !1,
            setTimeout(function() {
                return display.scroller.draggable = !0;
            }, 100)));
            if (!clickInGutter(cm, e)) {
                var start = posFromMouse(cm, e);
                switch (window.focus(), e_button(e)) {
                  case 1:
                    cm.state.selectingText ? cm.state.selectingText(e) : start ? leftButtonDown(cm, e, start) : e_target(e) == display.scroller && e_preventDefault(e);
                    break;

                  case 2:
                    webkit && (cm.state.lastMiddleDown = +new Date()), start && extendSelection(cm.doc, start),
                    setTimeout(function() {
                        return display.input.focus();
                    }, 20), e_preventDefault(e);
                    break;

                  case 3:
                    captureRightClick ? onContextMenu(cm, e) : delayBlurEvent(cm);
                }
            }
        }
    }
    function leftButtonDown(cm, e, start) {
        ie ? setTimeout(bind(ensureFocus, cm), 0) : cm.curOp.focus = activeElt();
        var type, now = +new Date();
        lastDoubleClick && lastDoubleClick.time > now - 400 && 0 == cmp(lastDoubleClick.pos, start) ? type = "triple" : lastClick && lastClick.time > now - 400 && 0 == cmp(lastClick.pos, start) ? (type = "double",
        lastDoubleClick = {
            time: now,
            pos: start
        }) : (type = "single", lastClick = {
            time: now,
            pos: start
        });
        var contained, sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;
        cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && "single" == type && (contained = sel.contains(start)) > -1 && (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) && (cmp(contained.to(), start) > 0 || start.xRel < 0) ? leftButtonStartDrag(cm, e, start, modifier) : leftButtonSelect(cm, e, start, type, modifier);
    }
    function leftButtonStartDrag(cm, e, start, modifier) {
        var display = cm.display, startTime = +new Date(), dragEnd = operation(cm, function(e2) {
            webkit && (display.scroller.draggable = !1), cm.state.draggingText = !1, off(document, "mouseup", dragEnd),
            off(display.scroller, "drop", dragEnd), Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10 && (e_preventDefault(e2),
            !modifier && +new Date() - 200 < startTime && extendSelection(cm.doc, start), webkit || ie && 9 == ie_version ? setTimeout(function() {
                document.body.focus(), display.input.focus();
            }, 20) : display.input.focus());
        });
        webkit && (display.scroller.draggable = !0), cm.state.draggingText = dragEnd, dragEnd.copy = mac ? e.altKey : e.ctrlKey,
        display.scroller.dragDrop && display.scroller.dragDrop(), on(document, "mouseup", dragEnd),
        on(display.scroller, "drop", dragEnd);
    }
    function leftButtonSelect(cm, e, start, type, addNew) {
        function extendTo(pos) {
            if (0 != cmp(lastPos, pos)) if (lastPos = pos, "rect" == type) {
                for (var ranges = [], tabSize = cm.options.tabSize, startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize), posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize), left = Math.min(startCol, posCol), right = Math.max(startCol, posCol), line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                    var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                    left == right ? ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                }
                ranges.length || ranges.push(new Range(start, start)), setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                    origin: "*mouse",
                    scroll: !1
                }), cm.scrollIntoView(pos);
            } else {
                var oldRange = ourRange, anchor = oldRange.anchor, head = pos;
                if ("single" != type) {
                    var range;
                    range = "double" == type ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))),
                    cmp(range.anchor, anchor) > 0 ? (head = range.head, anchor = minPos(oldRange.from(), range.anchor)) : (head = range.anchor,
                    anchor = maxPos(oldRange.to(), range.head));
                }
                var ranges$1 = startSel.ranges.slice(0);
                ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head), setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
            }
        }
        function extend(e) {
            var curCount = ++counter, cur = posFromMouse(cm, e, !0, "rect" == type);
            if (cur) if (0 != cmp(cur, lastPos)) {
                cm.curOp.focus = activeElt(), extendTo(cur);
                var visible = visibleLines(display, doc);
                (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function() {
                    counter == curCount && extend(e);
                }), 150);
            } else {
                var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                outside && setTimeout(operation(cm, function() {
                    counter == curCount && (display.scroller.scrollTop += outside, extend(e));
                }), 50);
            }
        }
        function done(e) {
            cm.state.selectingText = !1, counter = 1 / 0, e_preventDefault(e), display.input.focus(),
            off(document, "mousemove", move), off(document, "mouseup", up), doc.history.lastSelOrigin = null;
        }
        var display = cm.display, doc = cm.doc;
        e_preventDefault(e);
        var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
        if (addNew && !e.shiftKey ? (ourIndex = doc.sel.contains(start), ourRange = ourIndex > -1 ? ranges[ourIndex] : new Range(start, start)) : (ourRange = doc.sel.primary(),
        ourIndex = doc.sel.primIndex), chromeOS ? e.shiftKey && e.metaKey : e.altKey) type = "rect",
        addNew || (ourRange = new Range(start, start)), start = posFromMouse(cm, e, !0, !0),
        ourIndex = -1; else if ("double" == type) {
            var word = cm.findWordAt(start);
            ourRange = cm.display.shift || doc.extend ? extendRange(doc, ourRange, word.anchor, word.head) : word;
        } else if ("triple" == type) {
            var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
            ourRange = cm.display.shift || doc.extend ? extendRange(doc, ourRange, line.anchor, line.head) : line;
        } else ourRange = extendRange(doc, ourRange, start);
        addNew ? -1 == ourIndex ? (ourIndex = ranges.length, setSelection(doc, normalizeSelection(ranges.concat([ ourRange ]), ourIndex), {
            scroll: !1,
            origin: "*mouse"
        })) : ranges.length > 1 && ranges[ourIndex].empty() && "single" == type && !e.shiftKey ? (setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
            scroll: !1,
            origin: "*mouse"
        }), startSel = doc.sel) : replaceOneSelection(doc, ourIndex, ourRange, sel_mouse) : (ourIndex = 0,
        setSelection(doc, new Selection([ ourRange ], 0), sel_mouse), startSel = doc.sel);
        var lastPos = start, editorSize = display.wrapper.getBoundingClientRect(), counter = 0, move = operation(cm, function(e) {
            e_button(e) ? extend(e) : done(e);
        }), up = operation(cm, done);
        cm.state.selectingText = up, on(document, "mousemove", move), on(document, "mouseup", up);
    }
    function gutterEvent(cm, e, type, prevent) {
        var mX, mY;
        try {
            mX = e.clientX, mY = e.clientY;
        } catch (e) {
            return !1;
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return !1;
        prevent && e_preventDefault(e);
        var display = cm.display, lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
            var g = display.gutters.childNodes[i];
            if (g && g.getBoundingClientRect().right >= mX) {
                return signal(cm, type, cm, lineAtHeight(cm.doc, mY), cm.options.gutters[i], e),
                e_defaultPrevented(e);
            }
        }
    }
    function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", !0);
    }
    function onContextMenu(cm, e) {
        eventInWidget(cm.display, e) || contextMenuInGutter(cm, e) || signalDOMEvent(cm, e, "contextmenu") || cm.display.input.onContextMenu(e);
    }
    function contextMenuInGutter(cm, e) {
        return !!hasHandler(cm, "gutterContextMenu") && gutterEvent(cm, e, "gutterContextMenu", !1);
    }
    function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"),
        clearCaches(cm);
    }
    function guttersChanged(cm) {
        updateGutters(cm), regChange(cm), alignHorizontally(cm);
    }
    function dragDropChanged(cm, value, old) {
        if (!value != !(old && old != Init)) {
            var funcs = cm.display.dragFunctions, toggle = value ? on : off;
            toggle(cm.display.scroller, "dragstart", funcs.start), toggle(cm.display.scroller, "dragenter", funcs.enter),
            toggle(cm.display.scroller, "dragover", funcs.over), toggle(cm.display.scroller, "dragleave", funcs.leave),
            toggle(cm.display.scroller, "drop", funcs.drop);
        }
    }
    function wrappingChanged(cm) {
        cm.options.lineWrapping ? (addClass(cm.display.wrapper, "CodeMirror-wrap"), cm.display.sizer.style.minWidth = "",
        cm.display.sizerWidth = null) : (rmClass(cm.display.wrapper, "CodeMirror-wrap"),
        findMaxLine(cm)), estimateLineHeights(cm), regChange(cm), clearCaches(cm), setTimeout(function() {
            return updateScrollbars(cm);
        }, 100);
    }
    function CodeMirror(place, options) {
        var this$1 = this;
        if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);
        this.options = options = options ? copyObj(options) : {}, copyObj(defaults, options, !1),
        setGuttersForLineNumbers(options);
        var doc = options.value;
        "string" == typeof doc && (doc = new Doc(doc, options.mode, null, options.lineSeparator)),
        this.doc = doc;
        var input = new CodeMirror.inputStyles[options.inputStyle](this), display = this.display = new Display(place, doc, input);
        display.wrapper.CodeMirror = this, updateGutters(this), themeChanged(this), options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"),
        initScrollbars(this), this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: !1,
            delayingBlurEvent: !1,
            focused: !1,
            suppressEdits: !1,
            pasteIncoming: !1,
            cutIncoming: !1,
            selectingText: !1,
            draggingText: !1,
            highlight: new Delayed(),
            keySeq: null,
            specialChars: null
        }, options.autofocus && !mobile && display.input.focus(), ie && ie_version < 11 && setTimeout(function() {
            return this$1.display.input.reset(!0);
        }, 20), registerEventHandlers(this), ensureGlobalHandlers(), startOperation(this),
        this.curOp.forceUpdate = !0, attachDoc(this, doc), options.autofocus && !mobile || this.hasFocus() ? setTimeout(bind(onFocus, this), 20) : onBlur(this);
        for (var opt in optionHandlers) optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this$1, options[opt], Init);
        maybeUpdateLineNumberWidth(this), options.finishInit && options.finishInit(this);
        for (var i = 0; i < initHooks.length; ++i) initHooks[i](this$1);
        endOperation(this), webkit && options.lineWrapping && "optimizelegibility" == getComputedStyle(display.lineDiv).textRendering && (display.lineDiv.style.textRendering = "auto");
    }
    function registerEventHandlers(cm) {
        function finishTouch() {
            d.activeTouch && (touchFinished = setTimeout(function() {
                return d.activeTouch = null;
            }, 1e3), prevTouch = d.activeTouch, prevTouch.end = +new Date());
        }
        function isMouseLikeTouchEvent(e) {
            if (1 != e.touches.length) return !1;
            var touch = e.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
            if (null == other.left) return !0;
            var dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 400;
        }
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown)), ie && ie_version < 11 ? on(d.scroller, "dblclick", operation(cm, function(e) {
            if (!signalDOMEvent(cm, e)) {
                var pos = posFromMouse(cm, e);
                if (pos && !clickInGutter(cm, e) && !eventInWidget(cm.display, e)) {
                    e_preventDefault(e);
                    var word = cm.findWordAt(pos);
                    extendSelection(cm.doc, word.anchor, word.head);
                }
            }
        })) : on(d.scroller, "dblclick", function(e) {
            return signalDOMEvent(cm, e) || e_preventDefault(e);
        }), captureRightClick || on(d.scroller, "contextmenu", function(e) {
            return onContextMenu(cm, e);
        });
        var touchFinished, prevTouch = {
            end: 0
        };
        on(d.scroller, "touchstart", function(e) {
            if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
                d.input.ensurePolled(), clearTimeout(touchFinished);
                var now = +new Date();
                d.activeTouch = {
                    start: now,
                    moved: !1,
                    prev: now - prevTouch.end <= 300 ? prevTouch : null
                }, 1 == e.touches.length && (d.activeTouch.left = e.touches[0].pageX, d.activeTouch.top = e.touches[0].pageY);
            }
        }), on(d.scroller, "touchmove", function() {
            d.activeTouch && (d.activeTouch.moved = !0);
        }), on(d.scroller, "touchend", function(e) {
            var touch = d.activeTouch;
            if (touch && !eventInWidget(d, e) && null != touch.left && !touch.moved && new Date() - touch.start < 300) {
                var range, pos = cm.coordsChar(d.activeTouch, "page");
                range = !touch.prev || farAway(touch, touch.prev) ? new Range(pos, pos) : !touch.prev.prev || farAway(touch, touch.prev.prev) ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))),
                cm.setSelection(range.anchor, range.head), cm.focus(), e_preventDefault(e);
            }
            finishTouch();
        }), on(d.scroller, "touchcancel", finishTouch), on(d.scroller, "scroll", function() {
            d.scroller.clientHeight && (setScrollTop(cm, d.scroller.scrollTop), setScrollLeft(cm, d.scroller.scrollLeft, !0),
            signal(cm, "scroll", cm));
        }), on(d.scroller, "mousewheel", function(e) {
            return onScrollWheel(cm, e);
        }), on(d.scroller, "DOMMouseScroll", function(e) {
            return onScrollWheel(cm, e);
        }), on(d.wrapper, "scroll", function() {
            return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        }), d.dragFunctions = {
            enter: function(e) {
                signalDOMEvent(cm, e) || e_stop(e);
            },
            over: function(e) {
                signalDOMEvent(cm, e) || (onDragOver(cm, e), e_stop(e));
            },
            start: function(e) {
                return onDragStart(cm, e);
            },
            drop: operation(cm, onDrop),
            leave: function(e) {
                signalDOMEvent(cm, e) || clearDragCursor(cm);
            }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function(e) {
            return onKeyUp.call(cm, e);
        }), on(inp, "keydown", operation(cm, onKeyDown)), on(inp, "keypress", operation(cm, onKeyPress)),
        on(inp, "focus", function(e) {
            return onFocus(cm, e);
        }), on(inp, "blur", function(e) {
            return onBlur(cm, e);
        });
    }
    function indentLine(cm, n, how, aggressive) {
        var state, doc = cm.doc;
        null == how && (how = "add"), "smart" == how && (doc.mode.indent ? state = getStateBefore(cm, n) : how = "prev");
        var tabSize = cm.options.tabSize, line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
        line.stateAfter && (line.stateAfter = null);
        var indentation, curSpaceString = line.text.match(/^\s*/)[0];
        if (aggressive || /\S/.test(line.text)) {
            if ("smart" == how && ((indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)) == Pass || indentation > 150)) {
                if (!aggressive) return;
                how = "prev";
            }
        } else indentation = 0, how = "not";
        "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how),
        indentation = Math.max(0, indentation);
        var indentString = "", pos = 0;
        if (cm.options.indentWithTabs) for (var i = Math.floor(indentation / tabSize); i; --i) pos += tabSize,
        indentString += "\t";
        if (pos < indentation && (indentString += spaceStr(indentation - pos)), indentString != curSpaceString) return replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input"),
        line.stateAfter = null, !0;
        for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
            var range = doc.sel.ranges[i$1];
            if (range.head.line == n && range.head.ch < curSpaceString.length) {
                var pos$1 = Pos(n, curSpaceString.length);
                replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
                break;
            }
        }
    }
    function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
    }
    function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = !1, sel || (sel = doc.sel);
        var paste = cm.state.pasteIncoming || "paste" == origin, textLines = splitLinesAuto(inserted), multiPaste = null;
        if (paste && sel.ranges.length > 1) if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) {
                multiPaste = [];
                for (var i = 0; i < lastCopied.text.length; i++) multiPaste.push(doc.splitLines(lastCopied.text[i]));
            }
        } else textLines.length == sel.ranges.length && (multiPaste = map(textLines, function(l) {
            return [ l ];
        }));
        for (var updateInput, i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
            var range = sel.ranges[i$1], from = range.from(), to = range.to();
            range.empty() && (deleted && deleted > 0 ? from = Pos(from.line, from.ch - deleted) : cm.state.overwrite && !paste ? to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) : lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted && (from = to = Pos(from.line, 0))),
            updateInput = cm.curOp.updateInput;
            var changeEvent = {
                from: from,
                to: to,
                text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
            };
            makeChange(cm.doc, changeEvent), signalLater(cm, "inputRead", cm, changeEvent);
        }
        inserted && !paste && triggerElectric(cm, inserted), ensureCursorVisible(cm), cm.curOp.updateInput = updateInput,
        cm.curOp.typing = !0, cm.state.pasteIncoming = cm.state.cutIncoming = !1;
    }
    function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");
        if (pasted) return e.preventDefault(), cm.isReadOnly() || cm.options.disableInput || runInOp(cm, function() {
            return applyTextInput(cm, pasted, 0, null, "paste");
        }), !0;
    }
    function triggerElectric(cm, inserted) {
        if (cm.options.electricChars && cm.options.smartIndent) for (var sel = cm.doc.sel, i = sel.ranges.length - 1; i >= 0; i--) {
            var range = sel.ranges[i];
            if (!(range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line)) {
                var mode = cm.getModeAt(range.head), indented = !1;
                if (mode.electricChars) {
                    for (var j = 0; j < mode.electricChars.length; j++) if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                        indented = indentLine(cm, range.head.line, "smart");
                        break;
                    }
                } else mode.electricInput && mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)) && (indented = indentLine(cm, range.head.line, "smart"));
                indented && signalLater(cm, "electricInput", cm, range.head.line);
            }
        }
    }
    function copyableRanges(cm) {
        for (var text = [], ranges = [], i = 0; i < cm.doc.sel.ranges.length; i++) {
            var line = cm.doc.sel.ranges[i].head.line, lineRange = {
                anchor: Pos(line, 0),
                head: Pos(line + 1, 0)
            };
            ranges.push(lineRange), text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return {
            text: text,
            ranges: ranges
        };
    }
    function disableBrowserMagic(field, spellcheck) {
        field.setAttribute("autocorrect", "off"), field.setAttribute("autocapitalize", "off"),
        field.setAttribute("spellcheck", !!spellcheck);
    }
    function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"), div = elt("div", [ te ], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        return webkit ? te.style.width = "1000px" : te.setAttribute("wrap", "off"), ios && (te.style.border = "1px solid black"),
        disableBrowserMagic(te), div;
    }
    function findPosH(doc, pos, dir, unit, visually) {
        function findNextLine() {
            var l = line + dir;
            return !(l < doc.first || l >= doc.first + doc.size) && (line = l, lineObj = getLine(doc, l));
        }
        function moveOnce(boundToLine) {
            var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, !0);
            if (null == next) {
                if (boundToLine || !findNextLine()) return !1;
                ch = visually ? (dir < 0 ? lineRight : lineLeft)(lineObj) : dir < 0 ? lineObj.text.length : 0;
            } else ch = next;
            return !0;
        }
        var line = pos.line, ch = pos.ch, origDir = dir, lineObj = getLine(doc, line);
        if ("char" == unit) moveOnce(); else if ("column" == unit) moveOnce(!0); else if ("word" == unit || "group" == unit) for (var sawType = null, group = "group" == unit, helper = doc.cm && doc.cm.getHelper(pos, "wordChars"), first = !0; !(dir < 0) || moveOnce(!first); first = !1) {
            var cur = lineObj.text.charAt(ch) || "\n", type = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
            if (!group || first || type || (type = "s"), sawType && sawType != type) {
                dir < 0 && (dir = 1, moveOnce());
                break;
            }
            if (type && (sawType = type), dir > 0 && !moveOnce(!first)) break;
        }
        var result = skipAtomic(doc, Pos(line, ch), pos, origDir, !0);
        return cmp(pos, result) || (result.hitSide = !0), result;
    }
    function findPosV(cm, pos, dir, unit) {
        var y, doc = cm.doc, x = pos.left;
        if ("page" == unit) {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
        for (var target; target = coordsChar(cm, x, y), target.outside; ) {
            if (dir < 0 ? y <= 0 : y >= doc.height) {
                target.hitSide = !0;
                break;
            }
            y += 5 * dir;
        }
        return target;
    }
    function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden) return null;
        var line = getLine(cm.doc, pos.line), info = mapFromLineView(view, line, pos.line), order = getOrder(line), side = "left";
        if (order) {
            side = getBidiPartAt(order, pos.ch) % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        return result.offset = "right" == result.collapse ? result.end : result.start, result;
    }
    function badPos(pos, bad) {
        return bad && (pos.bad = !0), pos;
    }
    function domTextBetween(cm, from, to, fromLine, toLine) {
        function recognizeMarker(id) {
            return function(marker) {
                return marker.id == id;
            };
        }
        function walk(node) {
            if (1 == node.nodeType) {
                var cmText = node.getAttribute("cm-text");
                if (null != cmText) return void (text += "" == cmText ? node.textContent.replace(/\u200b/g, "") : cmText);
                var range, markerID = node.getAttribute("cm-marker");
                if (markerID) {
                    var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                    return void (found.length && (range = found[0].find()) && (text += getBetween(cm.doc, range.from, range.to).join(lineSep)));
                }
                if ("false" == node.getAttribute("contenteditable")) return;
                for (var i = 0; i < node.childNodes.length; i++) walk(node.childNodes[i]);
                /^(pre|div|p)$/i.test(node.nodeName) && (closing = !0);
            } else if (3 == node.nodeType) {
                var val = node.nodeValue;
                if (!val) return;
                closing && (text += lineSep, closing = !1), text += val;
            }
        }
        for (var text = "", closing = !1, lineSep = cm.doc.lineSeparator(); walk(from),
        from != to; ) from = from.nextSibling;
        return text;
    }
    function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
            if (!(lineNode = cm.display.lineDiv.childNodes[offset])) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), !0);
            node = null, offset = 0;
        } else for (lineNode = node; ;lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) return null;
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
        }
        for (var i = 0; i < cm.display.view.length; i++) {
            var lineView = cm.display.view[i];
            if (lineView.node == lineNode) return locateNodeInLineView(lineView, node, offset);
        }
    }
    function locateNodeInLineView(lineView, node, offset) {
        function find(textNode, topNode, offset) {
            for (var i = -1; i < (maps ? maps.length : 0); i++) for (var map = i < 0 ? measure.map : maps[i], j = 0; j < map.length; j += 3) {
                var curNode = map[j + 2];
                if (curNode == textNode || curNode == topNode) {
                    var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]), ch = map[j] + offset;
                    return (offset < 0 || curNode != textNode) && (ch = map[j + (offset ? 1 : 0)]),
                    Pos(line, ch);
                }
            }
        }
        var wrapper = lineView.text.firstChild, bad = !1;
        if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), !0);
        if (node == wrapper && (bad = !0, node = wrapper.childNodes[offset], offset = 0,
        !node)) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
        }
        var textNode = 3 == node.nodeType ? node : null, topNode = node;
        for (textNode || 1 != node.childNodes.length || 3 != node.firstChild.nodeType || (textNode = node.firstChild,
        offset && (offset = textNode.nodeValue.length)); topNode.parentNode != wrapper; ) topNode = topNode.parentNode;
        var measure = lineView.measure, maps = measure.maps, found = find(textNode, topNode, offset);
        if (found) return badPos(found, bad);
        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
            if (found = find(after, after.firstChild, 0)) return badPos(Pos(found.line, found.ch - dist), bad);
            dist += after.textContent.length;
        }
        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
            if (found = find(before, before.firstChild, -1)) return badPos(Pos(found.line, found.ch + dist$1), bad);
            dist$1 += before.textContent.length;
        }
    }
    function fromTextArea(textarea, options) {
        function save() {
            textarea.value = cm.getValue();
        }
        if (options = options ? copyObj(options) : {}, options.value = textarea.value, !options.tabindex && textarea.tabIndex && (options.tabindex = textarea.tabIndex),
        !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder),
        null == options.autofocus) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body;
        }
        var realSubmit;
        if (textarea.form && (on(textarea.form, "submit", save), !options.leaveSubmitMethodAlone)) {
            var form = textarea.form;
            realSubmit = form.submit;
            try {
                var wrappedSubmit = form.submit = function() {
                    save(), form.submit = realSubmit, form.submit(), form.submit = wrappedSubmit;
                };
            } catch (e) {}
        }
        options.finishInit = function(cm) {
            cm.save = save, cm.getTextArea = function() {
                return textarea;
            }, cm.toTextArea = function() {
                cm.toTextArea = isNaN, save(), textarea.parentNode.removeChild(cm.getWrapperElement()),
                textarea.style.display = "", textarea.form && (off(textarea.form, "submit", save),
                "function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit));
            };
        }, textarea.style.display = "none";
        var cm = CodeMirror(function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
    }
    var userAgent = navigator.userAgent, platform = navigator.platform, gecko = /gecko\/\d/i.test(userAgent), ie_upto10 = /MSIE \d/.test(userAgent), ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent), ie = ie_upto10 || ie_11up, ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]), webkit = /WebKit\//.test(userAgent), qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent), chrome = /Chrome\//.test(userAgent), presto = /Opera\//.test(userAgent), safari = /Apple Computer/.test(navigator.vendor), mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent), phantom = /PhantomJS/.test(userAgent), ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent), mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent), mac = ios || /Mac/.test(platform), chromeOS = /\bCrOS\b/.test(userAgent), windows = /win/i.test(platform), presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
    presto_version && (presto_version = Number(presto_version[1])), presto_version && presto_version >= 15 && (presto = !1,
    webkit = !0);
    var range, flipCtrlCmd = mac && (qtwebkit || presto && (null == presto_version || presto_version < 12.11)), captureRightClick = gecko || ie && ie_version >= 9, rmClass = function(node, cls) {
        var current = node.className, match = classTest(cls).exec(current);
        if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
    };
    range = document.createRange ? function(node, start, end, endNode) {
        var r = document.createRange();
        return r.setEnd(endNode || node, end), r.setStart(node, start), r;
    } : function(node, start, end) {
        var r = document.body.createTextRange();
        try {
            r.moveToElementText(node.parentNode);
        } catch (e) {
            return r;
        }
        return r.collapse(!0), r.moveEnd("character", end), r.moveStart("character", start),
        r;
    };
    var selectInput = function(node) {
        node.select();
    };
    ios ? selectInput = function(node) {
        node.selectionStart = 0, node.selectionEnd = node.value.length;
    } : ie && (selectInput = function(node) {
        try {
            node.select();
        } catch (_e) {}
    }), Delayed.prototype.set = function(ms, f) {
        clearTimeout(this.id), this.id = setTimeout(f, ms);
    };
    var zwspSupported, badBidiRects, scrollerGap = 30, Pass = {
        toString: function() {
            return "CodeMirror.Pass";
        }
    }, sel_dontScroll = {
        scroll: !1
    }, sel_mouse = {
        origin: "*mouse"
    }, sel_move = {
        origin: "+move"
    }, spaceStrs = [ "" ], nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/, sawReadOnlySpans = !1, sawCollapsedSpans = !1, bidiOther = null, bidiOrdering = function() {
        function charType(code) {
            return code <= 247 ? lowTypes.charAt(code) : 1424 <= code && code <= 1524 ? "R" : 1536 <= code && code <= 1785 ? arabicTypes.charAt(code - 1536) : 1774 <= code && code <= 2220 ? "r" : 8192 <= code && code <= 8203 ? "w" : 8204 == code ? "b" : "L";
        }
        function BidiSpan(level, from, to) {
            this.level = level, this.from = from, this.to = to;
        }
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111", bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
        return function(str) {
            if (!bidiRE.test(str)) return !1;
            for (var len = str.length, types = [], i = 0; i < len; ++i) types.push(charType(str.charCodeAt(i)));
            for (var i$1 = 0, prev = "L"; i$1 < len; ++i$1) {
                var type = types[i$1];
                "m" == type ? types[i$1] = prev : prev = type;
            }
            for (var i$2 = 0, cur = "L"; i$2 < len; ++i$2) {
                var type$1 = types[i$2];
                "1" == type$1 && "r" == cur ? types[i$2] = "n" : isStrong.test(type$1) && (cur = type$1,
                "r" == type$1 && (types[i$2] = "R"));
            }
            for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
                var type$2 = types[i$3];
                "+" == type$2 && "1" == prev$1 && "1" == types[i$3 + 1] ? types[i$3] = "1" : "," != type$2 || prev$1 != types[i$3 + 1] || "1" != prev$1 && "n" != prev$1 || (types[i$3] = prev$1),
                prev$1 = type$2;
            }
            for (var i$4 = 0; i$4 < len; ++i$4) {
                var type$3 = types[i$4];
                if ("," == type$3) types[i$4] = "N"; else if ("%" == type$3) {
                    var end = void 0;
                    for (end = i$4 + 1; end < len && "%" == types[end]; ++end) ;
                    for (var replace = i$4 && "!" == types[i$4 - 1] || end < len && "1" == types[end] ? "1" : "N", j = i$4; j < end; ++j) types[j] = replace;
                    i$4 = end - 1;
                }
            }
            for (var i$5 = 0, cur$1 = "L"; i$5 < len; ++i$5) {
                var type$4 = types[i$5];
                "L" == cur$1 && "1" == type$4 ? types[i$5] = "L" : isStrong.test(type$4) && (cur$1 = type$4);
            }
            for (var i$6 = 0; i$6 < len; ++i$6) if (isNeutral.test(types[i$6])) {
                var end$1 = void 0;
                for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) ;
                for (var before = "L" == (i$6 ? types[i$6 - 1] : "L"), after = "L" == (end$1 < len ? types[end$1] : "L"), replace$1 = before || after ? "L" : "R", j$1 = i$6; j$1 < end$1; ++j$1) types[j$1] = replace$1;
                i$6 = end$1 - 1;
            }
            for (var m, order = [], i$7 = 0; i$7 < len; ) if (countsAsLeft.test(types[i$7])) {
                var start = i$7;
                for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) ;
                order.push(new BidiSpan(0, start, i$7));
            } else {
                var pos = i$7, at = order.length;
                for (++i$7; i$7 < len && "L" != types[i$7]; ++i$7) ;
                for (var j$2 = pos; j$2 < i$7; ) if (countsAsNum.test(types[j$2])) {
                    pos < j$2 && order.splice(at, 0, new BidiSpan(1, pos, j$2));
                    var nstart = j$2;
                    for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) ;
                    order.splice(at, 0, new BidiSpan(2, nstart, j$2)), pos = j$2;
                } else ++j$2;
                pos < i$7 && order.splice(at, 0, new BidiSpan(1, pos, i$7));
            }
            return 1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length,
            order.unshift(new BidiSpan(0, 0, m[0].length))), 1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length,
            order.push(new BidiSpan(0, len - m[0].length, len))), 2 == order[0].level && order.unshift(new BidiSpan(1, order[0].to, order[0].to)),
            order[0].level != lst(order).level && order.push(new BidiSpan(order[0].level, len, len)),
            order;
        };
    }(), noHandlers = [], on = function(emitter, type, f) {
        if (emitter.addEventListener) emitter.addEventListener(type, f, !1); else if (emitter.attachEvent) emitter.attachEvent("on" + type, f); else {
            var map = emitter._handlers || (emitter._handlers = {});
            map[type] = (map[type] || noHandlers).concat(f);
        }
    }, dragAndDrop = function() {
        if (ie && ie_version < 9) return !1;
        var div = elt("div");
        return "draggable" in div || "dragDrop" in div;
    }(), splitLinesAuto = 3 != "\n\nb".split(/\n/).length ? function(string) {
        for (var pos = 0, result = [], l = string.length; pos <= l; ) {
            var nl = string.indexOf("\n", pos);
            -1 == nl && (nl = string.length);
            var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl), rt = line.indexOf("\r");
            -1 != rt ? (result.push(line.slice(0, rt)), pos += rt + 1) : (result.push(line),
            pos = nl + 1);
        }
        return result;
    } : function(string) {
        return string.split(/\r\n?|\n/);
    }, hasSelection = window.getSelection ? function(te) {
        try {
            return te.selectionStart != te.selectionEnd;
        } catch (e) {
            return !1;
        }
    } : function(te) {
        var range;
        try {
            range = te.ownerDocument.selection.createRange();
        } catch (e) {}
        return !(!range || range.parentElement() != te) && 0 != range.compareEndPoints("StartToEnd", range);
    }, hasCopyEvent = function() {
        var e = elt("div");
        return "oncopy" in e || (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy);
    }(), badZoomedRects = null, modes = {}, mimeModes = {}, modeExtensions = {}, StringStream = function(string, tabSize) {
        this.pos = this.start = 0, this.string = string, this.tabSize = tabSize || 8, this.lastColumnPos = this.lastColumnValue = 0,
        this.lineStart = 0;
    };
    StringStream.prototype = {
        eol: function() {
            return this.pos >= this.string.length;
        },
        sol: function() {
            return this.pos == this.lineStart;
        },
        peek: function() {
            return this.string.charAt(this.pos) || void 0;
        },
        next: function() {
            if (this.pos < this.string.length) return this.string.charAt(this.pos++);
        },
        eat: function(match) {
            var ch = this.string.charAt(this.pos);
            if ("string" == typeof match ? ch == match : ch && (match.test ? match.test(ch) : match(ch))) return ++this.pos,
            ch;
        },
        eatWhile: function(match) {
            for (var start = this.pos; this.eat(match); ) ;
            return this.pos > start;
        },
        eatSpace: function() {
            for (var this$1 = this, start = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); ) ++this$1.pos;
            return this.pos > start;
        },
        skipToEnd: function() {
            this.pos = this.string.length;
        },
        skipTo: function(ch) {
            var found = this.string.indexOf(ch, this.pos);
            if (found > -1) return this.pos = found, !0;
        },
        backUp: function(n) {
            this.pos -= n;
        },
        column: function() {
            return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue),
            this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        indentation: function() {
            return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        match: function(pattern, consume, caseInsensitive) {
            if ("string" != typeof pattern) {
                var match = this.string.slice(this.pos).match(pattern);
                return match && match.index > 0 ? null : (match && !1 !== consume && (this.pos += match[0].length),
                match);
            }
            var cased = function(str) {
                return caseInsensitive ? str.toLowerCase() : str;
            };
            if (cased(this.string.substr(this.pos, pattern.length)) == cased(pattern)) return !1 !== consume && (this.pos += pattern.length),
            !0;
        },
        current: function() {
            return this.string.slice(this.start, this.pos);
        },
        hideFirstChars: function(n, inner) {
            this.lineStart += n;
            try {
                return inner();
            } finally {
                this.lineStart -= n;
            }
        }
    }, eventMixin(Line), Line.prototype.lineNo = function() {
        return lineNo(this);
    };
    var measureText, styleToClassCache = {}, styleToClassCacheWithMode = {}, operationGroup = null, orphanDelayedCallbacks = null, nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    }, wheelSamples = 0, wheelPixelsPerUnit = null;
    ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
    var NativeScrollbars = function(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [ elt("div", null, null, "min-width: 1px") ], "CodeMirror-vscrollbar"), horiz = this.horiz = elt("div", [ elt("div", null, null, "height: 100%; min-height: 1px") ], "CodeMirror-hscrollbar");
        place(vert), place(horiz), on(vert, "scroll", function() {
            vert.clientHeight && scroll(vert.scrollTop, "vertical");
        }), on(horiz, "scroll", function() {
            horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal");
        }), this.checkedZeroWidth = !1, ie && ie_version < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
    };
    NativeScrollbars.prototype.update = function(measure) {
        var needsH = measure.scrollWidth > measure.clientWidth + 1, needsV = measure.scrollHeight > measure.clientHeight + 1, sWidth = measure.nativeBarWidth;
        if (needsV) {
            this.vert.style.display = "block", this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
        } else this.vert.style.display = "", this.vert.firstChild.style.height = "0";
        if (needsH) {
            this.horiz.style.display = "block", this.horiz.style.right = needsV ? sWidth + "px" : "0",
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = measure.scrollWidth - measure.clientWidth + totalWidth + "px";
        } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
        return !this.checkedZeroWidth && measure.clientHeight > 0 && (0 == sWidth && this.zeroWidthHack(),
        this.checkedZeroWidth = !0), {
            right: needsV ? sWidth : 0,
            bottom: needsH ? sWidth : 0
        };
    }, NativeScrollbars.prototype.setScrollLeft = function(pos) {
        this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz);
    }, NativeScrollbars.prototype.setScrollTop = function(pos) {
        this.vert.scrollTop != pos && (this.vert.scrollTop = pos), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert);
    }, NativeScrollbars.prototype.zeroWidthHack = function() {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = w, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none",
        this.disableHoriz = new Delayed(), this.disableVert = new Delayed();
    }, NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay) {
        function maybeDisable() {
            var box = bar.getBoundingClientRect();
            document.elementFromPoint(box.left + 1, box.bottom - 1) != bar ? bar.style.pointerEvents = "none" : delay.set(1e3, maybeDisable);
        }
        bar.style.pointerEvents = "auto", delay.set(1e3, maybeDisable);
    }, NativeScrollbars.prototype.clear = function() {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz), parent.removeChild(this.vert);
    };
    var NullScrollbars = function() {};
    NullScrollbars.prototype.update = function() {
        return {
            bottom: 0,
            right: 0
        };
    }, NullScrollbars.prototype.setScrollLeft = function() {}, NullScrollbars.prototype.setScrollTop = function() {},
    NullScrollbars.prototype.clear = function() {};
    var scrollbarModel = {
        native: NativeScrollbars,
        null: NullScrollbars
    }, nextOpId = 0, DisplayUpdate = function(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport, this.visible = visibleLines(display, cm.doc, viewport),
        this.editorIsHidden = !display.wrapper.offsetWidth, this.wrapperHeight = display.wrapper.clientHeight,
        this.wrapperWidth = display.wrapper.clientWidth, this.oldDisplayWidth = displayWidth(cm),
        this.force = force, this.dims = getDimensions(cm), this.events = [];
    };
    DisplayUpdate.prototype.signal = function(emitter, type) {
        hasHandler(emitter, type) && this.events.push(arguments);
    }, DisplayUpdate.prototype.finish = function() {
        for (var this$1 = this, i = 0; i < this.events.length; i++) signal.apply(null, this$1.events[i]);
    }, Selection.prototype = {
        primary: function() {
            return this.ranges[this.primIndex];
        },
        equals: function(other) {
            var this$1 = this;
            if (other == this) return !0;
            if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return !1;
            for (var i = 0; i < this.ranges.length; i++) {
                var here = this$1.ranges[i], there = other.ranges[i];
                if (0 != cmp(here.anchor, there.anchor) || 0 != cmp(here.head, there.head)) return !1;
            }
            return !0;
        },
        deepCopy: function() {
            for (var this$1 = this, out = [], i = 0; i < this.ranges.length; i++) out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
            return new Selection(out, this.primIndex);
        },
        somethingSelected: function() {
            for (var this$1 = this, i = 0; i < this.ranges.length; i++) if (!this$1.ranges[i].empty()) return !0;
            return !1;
        },
        contains: function(pos, end) {
            var this$1 = this;
            end || (end = pos);
            for (var i = 0; i < this.ranges.length; i++) {
                var range = this$1.ranges[i];
                if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) return i;
            }
            return -1;
        }
    }, Range.prototype = {
        from: function() {
            return minPos(this.anchor, this.head);
        },
        to: function() {
            return maxPos(this.anchor, this.head);
        },
        empty: function() {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        }
    }, LeafChunk.prototype = {
        chunkSize: function() {
            return this.lines.length;
        },
        removeInner: function(at, n) {
            for (var this$1 = this, i = at, e = at + n; i < e; ++i) {
                var line = this$1.lines[i];
                this$1.height -= line.height, cleanUpLine(line), signalLater(line, "delete");
            }
            this.lines.splice(at, n);
        },
        collapse: function(lines) {
            lines.push.apply(lines, this.lines);
        },
        insertInner: function(at, lines, height) {
            var this$1 = this;
            this.height += height, this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i = 0; i < lines.length; ++i) lines[i].parent = this$1;
        },
        iterN: function(at, n, op) {
            for (var this$1 = this, e = at + n; at < e; ++at) if (op(this$1.lines[at])) return !0;
        }
    }, BranchChunk.prototype = {
        chunkSize: function() {
            return this.size;
        },
        removeInner: function(at, n) {
            var this$1 = this;
            this.size -= n;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this$1.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var rm = Math.min(n, sz - at), oldHeight = child.height;
                    if (child.removeInner(at, rm), this$1.height -= oldHeight - child.height, sz == rm && (this$1.children.splice(i--, 1),
                    child.parent = null), 0 == (n -= rm)) break;
                    at = 0;
                } else at -= sz;
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                var lines = [];
                this.collapse(lines), this.children = [ new LeafChunk(lines) ], this.children[0].parent = this;
            }
        },
        collapse: function(lines) {
            for (var this$1 = this, i = 0; i < this.children.length; ++i) this$1.children[i].collapse(lines);
        },
        insertInner: function(at, lines, height) {
            var this$1 = this;
            this.size += lines.length, this.height += height;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this$1.children[i], sz = child.chunkSize();
                if (at <= sz) {
                    if (child.insertInner(at, lines, height), child.lines && child.lines.length > 50) {
                        for (var remaining = child.lines.length % 25 + 25, pos = remaining; pos < child.lines.length; ) {
                            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                            child.height -= leaf.height, this$1.children.splice(++i, 0, leaf), leaf.parent = this$1;
                        }
                        child.lines = child.lines.slice(0, remaining), this$1.maybeSpill();
                    }
                    break;
                }
                at -= sz;
            }
        },
        maybeSpill: function() {
            if (!(this.children.length <= 10)) {
                var me = this;
                do {
                    var spilled = me.children.splice(me.children.length - 5, 5), sibling = new BranchChunk(spilled);
                    if (me.parent) {
                        me.size -= sibling.size, me.height -= sibling.height;
                        var myIndex = indexOf(me.parent.children, me);
                        me.parent.children.splice(myIndex + 1, 0, sibling);
                    } else {
                        var copy = new BranchChunk(me.children);
                        copy.parent = me, me.children = [ copy, sibling ], me = copy;
                    }
                    sibling.parent = me.parent;
                } while (me.children.length > 10);
                me.parent.maybeSpill();
            }
        },
        iterN: function(at, n, op) {
            for (var this$1 = this, i = 0; i < this.children.length; ++i) {
                var child = this$1.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var used = Math.min(n, sz - at);
                    if (child.iterN(at, used, op)) return !0;
                    if (0 == (n -= used)) break;
                    at = 0;
                } else at -= sz;
            }
        }
    }, eventMixin(LineWidget), LineWidget.prototype.clear = function() {
        var this$1 = this, cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (null != no && ws) {
            for (var i = 0; i < ws.length; ++i) ws[i] == this$1 && ws.splice(i--, 1);
            ws.length || (line.widgets = null);
            var height = widgetHeight(this);
            updateLineHeight(line, Math.max(0, line.height - height)), cm && runInOp(cm, function() {
                adjustScrollWhenAboveVisible(cm, line, -height), regLineChange(cm, no, "widget");
            });
        }
    }, LineWidget.prototype.changed = function() {
        var oldH = this.height, cm = this.doc.cm, line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        diff && (updateLineHeight(line, line.height + diff), cm && runInOp(cm, function() {
            cm.curOp.forceUpdate = !0, adjustScrollWhenAboveVisible(cm, line, diff);
        }));
    };
    var nextMarkerId = 0;
    eventMixin(TextMarker), TextMarker.prototype.clear = function() {
        var this$1 = this;
        if (!this.explicitlyCleared) {
            var cm = this.doc.cm, withOp = cm && !cm.curOp;
            if (withOp && startOperation(cm), hasHandler(this, "clear")) {
                var found = this.find();
                found && signalLater(this, "clear", found.from, found.to);
            }
            for (var min = null, max = null, i = 0; i < this.lines.length; ++i) {
                var line = this$1.lines[i], span = getMarkedSpanFor(line.markedSpans, this$1);
                cm && !this$1.collapsed ? regLineChange(cm, lineNo(line), "text") : cm && (null != span.to && (max = lineNo(line)),
                null != span.from && (min = lineNo(line))), line.markedSpans = removeMarkedSpan(line.markedSpans, span),
                null == span.from && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm && updateLineHeight(line, textHeight(cm.display));
            }
            if (cm && this.collapsed && !cm.options.lineWrapping) for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
                var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
                len > cm.display.maxLineLength && (cm.display.maxLine = visual, cm.display.maxLineLength = len,
                cm.display.maxLineChanged = !0);
            }
            null != min && cm && this.collapsed && regChange(cm, min, max + 1), this.lines.length = 0,
            this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1,
            cm && reCheckSelection(cm.doc)), cm && signalLater(cm, "markerCleared", cm, this),
            withOp && endOperation(cm), this.parent && this.parent.clear();
        }
    }, TextMarker.prototype.find = function(side, lineObj) {
        var this$1 = this;
        null == side && "bookmark" == this.type && (side = 1);
        for (var from, to, i = 0; i < this.lines.length; ++i) {
            var line = this$1.lines[i], span = getMarkedSpanFor(line.markedSpans, this$1);
            if (null != span.from && (from = Pos(lineObj ? line : lineNo(line), span.from),
            -1 == side)) return from;
            if (null != span.to && (to = Pos(lineObj ? line : lineNo(line), span.to), 1 == side)) return to;
        }
        return from && {
            from: from,
            to: to
        };
    }, TextMarker.prototype.changed = function() {
        var pos = this.find(-1, !0), widget = this, cm = this.doc.cm;
        pos && cm && runInOp(cm, function() {
            var line = pos.line, lineN = lineNo(pos.line), view = findViewForLine(cm, lineN);
            if (view && (clearLineMeasurementCacheFor(view), cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0),
            cm.curOp.updateMaxLine = !0, !lineIsHidden(widget.doc, line) && null != widget.height) {
                var oldHeight = widget.height;
                widget.height = null;
                var dHeight = widgetHeight(widget) - oldHeight;
                dHeight && updateLineHeight(line, line.height + dHeight);
            }
        });
    }, TextMarker.prototype.attachLine = function(line) {
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            op.maybeHiddenMarkers && -1 != indexOf(op.maybeHiddenMarkers, this) || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(line);
    }, TextMarker.prototype.detachLine = function(line) {
        if (this.lines.splice(indexOf(this.lines, line), 1), !this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
    }, eventMixin(SharedTextMarker), SharedTextMarker.prototype.clear = function() {
        var this$1 = this;
        if (!this.explicitlyCleared) {
            this.explicitlyCleared = !0;
            for (var i = 0; i < this.markers.length; ++i) this$1.markers[i].clear();
            signalLater(this, "clear");
        }
    }, SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj);
    };
    var nextDocId = 0, Doc = function(text, mode, firstLine, lineSep) {
        if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
        null == firstLine && (firstLine = 0), BranchChunk.call(this, [ new LeafChunk([ new Line("", null) ]) ]),
        this.first = firstLine, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1,
        this.cleanGeneration = 1, this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start), this.history = new History(null), this.id = ++nextDocId,
        this.modeOption = mode, this.lineSep = lineSep, this.extend = !1, "string" == typeof text && (text = this.splitLines(text)),
        updateDoc(this, {
            from: start,
            to: start,
            text: text
        }), setSelection(this, simpleSelection(start), sel_dontScroll);
    };
    Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function(from, to, op) {
            op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from);
        },
        insert: function(at, lines) {
            for (var height = 0, i = 0; i < lines.length; ++i) height += lines[i].height;
            this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n) {
            this.removeInner(at - this.first, n);
        },
        getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            return !1 === lineSep ? lines : lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function(code) {
            var top = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
                from: top,
                to: Pos(last, getLine(this, last).text.length),
                text: this.splitLines(code),
                origin: "setValue",
                full: !0
            }, !0), setSelection(this, simpleSelection(top));
        }),
        replaceRange: function(code, from, to, origin) {
            from = clipPos(this, from), to = to ? clipPos(this, to) : from, replaceRange(this, code, from, to, origin);
        },
        getRange: function(from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            return !1 === lineSep ? lines : lines.join(lineSep || this.lineSeparator());
        },
        getLine: function(line) {
            var l = this.getLineHandle(line);
            return l && l.text;
        },
        getLineHandle: function(line) {
            if (isLine(this, line)) return getLine(this, line);
        },
        getLineNumber: function(line) {
            return lineNo(line);
        },
        getLineHandleVisualStart: function(line) {
            return "number" == typeof line && (line = getLine(this, line)), visualLine(line);
        },
        lineCount: function() {
            return this.size;
        },
        firstLine: function() {
            return this.first;
        },
        lastLine: function() {
            return this.first + this.size - 1;
        },
        clipPos: function(pos) {
            return clipPos(this, pos);
        },
        getCursor: function(start) {
            var range = this.sel.primary();
            return null == start || "head" == start ? range.head : "anchor" == start ? range.anchor : "end" == start || "to" == start || !1 === start ? range.to() : range.from();
        },
        listSelections: function() {
            return this.sel.ranges;
        },
        somethingSelected: function() {
            return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function(line, ch, options) {
            setSimpleSelection(this, clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
            extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
            extendSelections(this, clipPosArray(this, map(this.sel.ranges, f)), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
            var this$1 = this;
            if (ranges.length) {
                for (var out = [], i = 0; i < ranges.length; i++) out[i] = new Range(clipPos(this$1, ranges[i].anchor), clipPos(this$1, ranges[i].head));
                null == primary && (primary = Math.min(ranges.length - 1, this.sel.primIndex)),
                setSelection(this, normalizeSelection(out, primary), options);
            }
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor))), setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
        }),
        getSelection: function(lineSep) {
            for (var lines, this$1 = this, ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
                lines = lines ? lines.concat(sel) : sel;
            }
            return !1 === lineSep ? lines : lines.join(lineSep || this.lineSeparator());
        },
        getSelections: function(lineSep) {
            for (var this$1 = this, parts = [], ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
                !1 !== lineSep && (sel = sel.join(lineSep || this$1.lineSeparator())), parts[i] = sel;
            }
            return parts;
        },
        replaceSelection: function(code, collapse, origin) {
            for (var dup = [], i = 0; i < this.sel.ranges.length; i++) dup[i] = code;
            this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
            for (var this$1 = this, changes = [], sel = this.sel, i = 0; i < sel.ranges.length; i++) {
                var range = sel.ranges[i];
                changes[i] = {
                    from: range.from(),
                    to: range.to(),
                    text: this$1.splitLines(code[i]),
                    origin: origin
                };
            }
            for (var newSel = collapse && "end" != collapse && computeReplacedSel(this, changes, collapse), i$1 = changes.length - 1; i$1 >= 0; i$1--) makeChange(this$1, changes[i$1]);
            newSel ? setSelectionReplaceHistory(this, newSel) : this.cm && ensureCursorVisible(this.cm);
        }),
        undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", !0);
        }),
        redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", !0);
        }),
        setExtending: function(val) {
            this.extend = val;
        },
        getExtending: function() {
            return this.extend;
        },
        historySize: function() {
            for (var hist = this.history, done = 0, undone = 0, i = 0; i < hist.done.length; i++) hist.done[i].ranges || ++done;
            for (var i$1 = 0; i$1 < hist.undone.length; i$1++) hist.undone[i$1].ranges || ++undone;
            return {
                undo: done,
                redo: undone
            };
        },
        clearHistory: function() {
            this.history = new History(this.history.maxGeneration);
        },
        markClean: function() {
            this.cleanGeneration = this.changeGeneration(!0);
        },
        changeGeneration: function(forceSplit) {
            return forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null),
            this.history.generation;
        },
        isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function() {
            return {
                done: copyHistoryArray(this.history.done),
                undone: copyHistoryArray(this.history.undone)
            };
        },
        setHistory: function(histData) {
            var hist = this.history = new History(this.history.maxGeneration);
            hist.done = copyHistoryArray(histData.done.slice(0), null, !0), hist.undone = copyHistoryArray(histData.undone.slice(0), null, !0);
        },
        setGutterMarker: docMethodOp(function(line, gutterID, value) {
            return changeLine(this, line, "gutter", function(line) {
                var markers = line.gutterMarkers || (line.gutterMarkers = {});
                return markers[gutterID] = value, !value && isEmpty(markers) && (line.gutterMarkers = null),
                !0;
            });
        }),
        clearGutter: docMethodOp(function(gutterID) {
            var this$1 = this;
            this.iter(function(line) {
                line.gutterMarkers && line.gutterMarkers[gutterID] && changeLine(this$1, line, "gutter", function() {
                    return line.gutterMarkers[gutterID] = null, isEmpty(line.gutterMarkers) && (line.gutterMarkers = null),
                    !0;
                });
            });
        }),
        lineInfo: function(line) {
            var n;
            if ("number" == typeof line) {
                if (!isLine(this, line)) return null;
                if (n = line, !(line = getLine(this, line))) return null;
            } else if (null == (n = lineNo(line))) return null;
            return {
                line: n,
                handle: line,
                text: line.text,
                gutterMarkers: line.gutterMarkers,
                textClass: line.textClass,
                bgClass: line.bgClass,
                wrapClass: line.wrapClass,
                widgets: line.widgets
            };
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
                if (line[prop]) {
                    if (classTest(cls).test(line[prop])) return !1;
                    line[prop] += " " + cls;
                } else line[prop] = cls;
                return !0;
            });
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass", cur = line[prop];
                if (!cur) return !1;
                if (null == cls) line[prop] = null; else {
                    var found = cur.match(classTest(cls));
                    if (!found) return !1;
                    var end = found.index + found[0].length;
                    line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null;
                }
                return !0;
            });
        }),
        addLineWidget: docMethodOp(function(handle, node, options) {
            return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function(widget) {
            widget.clear();
        },
        markText: function(from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function(pos, options) {
            var realOpts = {
                replacedWith: options && (null == options.nodeType ? options.widget : options),
                insertLeft: options && options.insertLeft,
                clearWhenEmpty: !1,
                shared: options && options.shared,
                handleMouseEvents: options && options.handleMouseEvents
            };
            return pos = clipPos(this, pos), markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function(pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans) for (var i = 0; i < spans.length; ++i) {
                var span = spans[i];
                (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker);
            }
            return markers;
        },
        findMarks: function(from, to, filter) {
            from = clipPos(this, from), to = clipPos(this, to);
            var found = [], lineNo = from.line;
            return this.iter(from.line, to.line + 1, function(line) {
                var spans = line.markedSpans;
                if (spans) for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    null != span.to && lineNo == from.line && from.ch >= span.to || null == span.from && lineNo != from.line || null != span.from && lineNo == to.line && span.from >= to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker);
                }
                ++lineNo;
            }), found;
        },
        getAllMarks: function() {
            var markers = [];
            return this.iter(function(line) {
                var sps = line.markedSpans;
                if (sps) for (var i = 0; i < sps.length; ++i) null != sps[i].from && markers.push(sps[i].marker);
            }), markers;
        },
        posFromIndex: function(off) {
            var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
            return this.iter(function(line) {
                var sz = line.text.length + sepSize;
                if (sz > off) return ch = off, !0;
                off -= sz, ++lineNo;
            }), clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function(coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0) return 0;
            var sepSize = this.lineSeparator().length;
            return this.iter(this.first, coords.line, function(line) {
                index += line.text.length + sepSize;
            }), index;
        },
        copy: function(copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep);
            return doc.scrollTop = this.scrollTop, doc.scrollLeft = this.scrollLeft, doc.sel = this.sel,
            doc.extend = !1, copyHistory && (doc.history.undoDepth = this.history.undoDepth,
            doc.setHistory(this.getHistory())), doc;
        },
        linkedDoc: function(options) {
            options || (options = {});
            var from = this.first, to = this.first + this.size;
            null != options.from && options.from > from && (from = options.from), null != options.to && options.to < to && (to = options.to);
            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
            return options.sharedHist && (copy.history = this.history), (this.linked || (this.linked = [])).push({
                doc: copy,
                sharedHist: options.sharedHist
            }), copy.linked = [ {
                doc: this,
                isParent: !0,
                sharedHist: options.sharedHist
            } ], copySharedMarkers(copy, findSharedMarkers(this)), copy;
        },
        unlinkDoc: function(other) {
            var this$1 = this;
            if (other instanceof CodeMirror && (other = other.doc), this.linked) for (var i = 0; i < this.linked.length; ++i) {
                var link = this$1.linked[i];
                if (link.doc == other) {
                    this$1.linked.splice(i, 1), other.unlinkDoc(this$1), detachSharedMarkers(findSharedMarkers(this$1));
                    break;
                }
            }
            if (other.history == this.history) {
                var splitIds = [ other.id ];
                linkedDocs(other, function(doc) {
                    return splitIds.push(doc.id);
                }, !0), other.history = new History(null), other.history.done = copyHistoryArray(this.history.done, splitIds),
                other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
        },
        iterLinkedDocs: function(f) {
            linkedDocs(this, f);
        },
        getMode: function() {
            return this.mode;
        },
        getEditor: function() {
            return this.cm;
        },
        splitLines: function(str) {
            return this.lineSep ? str.split(this.lineSep) : splitLinesAuto(str);
        },
        lineSeparator: function() {
            return this.lineSep || "\n";
        }
    }), Doc.prototype.eachLine = Doc.prototype.iter;
    for (var lastDrop = 0, globalsRegistered = !1, keyNames = {
        3: "Enter",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        127: "Delete",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
    }, i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    for (var i$1 = 65; i$1 <= 90; i$1++) keyNames[i$1] = String.fromCharCode(i$1);
    for (var i$2 = 1; i$2 <= 12; i$2++) keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
    var keyMap = {};
    keyMap.basic = {
        Left: "goCharLeft",
        Right: "goCharRight",
        Up: "goLineUp",
        Down: "goLineDown",
        End: "goLineEnd",
        Home: "goLineStartSmart",
        PageUp: "goPageUp",
        PageDown: "goPageDown",
        Delete: "delCharAfter",
        Backspace: "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        Tab: "defaultTab",
        "Shift-Tab": "indentAuto",
        Enter: "newlineAndIndent",
        Insert: "toggleOverwrite",
        Esc: "singleSelection"
    }, keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
    }, keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight",
        "Alt-B": "goWordLeft",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
    }, keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: [ "basic", "emacsy" ]
    }, keyMap.default = mac ? keyMap.macDefault : keyMap.pcDefault;
    var lastClick, lastDoubleClick, commands = {
        selectAll: selectAll,
        singleSelection: function(cm) {
            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function(cm) {
            return deleteNearSelection(cm, function(range) {
                if (range.empty()) {
                    var len = getLine(cm.doc, range.head.line).text.length;
                    return range.head.ch == len && range.head.line < cm.lastLine() ? {
                        from: range.head,
                        to: Pos(range.head.line + 1, 0)
                    } : {
                        from: range.head,
                        to: Pos(range.head.line, len)
                    };
                }
                return {
                    from: range.from(),
                    to: range.to()
                };
            });
        },
        deleteLine: function(cm) {
            return deleteNearSelection(cm, function(range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                };
            });
        },
        delLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: range.from()
                };
            });
        },
        delWrappedLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return {
                    from: cm.coordsChar({
                        left: 0,
                        top: top
                    }, "div"),
                    to: range.from()
                };
            });
        },
        delWrappedLineRight: function(cm) {
            return deleteNearSelection(cm, function(range) {
                var top = cm.charCoords(range.head, "div").top + 5, rightPos = cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, "div");
                return {
                    from: range.from(),
                    to: rightPos
                };
            });
        },
        undo: function(cm) {
            return cm.undo();
        },
        redo: function(cm) {
            return cm.redo();
        },
        undoSelection: function(cm) {
            return cm.undoSelection();
        },
        redoSelection: function(cm) {
            return cm.redoSelection();
        },
        goDocStart: function(cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function(cm) {
            return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return lineStart(cm, range.head.line);
            }, {
                origin: "+move",
                bias: 1
            });
        },
        goLineStartSmart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return lineStartSmart(cm, range.head);
            }, {
                origin: "+move",
                bias: 1
            });
        },
        goLineEnd: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                return lineEnd(cm, range.head.line);
            }, {
                origin: "+move",
                bias: -1
            });
        },
        goLineRight: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, "div");
            }, sel_move);
        },
        goLineLeft: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return cm.coordsChar({
                    left: 0,
                    top: top
                }, "div");
            }, sel_move);
        },
        goLineLeftSmart: function(cm) {
            return cm.extendSelectionsBy(function(range) {
                var top = cm.charCoords(range.head, "div").top + 5, pos = cm.coordsChar({
                    left: 0,
                    top: top
                }, "div");
                return pos.ch < cm.getLine(pos.line).search(/\S/) ? lineStartSmart(cm, range.head) : pos;
            }, sel_move);
        },
        goLineUp: function(cm) {
            return cm.moveV(-1, "line");
        },
        goLineDown: function(cm) {
            return cm.moveV(1, "line");
        },
        goPageUp: function(cm) {
            return cm.moveV(-1, "page");
        },
        goPageDown: function(cm) {
            return cm.moveV(1, "page");
        },
        goCharLeft: function(cm) {
            return cm.moveH(-1, "char");
        },
        goCharRight: function(cm) {
            return cm.moveH(1, "char");
        },
        goColumnLeft: function(cm) {
            return cm.moveH(-1, "column");
        },
        goColumnRight: function(cm) {
            return cm.moveH(1, "column");
        },
        goWordLeft: function(cm) {
            return cm.moveH(-1, "word");
        },
        goGroupRight: function(cm) {
            return cm.moveH(1, "group");
        },
        goGroupLeft: function(cm) {
            return cm.moveH(-1, "group");
        },
        goWordRight: function(cm) {
            return cm.moveH(1, "word");
        },
        delCharBefore: function(cm) {
            return cm.deleteH(-1, "char");
        },
        delCharAfter: function(cm) {
            return cm.deleteH(1, "char");
        },
        delWordBefore: function(cm) {
            return cm.deleteH(-1, "word");
        },
        delWordAfter: function(cm) {
            return cm.deleteH(1, "word");
        },
        delGroupBefore: function(cm) {
            return cm.deleteH(-1, "group");
        },
        delGroupAfter: function(cm) {
            return cm.deleteH(1, "group");
        },
        indentAuto: function(cm) {
            return cm.indentSelection("smart");
        },
        indentMore: function(cm) {
            return cm.indentSelection("add");
        },
        indentLess: function(cm) {
            return cm.indentSelection("subtract");
        },
        insertTab: function(cm) {
            return cm.replaceSelection("\t");
        },
        insertSoftTab: function(cm) {
            for (var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize, i = 0; i < ranges.length; i++) {
                var pos = ranges[i].from(), col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                spaces.push(spaceStr(tabSize - col % tabSize));
            }
            cm.replaceSelections(spaces);
        },
        defaultTab: function(cm) {
            cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab");
        },
        transposeChars: function(cm) {
            return runInOp(cm, function() {
                for (var ranges = cm.listSelections(), newSel = [], i = 0; i < ranges.length; i++) if (ranges[i].empty()) {
                    var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                    if (line) if (cur.ch == line.length && (cur = new Pos(cur.line, cur.ch - 1)), cur.ch > 0) cur = new Pos(cur.line, cur.ch + 1),
                    cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose"); else if (cur.line > cm.doc.first) {
                        var prev = getLine(cm.doc, cur.line - 1).text;
                        prev && (cur = new Pos(cur.line, 1), cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose"));
                    }
                    newSel.push(new Range(cur, cur));
                }
                cm.setSelections(newSel);
            });
        },
        newlineAndIndent: function(cm) {
            return runInOp(cm, function() {
                for (var sels = cm.listSelections(), i = sels.length - 1; i >= 0; i--) cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
                sels = cm.listSelections();
                for (var i$1 = 0; i$1 < sels.length; i$1++) cm.indentLine(sels[i$1].from().line, null, !0);
                ensureCursorVisible(cm);
            });
        },
        openLine: function(cm) {
            return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function(cm) {
            return cm.toggleOverwrite();
        }
    }, stopSeq = new Delayed(), lastStoppedKey = null, Init = {
        toString: function() {
            return "CodeMirror.Init";
        }
    }, defaults = {}, optionHandlers = {};
    CodeMirror.defaults = defaults, CodeMirror.optionHandlers = optionHandlers;
    var initHooks = [];
    CodeMirror.defineInitHook = function(f) {
        return initHooks.push(f);
    };
    var lastCopied = null, ContentEditableInput = function(cm) {
        this.cm = cm, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null,
        this.polling = new Delayed(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null;
    };
    ContentEditableInput.prototype.init = function(display) {
        function onCopyCut(e) {
            if (!signalDOMEvent(cm, e)) {
                if (cm.somethingSelected()) setLastCopied({
                    lineWise: !1,
                    text: cm.getSelections()
                }), "cut" == e.type && cm.replaceSelection("", null, "cut"); else {
                    if (!cm.options.lineWiseCopyCut) return;
                    var ranges = copyableRanges(cm);
                    setLastCopied({
                        lineWise: !0,
                        text: ranges.text
                    }), "cut" == e.type && cm.operation(function() {
                        cm.setSelections(ranges.ranges, 0, sel_dontScroll), cm.replaceSelection("", null, "cut");
                    });
                }
                if (e.clipboardData) {
                    e.clipboardData.clearData();
                    var content = lastCopied.text.join("\n");
                    if (e.clipboardData.setData("Text", content), e.clipboardData.getData("Text") == content) return void e.preventDefault();
                }
                var kludge = hiddenTextarea(), te = kludge.firstChild;
                cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild), te.value = lastCopied.text.join("\n");
                var hadFocus = document.activeElement;
                selectInput(te), setTimeout(function() {
                    cm.display.lineSpace.removeChild(kludge), hadFocus.focus(), hadFocus == div && input.showPrimarySelection();
                }, 50);
            }
        }
        var this$1 = this, input = this, cm = input.cm, div = input.div = display.lineDiv;
        disableBrowserMagic(div, cm.options.spellcheck), on(div, "paste", function(e) {
            signalDOMEvent(cm, e) || handlePaste(e, cm) || ie_version <= 11 && setTimeout(operation(cm, function() {
                input.pollContent() || regChange(cm);
            }), 20);
        }), on(div, "compositionstart", function(e) {
            this$1.composing = {
                data: e.data,
                done: !1
            };
        }), on(div, "compositionupdate", function(e) {
            this$1.composing || (this$1.composing = {
                data: e.data,
                done: !1
            });
        }), on(div, "compositionend", function(e) {
            this$1.composing && (e.data != this$1.composing.data && this$1.readFromDOMSoon(),
            this$1.composing.done = !0);
        }), on(div, "touchstart", function() {
            return input.forceCompositionEnd();
        }), on(div, "input", function() {
            this$1.composing || this$1.readFromDOMSoon();
        }), on(div, "copy", onCopyCut), on(div, "cut", onCopyCut);
    }, ContentEditableInput.prototype.prepareSelection = function() {
        var result = prepareSelection(this.cm, !1);
        return result.focus = this.cm.state.focused, result;
    }, ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
        info && this.cm.display.view.length && ((info.focus || takeFocus) && this.showPrimarySelection(),
        this.showMultipleSelections(info));
    }, ContentEditableInput.prototype.showPrimarySelection = function() {
        var sel = window.getSelection(), prim = this.cm.doc.sel.primary(), curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset), curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
        if (!curAnchor || curAnchor.bad || !curFocus || curFocus.bad || 0 != cmp(minPos(curAnchor, curFocus), prim.from()) || 0 != cmp(maxPos(curAnchor, curFocus), prim.to())) {
            var start = posToDOM(this.cm, prim.from()), end = posToDOM(this.cm, prim.to());
            if (start || end) {
                var view = this.cm.display.view, old = sel.rangeCount && sel.getRangeAt(0);
                if (start) {
                    if (!end) {
                        var measure = view[view.length - 1].measure, map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
                        end = {
                            node: map[map.length - 1],
                            offset: map[map.length - 2] - map[map.length - 3]
                        };
                    }
                } else start = {
                    node: view[0].measure.map[2],
                    offset: 0
                };
                var rng;
                try {
                    rng = range(start.node, start.offset, end.offset, end.node);
                } catch (e) {}
                rng && (!gecko && this.cm.state.focused ? (sel.collapse(start.node, start.offset),
                rng.collapsed || (sel.removeAllRanges(), sel.addRange(rng))) : (sel.removeAllRanges(),
                sel.addRange(rng)), old && null == sel.anchorNode ? sel.addRange(old) : gecko && this.startGracePeriod()),
                this.rememberSelection();
            }
        }
    }, ContentEditableInput.prototype.startGracePeriod = function() {
        var this$1 = this;
        clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
            this$1.gracePeriod = !1, this$1.selectionChanged() && this$1.cm.operation(function() {
                return this$1.cm.curOp.selectionChanged = !0;
            });
        }, 20);
    }, ContentEditableInput.prototype.showMultipleSelections = function(info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors), removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    }, ContentEditableInput.prototype.rememberSelection = function() {
        var sel = window.getSelection();
        this.lastAnchorNode = sel.anchorNode, this.lastAnchorOffset = sel.anchorOffset,
        this.lastFocusNode = sel.focusNode, this.lastFocusOffset = sel.focusOffset;
    }, ContentEditableInput.prototype.selectionInEditor = function() {
        var sel = window.getSelection();
        if (!sel.rangeCount) return !1;
        var node = sel.getRangeAt(0).commonAncestorContainer;
        return contains(this.div, node);
    }, ContentEditableInput.prototype.focus = function() {
        "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0),
        this.div.focus());
    }, ContentEditableInput.prototype.blur = function() {
        this.div.blur();
    }, ContentEditableInput.prototype.getField = function() {
        return this.div;
    }, ContentEditableInput.prototype.supportsTouch = function() {
        return !0;
    }, ContentEditableInput.prototype.receivedFocus = function() {
        function poll() {
            input.cm.state.focused && (input.pollSelection(), input.polling.set(input.cm.options.pollInterval, poll));
        }
        var input = this;
        this.selectionInEditor() ? this.pollSelection() : runInOp(this.cm, function() {
            return input.cm.curOp.selectionChanged = !0;
        }), this.polling.set(this.cm.options.pollInterval, poll);
    }, ContentEditableInput.prototype.selectionChanged = function() {
        var sel = window.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    }, ContentEditableInput.prototype.pollSelection = function() {
        if (!this.composing && null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
            var sel = window.getSelection(), cm = this.cm;
            this.rememberSelection();
            var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset), head = domToPos(cm, sel.focusNode, sel.focusOffset);
            anchor && head && runInOp(cm, function() {
                setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll), (anchor.bad || head.bad) && (cm.curOp.selectionChanged = !0);
            });
        }
    }, ContentEditableInput.prototype.pollContent = function() {
        null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
        var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary(), from = sel.from(), to = sel.to();
        if (0 == from.ch && from.line > cm.firstLine() && (from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length)),
        to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine() && (to = Pos(to.line + 1, 0)),
        from.line < display.viewFrom || to.line > display.viewTo - 1) return !1;
        var fromIndex, fromLine, fromNode;
        from.line == display.viewFrom || 0 == (fromIndex = findViewIndex(cm, from.line)) ? (fromLine = lineNo(display.view[0].line),
        fromNode = display.view[0].node) : (fromLine = lineNo(display.view[fromIndex].line),
        fromNode = display.view[fromIndex - 1].node.nextSibling);
        var toLine, toNode, toIndex = findViewIndex(cm, to.line);
        if (toIndex == display.view.length - 1 ? (toLine = display.viewTo - 1, toNode = display.lineDiv.lastChild) : (toLine = lineNo(display.view[toIndex + 1].line) - 1,
        toNode = display.view[toIndex + 1].node.previousSibling), !fromNode) return !1;
        for (var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine)), oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length)); newText.length > 1 && oldText.length > 1; ) if (lst(newText) == lst(oldText)) newText.pop(),
        oldText.pop(), toLine--; else {
            if (newText[0] != oldText[0]) break;
            newText.shift(), oldText.shift(), fromLine++;
        }
        for (var cutFront = 0, cutEnd = 0, newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length); cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront); ) ++cutFront;
        for (var newBot = lst(newText), oldBot = lst(oldText), maxCutEnd = Math.min(newBot.length - (1 == newText.length ? cutFront : 0), oldBot.length - (1 == oldText.length ? cutFront : 0)); cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1); ) ++cutEnd;
        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, ""),
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
        var chFrom = Pos(fromLine, cutFront), chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
        return newText.length > 1 || newText[0] || cmp(chFrom, chTo) ? (replaceRange(cm.doc, newText, chFrom, chTo, "+input"),
        !0) : void 0;
    }, ContentEditableInput.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
    }, ContentEditableInput.prototype.reset = function() {
        this.forceCompositionEnd();
    }, ContentEditableInput.prototype.forceCompositionEnd = function() {
        this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.pollContent() || regChange(this.cm),
        this.div.blur(), this.div.focus());
    }, ContentEditableInput.prototype.readFromDOMSoon = function() {
        var this$1 = this;
        null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
            if (this$1.readDOMTimeout = null, this$1.composing) {
                if (!this$1.composing.done) return;
                this$1.composing = null;
            }
            !this$1.cm.isReadOnly() && this$1.pollContent() || runInOp(this$1.cm, function() {
                return regChange(this$1.cm);
            });
        }, 80));
    }, ContentEditableInput.prototype.setUneditable = function(node) {
        node.contentEditable = "false";
    }, ContentEditableInput.prototype.onKeyPress = function(e) {
        e.preventDefault(), this.cm.isReadOnly() || operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0);
    }, ContentEditableInput.prototype.readOnlyChanged = function(val) {
        this.div.contentEditable = String("nocursor" != val);
    }, ContentEditableInput.prototype.onContextMenu = function() {}, ContentEditableInput.prototype.resetPosition = function() {},
    ContentEditableInput.prototype.needsContentAttribute = !0;
    var TextareaInput = function(cm) {
        this.cm = cm, this.prevInput = "", this.pollingFast = !1, this.polling = new Delayed(),
        this.inaccurateSelection = !1, this.hasSelection = !1, this.composing = null;
    };
    TextareaInput.prototype.init = function(display) {
        function prepareCopyCut(e) {
            if (!signalDOMEvent(cm, e)) {
                if (cm.somethingSelected()) setLastCopied({
                    lineWise: !1,
                    text: cm.getSelections()
                }), input.inaccurateSelection && (input.prevInput = "", input.inaccurateSelection = !1,
                te.value = lastCopied.text.join("\n"), selectInput(te)); else {
                    if (!cm.options.lineWiseCopyCut) return;
                    var ranges = copyableRanges(cm);
                    setLastCopied({
                        lineWise: !0,
                        text: ranges.text
                    }), "cut" == e.type ? cm.setSelections(ranges.ranges, null, sel_dontScroll) : (input.prevInput = "",
                    te.value = ranges.text.join("\n"), selectInput(te));
                }
                "cut" == e.type && (cm.state.cutIncoming = !0);
            }
        }
        var this$1 = this, input = this, cm = this.cm, div = this.wrapper = hiddenTextarea(), te = this.textarea = div.firstChild;
        display.wrapper.insertBefore(div, display.wrapper.firstChild), ios && (te.style.width = "0px"),
        on(te, "input", function() {
            ie && ie_version >= 9 && this$1.hasSelection && (this$1.hasSelection = null), input.poll();
        }), on(te, "paste", function(e) {
            signalDOMEvent(cm, e) || handlePaste(e, cm) || (cm.state.pasteIncoming = !0, input.fastPoll());
        }), on(te, "cut", prepareCopyCut), on(te, "copy", prepareCopyCut), on(display.scroller, "paste", function(e) {
            eventInWidget(display, e) || signalDOMEvent(cm, e) || (cm.state.pasteIncoming = !0,
            input.focus());
        }), on(display.lineSpace, "selectstart", function(e) {
            eventInWidget(display, e) || e_preventDefault(e);
        }), on(te, "compositionstart", function() {
            var start = cm.getCursor("from");
            input.composing && input.composing.range.clear(), input.composing = {
                start: start,
                range: cm.markText(start, cm.getCursor("to"), {
                    className: "CodeMirror-composing"
                })
            };
        }), on(te, "compositionend", function() {
            input.composing && (input.poll(), input.composing.range.clear(), input.composing = null);
        });
    }, TextareaInput.prototype.prepareSelection = function() {
        var cm = this.cm, display = cm.display, doc = cm.doc, result = prepareSelection(cm);
        if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div"), wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)),
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
        }
        return result;
    }, TextareaInput.prototype.showSelection = function(drawn) {
        var cm = this.cm, display = cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors), removeChildrenAndAdd(display.selectionDiv, drawn.selection),
        null != drawn.teTop && (this.wrapper.style.top = drawn.teTop + "px", this.wrapper.style.left = drawn.teLeft + "px");
    }, TextareaInput.prototype.reset = function(typing) {
        if (!this.contextMenuPending) {
            var minimal, selected, cm = this.cm, doc = cm.doc;
            if (cm.somethingSelected()) {
                this.prevInput = "";
                var range = doc.sel.primary();
                minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1e3);
                var content = minimal ? "-" : selected || cm.getSelection();
                this.textarea.value = content, cm.state.focused && selectInput(this.textarea), ie && ie_version >= 9 && (this.hasSelection = content);
            } else typing || (this.prevInput = this.textarea.value = "", ie && ie_version >= 9 && (this.hasSelection = null));
            this.inaccurateSelection = minimal;
        }
    }, TextareaInput.prototype.getField = function() {
        return this.textarea;
    }, TextareaInput.prototype.supportsTouch = function() {
        return !1;
    }, TextareaInput.prototype.focus = function() {
        if ("nocursor" != this.cm.options.readOnly && (!mobile || activeElt() != this.textarea)) try {
            this.textarea.focus();
        } catch (e) {}
    }, TextareaInput.prototype.blur = function() {
        this.textarea.blur();
    }, TextareaInput.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
    }, TextareaInput.prototype.receivedFocus = function() {
        this.slowPoll();
    }, TextareaInput.prototype.slowPoll = function() {
        var this$1 = this;
        this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
            this$1.poll(), this$1.cm.state.focused && this$1.slowPoll();
        });
    }, TextareaInput.prototype.fastPoll = function() {
        function p() {
            input.poll() || missed ? (input.pollingFast = !1, input.slowPoll()) : (missed = !0,
            input.polling.set(60, p));
        }
        var missed = !1, input = this;
        input.pollingFast = !0, input.polling.set(20, p);
    }, TextareaInput.prototype.poll = function() {
        var this$1 = this, cm = this.cm, input = this.textarea, prevInput = this.prevInput;
        if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) return !1;
        var text = input.value;
        if (text == prevInput && !cm.somethingSelected()) return !1;
        if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) return cm.display.input.reset(),
        !1;
        if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (8203 != first || prevInput || (prevInput = "​"), 8666 == first) return this.reset(),
            this.cm.execCommand("undo");
        }
        for (var same = 0, l = Math.min(prevInput.length, text.length); same < l && prevInput.charCodeAt(same) == text.charCodeAt(same); ) ++same;
        return runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null),
            text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = this$1.prevInput = "" : this$1.prevInput = text,
            this$1.composing && (this$1.composing.range.clear(), this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
                className: "CodeMirror-composing"
            }));
        }), !0;
    }, TextareaInput.prototype.ensurePolled = function() {
        this.pollingFast && this.poll() && (this.pollingFast = !1);
    }, TextareaInput.prototype.onKeyPress = function() {
        ie && ie_version >= 9 && (this.hasSelection = null), this.fastPoll();
    }, TextareaInput.prototype.onContextMenu = function(e) {
        function prepareSelectAllHack() {
            if (null != te.selectionStart) {
                var selected = cm.somethingSelected(), extval = "​" + (selected ? te.value : "");
                te.value = "⇚", te.value = extval, input.prevInput = selected ? "" : "​", te.selectionStart = 1,
                te.selectionEnd = extval.length, display.selForContextMenu = cm.doc.sel;
            }
        }
        function rehide() {
            if (input.contextMenuPending = !1, input.wrapper.style.cssText = oldWrapperCSS,
            te.style.cssText = oldCSS, ie && ie_version < 9 && display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos),
            null != te.selectionStart) {
                (!ie || ie && ie_version < 9) && prepareSelectAllHack();
                var i = 0, poll = function() {
                    display.selForContextMenu == cm.doc.sel && 0 == te.selectionStart && te.selectionEnd > 0 && "​" == input.prevInput ? operation(cm, selectAll)(cm) : i++ < 10 ? display.detectingSelectAll = setTimeout(poll, 500) : display.input.reset();
                };
                display.detectingSelectAll = setTimeout(poll, 200);
            }
        }
        var input = this, cm = input.cm, display = cm.display, te = input.textarea, pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
        if (pos && !presto) {
            cm.options.resetSelectionOnContextMenu && -1 == cm.doc.sel.contains(pos) && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
            var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
            input.wrapper.style.cssText = "position: absolute";
            var wrapperBox = input.wrapper.getBoundingClientRect();
            te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
            var oldScrollY;
            if (webkit && (oldScrollY = window.scrollY), display.input.focus(), webkit && window.scrollTo(null, oldScrollY),
            display.input.reset(), cm.somethingSelected() || (te.value = input.prevInput = " "),
            input.contextMenuPending = !0, display.selForContextMenu = cm.doc.sel, clearTimeout(display.detectingSelectAll),
            ie && ie_version >= 9 && prepareSelectAllHack(), captureRightClick) {
                e_stop(e);
                var mouseup = function() {
                    off(window, "mouseup", mouseup), setTimeout(rehide, 20);
                };
                on(window, "mouseup", mouseup);
            } else setTimeout(rehide, 50);
        }
    }, TextareaInput.prototype.readOnlyChanged = function(val) {
        val || this.reset();
    }, TextareaInput.prototype.setUneditable = function() {}, TextareaInput.prototype.needsContentAttribute = !1,
    function(CodeMirror) {
        function option(name, deflt, handle, notOnInit) {
            CodeMirror.defaults[name] = deflt, handle && (optionHandlers[name] = notOnInit ? function(cm, val, old) {
                old != Init && handle(cm, val, old);
            } : handle);
        }
        var optionHandlers = CodeMirror.optionHandlers;
        CodeMirror.defineOption = option, CodeMirror.Init = Init, option("value", "", function(cm, val) {
            return cm.setValue(val);
        }, !0), option("mode", null, function(cm, val) {
            cm.doc.modeOption = val, loadMode(cm);
        }, !0), option("indentUnit", 2, loadMode, !0), option("indentWithTabs", !1), option("smartIndent", !0),
        option("tabSize", 4, function(cm) {
            resetModeState(cm), clearCaches(cm), regChange(cm);
        }, !0), option("lineSeparator", null, function(cm, val) {
            if (cm.doc.lineSep = val, val) {
                var newBreaks = [], lineNo = cm.doc.first;
                cm.doc.iter(function(line) {
                    for (var pos = 0; ;) {
                        var found = line.text.indexOf(val, pos);
                        if (-1 == found) break;
                        pos = found + val.length, newBreaks.push(Pos(lineNo, found));
                    }
                    lineNo++;
                });
                for (var i = newBreaks.length - 1; i >= 0; i--) replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
            }
        }), option("specialChars", /[\u0000-\u001f\u007f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
            cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g"),
            old != Init && cm.refresh();
        }), option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
            return cm.refresh();
        }, !0), option("electricChars", !0), option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
            throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, !0), option("spellcheck", !1, function(cm, val) {
            return cm.getInputField().spellcheck = val;
        }, !0), option("rtlMoveVisually", !windows), option("wholeLineUpdateBefore", !0),
        option("theme", "default", function(cm) {
            themeChanged(cm), guttersChanged(cm);
        }, !0), option("keyMap", "default", function(cm, val, old) {
            var next = getKeyMap(val), prev = old != Init && getKeyMap(old);
            prev && prev.detach && prev.detach(cm, next), next.attach && next.attach(cm, prev || null);
        }), option("extraKeys", null), option("lineWrapping", !1, wrappingChanged, !0),
        option("gutters", [], function(cm) {
            setGuttersForLineNumbers(cm.options), guttersChanged(cm);
        }, !0), option("fixedGutter", !0, function(cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0",
            cm.refresh();
        }, !0), option("coverGutterNextToScrollbar", !1, function(cm) {
            return updateScrollbars(cm);
        }, !0), option("scrollbarStyle", "native", function(cm) {
            initScrollbars(cm), updateScrollbars(cm), cm.display.scrollbars.setScrollTop(cm.doc.scrollTop),
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, !0), option("lineNumbers", !1, function(cm) {
            setGuttersForLineNumbers(cm.options), guttersChanged(cm);
        }, !0), option("firstLineNumber", 1, guttersChanged, !0), option("lineNumberFormatter", function(integer) {
            return integer;
        }, guttersChanged, !0), option("showCursorWhenSelecting", !1, updateSelection, !0),
        option("resetSelectionOnContextMenu", !0), option("lineWiseCopyCut", !0), option("readOnly", !1, function(cm, val) {
            "nocursor" == val ? (onBlur(cm), cm.display.input.blur(), cm.display.disabled = !0) : cm.display.disabled = !1,
            cm.display.input.readOnlyChanged(val);
        }), option("disableInput", !1, function(cm, val) {
            val || cm.display.input.reset();
        }, !0), option("dragDrop", !0, dragDropChanged), option("allowDropFileTypes", null),
        option("cursorBlinkRate", 530), option("cursorScrollMargin", 0), option("cursorHeight", 1, updateSelection, !0),
        option("singleCursorHeightPerLine", !0, updateSelection, !0), option("workTime", 100),
        option("workDelay", 100), option("flattenSpans", !0, resetModeState, !0), option("addModeClass", !1, resetModeState, !0),
        option("pollInterval", 100), option("undoDepth", 200, function(cm, val) {
            return cm.doc.history.undoDepth = val;
        }), option("historyEventDelay", 1250), option("viewportMargin", 10, function(cm) {
            return cm.refresh();
        }, !0), option("maxHighlightLength", 1e4, resetModeState, !0), option("moveInputWithCursor", !0, function(cm, val) {
            val || cm.display.input.resetPosition();
        }), option("tabindex", null, function(cm, val) {
            return cm.display.input.getField().tabIndex = val || "";
        }), option("autofocus", null);
    }(CodeMirror), function(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers, helpers = CodeMirror.helpers = {};
        CodeMirror.prototype = {
            constructor: CodeMirror,
            focus: function() {
                window.focus(), this.display.input.focus();
            },
            setOption: function(option, value) {
                var options = this.options, old = options[option];
                options[option] == value && "mode" != option || (options[option] = value, optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old),
                signal(this, "optionChange", this, option));
            },
            getOption: function(option) {
                return this.options[option];
            },
            getDoc: function() {
                return this.doc;
            },
            addKeyMap: function(map, bottom) {
                this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
            },
            removeKeyMap: function(map) {
                for (var maps = this.state.keyMaps, i = 0; i < maps.length; ++i) if (maps[i] == map || maps[i].name == map) return maps.splice(i, 1),
                !0;
            },
            addOverlay: methodOp(function(spec, options) {
                var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                if (mode.startState) throw new Error("Overlays may not be stateful.");
                insertSorted(this.state.overlays, {
                    mode: mode,
                    modeSpec: spec,
                    opaque: options && options.opaque,
                    priority: options && options.priority || 0
                }, function(overlay) {
                    return overlay.priority;
                }), this.state.modeGen++, regChange(this);
            }),
            removeOverlay: methodOp(function(spec) {
                for (var this$1 = this, overlays = this.state.overlays, i = 0; i < overlays.length; ++i) {
                    var cur = overlays[i].modeSpec;
                    if (cur == spec || "string" == typeof spec && cur.name == spec) return overlays.splice(i, 1),
                    this$1.state.modeGen++, void regChange(this$1);
                }
            }),
            indentLine: methodOp(function(n, dir, aggressive) {
                "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"),
                isLine(this.doc, n) && indentLine(this, n, dir, aggressive);
            }),
            indentSelection: methodOp(function(how) {
                for (var this$1 = this, ranges = this.doc.sel.ranges, end = -1, i = 0; i < ranges.length; i++) {
                    var range = ranges[i];
                    if (range.empty()) range.head.line > end && (indentLine(this$1, range.head.line, how, !0),
                    end = range.head.line, i == this$1.doc.sel.primIndex && ensureCursorVisible(this$1)); else {
                        var from = range.from(), to = range.to(), start = Math.max(end, from.line);
                        end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                        for (var j = start; j < end; ++j) indentLine(this$1, j, how);
                        var newRanges = this$1.doc.sel.ranges;
                        0 == from.ch && ranges.length == newRanges.length && newRanges[i].from().ch > 0 && replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                    }
                }
            }),
            getTokenAt: function(pos, precise) {
                return takeToken(this, pos, precise);
            },
            getLineTokens: function(line, precise) {
                return takeToken(this, Pos(line), precise, !0);
            },
            getTokenTypeAt: function(pos) {
                pos = clipPos(this.doc, pos);
                var type, styles = getLineStyles(this, getLine(this.doc, pos.line)), before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                if (0 == ch) type = styles[2]; else for (;;) {
                    var mid = before + after >> 1;
                    if ((mid ? styles[2 * mid - 1] : 0) >= ch) after = mid; else {
                        if (!(styles[2 * mid + 1] < ch)) {
                            type = styles[2 * mid + 2];
                            break;
                        }
                        before = mid + 1;
                    }
                }
                var cut = type ? type.indexOf("overlay ") : -1;
                return cut < 0 ? type : 0 == cut ? null : type.slice(0, cut - 1);
            },
            getModeAt: function(pos) {
                var mode = this.doc.mode;
                return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode;
            },
            getHelper: function(pos, type) {
                return this.getHelpers(pos, type)[0];
            },
            getHelpers: function(pos, type) {
                var this$1 = this, found = [];
                if (!helpers.hasOwnProperty(type)) return found;
                var help = helpers[type], mode = this.getModeAt(pos);
                if ("string" == typeof mode[type]) help[mode[type]] && found.push(help[mode[type]]); else if (mode[type]) for (var i = 0; i < mode[type].length; i++) {
                    var val = help[mode[type][i]];
                    val && found.push(val);
                } else mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
                for (var i$1 = 0; i$1 < help._global.length; i$1++) {
                    var cur = help._global[i$1];
                    cur.pred(mode, this$1) && -1 == indexOf(found, cur.val) && found.push(cur.val);
                }
                return found;
            },
            getStateAfter: function(line, precise) {
                var doc = this.doc;
                return line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line), getStateBefore(this, line + 1, precise);
            },
            cursorCoords: function(start, mode) {
                var pos, range = this.doc.sel.primary();
                return pos = null == start ? range.head : "object" == typeof start ? clipPos(this.doc, start) : start ? range.from() : range.to(),
                cursorCoords(this, pos, mode || "page");
            },
            charCoords: function(pos, mode) {
                return charCoords(this, clipPos(this.doc, pos), mode || "page");
            },
            coordsChar: function(coords, mode) {
                return coords = fromCoordSystem(this, coords, mode || "page"), coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function(height, mode) {
                return height = fromCoordSystem(this, {
                    top: height,
                    left: 0
                }, mode || "page").top, lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function(line, mode, includeWidgets) {
                var lineObj, end = !1;
                if ("number" == typeof line) {
                    var last = this.doc.first + this.doc.size - 1;
                    line < this.doc.first ? line = this.doc.first : line > last && (line = last, end = !0),
                    lineObj = getLine(this.doc, line);
                } else lineObj = line;
                return intoCoordSystem(this, lineObj, {
                    top: 0,
                    left: 0
                }, mode || "page", includeWidgets).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
            },
            defaultTextHeight: function() {
                return textHeight(this.display);
            },
            defaultCharWidth: function() {
                return charWidth(this.display);
            },
            getViewport: function() {
                return {
                    from: this.display.viewFrom,
                    to: this.display.viewTo
                };
            },
            addWidget: function(pos, node, scroll, vert, horiz) {
                var display = this.display;
                pos = cursorCoords(this, clipPos(this.doc, pos));
                var top = pos.bottom, left = pos.left;
                if (node.style.position = "absolute", node.setAttribute("cm-ignore-events", "true"),
                this.display.input.setUneditable(node), display.sizer.appendChild(node), "over" == vert) top = pos.top; else if ("above" == vert || "near" == vert) {
                    var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                    ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom),
                    left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth);
                }
                node.style.top = top + "px", node.style.left = node.style.right = "", "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth,
                node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2),
                node.style.left = left + "px"), scroll && scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
            },
            triggerOnKeyDown: methodOp(onKeyDown),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            execCommand: function(cmd) {
                if (commands.hasOwnProperty(cmd)) return commands[cmd].call(null, this);
            },
            triggerElectric: methodOp(function(text) {
                triggerElectric(this, text);
            }),
            findPosH: function(from, amount, unit, visually) {
                var this$1 = this, dir = 1;
                amount < 0 && (dir = -1, amount = -amount);
                for (var cur = clipPos(this.doc, from), i = 0; i < amount && (cur = findPosH(this$1.doc, cur, dir, unit, visually),
                !cur.hitSide); ++i) ;
                return cur;
            },
            moveH: methodOp(function(dir, unit) {
                var this$1 = this;
                this.extendSelectionsBy(function(range) {
                    return this$1.display.shift || this$1.doc.extend || range.empty() ? findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) : dir < 0 ? range.from() : range.to();
                }, sel_move);
            }),
            deleteH: methodOp(function(dir, unit) {
                var sel = this.doc.sel, doc = this.doc;
                sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function(range) {
                    var other = findPosH(doc, range.head, dir, unit, !1);
                    return dir < 0 ? {
                        from: other,
                        to: range.head
                    } : {
                        from: range.head,
                        to: other
                    };
                });
            }),
            findPosV: function(from, amount, unit, goalColumn) {
                var this$1 = this, dir = 1, x = goalColumn;
                amount < 0 && (dir = -1, amount = -amount);
                for (var cur = clipPos(this.doc, from), i = 0; i < amount; ++i) {
                    var coords = cursorCoords(this$1, cur, "div");
                    if (null == x ? x = coords.left : coords.left = x, cur = findPosV(this$1, coords, dir, unit),
                    cur.hitSide) break;
                }
                return cur;
            },
            moveV: methodOp(function(dir, unit) {
                var this$1 = this, doc = this.doc, goals = [], collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
                if (doc.extendSelectionsBy(function(range) {
                    if (collapse) return dir < 0 ? range.from() : range.to();
                    var headPos = cursorCoords(this$1, range.head, "div");
                    null != range.goalColumn && (headPos.left = range.goalColumn), goals.push(headPos.left);
                    var pos = findPosV(this$1, headPos, dir, unit);
                    return "page" == unit && range == doc.sel.primary() && addToScrollPos(this$1, null, charCoords(this$1, pos, "div").top - headPos.top),
                    pos;
                }, sel_move), goals.length) for (var i = 0; i < doc.sel.ranges.length; i++) doc.sel.ranges[i].goalColumn = goals[i];
            }),
            findWordAt: function(pos) {
                var doc = this.doc, line = getLine(doc, pos.line).text, start = pos.ch, end = pos.ch;
                if (line) {
                    var helper = this.getHelper(pos, "wordChars");
                    (pos.xRel < 0 || end == line.length) && start ? --start : ++end;
                    for (var startChar = line.charAt(start), check = isWordChar(startChar, helper) ? function(ch) {
                        return isWordChar(ch, helper);
                    } : /\s/.test(startChar) ? function(ch) {
                        return /\s/.test(ch);
                    } : function(ch) {
                        return !/\s/.test(ch) && !isWordChar(ch);
                    }; start > 0 && check(line.charAt(start - 1)); ) --start;
                    for (;end < line.length && check(line.charAt(end)); ) ++end;
                }
                return new Range(Pos(pos.line, start), Pos(pos.line, end));
            },
            toggleOverwrite: function(value) {
                null != value && value == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? addClass(this.display.cursorDiv, "CodeMirror-overwrite") : rmClass(this.display.cursorDiv, "CodeMirror-overwrite"),
                signal(this, "overwriteToggle", this, this.state.overwrite));
            },
            hasFocus: function() {
                return this.display.input.getField() == activeElt();
            },
            isReadOnly: function() {
                return !(!this.options.readOnly && !this.doc.cantEdit);
            },
            scrollTo: methodOp(function(x, y) {
                null == x && null == y || resolveScrollToPos(this), null != x && (this.curOp.scrollLeft = x),
                null != y && (this.curOp.scrollTop = y);
            }),
            getScrollInfo: function() {
                var scroller = this.display.scroller;
                return {
                    left: scroller.scrollLeft,
                    top: scroller.scrollTop,
                    height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                    width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                    clientHeight: displayHeight(this),
                    clientWidth: displayWidth(this)
                };
            },
            scrollIntoView: methodOp(function(range, margin) {
                if (null == range ? (range = {
                    from: this.doc.sel.primary().head,
                    to: null
                }, null == margin && (margin = this.options.cursorScrollMargin)) : "number" == typeof range ? range = {
                    from: Pos(range, 0),
                    to: null
                } : null == range.from && (range = {
                    from: range,
                    to: null
                }), range.to || (range.to = range.from), range.margin = margin || 0, null != range.from.line) resolveScrollToPos(this),
                this.curOp.scrollToPos = range; else {
                    var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
                    this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
                }
            }),
            setSize: methodOp(function(width, height) {
                var this$1 = this, interpret = function(val) {
                    return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val;
                };
                null != width && (this.display.wrapper.style.width = interpret(width)), null != height && (this.display.wrapper.style.height = interpret(height)),
                this.options.lineWrapping && clearLineMeasurementCache(this);
                var lineNo = this.display.viewFrom;
                this.doc.iter(lineNo, this.display.viewTo, function(line) {
                    if (line.widgets) for (var i = 0; i < line.widgets.length; i++) if (line.widgets[i].noHScroll) {
                        regLineChange(this$1, lineNo, "widget");
                        break;
                    }
                    ++lineNo;
                }), this.curOp.forceUpdate = !0, signal(this, "refresh", this);
            }),
            operation: function(f) {
                return runInOp(this, f);
            },
            refresh: methodOp(function() {
                var oldHeight = this.display.cachedTextHeight;
                regChange(this), this.curOp.forceUpdate = !0, clearCaches(this), this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop),
                updateGutterSpace(this), (null == oldHeight || Math.abs(oldHeight - textHeight(this.display)) > .5) && estimateLineHeights(this),
                signal(this, "refresh", this);
            }),
            swapDoc: methodOp(function(doc) {
                var old = this.doc;
                return old.cm = null, attachDoc(this, doc), clearCaches(this), this.display.input.reset(),
                this.scrollTo(doc.scrollLeft, doc.scrollTop), this.curOp.forceScroll = !0, signalLater(this, "swapDoc", this, old),
                old;
            }),
            getInputField: function() {
                return this.display.input.getField();
            },
            getWrapperElement: function() {
                return this.display.wrapper;
            },
            getScrollerElement: function() {
                return this.display.scroller;
            },
            getGutterElement: function() {
                return this.display.gutters;
            }
        }, eventMixin(CodeMirror), CodeMirror.registerHelper = function(type, name, value) {
            helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {
                _global: []
            }), helpers[type][name] = value;
        }, CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
            CodeMirror.registerHelper(type, name, value), helpers[type]._global.push({
                pred: predicate,
                val: value
            });
        };
    }(CodeMirror);
    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
    for (var prop in Doc.prototype) Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror.prototype[prop] = function(method) {
        return function() {
            return method.apply(this.doc, arguments);
        };
    }(Doc.prototype[prop]));
    return eventMixin(Doc), CodeMirror.inputStyles = {
        textarea: TextareaInput,
        contenteditable: ContentEditableInput
    }, CodeMirror.defineMode = function(name) {
        CodeMirror.defaults.mode || "null" == name || (CodeMirror.defaults.mode = name),
        defineMode.apply(this, arguments);
    }, CodeMirror.defineMIME = defineMIME, CodeMirror.defineMode("null", function() {
        return {
            token: function(stream) {
                return stream.skipToEnd();
            }
        };
    }), CodeMirror.defineMIME("text/plain", "null"), CodeMirror.defineExtension = function(name, func) {
        CodeMirror.prototype[name] = func;
    }, CodeMirror.defineDocExtension = function(name, func) {
        Doc.prototype[name] = func;
    }, CodeMirror.fromTextArea = fromTextArea, function(CodeMirror) {
        CodeMirror.off = off, CodeMirror.on = on, CodeMirror.wheelEventPixels = wheelEventPixels,
        CodeMirror.Doc = Doc, CodeMirror.splitLines = splitLinesAuto, CodeMirror.countColumn = countColumn,
        CodeMirror.findColumn = findColumn, CodeMirror.isWordChar = isWordCharBasic, CodeMirror.Pass = Pass,
        CodeMirror.signal = signal, CodeMirror.Line = Line, CodeMirror.changeEnd = changeEnd,
        CodeMirror.scrollbarModel = scrollbarModel, CodeMirror.Pos = Pos, CodeMirror.cmpPos = cmp,
        CodeMirror.modes = modes, CodeMirror.mimeModes = mimeModes, CodeMirror.resolveMode = resolveMode,
        CodeMirror.getMode = getMode, CodeMirror.modeExtensions = modeExtensions, CodeMirror.extendMode = extendMode,
        CodeMirror.copyState = copyState, CodeMirror.startState = startState, CodeMirror.innerMode = innerMode,
        CodeMirror.commands = commands, CodeMirror.keyMap = keyMap, CodeMirror.keyName = keyName,
        CodeMirror.isModifierKey = isModifierKey, CodeMirror.lookupKey = lookupKey, CodeMirror.normalizeKeyMap = normalizeKeyMap,
        CodeMirror.StringStream = StringStream, CodeMirror.SharedTextMarker = SharedTextMarker,
        CodeMirror.TextMarker = TextMarker, CodeMirror.LineWidget = LineWidget, CodeMirror.e_preventDefault = e_preventDefault,
        CodeMirror.e_stopPropagation = e_stopPropagation, CodeMirror.e_stop = e_stop, CodeMirror.addClass = addClass,
        CodeMirror.contains = contains, CodeMirror.rmClass = rmClass, CodeMirror.keyNames = keyNames;
    }(CodeMirror), CodeMirror.version = "5.23.0", CodeMirror;
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("choicescript", function(conf, parserConf) {
        var cmdRegExp = function(words) {
            return new RegExp("^\\s*\\*(" + words.join("|") + ")(?: .*)?$");
        }, commonCommands = [ "abort", "achievement", "achieve", "advertisement", "allow_reuse", "author", "bug", "check_achievements", "check_purchase", "check_registration", "choice", "create", "delay_break", "delay_ending", "delete", "disable_reuse", "elseif", "elsif", "else", "end_trial", "ending", "fake_choice", "finish", "gosub_scene", "gosub", "goto_random_scene", "goto_scene", "gotoref", "goto", "hide_reuse", "if", "image", "input_number", "input_text", "line_break", "link_button", "link", "login", "looplimit", "more_games", "page_break", "print", "purchase", "rand", "redirect_scene", "reset", "restart", "restore_game", "restore_purchases", "return", "save_game", "selectable_if", "scene_list", "script", "setref", "set", "share_this_game", "show_password", "sound", "stat_chart", "subscribe", "temp", "title" ], jumpCommands = [ "ending", "finish", "gosub_scene", "gosub", "goto_random_scene", "goto_scene", "gotoref", "goto", "label", "redirect_scene", "return" ], indentCommands = [ "achievement", "choice", "if", "scene_list", "elseif", "else", "elsif", "fake_choice", "stat_chart" ], dedentCommands = [ "finish", "goto_scene", "goto", "ending", "redirect_scene" ], csPlusCommands = [ "console_log", "console_track", "console_track_all", "console_untrack_all", "console_untrack", "console_clear", "console_track_list" ], choiceOption = /\s+(?:\*(hide_reuse|allow_reuse|disable_reuse|(if|selectable_if) .+) )?#.+/, builtins = cmdRegExp(commonCommands);
        indentCommands = cmdRegExp(indentCommands), dedentCommands = cmdRegExp(dedentCommands),
        jumpCommands = cmdRegExp(jumpCommands), csPlusCommands = cmdRegExp(csPlusCommands);
        var TOKENS = {
            start: [ {
                regex: /\s*\*comment(?: .*)?/,
                token: "comment"
            }, {
                regex: jumpCommands,
                token: "keyword"
            }, {
                regex: /\s+(\*hide_reuse |\*allow_reuse |\*disable_reuse ){0,1}(\*if .+ ?|\*selectable_if .+ ?){0,1}#.+/,
                token: "operator"
            }, {
                regex: builtins,
                token: "builtin"
            }, {
                regex: csPlusCommands,
                token: "cs-plus"
            }, {
                regex: choiceOption,
                token: "variable"
            }, {
                regex: /([A-Za-z\u00C0-\u00FF\u0100-\u017F]+'[A-Za-z\u00C0-\u00FF\u0100-\u017F]+|[A-Za-z\u00C0-\u00FF\u0100-\u017F]{2,}|[AaI]'?)(?=$|[\s\.,:;\?'\-\!—…])/,
                token: "word"
            }, {
                regex: /\$!{0,2}\{[\w\{\}\+\-&\*\/\s0-9#]+(\[[\w0-9\[\]]+\])*\}/,
                token: "variable"
            }, {
                regex: /[\{\}]/,
                token: "curly-bracket"
            }, {
                regex: /[\(\)]/,
                token: "standard-bracket"
            }, {
                regex: /[\[\]]/,
                token: "square-bracket"
            }, {
                regex: /(--|\.\.\.)/,
                token: "formattable"
            } ]
        };
        return {
            startState: function() {
                return {
                    next: "start",
                    lastToken: null
                };
            },
            token: function(stream, state) {
                for (;stream.pos == stream.start; ) var style = function(stream, state) {
                    var next_rule = state.next || "start";
                    if (next_rule) {
                        state.next = state.next;
                        var nr = TOKENS[next_rule];
                        if (nr.splice) {
                            for (var i$ = 0; i$ < nr.length; ++i$) {
                                var r = nr[i$];
                                if (r.regex && stream.match(r.regex)) return state.next = r.next || state.next,
                                r.token;
                            }
                            return stream.next(), "null";
                        }
                        if (stream.match(r = TOKENS[next_rule])) return r.regex && stream.match(r.regex) ? (state.next = r.next,
                        r.token) : (stream.next(), "null");
                    }
                    return stream.next(), "error";
                }(stream, state);
                return state.lastToken = {
                    style: style,
                    indent: stream.indentation(),
                    content: stream.current()
                }, style;
            },
            indent: function(state) {
                if (void 0 === state.lastToken || null === state.lastToken) return 0;
                var indentation = state.lastToken.indent || 0;
                return state.lastToken.content.match(indentCommands) || state.lastToken.content.match(choiceOption) ? indentation += conf.indentUnit : state.lastToken.content.match(dedentCommands) && (indentation -= conf.indentUnit),
                indentation = indentation < 0 ? 0 : indentation;
            },
            blankLine: function(state) {
                state.lastToken = {
                    style: "blank-line",
                    indent: 0,
                    content: ""
                };
            }
        };
    }), CodeMirror.defineMIME("text/x-choicescript", "choicescript");
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    function dialogDiv(cm, template, bottom) {
        var dialog, wrap = cm.getWrapperElement();
        return dialog = wrap.appendChild(document.createElement("div")), dialog.className = bottom ? "CodeMirror-dialog CodeMirror-dialog-bottom" : "CodeMirror-dialog CodeMirror-dialog-top",
        "string" == typeof template ? dialog.innerHTML = template : dialog.appendChild(template),
        dialog;
    }
    function closeNotification(cm, newVal) {
        cm.state.currentNotificationClose && cm.state.currentNotificationClose(), cm.state.currentNotificationClose = newVal;
    }
    CodeMirror.defineExtension("openDialog", function(template, callback, options) {
        function close(newVal) {
            if ("string" == typeof newVal) inp.value = newVal; else {
                if (closed) return;
                closed = !0, dialog.parentNode.removeChild(dialog), me.focus(), options.onClose && options.onClose(dialog);
            }
        }
        options || (options = {}), closeNotification(this, null);
        var button, dialog = dialogDiv(this, template, options.bottom), closed = !1, me = this, inp = dialog.getElementsByTagName("input")[0];
        return inp ? (inp.focus(), options.value && (inp.value = options.value, !1 !== options.selectValueOnOpen && inp.select()),
        options.onInput && CodeMirror.on(inp, "input", function(e) {
            options.onInput(e, inp.value, close);
        }), options.onKeyUp && CodeMirror.on(inp, "keyup", function(e) {
            options.onKeyUp(e, inp.value, close);
        }), CodeMirror.on(inp, "keydown", function(e) {
            options && options.onKeyDown && options.onKeyDown(e, inp.value, close) || ((27 == e.keyCode || !1 !== options.closeOnEnter && 13 == e.keyCode) && (inp.blur(),
            CodeMirror.e_stop(e), close()), 13 == e.keyCode && callback(inp.value, e));
        }), !1 !== options.closeOnBlur && CodeMirror.on(inp, "blur", close)) : (button = dialog.getElementsByTagName("button")[0]) && (CodeMirror.on(button, "click", function() {
            close(), me.focus();
        }), !1 !== options.closeOnBlur && CodeMirror.on(button, "blur", close), button.focus()),
        close;
    }), CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
        function close() {
            closed || (closed = !0, dialog.parentNode.removeChild(dialog), me.focus());
        }
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options && options.bottom), buttons = dialog.getElementsByTagName("button"), closed = !1, me = this, blurring = 1;
        buttons[0].focus();
        for (var i = 0; i < buttons.length; ++i) {
            var b = buttons[i];
            !function(callback) {
                CodeMirror.on(b, "click", function(e) {
                    CodeMirror.e_preventDefault(e), close(), callback && callback(me);
                });
            }(callbacks[i]), CodeMirror.on(b, "blur", function() {
                --blurring, setTimeout(function() {
                    blurring <= 0 && close();
                }, 200);
            }), CodeMirror.on(b, "focus", function() {
                ++blurring;
            });
        }
    }), CodeMirror.defineExtension("openNotification", function(template, options) {
        function close() {
            closed || (closed = !0, clearTimeout(doneTimer), dialog.parentNode.removeChild(dialog));
        }
        closeNotification(this, close);
        var doneTimer, dialog = dialogDiv(this, template, options && options.bottom), closed = !1, duration = options && void 0 !== options.duration ? options.duration : 5e3;
        return CodeMirror.on(dialog, "click", function(e) {
            CodeMirror.e_preventDefault(e), close();
        }), duration && (doneTimer = setTimeout(close, duration)), close;
    });
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function Completion(cm, options) {
        this.cm = cm, this.options = options, this.widget = null, this.debounce = 0, this.tick = 0,
        this.startPos = this.cm.getCursor("start"), this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
        var self = this;
        cm.on("cursorActivity", this.activityFunc = function() {
            self.cursorActivity();
        });
    }
    function isNewCompletion(old, nw) {
        return CodeMirror.cmpPos(nw.from, old.from) > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch;
    }
    function parseOptions(cm, pos, options) {
        var editor = cm.options.hintOptions, out = {};
        for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
        if (editor) for (var prop in editor) void 0 !== editor[prop] && (out[prop] = editor[prop]);
        if (options) for (var prop in options) void 0 !== options[prop] && (out[prop] = options[prop]);
        return out.hint.resolve && (out.hint = out.hint.resolve(cm, pos)), out;
    }
    function getText(completion) {
        return "string" == typeof completion ? completion : completion.text;
    }
    function buildKeyMap(completion, handle) {
        function addBinding(key, val) {
            var bound;
            bound = "string" != typeof val ? function(cm) {
                return val(cm, handle);
            } : baseMap.hasOwnProperty(val) ? baseMap[val] : val, ourMap[key] = bound;
        }
        var baseMap = {
            Up: function() {
                handle.moveFocus(-1);
            },
            Down: function() {
                handle.moveFocus(1);
            },
            PageUp: function() {
                handle.moveFocus(1 - handle.menuSize(), !0);
            },
            PageDown: function() {
                handle.moveFocus(handle.menuSize() - 1, !0);
            },
            Home: function() {
                handle.setFocus(0);
            },
            End: function() {
                handle.setFocus(handle.length - 1);
            },
            Enter: handle.pick,
            Tab: handle.pick,
            Esc: handle.close
        }, custom = completion.options.customKeys, ourMap = custom ? {} : baseMap;
        if (custom) for (var key in custom) custom.hasOwnProperty(key) && addBinding(key, custom[key]);
        var extra = completion.options.extraKeys;
        if (extra) for (var key in extra) extra.hasOwnProperty(key) && addBinding(key, extra[key]);
        return ourMap;
    }
    function getHintElement(hintsElement, el) {
        for (;el && el != hintsElement; ) {
            if ("LI" === el.nodeName.toUpperCase() && el.parentNode == hintsElement) return el;
            el = el.parentNode;
        }
    }
    function Widget(completion, data) {
        this.completion = completion, this.data = data, this.picked = !1;
        var widget = this, cm = completion.cm, hints = this.hints = document.createElement("ul");
        hints.className = "CodeMirror-hints", this.selectedHint = data.selectedHint || 0;
        for (var completions = data.list, i = 0; i < completions.length; ++i) {
            var elt = hints.appendChild(document.createElement("li")), cur = completions[i], className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
            null != cur.className && (className = cur.className + " " + className), elt.className = className,
            cur.render ? cur.render(elt, data, cur) : elt.appendChild(document.createTextNode(cur.displayText || getText(cur))),
            elt.hintId = i;
        }
        var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null), left = pos.left, top = pos.bottom, below = !0;
        hints.style.left = left + "px", hints.style.top = top + "px";
        var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth), winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
        (completion.options.container || document.body).appendChild(hints);
        var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH, scrolls = hints.scrollHeight > hints.clientHeight + 1, startScroll = cm.getScrollInfo();
        if (overlapY > 0) {
            var height = box.bottom - box.top;
            if (pos.top - (pos.bottom - box.top) - height > 0) hints.style.top = (top = pos.top - height) + "px",
            below = !1; else if (height > winH) {
                hints.style.height = winH - 5 + "px", hints.style.top = (top = pos.bottom - box.top) + "px";
                var cursor = cm.getCursor();
                data.from.ch != cursor.ch && (pos = cm.cursorCoords(cursor), hints.style.left = (left = pos.left) + "px",
                box = hints.getBoundingClientRect());
            }
        }
        var overlapX = box.right - winW;
        if (overlapX > 0 && (box.right - box.left > winW && (hints.style.width = winW - 5 + "px",
        overlapX -= box.right - box.left - winW), hints.style.left = (left = pos.left - overlapX) + "px"),
        scrolls) for (var node = hints.firstChild; node; node = node.nextSibling) node.style.paddingRight = cm.display.nativeBarWidth + "px";
        if (cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
            moveFocus: function(n, avoidWrap) {
                widget.changeActive(widget.selectedHint + n, avoidWrap);
            },
            setFocus: function(n) {
                widget.changeActive(n);
            },
            menuSize: function() {
                return widget.screenAmount();
            },
            length: completions.length,
            close: function() {
                completion.close();
            },
            pick: function() {
                widget.pick();
            },
            data: data
        })), completion.options.closeOnUnfocus) {
            var closingOnBlur;
            cm.on("blur", this.onBlur = function() {
                closingOnBlur = setTimeout(function() {
                    completion.close();
                }, 100);
            }), cm.on("focus", this.onFocus = function() {
                clearTimeout(closingOnBlur);
            });
        }
        return cm.on("scroll", this.onScroll = function() {
            var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect(), newTop = top + startScroll.top - curScroll.top, point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
            if (below || (point += hints.offsetHeight), point <= editor.top || point >= editor.bottom) return completion.close();
            hints.style.top = newTop + "px", hints.style.left = left + startScroll.left - curScroll.left + "px";
        }), CodeMirror.on(hints, "dblclick", function(e) {
            var t = getHintElement(hints, e.target || e.srcElement);
            t && null != t.hintId && (widget.changeActive(t.hintId), widget.pick());
        }), CodeMirror.on(hints, "click", function(e) {
            var t = getHintElement(hints, e.target || e.srcElement);
            t && null != t.hintId && (widget.changeActive(t.hintId), completion.options.completeOnSingleClick && widget.pick());
        }), CodeMirror.on(hints, "mousedown", function() {
            setTimeout(function() {
                cm.focus();
            }, 20);
        }), CodeMirror.signal(data, "select", completions[0], hints.firstChild), !0;
    }
    function applicableHelpers(cm, helpers) {
        if (!cm.somethingSelected()) return helpers;
        for (var result = [], i = 0; i < helpers.length; i++) helpers[i].supportsSelection && result.push(helpers[i]);
        return result;
    }
    function fetchHints(hint, cm, options, callback) {
        if (hint.async) hint(cm, callback, options); else {
            var result = hint(cm, options);
            result && result.then ? result.then(callback) : callback(result);
        }
    }
    function resolveAutoHints(cm, pos) {
        var words, helpers = cm.getHelpers(pos, "hint");
        if (helpers.length) {
            var resolved = function(cm, callback, options) {
                function run(i) {
                    if (i == app.length) return callback(null);
                    fetchHints(app[i], cm, options, function(result) {
                        result && result.list.length > 0 ? callback(result) : run(i + 1);
                    });
                }
                var app = applicableHelpers(cm, helpers);
                run(0);
            };
            return resolved.async = !0, resolved.supportsSelection = !0, resolved;
        }
        return (words = cm.getHelper(cm.getCursor(), "hintWords")) ? function(cm) {
            return CodeMirror.hint.fromList(cm, {
                words: words
            });
        } : CodeMirror.hint.anyword ? function(cm, options) {
            return CodeMirror.hint.anyword(cm, options);
        } : function() {};
    }
    var HINT_ELEMENT_CLASS = "CodeMirror-hint", ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
    CodeMirror.showHint = function(cm, getHints, options) {
        if (!getHints) return cm.showHint(options);
        options && options.async && (getHints.async = !0);
        var newOpts = {
            hint: getHints
        };
        if (options) for (var prop in options) newOpts[prop] = options[prop];
        return cm.showHint(newOpts);
    }, CodeMirror.defineExtension("showHint", function(options) {
        options = parseOptions(this, this.getCursor("start"), options);
        var selections = this.listSelections();
        if (!(selections.length > 1)) {
            if (this.somethingSelected()) {
                if (!options.hint.supportsSelection) return;
                for (var i = 0; i < selections.length; i++) if (selections[i].head.line != selections[i].anchor.line) return;
            }
            this.state.completionActive && this.state.completionActive.close();
            var completion = this.state.completionActive = new Completion(this, options);
            completion.options.hint && (CodeMirror.signal(this, "startCompletion", this), completion.update(!0));
        }
    });
    var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
        return setTimeout(fn, 1e3 / 60);
    }, cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
    Completion.prototype = {
        close: function() {
            this.active() && (this.cm.state.completionActive = null, this.tick = null, this.cm.off("cursorActivity", this.activityFunc),
            this.widget && this.data && CodeMirror.signal(this.data, "close"), this.widget && this.widget.close(),
            CodeMirror.signal(this.cm, "endCompletion", this.cm));
        },
        active: function() {
            return this.cm.state.completionActive == this;
        },
        pick: function(data, i) {
            var completion = data.list[i];
            completion.hint ? completion.hint(this.cm, data, completion) : this.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, "complete"),
            CodeMirror.signal(data, "pick", completion), this.close();
        },
        cursorActivity: function() {
            this.debounce && (cancelAnimationFrame(this.debounce), this.debounce = 0);
            var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
            if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < this.startPos.ch || this.cm.somethingSelected() || pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1))) this.close(); else {
                var self = this;
                this.debounce = requestAnimationFrame(function() {
                    self.update();
                }), this.widget && this.widget.disable();
            }
        },
        update: function(first) {
            if (null != this.tick) {
                var self = this, myTick = ++this.tick;
                fetchHints(this.options.hint, this.cm, this.options, function(data) {
                    self.tick == myTick && self.finishUpdate(data, first);
                });
            }
        },
        finishUpdate: function(data, first) {
            this.data && CodeMirror.signal(this.data, "update");
            var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
            this.widget && this.widget.close(), data && this.data && isNewCompletion(this.data, data) || (this.data = data,
            data && data.list.length && (picked && 1 == data.list.length ? this.pick(data, 0) : (this.widget = new Widget(this, data),
            CodeMirror.signal(data, "shown"))));
        }
    }, Widget.prototype = {
        close: function() {
            if (this.completion.widget == this) {
                this.completion.widget = null, this.hints.parentNode.removeChild(this.hints), this.completion.cm.removeKeyMap(this.keyMap);
                var cm = this.completion.cm;
                this.completion.options.closeOnUnfocus && (cm.off("blur", this.onBlur), cm.off("focus", this.onFocus)),
                cm.off("scroll", this.onScroll);
            }
        },
        disable: function() {
            this.completion.cm.removeKeyMap(this.keyMap);
            var widget = this;
            this.keyMap = {
                Enter: function() {
                    widget.picked = !0;
                }
            }, this.completion.cm.addKeyMap(this.keyMap);
        },
        pick: function() {
            this.completion.pick(this.data, this.selectedHint);
        },
        changeActive: function(i, avoidWrap) {
            if (i >= this.data.list.length ? i = avoidWrap ? this.data.list.length - 1 : 0 : i < 0 && (i = avoidWrap ? 0 : this.data.list.length - 1),
            this.selectedHint != i) {
                var node = this.hints.childNodes[this.selectedHint];
                node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, ""), node = this.hints.childNodes[this.selectedHint = i],
                node.className += " " + ACTIVE_HINT_ELEMENT_CLASS, node.offsetTop < this.hints.scrollTop ? this.hints.scrollTop = node.offsetTop - 3 : node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight && (this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3),
                CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
            }
        },
        screenAmount: function() {
            return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
        }
    }, CodeMirror.registerHelper("hint", "auto", {
        resolve: resolveAutoHints
    }), CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
        var cur = cm.getCursor(), token = cm.getTokenAt(cur), to = CodeMirror.Pos(cur.line, token.end);
        if (token.string && /\w/.test(token.string[token.string.length - 1])) var term = token.string, from = CodeMirror.Pos(cur.line, token.start); else var term = "", from = to;
        for (var found = [], i = 0; i < options.words.length; i++) {
            var word = options.words[i];
            word.slice(0, term.length) == term && found.push(word);
        }
        if (found.length) return {
            list: found,
            from: from,
            to: to
        };
    }), CodeMirror.commands.autocomplete = CodeMirror.showHint;
    var defaultOptions = {
        hint: CodeMirror.hint.auto,
        completeSingle: !0,
        alignWithWord: !0,
        closeCharacters: /[\s()\[\]{};:>,]/,
        closeOnUnfocus: !0,
        completeOnSingleClick: !0,
        container: null,
        customKeys: null,
        extraKeys: null
    };
    CodeMirror.defineOption("hintOptions", null);
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    var WORD = /[\w$]+/;
    CodeMirror.registerHelper("hint", "anyword", function(editor, options) {
        for (var word = options && options.word || WORD, range = options && options.range || 500, cur = editor.getCursor(), curLine = editor.getLine(cur.line), end = cur.ch, start = end; start && word.test(curLine.charAt(start - 1)); ) --start;
        for (var curWord = start != end && curLine.slice(start, end), list = options && options.list || [], seen = {}, re = new RegExp(word.source, "g"), dir = -1; dir <= 1; dir += 2) for (var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir; line != endLine; line += dir) for (var m, text = editor.getLine(line); m = re.exec(text); ) line == cur.line && m[0] === curWord || curWord && 0 != m[0].lastIndexOf(curWord, 0) || Object.prototype.hasOwnProperty.call(seen, m[0]) || (seen[m[0]] = !0,
        list.push(m[0]));
        return {
            list: list,
            from: CodeMirror.Pos(cur.line, start),
            to: CodeMirror.Pos(cur.line, end)
        };
    });
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function setFullscreen(cm) {
        var wrap = cm.getWrapperElement();
        cm.state.fullScreenRestore = {
            scrollTop: window.pageYOffset,
            scrollLeft: window.pageXOffset,
            width: wrap.style.width,
            height: wrap.style.height
        }, wrap.style.width = "", wrap.style.height = "auto", wrap.className += " CodeMirror-fullscreen",
        document.documentElement.style.overflow = "hidden", cm.refresh();
    }
    function setNormal(cm) {
        var wrap = cm.getWrapperElement();
        wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, ""), document.documentElement.style.overflow = "";
        var info = cm.state.fullScreenRestore;
        wrap.style.width = info.width, wrap.style.height = info.height, window.scrollTo(info.scrollLeft, info.scrollTop),
        cm.refresh();
    }
    CodeMirror.defineOption("fullScreen", !1, function(cm, val, old) {
        old == CodeMirror.Init && (old = !1), !old != !val && (val ? setFullscreen(cm) : setNormal(cm));
    });
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    function findMatchingBracket(cm, where, strict, config) {
        var line = cm.getLineHandle(where.line), pos = where.ch - 1, match = pos >= 0 && matching[line.text.charAt(pos)] || matching[line.text.charAt(++pos)];
        if (!match) return null;
        var dir = ">" == match.charAt(1) ? 1 : -1;
        if (strict && dir > 0 != (pos == where.ch)) return null;
        var style = cm.getTokenTypeAt(Pos(where.line, pos + 1)), found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
        return null == found ? null : {
            from: Pos(where.line, pos),
            to: found && found.pos,
            match: found && found.ch == match.charAt(0),
            forward: dir > 0
        };
    }
    function scanForBracket(cm, where, dir, style, config) {
        for (var maxScanLen = config && config.maxScanLineLength || 1e4, maxScanLines = config && config.maxScanLines || 1e3, stack = [], re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/, lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines), lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
            var line = cm.getLine(lineNo);
            if (line) {
                var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
                if (!(line.length > maxScanLen)) for (lineNo == where.line && (pos = where.ch - (dir < 0 ? 1 : 0)); pos != end; pos += dir) {
                    var ch = line.charAt(pos);
                    if (re.test(ch) && (void 0 === style || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
                        var match = matching[ch];
                        if (">" == match.charAt(1) == dir > 0) stack.push(ch); else {
                            if (!stack.length) return {
                                pos: Pos(lineNo, pos),
                                ch: ch
                            };
                            stack.pop();
                        }
                    }
                }
            }
        }
        return lineNo - dir != (dir > 0 ? cm.lastLine() : cm.firstLine()) && null;
    }
    function matchBrackets(cm, autoclear, config) {
        for (var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, marks = [], ranges = cm.listSelections(), i = 0; i < ranges.length; i++) {
            var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, !1, config);
            if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
                var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
                marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {
                    className: style
                })), match.to && cm.getLine(match.to.line).length <= maxHighlightLen && marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {
                    className: style
                }));
            }
        }
        if (marks.length) {
            ie_lt8 && cm.state.focused && cm.focus();
            var clear = function() {
                cm.operation(function() {
                    for (var i = 0; i < marks.length; i++) marks[i].clear();
                });
            };
            if (!autoclear) return clear;
            setTimeout(clear, 800);
        }
    }
    function doMatchBrackets(cm) {
        cm.operation(function() {
            currentlyHighlighted && (currentlyHighlighted(), currentlyHighlighted = null), currentlyHighlighted = matchBrackets(cm, !1, cm.state.matchBrackets);
        });
    }
    var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (null == document.documentMode || document.documentMode < 8), Pos = CodeMirror.Pos, matching = {
        "(": ")>",
        ")": "(<",
        "[": "]>",
        "]": "[<",
        "{": "}>",
        "}": "{<"
    }, currentlyHighlighted = null;
    CodeMirror.defineOption("matchBrackets", !1, function(cm, val, old) {
        old && old != CodeMirror.Init && (cm.off("cursorActivity", doMatchBrackets), currentlyHighlighted && (currentlyHighlighted(),
        currentlyHighlighted = null)), val && (cm.state.matchBrackets = "object" == typeof val ? val : {},
        cm.on("cursorActivity", doMatchBrackets));
    }), CodeMirror.defineExtension("matchBrackets", function() {
        matchBrackets(this, !0);
    }), CodeMirror.defineExtension("findMatchingBracket", function(pos, strict, config) {
        return findMatchingBracket(this, pos, strict, config);
    }), CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config) {
        return scanForBracket(this, pos, dir, style, config);
    });
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function ensureState(states, name) {
        if (!states.hasOwnProperty(name)) throw new Error("Undefined state " + name + " in simple mode");
    }
    function toRegex(val, caret) {
        if (!val) return /(?:)/;
        var flags = "";
        return val instanceof RegExp ? (val.ignoreCase && (flags = "i"), val = val.source) : val = String(val),
        new RegExp((!1 === caret ? "" : "^") + "(?:" + val + ")", flags);
    }
    function asToken(val) {
        if (!val) return null;
        if ("string" == typeof val) return val.replace(/\./g, " ");
        for (var result = [], i = 0; i < val.length; i++) result.push(val[i] && val[i].replace(/\./g, " "));
        return result;
    }
    function Rule(data, states) {
        (data.next || data.push) && ensureState(states, data.next || data.push), this.regex = toRegex(data.regex),
        this.token = asToken(data.token), this.data = data;
    }
    function tokenFunction(states, config) {
        return function(stream, state) {
            if (state.pending) {
                var pend = state.pending.shift();
                return 0 == state.pending.length && (state.pending = null), stream.pos += pend.text.length,
                pend.token;
            }
            if (state.local) {
                if (state.local.end && stream.match(state.local.end)) {
                    var tok = state.local.endToken || null;
                    return state.local = state.localState = null, tok;
                }
                var m, tok = state.local.mode.token(stream, state.localState);
                return state.local.endScan && (m = state.local.endScan.exec(stream.current())) && (stream.pos = stream.start + m.index),
                tok;
            }
            for (var curState = states[state.state], i = 0; i < curState.length; i++) {
                var rule = curState[i], matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
                if (matches) {
                    if (rule.data.next ? state.state = rule.data.next : rule.data.push ? ((state.stack || (state.stack = [])).push(state.state),
                    state.state = rule.data.push) : rule.data.pop && state.stack && state.stack.length && (state.state = state.stack.pop()),
                    rule.data.mode && enterLocalMode(config, state, rule.data.mode, rule.token), rule.data.indent && state.indent.push(stream.indentation() + config.indentUnit),
                    rule.data.dedent && state.indent.pop(), matches.length > 2) {
                        state.pending = [];
                        for (var j = 2; j < matches.length; j++) matches[j] && state.pending.push({
                            text: matches[j],
                            token: rule.token[j - 1]
                        });
                        return stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0)),
                        rule.token[0];
                    }
                    return rule.token && rule.token.join ? rule.token[0] : rule.token;
                }
            }
            return stream.next(), null;
        };
    }
    function cmp(a, b) {
        if (a === b) return !0;
        if (!a || "object" != typeof a || !b || "object" != typeof b) return !1;
        var props = 0;
        for (var prop in a) if (a.hasOwnProperty(prop)) {
            if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return !1;
            props++;
        }
        for (var prop in b) b.hasOwnProperty(prop) && props--;
        return 0 == props;
    }
    function enterLocalMode(config, state, spec, token) {
        var pers;
        if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next) (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) && (pers = p);
        var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec), lState = pers ? pers.state : CodeMirror.startState(mode);
        spec.persistent && !pers && (state.persistentStates = {
            mode: mode,
            spec: spec.spec,
            state: lState,
            next: state.persistentStates
        }), state.localState = lState, state.local = {
            mode: mode,
            end: spec.end && toRegex(spec.end),
            endScan: spec.end && !1 !== spec.forceEnd && toRegex(spec.end, !1),
            endToken: token && token.join ? token[token.length - 1] : token
        };
    }
    function indexOf(val, arr) {
        for (var i = 0; i < arr.length; i++) if (arr[i] === val) return !0;
    }
    function indentFunction(states, meta) {
        return function(state, textAfter, line) {
            if (state.local && state.local.mode.indent) return state.local.mode.indent(state.localState, textAfter, line);
            if (null == state.indent || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1) return CodeMirror.Pass;
            var pos = state.indent.length - 1, rules = states[state.state];
            scan: for (;;) {
                for (var i = 0; i < rules.length; i++) {
                    var rule = rules[i];
                    if (rule.data.dedent && !1 !== rule.data.dedentIfLineStart) {
                        var m = rule.regex.exec(textAfter);
                        if (m && m[0]) {
                            pos--, (rule.next || rule.push) && (rules = states[rule.next || rule.push]), textAfter = textAfter.slice(m[0].length);
                            continue scan;
                        }
                    }
                }
                break;
            }
            return pos < 0 ? 0 : state.indent[pos];
        };
    }
    CodeMirror.defineSimpleMode = function(name, states) {
        CodeMirror.defineMode(name, function(config) {
            return CodeMirror.simpleMode(config, states);
        });
    }, CodeMirror.simpleMode = function(config, states) {
        ensureState(states, "start");
        var states_ = {}, meta = states.meta || {}, hasIndentation = !1;
        for (var state in states) if (state != meta && states.hasOwnProperty(state)) for (var list = states_[state] = [], orig = states[state], i = 0; i < orig.length; i++) {
            var data = orig[i];
            list.push(new Rule(data, states)), (data.indent || data.dedent) && (hasIndentation = !0);
        }
        var mode = {
            startState: function() {
                return {
                    state: "start",
                    pending: null,
                    local: null,
                    localState: null,
                    indent: hasIndentation ? [] : null
                };
            },
            copyState: function(state) {
                var s = {
                    state: state.state,
                    pending: state.pending,
                    local: state.local,
                    localState: null,
                    indent: state.indent && state.indent.slice(0)
                };
                state.localState && (s.localState = CodeMirror.copyState(state.local.mode, state.localState)),
                state.stack && (s.stack = state.stack.slice(0));
                for (var pers = state.persistentStates; pers; pers = pers.next) s.persistentStates = {
                    mode: pers.mode,
                    spec: pers.spec,
                    state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),
                    next: s.persistentStates
                };
                return s;
            },
            token: tokenFunction(states_, config),
            innerMode: function(state) {
                return state.local && {
                    mode: state.local.mode,
                    state: state.localState
                };
            },
            indent: indentFunction(states_, meta)
        };
        if (meta) for (var prop in meta) meta.hasOwnProperty(prop) && (mode[prop] = meta[prop]);
        return mode;
    };
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    CodeMirror.overlayMode = function(base, overlay, combine) {
        return {
            startState: function() {
                return {
                    base: CodeMirror.startState(base),
                    overlay: CodeMirror.startState(overlay),
                    basePos: 0,
                    baseCur: null,
                    overlayPos: 0,
                    overlayCur: null,
                    streamSeen: null
                };
            },
            copyState: function(state) {
                return {
                    base: CodeMirror.copyState(base, state.base),
                    overlay: CodeMirror.copyState(overlay, state.overlay),
                    basePos: state.basePos,
                    baseCur: null,
                    overlayPos: state.overlayPos,
                    overlayCur: null
                };
            },
            token: function(stream, state) {
                return (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) && (state.streamSeen = stream,
                state.basePos = state.overlayPos = stream.start), stream.start == state.basePos && (state.baseCur = base.token(stream, state.base),
                state.basePos = stream.pos), stream.start == state.overlayPos && (stream.pos = stream.start,
                state.overlayCur = overlay.token(stream, state.overlay), state.overlayPos = stream.pos),
                stream.pos = Math.min(state.basePos, state.overlayPos), null == state.overlayCur ? state.baseCur : null != state.baseCur && state.overlay.combineTokens || combine && null == state.overlay.combineTokens ? state.baseCur + " " + state.overlayCur : state.overlayCur;
            },
            indent: base.indent && function(state, textAfter) {
                return base.indent(state.base, textAfter);
            },
            electricChars: base.electricChars,
            innerMode: function(state) {
                return {
                    state: state.base,
                    mode: base
                };
            },
            blankLine: function(state) {
                var baseToken, overlayToken;
                return base.blankLine && (baseToken = base.blankLine(state.base)), overlay.blankLine && (overlayToken = overlay.blankLine(state.overlay)),
                null == overlayToken ? baseToken : combine && null != baseToken ? baseToken + " " + overlayToken : overlayToken;
            }
        };
    };
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("./searchcursor"), require("../dialog/dialog")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror", "./searchcursor", "../dialog/dialog" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function searchOverlay(query, caseInsensitive) {
        return "string" == typeof query ? query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g") : query.global || (query = new RegExp(query.source, query.ignoreCase ? "gi" : "g")),
        {
            token: function(stream) {
                query.lastIndex = stream.pos;
                var match = query.exec(stream.string);
                if (match && match.index == stream.pos) return stream.pos += match[0].length || 1,
                "searching";
                match ? stream.pos = match.index : stream.skipToEnd();
            }
        };
    }
    function SearchState() {
        this.posFrom = this.posTo = this.lastQuery = this.query = null, this.overlay = null;
    }
    function getSearchState(cm) {
        return cm.state.search || (cm.state.search = new SearchState());
    }
    function queryCaseInsensitive(query) {
        return "string" == typeof query && query == query.toLowerCase();
    }
    function getSearchCursor(cm, query, pos) {
        return cm.getSearchCursor(query, pos, queryCaseInsensitive(query));
    }
    function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {
        cm.openDialog(text, onEnter, {
            value: deflt,
            selectValueOnOpen: !0,
            closeOnEnter: !1,
            onClose: function() {
                clearSearch(cm);
            },
            onKeyDown: onKeyDown
        });
    }
    function dialog(cm, text, shortText, deflt, f) {
        cm.openDialog ? cm.openDialog(text, f, {
            value: deflt,
            selectValueOnOpen: !0
        }) : f(prompt(shortText, deflt));
    }
    function confirmDialog(cm, text, shortText, fs) {
        cm.openConfirm ? cm.openConfirm(text, fs) : confirm(shortText) && fs[0]();
    }
    function parseString(string) {
        return string.replace(/\\(.)/g, function(_, ch) {
            return "n" == ch ? "\n" : "r" == ch ? "\r" : ch;
        });
    }
    function parseQuery(query) {
        var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
        if (isRE) try {
            query = new RegExp(isRE[1], -1 == isRE[2].indexOf("i") ? "" : "i");
        } catch (e) {} else query = parseString(query);
        return ("string" == typeof query ? "" == query : query.test("")) && (query = /x^/),
        query;
    }
    function startSearch(cm, state, query) {
        state.queryText = query, state.query = parseQuery(query), cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query)),
        state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query)), cm.addOverlay(state.overlay),
        cm.showMatchesOnScrollbar && (state.annotate && (state.annotate.clear(), state.annotate = null),
        state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query)));
    }
    function doSearch(cm, rev, persistent, immediate) {
        var state = getSearchState(cm);
        if (state.query) return findNext(cm, rev);
        var q = cm.getSelection() || state.lastQuery;
        if (persistent && cm.openDialog) {
            var hiding = null, searchNext = function(query, event) {
                CodeMirror.e_stop(event), query && (query != state.queryText && (startSearch(cm, state, query),
                state.posFrom = state.posTo = cm.getCursor()), hiding && (hiding.style.opacity = 1),
                findNext(cm, event.shiftKey, function(_, to) {
                    var dialog;
                    to.line < 3 && document.querySelector && (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) && dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top && ((hiding = dialog).style.opacity = .4);
                }));
            };
            persistentDialog(cm, queryDialog, q, searchNext, function(event, query) {
                var keyName = CodeMirror.keyName(event), cmd = CodeMirror.keyMap[cm.getOption("keyMap")][keyName];
                cmd || (cmd = cm.getOption("extraKeys")[keyName]), "findNext" == cmd || "findPrev" == cmd || "findPersistentNext" == cmd || "findPersistentPrev" == cmd ? (CodeMirror.e_stop(event),
                startSearch(cm, getSearchState(cm), query), cm.execCommand(cmd)) : "find" != cmd && "findPersistent" != cmd || (CodeMirror.e_stop(event),
                searchNext(query, event));
            }), immediate && q && (startSearch(cm, state, q), findNext(cm, rev));
        } else dialog(cm, queryDialog, "Search for:", q, function(query) {
            query && !state.query && cm.operation(function() {
                startSearch(cm, state, query), state.posFrom = state.posTo = cm.getCursor(), findNext(cm, rev);
            });
        });
    }
    function findNext(cm, rev, callback) {
        cm.operation(function() {
            var state = getSearchState(cm), cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
            (cursor.find(rev) || (cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0)),
            cursor.find(rev))) && (cm.setSelection(cursor.from(), cursor.to()), cm.scrollIntoView({
                from: cursor.from(),
                to: cursor.to()
            }, 20), state.posFrom = cursor.from(), state.posTo = cursor.to(), callback && callback(cursor.from(), cursor.to()));
        });
    }
    function clearSearch(cm) {
        cm.operation(function() {
            var state = getSearchState(cm);
            state.lastQuery = state.query, state.query && (state.query = state.queryText = null,
            cm.removeOverlay(state.overlay), state.annotate && (state.annotate.clear(), state.annotate = null));
        });
    }
    function replaceAll(cm, query, text) {
        cm.operation(function() {
            for (var cursor = getSearchCursor(cm, query); cursor.findNext(); ) if ("string" != typeof query) {
                var match = cm.getRange(cursor.from(), cursor.to()).match(query);
                cursor.replace(text.replace(/\$(\d)/g, function(_, i) {
                    return match[i];
                }));
            } else cursor.replace(text);
        });
    }
    function replace(cm, all) {
        if (!cm.getOption("readOnly")) {
            var query = cm.getSelection() || getSearchState(cm).lastQuery, dialogText = all ? "Replace all:" : "Replace:";
            dialog(cm, dialogText + replaceQueryDialog, dialogText, query, function(query) {
                query && (query = parseQuery(query), dialog(cm, replacementQueryDialog, "Replace with:", "", function(text) {
                    if (text = parseString(text), all) replaceAll(cm, query, text); else {
                        clearSearch(cm);
                        var cursor = getSearchCursor(cm, query, cm.getCursor("from")), advance = function() {
                            var match, start = cursor.from();
                            !(match = cursor.findNext()) && (cursor = getSearchCursor(cm, query), !(match = cursor.findNext()) || start && cursor.from().line == start.line && cursor.from().ch == start.ch) || (cm.setSelection(cursor.from(), cursor.to()),
                            cm.scrollIntoView({
                                from: cursor.from(),
                                to: cursor.to()
                            }), confirmDialog(cm, doReplaceConfirm, "Replace?", [ function() {
                                doReplace(match);
                            }, advance, function() {
                                replaceAll(cm, query, text);
                            } ]));
                        }, doReplace = function(match) {
                            cursor.replace("string" == typeof query ? text : text.replace(/\$(\d)/g, function(_, i) {
                                return match[i];
                            })), advance();
                        };
                        advance();
                    }
                }));
            });
        }
    }
    var queryDialog = 'Search: <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>', replaceQueryDialog = ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>', replacementQueryDialog = 'With: <input type="text" style="width: 10em" class="CodeMirror-search-field"/>', doReplaceConfirm = "Replace? <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>";
    CodeMirror.commands.find = function(cm) {
        clearSearch(cm), doSearch(cm);
    }, CodeMirror.commands.findPersistent = function(cm) {
        clearSearch(cm), doSearch(cm, !1, !0);
    }, CodeMirror.commands.findPersistentNext = function(cm) {
        doSearch(cm, !1, !0, !0);
    }, CodeMirror.commands.findPersistentPrev = function(cm) {
        doSearch(cm, !0, !0, !0);
    }, CodeMirror.commands.findNext = doSearch, CodeMirror.commands.findPrev = function(cm) {
        doSearch(cm, !0);
    }, CodeMirror.commands.clearSearch = clearSearch, CodeMirror.commands.replace = replace,
    CodeMirror.commands.replaceAll = function(cm) {
        replace(cm, !0);
    };
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function SearchCursor(doc, query, pos, caseFold) {
        if (this.atOccurrence = !1, this.doc = doc, null == caseFold && "string" == typeof query && (caseFold = !1),
        pos = pos ? doc.clipPos(pos) : Pos(0, 0), this.pos = {
            from: pos,
            to: pos
        }, "string" != typeof query) query.global || (query = new RegExp(query.source, query.ignoreCase ? "ig" : "g")),
        this.matches = function(reverse, pos) {
            if (reverse) {
                query.lastIndex = 0;
                for (var match, start, line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0; ;) {
                    query.lastIndex = cutOff;
                    var newMatch = query.exec(line);
                    if (!newMatch) break;
                    if (match = newMatch, start = match.index, (cutOff = match.index + (match[0].length || 1)) == line.length) break;
                }
                var matchLen = match && match[0].length || 0;
                matchLen || (0 == start && 0 == line.length ? match = void 0 : start != doc.getLine(pos.line).length && matchLen++);
            } else {
                query.lastIndex = pos.ch;
                var line = doc.getLine(pos.line), match = query.exec(line), matchLen = match && match[0].length || 0, start = match && match.index;
                start + matchLen == line.length || matchLen || (matchLen = 1);
            }
            if (match && matchLen) return {
                from: Pos(pos.line, start),
                to: Pos(pos.line, start + matchLen),
                match: match
            };
        }; else {
            var origQuery = query;
            caseFold && (query = query.toLowerCase());
            var fold = caseFold ? function(str) {
                return str.toLowerCase();
            } : function(str) {
                return str;
            }, target = query.split("\n");
            if (1 == target.length) query.length ? this.matches = function(reverse, pos) {
                if (reverse) {
                    var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig), match = line.lastIndexOf(query);
                    if (match > -1) return match = adjustPos(orig, line, match), {
                        from: Pos(pos.line, match),
                        to: Pos(pos.line, match + origQuery.length)
                    };
                } else {
                    var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig), match = line.indexOf(query);
                    if (match > -1) return match = adjustPos(orig, line, match) + pos.ch, {
                        from: Pos(pos.line, match),
                        to: Pos(pos.line, match + origQuery.length)
                    };
                }
            } : this.matches = function() {}; else {
                var origTarget = origQuery.split("\n");
                this.matches = function(reverse, pos) {
                    var last = target.length - 1;
                    if (reverse) {
                        if (pos.line - (target.length - 1) < doc.firstLine()) return;
                        if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;
                        for (var to = Pos(pos.line, origTarget[last].length), ln = pos.line - 1, i = last - 1; i >= 1; --i,
                        --ln) if (target[i] != fold(doc.getLine(ln))) return;
                        var line = doc.getLine(ln), cut = line.length - origTarget[0].length;
                        if (fold(line.slice(cut)) != target[0]) return;
                        return {
                            from: Pos(ln, cut),
                            to: to
                        };
                    }
                    if (!(pos.line + (target.length - 1) > doc.lastLine())) {
                        var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;
                        if (fold(line.slice(cut)) == target[0]) {
                            for (var from = Pos(pos.line, cut), ln = pos.line + 1, i = 1; i < last; ++i, ++ln) if (target[i] != fold(doc.getLine(ln))) return;
                            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) == target[last]) return {
                                from: from,
                                to: Pos(ln, origTarget[last].length)
                            };
                        }
                    }
                };
            }
        }
    }
    function adjustPos(orig, folded, pos) {
        if (orig.length == folded.length) return pos;
        for (var pos1 = Math.min(pos, orig.length); ;) {
            var len1 = orig.slice(0, pos1).toLowerCase().length;
            if (len1 < pos) ++pos1; else {
                if (!(len1 > pos)) return pos1;
                --pos1;
            }
        }
    }
    var Pos = CodeMirror.Pos;
    SearchCursor.prototype = {
        findNext: function() {
            return this.find(!1);
        },
        findPrevious: function() {
            return this.find(!0);
        },
        find: function(reverse) {
            function savePosAndFail(line) {
                var pos = Pos(line, 0);
                return self.pos = {
                    from: pos,
                    to: pos
                }, self.atOccurrence = !1, !1;
            }
            for (var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to); ;) {
                if (this.pos = this.matches(reverse, pos)) return this.atOccurrence = !0, this.pos.match || !0;
                if (reverse) {
                    if (!pos.line) return savePosAndFail(0);
                    pos = Pos(pos.line - 1, this.doc.getLine(pos.line - 1).length);
                } else {
                    var maxLine = this.doc.lineCount();
                    if (pos.line == maxLine - 1) return savePosAndFail(maxLine);
                    pos = Pos(pos.line + 1, 0);
                }
            }
        },
        from: function() {
            if (this.atOccurrence) return this.pos.from;
        },
        to: function() {
            if (this.atOccurrence) return this.pos.to;
        },
        replace: function(newText, origin) {
            if (this.atOccurrence) {
                var lines = CodeMirror.splitLines(newText);
                this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin), this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (1 == lines.length ? this.pos.from.ch : 0));
            }
        }
    }, CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this.doc, query, pos, caseFold);
    }), CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this, query, pos, caseFold);
    }), CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
        for (var ranges = [], cur = this.getSearchCursor(query, this.getCursor("from"), caseFold); cur.findNext() && !(CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0); ) ranges.push({
            anchor: cur.from(),
            head: cur.to()
        });
        ranges.length && this.setSelections(ranges, 0);
    });
}), function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("../dialog/dialog")) : "function" == typeof define && define.amd ? define([ "../../lib/codemirror", "../dialog/dialog" ], mod) : mod(CodeMirror);
}(function(CodeMirror) {
    "use strict";
    function dialog(cm, text, shortText, deflt, f) {
        cm.openDialog ? cm.openDialog(text, f, {
            value: deflt,
            selectValueOnOpen: !0
        }) : f(prompt(shortText, deflt));
    }
    function interpretLine(cm, string) {
        var num = Number(string);
        return /^[-+]/.test(string) ? cm.getCursor().line + num : num - 1;
    }
    CodeMirror.commands.jumpToLine = function(cm) {
        var cur = cm.getCursor();
        dialog(cm, 'Jump to line: <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use line:column or scroll% syntax)</span>', "Jump to line:", cur.line + 1 + ":" + cur.ch, function(posStr) {
            if (posStr) {
                var match;
                if (match = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr)) cm.setCursor(interpretLine(cm, match[1]), Number(match[2])); else if (match = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr)) {
                    var line = Math.round(cm.lineCount() * Number(match[1]) / 100);
                    /^[-+]/.test(match[1]) && (line = cur.line + line + 1), cm.setCursor(line - 1, cur.ch);
                } else (match = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) && cm.setCursor(interpretLine(cm, match[1]), cur.ch);
            }
        });
    }, CodeMirror.keyMap.default["Alt-G"] = "jumpToLine";
}),function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Dropbox={})}(this,(function(e){"use strict";function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){for(var r=0;t.length>r;r++){var s=t[r];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}function s(e,t,s){return t&&r(e.prototype,t),s&&r(e,s),e}function i(e){return(i=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function n(e,t){return(n=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function a(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function u(e,t,r){return(u=a()?Reflect.construct:function(e,t,r){var s=[null];s.push.apply(s,t);var i=new(Function.bind.apply(e,s));return r&&n(i,r.prototype),i}).apply(null,arguments)}function o(e){var t="function"==typeof Map?new Map:void 0;return(o=function(e){if(null===e||-1===Function.toString.call(e).indexOf("[native code]"))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return u(e,arguments,i(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n(r,e)})(e)}function c(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}var p="app",l="user",m="team",f="dropboxapi.com",h="dropbox.com",d={api:"api",notify:"bolt",content:"api-content"},_={};function g(e){var t="000".concat(e.charCodeAt(0).toString(16)).slice(-4);return"\\u".concat(t)}_.accountSetProfilePhoto=function(e){return this.request("account/set_profile_photo",e,"user","api","rpc","account_info.write")},_.authTokenFromOauth1=function(e){return this.request("auth/token/from_oauth1",e,"app","api","rpc",null)},_.authTokenRevoke=function(){return this.request("auth/token/revoke",null,"user","api","rpc",null)},_.checkApp=function(e){return this.request("check/app",e,"app","api","rpc",null)},_.checkUser=function(e){return this.request("check/user",e,"user","api","rpc","account_info.read")},_.contactsDeleteManualContacts=function(){return this.request("contacts/delete_manual_contacts",null,"user","api","rpc","contacts.write")},_.contactsDeleteManualContactsBatch=function(e){return this.request("contacts/delete_manual_contacts_batch",e,"user","api","rpc","contacts.write")},_.filePropertiesPropertiesAdd=function(e){return this.request("file_properties/properties/add",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesOverwrite=function(e){return this.request("file_properties/properties/overwrite",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesRemove=function(e){return this.request("file_properties/properties/remove",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesSearch=function(e){return this.request("file_properties/properties/search",e,"user","api","rpc","files.metadata.read")},_.filePropertiesPropertiesSearchContinue=function(e){return this.request("file_properties/properties/search/continue",e,"user","api","rpc","files.metadata.read")},_.filePropertiesPropertiesUpdate=function(e){return this.request("file_properties/properties/update",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesAddForTeam=function(e){return this.request("file_properties/templates/add_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesAddForUser=function(e){return this.request("file_properties/templates/add_for_user",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesGetForTeam=function(e){return this.request("file_properties/templates/get_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesGetForUser=function(e){return this.request("file_properties/templates/get_for_user",e,"user","api","rpc","files.metadata.read")},_.filePropertiesTemplatesListForTeam=function(){return this.request("file_properties/templates/list_for_team",null,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesListForUser=function(){return this.request("file_properties/templates/list_for_user",null,"user","api","rpc","files.metadata.read")},_.filePropertiesTemplatesRemoveForTeam=function(e){return this.request("file_properties/templates/remove_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesRemoveForUser=function(e){return this.request("file_properties/templates/remove_for_user",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesUpdateForTeam=function(e){return this.request("file_properties/templates/update_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesUpdateForUser=function(e){return this.request("file_properties/templates/update_for_user",e,"user","api","rpc","files.metadata.write")},_.fileRequestsCount=function(){return this.request("file_requests/count",null,"user","api","rpc","file_requests.read")},_.fileRequestsCreate=function(e){return this.request("file_requests/create",e,"user","api","rpc","file_requests.write")},_.fileRequestsDelete=function(e){return this.request("file_requests/delete",e,"user","api","rpc","file_requests.write")},_.fileRequestsDeleteAllClosed=function(){return this.request("file_requests/delete_all_closed",null,"user","api","rpc","file_requests.write")},_.fileRequestsGet=function(e){return this.request("file_requests/get",e,"user","api","rpc","file_requests.read")},_.fileRequestsListV2=function(e){return this.request("file_requests/list_v2",e,"user","api","rpc","file_requests.read")},_.fileRequestsList=function(){return this.request("file_requests/list",null,"user","api","rpc","file_requests.read")},_.fileRequestsListContinue=function(e){return this.request("file_requests/list/continue",e,"user","api","rpc","file_requests.read")},_.fileRequestsUpdate=function(e){return this.request("file_requests/update",e,"user","api","rpc","file_requests.write")},_.filesAlphaGetMetadata=function(e){return this.request("files/alpha/get_metadata",e,"user","api","rpc","files.metadata.read")},_.filesAlphaUpload=function(e){return this.request("files/alpha/upload",e,"user","content","upload","files.content.write")},_.filesCopyV2=function(e){return this.request("files/copy_v2",e,"user","api","rpc","files.content.write")},_.filesCopy=function(e){return this.request("files/copy",e,"user","api","rpc","files.content.write")},_.filesCopyBatchV2=function(e){return this.request("files/copy_batch_v2",e,"user","api","rpc","files.content.write")},_.filesCopyBatch=function(e){return this.request("files/copy_batch",e,"user","api","rpc","files.content.write")},_.filesCopyBatchCheckV2=function(e){return this.request("files/copy_batch/check_v2",e,"user","api","rpc","files.content.write")},_.filesCopyBatchCheck=function(e){return this.request("files/copy_batch/check",e,"user","api","rpc","files.content.write")},_.filesCopyReferenceGet=function(e){return this.request("files/copy_reference/get",e,"user","api","rpc","files.content.write")},_.filesCopyReferenceSave=function(e){return this.request("files/copy_reference/save",e,"user","api","rpc","files.content.write")},_.filesCreateFolderV2=function(e){return this.request("files/create_folder_v2",e,"user","api","rpc","files.content.write")},_.filesCreateFolder=function(e){return this.request("files/create_folder",e,"user","api","rpc","files.content.write")},_.filesCreateFolderBatch=function(e){return this.request("files/create_folder_batch",e,"user","api","rpc","files.content.write")},_.filesCreateFolderBatchCheck=function(e){return this.request("files/create_folder_batch/check",e,"user","api","rpc","files.content.write")},_.filesDeleteV2=function(e){return this.request("files/delete_v2",e,"user","api","rpc","files.content.write")},_.filesDelete=function(e){return this.request("files/delete",e,"user","api","rpc","files.content.write")},_.filesDeleteBatch=function(e){return this.request("files/delete_batch",e,"user","api","rpc","files.content.write")},_.filesDeleteBatchCheck=function(e){return this.request("files/delete_batch/check",e,"user","api","rpc","files.content.write")},_.filesDownload=function(e){return this.request("files/download",e,"user","content","download","files.content.read")},_.filesDownloadZip=function(e){return this.request("files/download_zip",e,"user","content","download","files.content.read")},_.filesExport=function(e){return this.request("files/export",e,"user","content","download","files.content.read")},_.filesGetFileLockBatch=function(e){return this.request("files/get_file_lock_batch",e,"user","api","rpc","files.content.read")},_.filesGetMetadata=function(e){return this.request("files/get_metadata",e,"user","api","rpc","files.metadata.read")},_.filesGetPreview=function(e){return this.request("files/get_preview",e,"user","content","download","files.content.read")},_.filesGetTemporaryLink=function(e){return this.request("files/get_temporary_link",e,"user","api","rpc","files.content.read")},_.filesGetTemporaryUploadLink=function(e){return this.request("files/get_temporary_upload_link",e,"user","api","rpc","files.content.write")},_.filesGetThumbnail=function(e){return this.request("files/get_thumbnail",e,"user","content","download","files.content.read")},_.filesGetThumbnailV2=function(e){return this.request("files/get_thumbnail_v2",e,"app, user","content","download","files.content.read")},_.filesGetThumbnailBatch=function(e){return this.request("files/get_thumbnail_batch",e,"user","content","rpc","files.content.read")},_.filesListFolder=function(e){return this.request("files/list_folder",e,"app, user","api","rpc","files.metadata.read")},_.filesListFolderContinue=function(e){return this.request("files/list_folder/continue",e,"app, user","api","rpc","files.metadata.read")},_.filesListFolderGetLatestCursor=function(e){return this.request("files/list_folder/get_latest_cursor",e,"user","api","rpc","files.metadata.read")},_.filesListFolderLongpoll=function(e){return this.request("files/list_folder/longpoll",e,"noauth","notify","rpc","files.metadata.read")},_.filesListRevisions=function(e){return this.request("files/list_revisions",e,"user","api","rpc","files.metadata.read")},_.filesLockFileBatch=function(e){return this.request("files/lock_file_batch",e,"user","api","rpc","files.content.write")},_.filesMoveV2=function(e){return this.request("files/move_v2",e,"user","api","rpc","files.content.write")},_.filesMove=function(e){return this.request("files/move",e,"user","api","rpc","files.content.write")},_.filesMoveBatchV2=function(e){return this.request("files/move_batch_v2",e,"user","api","rpc","files.content.write")},_.filesMoveBatch=function(e){return this.request("files/move_batch",e,"user","api","rpc","files.content.write")},_.filesMoveBatchCheckV2=function(e){return this.request("files/move_batch/check_v2",e,"user","api","rpc","files.content.write")},_.filesMoveBatchCheck=function(e){return this.request("files/move_batch/check",e,"user","api","rpc","files.content.write")},_.filesPaperCreate=function(e){return this.request("files/paper/create",e,"user","api","upload","files.content.write")},_.filesPaperUpdate=function(e){return this.request("files/paper/update",e,"user","api","upload","files.content.write")},_.filesPermanentlyDelete=function(e){return this.request("files/permanently_delete",e,"user","api","rpc","files.permanent_delete")},_.filesPropertiesAdd=function(e){return this.request("files/properties/add",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesOverwrite=function(e){return this.request("files/properties/overwrite",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesRemove=function(e){return this.request("files/properties/remove",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesTemplateGet=function(e){return this.request("files/properties/template/get",e,"user","api","rpc","files.metadata.read")},_.filesPropertiesTemplateList=function(){return this.request("files/properties/template/list",null,"user","api","rpc","files.metadata.read")},_.filesPropertiesUpdate=function(e){return this.request("files/properties/update",e,"user","api","rpc","files.metadata.write")},_.filesRestore=function(e){return this.request("files/restore",e,"user","api","rpc","files.content.write")},_.filesSaveUrl=function(e){return this.request("files/save_url",e,"user","api","rpc","files.content.write")},_.filesSaveUrlCheckJobStatus=function(e){return this.request("files/save_url/check_job_status",e,"user","api","rpc","files.content.write")},_.filesSearch=function(e){return this.request("files/search",e,"user","api","rpc","files.metadata.read")},_.filesSearchV2=function(e){return this.request("files/search_v2",e,"user","api","rpc","files.metadata.read")},_.filesSearchContinueV2=function(e){return this.request("files/search/continue_v2",e,"user","api","rpc","files.metadata.read")},_.filesTagsAdd=function(e){return this.request("files/tags/add",e,"user","api","rpc","files.metadata.write")},_.filesTagsGet=function(e){return this.request("files/tags/get",e,"user","api","rpc","files.metadata.read")},_.filesTagsRemove=function(e){return this.request("files/tags/remove",e,"user","api","rpc","files.metadata.write")},_.filesUnlockFileBatch=function(e){return this.request("files/unlock_file_batch",e,"user","api","rpc","files.content.write")},_.filesUpload=function(e){return this.request("files/upload",e,"user","content","upload","files.content.write")},_.filesUploadSessionAppendV2=function(e){return this.request("files/upload_session/append_v2",e,"user","content","upload","files.content.write")},_.filesUploadSessionAppend=function(e){return this.request("files/upload_session/append",e,"user","content","upload","files.content.write")},_.filesUploadSessionFinish=function(e){return this.request("files/upload_session/finish",e,"user","content","upload","files.content.write")},_.filesUploadSessionFinishBatch=function(e){return this.request("files/upload_session/finish_batch",e,"user","api","rpc","files.content.write")},_.filesUploadSessionFinishBatchV2=function(e){return this.request("files/upload_session/finish_batch_v2",e,"user","api","rpc","files.content.write")},_.filesUploadSessionFinishBatchCheck=function(e){return this.request("files/upload_session/finish_batch/check",e,"user","api","rpc","files.content.write")},_.filesUploadSessionStart=function(e){return this.request("files/upload_session/start",e,"user","content","upload","files.content.write")},_.paperDocsArchive=function(e){return this.request("paper/docs/archive",e,"user","api","rpc","files.content.write")},_.paperDocsCreate=function(e){return this.request("paper/docs/create",e,"user","api","upload","files.content.write")},_.paperDocsDownload=function(e){return this.request("paper/docs/download",e,"user","api","download","files.content.read")},_.paperDocsFolderUsersList=function(e){return this.request("paper/docs/folder_users/list",e,"user","api","rpc","sharing.read")},_.paperDocsFolderUsersListContinue=function(e){return this.request("paper/docs/folder_users/list/continue",e,"user","api","rpc","sharing.read")},_.paperDocsGetFolderInfo=function(e){return this.request("paper/docs/get_folder_info",e,"user","api","rpc","sharing.read")},_.paperDocsList=function(e){return this.request("paper/docs/list",e,"user","api","rpc","files.metadata.read")},_.paperDocsListContinue=function(e){return this.request("paper/docs/list/continue",e,"user","api","rpc","files.metadata.read")},_.paperDocsPermanentlyDelete=function(e){return this.request("paper/docs/permanently_delete",e,"user","api","rpc","files.permanent_delete")},_.paperDocsSharingPolicyGet=function(e){return this.request("paper/docs/sharing_policy/get",e,"user","api","rpc","sharing.read")},_.paperDocsSharingPolicySet=function(e){return this.request("paper/docs/sharing_policy/set",e,"user","api","rpc","sharing.write")},_.paperDocsUpdate=function(e){return this.request("paper/docs/update",e,"user","api","upload","files.content.write")},_.paperDocsUsersAdd=function(e){return this.request("paper/docs/users/add",e,"user","api","rpc","sharing.write")},_.paperDocsUsersList=function(e){return this.request("paper/docs/users/list",e,"user","api","rpc","sharing.read")},_.paperDocsUsersListContinue=function(e){return this.request("paper/docs/users/list/continue",e,"user","api","rpc","sharing.read")},_.paperDocsUsersRemove=function(e){return this.request("paper/docs/users/remove",e,"user","api","rpc","sharing.write")},_.paperFoldersCreate=function(e){return this.request("paper/folders/create",e,"user","api","rpc","files.content.write")},_.sharingAddFileMember=function(e){return this.request("sharing/add_file_member",e,"user","api","rpc","sharing.write")},_.sharingAddFolderMember=function(e){return this.request("sharing/add_folder_member",e,"user","api","rpc","sharing.write")},_.sharingCheckJobStatus=function(e){return this.request("sharing/check_job_status",e,"user","api","rpc","sharing.write")},_.sharingCheckRemoveMemberJobStatus=function(e){return this.request("sharing/check_remove_member_job_status",e,"user","api","rpc","sharing.write")},_.sharingCheckShareJobStatus=function(e){return this.request("sharing/check_share_job_status",e,"user","api","rpc","sharing.write")},_.sharingCreateSharedLink=function(e){return this.request("sharing/create_shared_link",e,"user","api","rpc","sharing.write")},_.sharingCreateSharedLinkWithSettings=function(e){return this.request("sharing/create_shared_link_with_settings",e,"user","api","rpc","sharing.write")},_.sharingGetFileMetadata=function(e){return this.request("sharing/get_file_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetFileMetadataBatch=function(e){return this.request("sharing/get_file_metadata/batch",e,"user","api","rpc","sharing.read")},_.sharingGetFolderMetadata=function(e){return this.request("sharing/get_folder_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetSharedLinkFile=function(e){return this.request("sharing/get_shared_link_file",e,"user","content","download","sharing.read")},_.sharingGetSharedLinkMetadata=function(e){return this.request("sharing/get_shared_link_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetSharedLinks=function(e){return this.request("sharing/get_shared_links",e,"user","api","rpc","sharing.read")},_.sharingListFileMembers=function(e){return this.request("sharing/list_file_members",e,"user","api","rpc","sharing.read")},_.sharingListFileMembersBatch=function(e){return this.request("sharing/list_file_members/batch",e,"user","api","rpc","sharing.read")},_.sharingListFileMembersContinue=function(e){return this.request("sharing/list_file_members/continue",e,"user","api","rpc","sharing.read")},_.sharingListFolderMembers=function(e){return this.request("sharing/list_folder_members",e,"user","api","rpc","sharing.read")},_.sharingListFolderMembersContinue=function(e){return this.request("sharing/list_folder_members/continue",e,"user","api","rpc","sharing.read")},_.sharingListFolders=function(e){return this.request("sharing/list_folders",e,"user","api","rpc","sharing.read")},_.sharingListFoldersContinue=function(e){return this.request("sharing/list_folders/continue",e,"user","api","rpc","sharing.read")},_.sharingListMountableFolders=function(e){return this.request("sharing/list_mountable_folders",e,"user","api","rpc","sharing.read")},_.sharingListMountableFoldersContinue=function(e){return this.request("sharing/list_mountable_folders/continue",e,"user","api","rpc","sharing.read")},_.sharingListReceivedFiles=function(e){return this.request("sharing/list_received_files",e,"user","api","rpc","sharing.read")},_.sharingListReceivedFilesContinue=function(e){return this.request("sharing/list_received_files/continue",e,"user","api","rpc","sharing.read")},_.sharingListSharedLinks=function(e){return this.request("sharing/list_shared_links",e,"user","api","rpc","sharing.read")},_.sharingModifySharedLinkSettings=function(e){return this.request("sharing/modify_shared_link_settings",e,"user","api","rpc","sharing.write")},_.sharingMountFolder=function(e){return this.request("sharing/mount_folder",e,"user","api","rpc","sharing.write")},_.sharingRelinquishFileMembership=function(e){return this.request("sharing/relinquish_file_membership",e,"user","api","rpc","sharing.write")},_.sharingRelinquishFolderMembership=function(e){return this.request("sharing/relinquish_folder_membership",e,"user","api","rpc","sharing.write")},_.sharingRemoveFileMember=function(e){return this.request("sharing/remove_file_member",e,"user","api","rpc","sharing.write")},_.sharingRemoveFileMember2=function(e){return this.request("sharing/remove_file_member_2",e,"user","api","rpc","sharing.write")},_.sharingRemoveFolderMember=function(e){return this.request("sharing/remove_folder_member",e,"user","api","rpc","sharing.write")},_.sharingRevokeSharedLink=function(e){return this.request("sharing/revoke_shared_link",e,"user","api","rpc","sharing.write")},_.sharingSetAccessInheritance=function(e){return this.request("sharing/set_access_inheritance",e,"user","api","rpc","sharing.write")},_.sharingShareFolder=function(e){return this.request("sharing/share_folder",e,"user","api","rpc","sharing.write")},_.sharingTransferFolder=function(e){return this.request("sharing/transfer_folder",e,"user","api","rpc","sharing.write")},_.sharingUnmountFolder=function(e){return this.request("sharing/unmount_folder",e,"user","api","rpc","sharing.write")},_.sharingUnshareFile=function(e){return this.request("sharing/unshare_file",e,"user","api","rpc","sharing.write")},_.sharingUnshareFolder=function(e){return this.request("sharing/unshare_folder",e,"user","api","rpc","sharing.write")},_.sharingUpdateFileMember=function(e){return this.request("sharing/update_file_member",e,"user","api","rpc","sharing.write")},_.sharingUpdateFolderMember=function(e){return this.request("sharing/update_folder_member",e,"user","api","rpc","sharing.write")},_.sharingUpdateFolderPolicy=function(e){return this.request("sharing/update_folder_policy",e,"user","api","rpc","sharing.write")},_.teamDevicesListMemberDevices=function(e){return this.request("team/devices/list_member_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesListMembersDevices=function(e){return this.request("team/devices/list_members_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesListTeamDevices=function(e){return this.request("team/devices/list_team_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesRevokeDeviceSession=function(e){return this.request("team/devices/revoke_device_session",e,"team","api","rpc","sessions.modify")},_.teamDevicesRevokeDeviceSessionBatch=function(e){return this.request("team/devices/revoke_device_session_batch",e,"team","api","rpc","sessions.modify")},_.teamFeaturesGetValues=function(e){return this.request("team/features/get_values",e,"team","api","rpc","team_info.read")},_.teamGetInfo=function(){return this.request("team/get_info",null,"team","api","rpc","team_info.read")},_.teamGroupsCreate=function(e){return this.request("team/groups/create",e,"team","api","rpc","groups.write")},_.teamGroupsDelete=function(e){return this.request("team/groups/delete",e,"team","api","rpc","groups.write")},_.teamGroupsGetInfo=function(e){return this.request("team/groups/get_info",e,"team","api","rpc","groups.read")},_.teamGroupsJobStatusGet=function(e){return this.request("team/groups/job_status/get",e,"team","api","rpc","groups.write")},_.teamGroupsList=function(e){return this.request("team/groups/list",e,"team","api","rpc","groups.read")},_.teamGroupsListContinue=function(e){return this.request("team/groups/list/continue",e,"team","api","rpc","groups.read")},_.teamGroupsMembersAdd=function(e){return this.request("team/groups/members/add",e,"team","api","rpc","groups.write")},_.teamGroupsMembersList=function(e){return this.request("team/groups/members/list",e,"team","api","rpc","groups.read")},_.teamGroupsMembersListContinue=function(e){return this.request("team/groups/members/list/continue",e,"team","api","rpc","groups.read")},_.teamGroupsMembersRemove=function(e){return this.request("team/groups/members/remove",e,"team","api","rpc","groups.write")},_.teamGroupsMembersSetAccessType=function(e){return this.request("team/groups/members/set_access_type",e,"team","api","rpc","groups.write")},_.teamGroupsUpdate=function(e){return this.request("team/groups/update",e,"team","api","rpc","groups.write")},_.teamLegalHoldsCreatePolicy=function(e){return this.request("team/legal_holds/create_policy",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsGetPolicy=function(e){return this.request("team/legal_holds/get_policy",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsListHeldRevisions=function(e){return this.request("team/legal_holds/list_held_revisions",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsListHeldRevisionsContinue=function(e){return this.request("team/legal_holds/list_held_revisions_continue",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsListPolicies=function(e){return this.request("team/legal_holds/list_policies",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsReleasePolicy=function(e){return this.request("team/legal_holds/release_policy",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsUpdatePolicy=function(e){return this.request("team/legal_holds/update_policy",e,"team","api","rpc","team_data.member")},_.teamLinkedAppsListMemberLinkedApps=function(e){return this.request("team/linked_apps/list_member_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsListMembersLinkedApps=function(e){return this.request("team/linked_apps/list_members_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsListTeamLinkedApps=function(e){return this.request("team/linked_apps/list_team_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsRevokeLinkedApp=function(e){return this.request("team/linked_apps/revoke_linked_app",e,"team","api","rpc","sessions.modify")},_.teamLinkedAppsRevokeLinkedAppBatch=function(e){return this.request("team/linked_apps/revoke_linked_app_batch",e,"team","api","rpc","sessions.modify")},_.teamMemberSpaceLimitsExcludedUsersAdd=function(e){return this.request("team/member_space_limits/excluded_users/add",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsExcludedUsersList=function(e){return this.request("team/member_space_limits/excluded_users/list",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsExcludedUsersListContinue=function(e){return this.request("team/member_space_limits/excluded_users/list/continue",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsExcludedUsersRemove=function(e){return this.request("team/member_space_limits/excluded_users/remove",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsGetCustomQuota=function(e){return this.request("team/member_space_limits/get_custom_quota",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsRemoveCustomQuota=function(e){return this.request("team/member_space_limits/remove_custom_quota",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsSetCustomQuota=function(e){return this.request("team/member_space_limits/set_custom_quota",e,"team","api","rpc","members.read")},_.teamMembersAddV2=function(e){return this.request("team/members/add_v2",e,"team","api","rpc","members.write")},_.teamMembersAdd=function(e){return this.request("team/members/add",e,"team","api","rpc","members.write")},_.teamMembersAddJobStatusGetV2=function(e){return this.request("team/members/add/job_status/get_v2",e,"team","api","rpc","members.write")},_.teamMembersAddJobStatusGet=function(e){return this.request("team/members/add/job_status/get",e,"team","api","rpc","members.write")},_.teamMembersDeleteProfilePhotoV2=function(e){return this.request("team/members/delete_profile_photo_v2",e,"team","api","rpc","members.write")},_.teamMembersDeleteProfilePhoto=function(e){return this.request("team/members/delete_profile_photo",e,"team","api","rpc","members.write")},_.teamMembersGetAvailableTeamMemberRoles=function(){return this.request("team/members/get_available_team_member_roles",null,"team","api","rpc","members.read")},_.teamMembersGetInfoV2=function(e){return this.request("team/members/get_info_v2",e,"team","api","rpc","members.read")},_.teamMembersGetInfo=function(e){return this.request("team/members/get_info",e,"team","api","rpc","members.read")},_.teamMembersListV2=function(e){return this.request("team/members/list_v2",e,"team","api","rpc","members.read")},_.teamMembersList=function(e){return this.request("team/members/list",e,"team","api","rpc","members.read")},_.teamMembersListContinueV2=function(e){return this.request("team/members/list/continue_v2",e,"team","api","rpc","members.read")},_.teamMembersListContinue=function(e){return this.request("team/members/list/continue",e,"team","api","rpc","members.read")},_.teamMembersMoveFormerMemberFiles=function(e){return this.request("team/members/move_former_member_files",e,"team","api","rpc","members.write")},_.teamMembersMoveFormerMemberFilesJobStatusCheck=function(e){return this.request("team/members/move_former_member_files/job_status/check",e,"team","api","rpc","members.write")},_.teamMembersRecover=function(e){return this.request("team/members/recover",e,"team","api","rpc","members.delete")},_.teamMembersRemove=function(e){return this.request("team/members/remove",e,"team","api","rpc","members.delete")},_.teamMembersRemoveJobStatusGet=function(e){return this.request("team/members/remove/job_status/get",e,"team","api","rpc","members.delete")},_.teamMembersSecondaryEmailsAdd=function(e){return this.request("team/members/secondary_emails/add",e,"team","api","rpc","members.write")},_.teamMembersSecondaryEmailsDelete=function(e){return this.request("team/members/secondary_emails/delete",e,"team","api","rpc","members.write")},_.teamMembersSecondaryEmailsResendVerificationEmails=function(e){return this.request("team/members/secondary_emails/resend_verification_emails",e,"team","api","rpc","members.write")},_.teamMembersSendWelcomeEmail=function(e){return this.request("team/members/send_welcome_email",e,"team","api","rpc","members.write")},_.teamMembersSetAdminPermissionsV2=function(e){return this.request("team/members/set_admin_permissions_v2",e,"team","api","rpc","members.write")},_.teamMembersSetAdminPermissions=function(e){return this.request("team/members/set_admin_permissions",e,"team","api","rpc","members.write")},_.teamMembersSetProfileV2=function(e){return this.request("team/members/set_profile_v2",e,"team","api","rpc","members.write")},_.teamMembersSetProfile=function(e){return this.request("team/members/set_profile",e,"team","api","rpc","members.write")},_.teamMembersSetProfilePhotoV2=function(e){return this.request("team/members/set_profile_photo_v2",e,"team","api","rpc","members.write")},_.teamMembersSetProfilePhoto=function(e){return this.request("team/members/set_profile_photo",e,"team","api","rpc","members.write")},_.teamMembersSuspend=function(e){return this.request("team/members/suspend",e,"team","api","rpc","members.write")},_.teamMembersUnsuspend=function(e){return this.request("team/members/unsuspend",e,"team","api","rpc","members.write")},_.teamNamespacesList=function(e){return this.request("team/namespaces/list",e,"team","api","rpc","team_data.member")},_.teamNamespacesListContinue=function(e){return this.request("team/namespaces/list/continue",e,"team","api","rpc","team_data.member")},_.teamPropertiesTemplateAdd=function(e){return this.request("team/properties/template/add",e,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateGet=function(e){return this.request("team/properties/template/get",e,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateList=function(){return this.request("team/properties/template/list",null,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateUpdate=function(e){return this.request("team/properties/template/update",e,"team","api","rpc","files.team_metadata.write")},_.teamReportsGetActivity=function(e){return this.request("team/reports/get_activity",e,"team","api","rpc","team_info.read")},_.teamReportsGetDevices=function(e){return this.request("team/reports/get_devices",e,"team","api","rpc","team_info.read")},_.teamReportsGetMembership=function(e){return this.request("team/reports/get_membership",e,"team","api","rpc","team_info.read")},_.teamReportsGetStorage=function(e){return this.request("team/reports/get_storage",e,"team","api","rpc","team_info.read")},_.teamTeamFolderActivate=function(e){return this.request("team/team_folder/activate",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderArchive=function(e){return this.request("team/team_folder/archive",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderArchiveCheck=function(e){return this.request("team/team_folder/archive/check",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderCreate=function(e){return this.request("team/team_folder/create",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderGetInfo=function(e){return this.request("team/team_folder/get_info",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderList=function(e){return this.request("team/team_folder/list",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderListContinue=function(e){return this.request("team/team_folder/list/continue",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderPermanentlyDelete=function(e){return this.request("team/team_folder/permanently_delete",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderRename=function(e){return this.request("team/team_folder/rename",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderUpdateSyncSettings=function(e){return this.request("team/team_folder/update_sync_settings",e,"team","api","rpc","team_data.team_space")},_.teamTokenGetAuthenticatedAdmin=function(){return this.request("team/token/get_authenticated_admin",null,"team","api","rpc","team_info.read")},_.teamLogGetEvents=function(e){return this.request("team_log/get_events",e,"team","api","rpc","events.read")},_.teamLogGetEventsContinue=function(e){return this.request("team_log/get_events/continue",e,"team","api","rpc","events.read")},_.usersFeaturesGetValues=function(e){return this.request("users/features/get_values",e,"user","api","rpc","account_info.read")},_.usersGetAccount=function(e){return this.request("users/get_account",e,"user","api","rpc","sharing.read")},_.usersGetAccountBatch=function(e){return this.request("users/get_account_batch",e,"user","api","rpc","sharing.read")},_.usersGetCurrentAccount=function(){return this.request("users/get_current_account",null,"user","api","rpc","account_info.read")},_.usersGetSpaceUsage=function(){return this.request("users/get_space_usage",null,"user","api","rpc","account_info.read")};var q=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";return r?(t!==f&&void 0!==d[e]&&(e=d[e],r="-"),"https://".concat(e).concat(r).concat(t,"/2/")):"https://".concat(t,"/2/")},b=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:h;return e!==h&&(e="meta-".concat(e)),"https://".concat(e,"/oauth2/authorize")},v=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:f,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:".",r="api";return e!==f&&(r=d[r],t="-"),"https://".concat(r).concat(t).concat(e,"/oauth2/token")};function w(e){return JSON.stringify(e).replace(/[\u007f-\uffff]/g,g)}function k(e){return new Date(Date.now()+1e3*e)}function y(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope||"undefined"==typeof module||"undefined"!=typeof window}function A(){return"undefined"!=typeof window}function C(e){return e.toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}var S,T,L,M=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&n(e,t)}(o,e);var r,s,u=(r=o,s=a(),function(){var e,t=i(r);if(s){var n=i(this).constructor;e=Reflect.construct(t,arguments,n)}else e=t.apply(this,arguments);return c(this,e)});function o(e,r,s){var i;return t(this,o),(i=u.call(this,"Response failed with a ".concat(e," code"))).name="DropboxResponseError",i.status=e,i.headers=r,i.error=s,i}return o}(o(Error)),P=function e(r,s,i){t(this,e),this.status=r,this.headers=s,this.result=i};function R(e){return e.text().then((function(t){var r;try{r=JSON.parse(t)}catch(e){r=t}throw new M(e.status,e.headers,r)}))}function F(e){return e.ok?e.text().then((function(t){var r;try{r=JSON.parse(t)}catch(e){r=t}return new P(e.status,e.headers,r)})):R(e)}S=A()?window.fetch.bind(window):require("node-fetch"),T=A()?window.crypto||window.msCrypto:require("crypto"),L="undefined"==typeof TextEncoder?require("util").TextEncoder:TextEncoder;var D,G=["legacy","offline","online"],U=["code","token"],x=["none","user","team"],E=function(){function e(r){t(this,e),this.fetch=(r=r||{}).fetch||S,this.accessToken=r.accessToken,this.accessTokenExpiresAt=r.accessTokenExpiresAt,this.refreshToken=r.refreshToken,this.clientId=r.clientId,this.clientSecret=r.clientSecret,this.domain=r.domain,this.domainDelimiter=r.domainDelimiter,this.customHeaders=r.customHeaders,this.dataOnBody=r.dataOnBody}return s(e,[{key:"setAccessToken",value:function(e){this.accessToken=e}},{key:"getAccessToken",value:function(){return this.accessToken}},{key:"setClientId",value:function(e){this.clientId=e}},{key:"getClientId",value:function(){return this.clientId}},{key:"setClientSecret",value:function(e){this.clientSecret=e}},{key:"getClientSecret",value:function(){return this.clientSecret}},{key:"getRefreshToken",value:function(){return this.refreshToken}},{key:"setRefreshToken",value:function(e){this.refreshToken=e}},{key:"getAccessTokenExpiresAt",value:function(){return this.accessTokenExpiresAt}},{key:"setAccessTokenExpiresAt",value:function(e){this.accessTokenExpiresAt=e}},{key:"setCodeVerifier",value:function(e){this.codeVerifier=e}},{key:"getCodeVerifier",value:function(){return this.codeVerifier}},{key:"generateCodeChallenge",value:function(){var e,t=this,r=(new L).encode(this.codeVerifier);if(A())return T.subtle.digest("SHA-256",r).then((function(r){var s=btoa(String.fromCharCode.apply(null,new Uint8Array(r)));e=C(s).substr(0,128),t.codeChallenge=e}));var s=T.createHash("sha256").update(r).digest();return e=C(s),this.codeChallenge=e,Promise.resolve()}},{key:"generatePKCECodes",value:function(){var e;if(A()){var t=new Uint8Array(128),r=T.getRandomValues(t);e=C(btoa(r)).substr(0,128)}else{e=C(T.randomBytes(128)).substr(0,128)}return this.codeVerifier=e,this.generateCodeChallenge()}},{key:"getAuthenticationUrl",value:function(e,t){var r,s=this,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"token",n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"none",o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=this.getClientId(),p=b(this.domain);if(!c)throw Error("A client id is required. You can set the client id using .setClientId().");if("code"!==i&&!e)throw Error("A redirect uri is required.");if(!U.includes(i))throw Error("Authorization type must be code or token");if(n&&!G.includes(n))throw Error("Token Access Type must be legacy, offline, or online");if(a&&!(a instanceof Array))throw Error("Scope must be an array of strings");if(!x.includes(u))throw Error("includeGrantedScopes must be none, user, or team");return r="code"===i?"".concat(p,"?response_type=code&client_id=").concat(c):"".concat(p,"?response_type=token&client_id=").concat(c),e&&(r+="&redirect_uri=".concat(e)),t&&(r+="&state=".concat(t)),n&&(r+="&token_access_type=".concat(n)),a&&(r+="&scope=".concat(a.join(" "))),"none"!==u&&(r+="&include_granted_scopes=".concat(u)),o?this.generatePKCECodes().then((function(){return r+="&code_challenge_method=S256",r+="&code_challenge=".concat(s.codeChallenge)})):Promise.resolve(r)}},{key:"getAccessTokenFromCode",value:function(e,t){var r=this.getClientId(),s=this.getClientSecret();if(!r)throw Error("A client id is required. You can set the client id using .setClientId().");var i=v(this.domain,this.domainDelimiter);if(i+="?grant_type=authorization_code",i+="&code=".concat(t),i+="&client_id=".concat(r),s)i+="&client_secret=".concat(s);else{if(!this.codeVerifier)throw Error("You must use PKCE when generating the authorization URL to not include a client secret");i+="&code_verifier=".concat(this.codeVerifier)}e&&(i+="&redirect_uri=".concat(e));return this.fetch(i,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"}}).then((function(e){return F(e)}))}},{key:"checkAndRefreshAccessToken",value:function(){var e=this.getRefreshToken()&&this.getClientId(),t=!this.getAccessTokenExpiresAt()||new Date(Date.now()+3e5)>=this.getAccessTokenExpiresAt(),r=!this.getAccessToken();return(t||r)&&e?this.refreshAccessToken():Promise.resolve()}},{key:"refreshAccessToken",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=this.getClientId(),s=this.getClientSecret();if(!r)throw Error("A client id is required. You can set the client id using .setClientId().");if(t&&!(t instanceof Array))throw Error("Scope must be an array of strings");var i=v(this.domain,this.domainDelimiter),n={headers:{"Content-Type":"application/json"},method:"POST"};if(this.dataOnBody){var a={grant_type:"refresh_token",client_id:r,refresh_token:this.getRefreshToken()};s&&(a.client_secret=s),t&&(a.scope=t.join(" ")),n.body=a}else i+="?grant_type=refresh_token&refresh_token=".concat(this.getRefreshToken()),i+="&client_id=".concat(r),s&&(i+="&client_secret=".concat(s)),t&&(i+="&scope=".concat(t.join(" ")));return this.fetch(i,n).then((function(e){return F(e)})).then((function(t){e.setAccessToken(t.result.access_token),e.setAccessTokenExpiresAt(k(t.result.expires_in))}))}}]),e}();D="undefined"!=typeof window?window.fetch.bind(window):require("node-fetch");var V="undefined"==typeof btoa?function(e){return Buffer.from(e).toString("base64")}:btoa;e.Dropbox=function(){function e(r){t(this,e),this.auth=(r=r||{}).auth?r.auth:new E(r),this.fetch=r.fetch||D,this.selectUser=r.selectUser,this.selectAdmin=r.selectAdmin,this.pathRoot=r.pathRoot,this.domain=r.domain||this.auth.domain,this.domainDelimiter=r.domainDelimiter||this.auth.domainDelimiter,this.customHeaders=r.customHeaders||this.auth.customHeaders,Object.assign(this,_)}return s(e,[{key:"request",value:function(e,t,r,s,i){switch(i){case"rpc":return this.rpcRequest(e,t,r,s);case"download":return this.downloadRequest(e,t,r,s);case"upload":return this.uploadRequest(e,t,r,s);default:throw Error("Invalid request style: ".concat(i))}}},{key:"rpcRequest",value:function(e,t,r,s){var i=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e={method:"POST",body:t?JSON.stringify(t):null,headers:{}};return t&&(e.headers["Content-Type"]="application/json"),i.setAuthHeaders(r,e),i.setCommonHeaders(e),e})).then((function(t){return i.fetch(q(s,i.domain,i.domainDelimiter)+e,t)})).then((function(e){return F(e)}))}},{key:"downloadRequest",value:function(e,t,r,s){var i=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e={method:"POST",headers:{"Dropbox-API-Arg":w(t)}};return i.setAuthHeaders(r,e),i.setCommonHeaders(e),e})).then((function(t){return i.fetch(q(s,i.domain,i.domainDelimiter)+e,t)})).then((function(e){return function(e){return e.ok?new Promise((function(t){y()?e.blob().then((function(e){return t(e)})):e.buffer().then((function(e){return t(e)}))})).then((function(t){var r=JSON.parse(e.headers.get("dropbox-api-result"));return y()?r.fileBlob=t:r.fileBinary=t,new P(e.status,e.headers,r)})):R(e)}(e)}))}},{key:"uploadRequest",value:function(e,t,r,s){var i=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e=t.contents;delete t.contents;var s={body:e,method:"POST",headers:{"Content-Type":"application/octet-stream","Dropbox-API-Arg":w(t)}};return i.setAuthHeaders(r,s),i.setCommonHeaders(s),s})).then((function(t){return i.fetch(q(s,i.domain,i.domainDelimiter)+e,t)})).then((function(e){return F(e)}))}},{key:"setAuthHeaders",value:function(e,t){if(e.split(",").length>1){var r=e.replace(" ","").split(",");r.includes(l)&&this.auth.getAccessToken()?e=l:r.includes(m)&&this.auth.getAccessToken()?e=m:r.includes(p)&&(e=p)}switch(e){case p:if(this.auth.clientId&&this.auth.clientSecret){var s=V("".concat(this.auth.clientId,":").concat(this.auth.clientSecret));t.headers.Authorization="Basic ".concat(s)}break;case m:case l:this.auth.getAccessToken()&&(t.headers.Authorization="Bearer ".concat(this.auth.getAccessToken()));break;case"noauth":case"cookie":break;default:throw Error("Unhandled auth type: ".concat(e))}}},{key:"setCommonHeaders",value:function(e){var t=this;(this.selectUser&&(e.headers["Dropbox-API-Select-User"]=this.selectUser),this.selectAdmin&&(e.headers["Dropbox-API-Select-Admin"]=this.selectAdmin),this.pathRoot&&(e.headers["Dropbox-API-Path-Root"]=this.pathRoot),this.customHeaders)&&Object.keys(this.customHeaders).forEach((function(r){e.headers[r]=t.customHeaders[r]}))}}]),e}(),e.DropboxAuth=E,e.DropboxResponse=P,e.DropboxResponseError=M,Object.defineProperty(e,"__esModule",{value:!0})})), function(r, v, f) {
    function w(a, b, g) {
        a.addEventListener ? a.addEventListener(b, g, !1) : a.attachEvent("on" + b, g);
    }
    function A(a) {
        if ("keypress" == a.type) {
            var b = String.fromCharCode(a.which);
            return a.shiftKey || (b = b.toLowerCase()), b;
        }
        return p[a.which] ? p[a.which] : t[a.which] ? t[a.which] : String.fromCharCode(a.which).toLowerCase();
    }
    function F(a) {
        var b = [];
        return a.shiftKey && b.push("shift"), a.altKey && b.push("alt"), a.ctrlKey && b.push("ctrl"),
        a.metaKey && b.push("meta"), b;
    }
    function x(a) {
        return "shift" == a || "ctrl" == a || "alt" == a || "meta" == a;
    }
    function B(a, b) {
        var g, c, d, f = [];
        for (g = a, "+" === g ? g = [ "+" ] : (g = g.replace(/\+{2}/g, "+plus"), g = g.split("+")),
        d = 0; d < g.length; ++d) c = g[d], C[c] && (c = C[c]), b && "keypress" != b && D[c] && (c = D[c],
        f.push("shift")), x(c) && f.push(c);
        if (g = c, !(d = b)) {
            if (!n) {
                n = {};
                for (var q in p) 95 < q && 112 > q || p.hasOwnProperty(q) && (n[p[q]] = q);
            }
            d = n[g] ? "keydown" : "keypress";
        }
        return "keypress" == d && f.length && (d = "keydown"), {
            key: c,
            modifiers: f,
            action: d
        };
    }
    function E(a, b) {
        return null !== a && a !== v && (a === b || E(a.parentNode, b));
    }
    function c(a) {
        function b(a) {
            a = a || {};
            var l, b = !1;
            for (l in n) a[l] ? b = !0 : n[l] = 0;
            b || (y = !1);
        }
        function g(a, b, u, e, c, g) {
            var l, m, k = [], f = u.type;
            if (!h._callbacks[a]) return [];
            for ("keyup" == f && x(a) && (b = [ a ]), l = 0; l < h._callbacks[a].length; ++l) if (m = h._callbacks[a][l],
            (e || !m.seq || n[m.seq] == m.level) && f == m.action) {
                var d;
                (d = "keypress" == f && !u.metaKey && !u.ctrlKey) || (d = m.modifiers, d = b.sort().join(",") === d.sort().join(",")),
                d && (d = e && m.seq == e && m.level == g, (!e && m.combo == c || d) && h._callbacks[a].splice(l, 1),
                k.push(m));
            }
            return k;
        }
        function f(a, b, c, e) {
            h.stopCallback(b, b.target || b.srcElement, c, e) || !1 !== a(b, c) || (b.preventDefault ? b.preventDefault() : b.returnValue = !1,
            b.stopPropagation ? b.stopPropagation() : b.cancelBubble = !0);
        }
        function d(a) {
            "number" != typeof a.which && (a.which = a.keyCode);
            var b = A(a);
            b && ("keyup" == a.type && z === b ? z = !1 : h.handleKey(b, F(a), a));
        }
        function p(a, c, u, e) {
            function g(c) {
                f(u, c, a), "keyup" !== e && (z = A(c)), setTimeout(b, 10);
            }
            for (var d = n[a] = 0; d < c.length; ++d) {
                var m = d + 1 === c.length ? g : function(c) {
                    return function() {
                        y = c, ++n[a], clearTimeout(r), r = setTimeout(b, 1e3);
                    };
                }(e || B(c[d + 1]).action);
                q(c[d], m, e, a, d);
            }
        }
        function q(a, b, c, e, d) {
            h._directMap[a + ":" + c] = b, a = a.replace(/\s+/g, " ");
            var f = a.split(" ");
            1 < f.length ? p(a, f, b, c) : (c = B(a, c), h._callbacks[c.key] = h._callbacks[c.key] || [],
            g(c.key, c.modifiers, {
                type: c.action
            }, e, a, d), h._callbacks[c.key][e ? "unshift" : "push"]({
                callback: b,
                modifiers: c.modifiers,
                action: c.action,
                seq: e,
                level: d,
                combo: a
            }));
        }
        var h = this;
        if (a = a || v, !(h instanceof c)) return new c(a);
        h.target = a, h._callbacks = {}, h._directMap = {};
        var r, n = {}, z = !1, t = !1, y = !1;
        h._handleKey = function(a, c, d) {
            var k, e = g(a, c, d);
            c = {};
            var h = 0, l = !1;
            for (k = 0; k < e.length; ++k) e[k].seq && (h = Math.max(h, e[k].level));
            for (k = 0; k < e.length; ++k) e[k].seq ? e[k].level == h && (l = !0, c[e[k].seq] = 1,
            f(e[k].callback, d, e[k].combo, e[k].seq)) : l || f(e[k].callback, d, e[k].combo);
            e = "keypress" == d.type && t, d.type != y || x(a) || e || b(c), t = l && "keydown" == d.type;
        }, h._bindMultiple = function(a, b, c) {
            for (var d = 0; d < a.length; ++d) q(a[d], b, c);
        }, w(a, "keypress", d), w(a, "keydown", d), w(a, "keyup", d);
    }
    if (r) {
        var n, p = {
            8: "backspace",
            9: "tab",
            13: "enter",
            16: "shift",
            17: "ctrl",
            18: "alt",
            20: "capslock",
            27: "esc",
            32: "space",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            45: "ins",
            46: "del",
            91: "meta",
            93: "meta",
            224: "meta"
        }, t = {
            106: "*",
            107: "+",
            109: "-",
            110: ".",
            111: "/",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'"
        }, D = {
            "~": "`",
            "!": "1",
            "@": "2",
            "#": "3",
            $: "4",
            "%": "5",
            "^": "6",
            "&": "7",
            "*": "8",
            "(": "9",
            ")": "0",
            _: "-",
            "+": "=",
            ":": ";",
            '"': "'",
            "<": ",",
            ">": ".",
            "?": "/",
            "|": "\\"
        }, C = {
            option: "alt",
            command: "meta",
            return: "enter",
            escape: "esc",
            plus: "+",
            mod: /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
        };
        for (f = 1; 20 > f; ++f) p[111 + f] = "f" + f;
        for (f = 0; 9 >= f; ++f) p[f + 96] = f.toString();
        c.prototype.bind = function(a, b, c) {
            return a = a instanceof Array ? a : [ a ], this._bindMultiple.call(this, a, b, c),
            this;
        }, c.prototype.unbind = function(a, b) {
            return this.bind.call(this, a, function() {}, b);
        }, c.prototype.trigger = function(a, b) {
            return this._directMap[a + ":" + b] && this._directMap[a + ":" + b]({}, a), this;
        }, c.prototype.reset = function() {
            return this._callbacks = {}, this._directMap = {}, this;
        }, c.prototype.stopCallback = function(a, b) {
            return !(-1 < (" " + b.className + " ").indexOf(" mousetrap ") || E(b, this.target)) && ("INPUT" == b.tagName || "SELECT" == b.tagName || "TEXTAREA" == b.tagName || b.isContentEditable);
        }, c.prototype.handleKey = function() {
            return this._handleKey.apply(this, arguments);
        }, c.addKeycodes = function(a) {
            for (var b in a) a.hasOwnProperty(b) && (p[b] = a[b]);
            n = null;
        }, c.init = function() {
            var b, a = c(v);
            for (b in a) "_" !== b.charAt(0) && (c[b] = function(b) {
                return function() {
                    return a[b].apply(a, arguments);
                };
            }(b));
        }, c.init(), r.Mousetrap = c, "undefined" != typeof module && module.exports && (module.exports = c),
        "function" == typeof define && define.amd && define(function() {
            return c;
        });
    }
}("undefined" != typeof window ? window : null, "undefined" != typeof window ? document : null);

var Typo = function(dictionary, affData, wordsData, settings) {
    if (settings = settings || {}, this.platform = settings.platform || "chrome", this.dictionary = null,
    this.rules = {}, this.dictionaryTable = {}, this.compoundRules = [], this.compoundRuleCodes = {},
    this.replacementTable = [], this.flags = settings.flags || {}, dictionary) {
        if (this.dictionary = dictionary, "chrome" == this.platform) affData || (affData = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + dictionary + "/" + dictionary + ".aff"))),
        wordsData || (wordsData = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + dictionary + "/" + dictionary + ".dic"))); else {
            var path = settings.dictionaryPath || "";
            affData || (affData = this._readFile(path + "/" + dictionary + "/" + dictionary + ".aff")),
            wordsData || (wordsData = this._readFile(path + "/" + dictionary + "/" + dictionary + ".dic"));
        }
        this.rules = this._parseAFF(affData), this.compoundRuleCodes = {};
        for (var i = 0, _len = this.compoundRules.length; i < _len; i++) for (var rule = this.compoundRules[i], j = 0, _jlen = rule.length; j < _jlen; j++) this.compoundRuleCodes[rule[j]] = [];
        "ONLYINCOMPOUND" in this.flags && (this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = []),
        this.dictionaryTable = this._parseDIC(wordsData);
        for (var i in this.compoundRuleCodes) 0 == this.compoundRuleCodes[i].length && delete this.compoundRuleCodes[i];
        for (var i = 0, _len = this.compoundRules.length; i < _len; i++) {
            for (var ruleText = this.compoundRules[i], expressionText = "", j = 0, _jlen = ruleText.length; j < _jlen; j++) {
                var character = ruleText[j];
                character in this.compoundRuleCodes ? expressionText += "(" + this.compoundRuleCodes[character].join("|") + ")" : expressionText += character;
            }
            this.compoundRules[i] = new RegExp(expressionText, "i");
        }
    }
    return this;
};

if (Typo.prototype = {
    load: function(obj) {
        for (var i in obj) this[i] = obj[i];
        return this;
    },
    _readFile: function(path, charset) {
        charset || (charset = "ISO8859-1");
        var req = new XMLHttpRequest();
        return req.open("GET", path, !1), req.overrideMimeType && req.overrideMimeType("text/plain; charset=" + charset),
        req.send(null), req.responseText;
    },
    _parseAFF: function(data) {
        var rules = {};
        data = this._removeAffixComments(data);
        for (var lines = data.split("\n"), i = 0, _len = lines.length; i < _len; i++) {
            var line = lines[i], definitionParts = line.split(/\s+/), ruleType = definitionParts[0];
            if ("PFX" == ruleType || "SFX" == ruleType) {
                for (var ruleCode = definitionParts[1], combineable = definitionParts[2], numEntries = parseInt(definitionParts[3], 10), entries = [], j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                    var line = lines[j], lineParts = line.split(/\s+/), charactersToRemove = lineParts[2], additionParts = lineParts[3].split("/"), charactersToAdd = additionParts[0];
                    "0" === charactersToAdd && (charactersToAdd = "");
                    var continuationClasses = this.parseRuleCodes(additionParts[1]), regexToMatch = lineParts[4], entry = {};
                    entry.add = charactersToAdd, continuationClasses.length > 0 && (entry.continuationClasses = continuationClasses),
                    "." !== regexToMatch && (entry.match = "SFX" === ruleType ? new RegExp(regexToMatch + "$") : new RegExp("^" + regexToMatch)),
                    "0" != charactersToRemove && (entry.remove = "SFX" === ruleType ? new RegExp(charactersToRemove + "$") : charactersToRemove),
                    entries.push(entry);
                }
                rules[ruleCode] = {
                    type: ruleType,
                    combineable: "Y" == combineable,
                    entries: entries
                }, i += numEntries;
            } else if ("COMPOUNDRULE" === ruleType) {
                for (var numEntries = parseInt(definitionParts[1], 10), j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                    var line = lines[j], lineParts = line.split(/\s+/);
                    this.compoundRules.push(lineParts[1]);
                }
                i += numEntries;
            } else if ("REP" === ruleType) {
                var lineParts = line.split(/\s+/);
                3 === lineParts.length && this.replacementTable.push([ lineParts[1], lineParts[2] ]);
            } else this.flags[ruleType] = definitionParts[1];
        }
        return rules;
    },
    _removeAffixComments: function(data) {
        return data = data.replace(/#.*$/gm, ""), data = data.replace(/^\s\s*/m, "").replace(/\s\s*$/m, ""),
        data = data.replace(/\n{2,}/g, "\n"), data = data.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    },
    _parseDIC: function(data) {
        function addWord(word, rules) {
            word in dictionaryTable && "object" == typeof dictionaryTable[word] || (dictionaryTable[word] = []),
            dictionaryTable[word].push(rules);
        }
        data = this._removeDicComments(data);
        for (var lines = data.split("\n"), dictionaryTable = {}, i = 1, _len = lines.length; i < _len; i++) {
            var line = lines[i], parts = line.split("/", 2), word = parts[0];
            if (parts.length > 1) {
                var ruleCodesArray = this.parseRuleCodes(parts[1]);
                "NEEDAFFIX" in this.flags && -1 != ruleCodesArray.indexOf(this.flags.NEEDAFFIX) || addWord(word, ruleCodesArray);
                for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
                    var code = ruleCodesArray[j], rule = this.rules[code];
                    if (rule) for (var newWords = this._applyRule(word, rule), ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                        var newWord = newWords[ii];
                        if (addWord(newWord, []), rule.combineable) for (var k = j + 1; k < _jlen; k++) {
                            var combineCode = ruleCodesArray[k], combineRule = this.rules[combineCode];
                            if (combineRule && combineRule.combineable && rule.type != combineRule.type) for (var otherNewWords = this._applyRule(newWord, combineRule), iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                                var otherNewWord = otherNewWords[iii];
                                addWord(otherNewWord, []);
                            }
                        }
                    }
                    code in this.compoundRuleCodes && this.compoundRuleCodes[code].push(word);
                }
            } else addWord(word, []);
        }
        return dictionaryTable;
    },
    _removeDicComments: function(data) {
        return data = data.replace(/^\t.*$/gm, "");
    },
    parseRuleCodes: function(textCodes) {
        if (!textCodes) return [];
        if (!("FLAG" in this.flags)) return textCodes.split("");
        if ("long" === this.flags.FLAG) {
            for (var flags = [], i = 0, _len = textCodes.length; i < _len; i += 2) flags.push(textCodes.substr(i, 2));
            return flags;
        }
        return "num" === this.flags.FLAG ? textCode.split(",") : void 0;
    },
    _applyRule: function(word, rule) {
        for (var entries = rule.entries, newWords = [], i = 0, _len = entries.length; i < _len; i++) {
            var entry = entries[i];
            if (!entry.match || word.match(entry.match)) {
                var newWord = word;
                if (entry.remove && (newWord = newWord.replace(entry.remove, "")), "SFX" === rule.type ? newWord += entry.add : newWord = entry.add + newWord,
                newWords.push(newWord), "continuationClasses" in entry) for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {
                    var continuationRule = this.rules[entry.continuationClasses[j]];
                    continuationRule && (newWords = newWords.concat(this._applyRule(newWord, continuationRule)));
                }
            }
        }
        return newWords;
    },
    check: function(aWord) {
        var trimmedWord = aWord.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        if (this.checkExact(trimmedWord)) return !0;
        if (trimmedWord.toUpperCase() === trimmedWord) {
            var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
            if (this.hasFlag(capitalizedWord, "KEEPCASE")) return !1;
            if (this.checkExact(capitalizedWord)) return !0;
        }
        var lowercaseWord = trimmedWord.toLowerCase();
        if (lowercaseWord !== trimmedWord) {
            if (this.hasFlag(lowercaseWord, "KEEPCASE")) return !1;
            if (this.checkExact(lowercaseWord)) return !0;
        }
        return !1;
    },
    checkExact: function(word) {
        var ruleCodes = this.dictionaryTable[word];
        if (void 0 === ruleCodes) {
            if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) for (var i = 0, _len = this.compoundRules.length; i < _len; i++) if (word.match(this.compoundRules[i])) return !0;
            return !1;
        }
        for (var i = 0, _len = ruleCodes.length; i < _len; i++) if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) return !0;
        return !1;
    },
    hasFlag: function(word, flag, wordFlags) {
        if (flag in this.flags) {
            if (void 0 === wordFlags) var wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
            if (wordFlags && -1 !== wordFlags.indexOf(this.flags[flag])) return !0;
        }
        return !1;
    },
    alphabet: "",
    suggest: function(word, limit, callback) {
        function edits1(words, callback) {
            for (var rv = [], workers = [], workersCompleted = [], processNext = function() {
                for (var i = 0; i < 4; ++i) if (!workersCompleted[i]) return;
                callback(rv);
            }, i = 0; i < 4; ++i) {
                var worker = new Worker("lib/typo/wordprocessor.js");
                worker.addEventListener("message", function(index) {
                    return function(e) {
                        rv = rv.concat(e.data), workersCompleted[index] = !0, this.terminate(), processNext();
                    };
                }(i)), workers.push(worker), workersCompleted.push(!1);
            }
            for (var sliceSize = words.length / 4, i = 0; i < 4; ++i) 3 != i ? workers[i].postMessage(words.slice(sliceSize * i, sliceSize * (i + 1))) : workers[i].postMessage(words.slice(sliceSize * i));
        }
        function known(words) {
            for (var rv = [], i = 0; i < words.length; i++) self.check(words[i]) && rv.push(words[i]);
            return rv;
        }
        if (limit || (limit = 5), this.check(word)) return void callback([]);
        for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {
            var replacementEntry = this.replacementTable[i];
            if (-1 !== word.indexOf(replacementEntry[0])) {
                var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
                if (this.check(correctedWord)) return void callback([ correctedWord ]);
            }
        }
        var self = this;
        self.alphabet = "abcdefghijklmnopqrstuvwxyz", function(word, callback) {
            edits1([ word ], function(ed1) {
                edits1(ed1, function(ed2) {
                    function sorter(a, b) {
                        return a[1] < b[1] ? -1 : 1;
                    }
                    for (var corrections = known(ed1).concat(known(ed2)), weighted_corrections = {}, i = 0, _len = corrections.length; i < _len; i++) corrections[i] in weighted_corrections ? weighted_corrections[corrections[i]] += 1 : weighted_corrections[corrections[i]] = 1;
                    var sorted_corrections = [];
                    for (var i in weighted_corrections) sorted_corrections.push([ i, weighted_corrections[i] ]);
                    sorted_corrections.sort(sorter).reverse();
                    for (var rv = [], i = 0, _len = Math.min(limit, sorted_corrections.length); i < _len; i++) self.hasFlag(sorted_corrections[i][0], "NOSUGGEST") || rv.push(sorted_corrections[i][0]);
                    callback(rv);
                });
            });
        }(word, function(rv) {
            callback(rv);
        });
    }
}, function() {
    !function(n) {
        var v = this || (0, eval)("this"), y = v.document, L = v.navigator, r = v.jQuery, D = v.JSON;
        !function(n) {
            "function" == typeof require && "object" == typeof exports && "object" == typeof module ? n(module.exports || exports, require) : "function" == typeof define && define.amd ? define([ "exports", "require" ], n) : n(v.ko = {});
        }(function(M, N) {
            function H(a, d) {
                return (null === a || typeof a in Q) && a === d;
            }
            function R(a, d) {
                var c;
                return function() {
                    c || (c = setTimeout(function() {
                        c = n, a();
                    }, d));
                };
            }
            function S(a, d) {
                var c;
                return function() {
                    clearTimeout(c), c = setTimeout(a, d);
                };
            }
            function I(b, d, c, e) {
                a.d[b] = {
                    init: function(b, h, k, g, m) {
                        var l, s;
                        return a.s(function() {
                            var g = a.a.c(h()), k = !c != !g, z = !s;
                            (z || d || k !== l) && (z && a.Y.la() && (s = a.a.ia(a.f.childNodes(b), !0)), k ? (z || a.f.T(b, a.a.ia(s)),
                            a.Ca(e ? e(m, g) : m, b)) : a.f.ja(b), l = k);
                        }, null, {
                            o: b
                        }), {
                            controlsDescendantBindings: !0
                        };
                    }
                }, a.h.ha[b] = !1, a.f.Q[b] = !0;
            }
            var a = void 0 !== M ? M : {};
            a.b = function(b, d) {
                for (var c = b.split("."), e = a, f = 0; f < c.length - 1; f++) e = e[c[f]];
                e[c[c.length - 1]] = d;
            }, a.A = function(a, d, c) {
                a[d] = c;
            }, a.version = "3.2.0", a.b("version", a.version), a.a = function() {
                function b(a, b) {
                    for (var c in a) a.hasOwnProperty(c) && b(c, a[c]);
                }
                function d(a, b) {
                    if (b) for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
                    return a;
                }
                function c(a, b) {
                    return a.__proto__ = b, a;
                }
                var e = {
                    __proto__: []
                } instanceof Array, f = {}, h = {};
                f[L && /Firefox\/2/i.test(L.userAgent) ? "KeyboardEvent" : "UIEvents"] = [ "keyup", "keydown", "keypress" ],
                f.MouseEvents = "click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" "),
                b(f, function(a, b) {
                    if (b.length) for (var c = 0, d = b.length; c < d; c++) h[b[c]] = a;
                });
                var k = {
                    propertychange: !0
                }, g = y && function() {
                    for (var a = 3, b = y.createElement("div"), c = b.getElementsByTagName("i"); b.innerHTML = "\x3c!--[if gt IE " + ++a + "]><i></i><![endif]--\x3e",
                    c[0]; ) ;
                    return 4 < a ? a : n;
                }();
                return {
                    vb: [ "authenticity_token", /^__RequestVerificationToken(_.*)?$/ ],
                    u: function(a, b) {
                        for (var c = 0, d = a.length; c < d; c++) b(a[c], c);
                    },
                    m: function(a, b) {
                        if ("function" == typeof Array.prototype.indexOf) return Array.prototype.indexOf.call(a, b);
                        for (var c = 0, d = a.length; c < d; c++) if (a[c] === b) return c;
                        return -1;
                    },
                    qb: function(a, b, c) {
                        for (var d = 0, g = a.length; d < g; d++) if (b.call(c, a[d], d)) return a[d];
                        return null;
                    },
                    ua: function(m, b) {
                        var c = a.a.m(m, b);
                        0 < c ? m.splice(c, 1) : 0 === c && m.shift();
                    },
                    rb: function(m) {
                        m = m || [];
                        for (var b = [], c = 0, d = m.length; c < d; c++) 0 > a.a.m(b, m[c]) && b.push(m[c]);
                        return b;
                    },
                    Da: function(a, b) {
                        a = a || [];
                        for (var c = [], d = 0, g = a.length; d < g; d++) c.push(b(a[d], d));
                        return c;
                    },
                    ta: function(a, b) {
                        a = a || [];
                        for (var c = [], d = 0, g = a.length; d < g; d++) b(a[d], d) && c.push(a[d]);
                        return c;
                    },
                    ga: function(a, b) {
                        if (b instanceof Array) a.push.apply(a, b); else for (var c = 0, d = b.length; c < d; c++) a.push(b[c]);
                        return a;
                    },
                    ea: function(b, c, d) {
                        var g = a.a.m(a.a.Xa(b), c);
                        0 > g ? d && b.push(c) : d || b.splice(g, 1);
                    },
                    xa: e,
                    extend: d,
                    za: c,
                    Aa: e ? c : d,
                    G: b,
                    na: function(a, b) {
                        if (!a) return a;
                        var d, c = {};
                        for (d in a) a.hasOwnProperty(d) && (c[d] = b(a[d], d, a));
                        return c;
                    },
                    Ka: function(b) {
                        for (;b.firstChild; ) a.removeNode(b.firstChild);
                    },
                    oc: function(b) {
                        b = a.a.S(b);
                        for (var c = y.createElement("div"), d = 0, g = b.length; d < g; d++) c.appendChild(a.R(b[d]));
                        return c;
                    },
                    ia: function(b, c) {
                        for (var d = 0, g = b.length, e = []; d < g; d++) {
                            var f = b[d].cloneNode(!0);
                            e.push(c ? a.R(f) : f);
                        }
                        return e;
                    },
                    T: function(b, c) {
                        if (a.a.Ka(b), c) for (var d = 0, g = c.length; d < g; d++) b.appendChild(c[d]);
                    },
                    Lb: function(b, c) {
                        var d = b.nodeType ? [ b ] : b;
                        if (0 < d.length) {
                            for (var g = d[0], e = g.parentNode, f = 0, h = c.length; f < h; f++) e.insertBefore(c[f], g);
                            for (f = 0, h = d.length; f < h; f++) a.removeNode(d[f]);
                        }
                    },
                    ka: function(a, b) {
                        if (a.length) {
                            for (b = 8 === b.nodeType && b.parentNode || b; a.length && a[0].parentNode !== b; ) a.shift();
                            if (1 < a.length) {
                                var c = a[0], d = a[a.length - 1];
                                for (a.length = 0; c !== d; ) if (a.push(c), !(c = c.nextSibling)) return;
                                a.push(d);
                            }
                        }
                        return a;
                    },
                    Nb: function(a, b) {
                        7 > g ? a.setAttribute("selected", b) : a.selected = b;
                    },
                    cb: function(a) {
                        return null === a || a === n ? "" : a.trim ? a.trim() : a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
                    },
                    uc: function(a, b) {
                        return a = a || "", !(b.length > a.length) && a.substring(0, b.length) === b;
                    },
                    cc: function(a, b) {
                        if (a === b) return !0;
                        if (11 === a.nodeType) return !1;
                        if (b.contains) return b.contains(3 === a.nodeType ? a.parentNode : a);
                        if (b.compareDocumentPosition) return 16 == (16 & b.compareDocumentPosition(a));
                        for (;a && a != b; ) a = a.parentNode;
                        return !!a;
                    },
                    Ja: function(b) {
                        return a.a.cc(b, b.ownerDocument.documentElement);
                    },
                    ob: function(b) {
                        return !!a.a.qb(b, a.a.Ja);
                    },
                    t: function(a) {
                        return a && a.tagName && a.tagName.toLowerCase();
                    },
                    n: function(b, c, d) {
                        var e = g && k[c];
                        if (!e && r) r(b).bind(c, d); else if (e || "function" != typeof b.addEventListener) {
                            if (void 0 === b.attachEvent) throw Error("Browser doesn't support addEventListener or attachEvent");
                            var f = function(a) {
                                d.call(b, a);
                            }, h = "on" + c;
                            b.attachEvent(h, f), a.a.w.da(b, function() {
                                b.detachEvent(h, f);
                            });
                        } else b.addEventListener(c, d, !1);
                    },
                    oa: function(b, c) {
                        if (!b || !b.nodeType) throw Error("element must be a DOM node when calling triggerEvent");
                        var d;
                        if ("input" === a.a.t(b) && b.type && "click" == c.toLowerCase() ? (d = b.type,
                        d = "checkbox" == d || "radio" == d) : d = !1, r && !d) r(b).trigger(c); else if ("function" == typeof y.createEvent) {
                            if ("function" != typeof b.dispatchEvent) throw Error("The supplied element doesn't support dispatchEvent");
                            d = y.createEvent(h[c] || "HTMLEvents"), d.initEvent(c, !0, !0, v, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, b),
                            b.dispatchEvent(d);
                        } else if (d && b.click) b.click(); else {
                            if (void 0 === b.fireEvent) throw Error("Browser doesn't support triggering events");
                            b.fireEvent("on" + c);
                        }
                    },
                    c: function(b) {
                        return a.C(b) ? b() : b;
                    },
                    Xa: function(b) {
                        return a.C(b) ? b.v() : b;
                    },
                    Ba: function(b, c, d) {
                        if (c) {
                            var g = /\S+/g, e = b.className.match(g) || [];
                            a.a.u(c.match(g), function(b) {
                                a.a.ea(e, b, d);
                            }), b.className = e.join(" ");
                        }
                    },
                    bb: function(b, c) {
                        var d = a.a.c(c);
                        null !== d && d !== n || (d = "");
                        var g = a.f.firstChild(b);
                        !g || 3 != g.nodeType || a.f.nextSibling(g) ? a.f.T(b, [ b.ownerDocument.createTextNode(d) ]) : g.data = d,
                        a.a.fc(b);
                    },
                    Mb: function(a, b) {
                        if (a.name = b, 7 >= g) try {
                            a.mergeAttributes(y.createElement("<input name='" + a.name + "'/>"), !1);
                        } catch (c) {}
                    },
                    fc: function(a) {
                        9 <= g && (a = 1 == a.nodeType ? a : a.parentNode, a.style && (a.style.zoom = a.style.zoom));
                    },
                    dc: function(a) {
                        if (g) {
                            var b = a.style.width;
                            a.style.width = 0, a.style.width = b;
                        }
                    },
                    sc: function(b, c) {
                        b = a.a.c(b), c = a.a.c(c);
                        for (var d = [], g = b; g <= c; g++) d.push(g);
                        return d;
                    },
                    S: function(a) {
                        for (var b = [], c = 0, d = a.length; c < d; c++) b.push(a[c]);
                        return b;
                    },
                    xc: 6 === g,
                    yc: 7 === g,
                    L: g,
                    xb: function(b, c) {
                        for (var d = a.a.S(b.getElementsByTagName("input")).concat(a.a.S(b.getElementsByTagName("textarea"))), g = "string" == typeof c ? function(a) {
                            return a.name === c;
                        } : function(a) {
                            return c.test(a.name);
                        }, e = [], f = d.length - 1; 0 <= f; f--) g(d[f]) && e.push(d[f]);
                        return e;
                    },
                    pc: function(b) {
                        return "string" == typeof b && (b = a.a.cb(b)) ? D && D.parse ? D.parse(b) : new Function("return " + b)() : null;
                    },
                    eb: function(b, c, d) {
                        if (!D || !D.stringify) throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
                        return D.stringify(a.a.c(b), c, d);
                    },
                    qc: function(c, d, g) {
                        g = g || {};
                        var e = g.params || {}, f = g.includeFields || this.vb, h = c;
                        if ("object" == typeof c && "form" === a.a.t(c)) for (var h = c.action, k = f.length - 1; 0 <= k; k--) for (var t = a.a.xb(c, f[k]), E = t.length - 1; 0 <= E; E--) e[t[E].name] = t[E].value;
                        d = a.a.c(d);
                        var x = y.createElement("form");
                        x.style.display = "none", x.action = h, x.method = "post";
                        for (var n in d) c = y.createElement("input"), c.type = "hidden", c.name = n, c.value = a.a.eb(a.a.c(d[n])),
                        x.appendChild(c);
                        b(e, function(a, b) {
                            var c = y.createElement("input");
                            c.type = "hidden", c.name = a, c.value = b, x.appendChild(c);
                        }), y.body.appendChild(x), g.submitter ? g.submitter(x) : x.submit(), setTimeout(function() {
                            x.parentNode.removeChild(x);
                        }, 0);
                    }
                };
            }(), a.b("utils", a.a), a.b("utils.arrayForEach", a.a.u), a.b("utils.arrayFirst", a.a.qb),
            a.b("utils.arrayFilter", a.a.ta), a.b("utils.arrayGetDistinctValues", a.a.rb), a.b("utils.arrayIndexOf", a.a.m),
            a.b("utils.arrayMap", a.a.Da), a.b("utils.arrayPushAll", a.a.ga), a.b("utils.arrayRemoveItem", a.a.ua),
            a.b("utils.extend", a.a.extend), a.b("utils.fieldsIncludedWithJsonPost", a.a.vb),
            a.b("utils.getFormFields", a.a.xb), a.b("utils.peekObservable", a.a.Xa), a.b("utils.postJson", a.a.qc),
            a.b("utils.parseJson", a.a.pc), a.b("utils.registerEventHandler", a.a.n), a.b("utils.stringifyJson", a.a.eb),
            a.b("utils.range", a.a.sc), a.b("utils.toggleDomNodeCssClass", a.a.Ba), a.b("utils.triggerEvent", a.a.oa),
            a.b("utils.unwrapObservable", a.a.c), a.b("utils.objectForEach", a.a.G), a.b("utils.addOrRemoveItem", a.a.ea),
            a.b("unwrap", a.a.c), Function.prototype.bind || (Function.prototype.bind = function(a) {
                var d = this, c = Array.prototype.slice.call(arguments);
                return a = c.shift(), function() {
                    return d.apply(a, c.concat(Array.prototype.slice.call(arguments)));
                };
            }), a.a.e = new function() {
                function a(b, h) {
                    var k = b[c];
                    if (!k || "null" === k || !e[k]) {
                        if (!h) return n;
                        k = b[c] = "ko" + d++, e[k] = {};
                    }
                    return e[k];
                }
                var d = 0, c = "__ko__" + new Date().getTime(), e = {};
                return {
                    get: function(c, d) {
                        var e = a(c, !1);
                        return e === n ? n : e[d];
                    },
                    set: function(c, d, e) {
                        e === n && a(c, !1) === n || (a(c, !0)[d] = e);
                    },
                    clear: function(a) {
                        var b = a[c];
                        return !!b && (delete e[b], a[c] = null, !0);
                    },
                    F: function() {
                        return d++ + c;
                    }
                };
            }(), a.b("utils.domData", a.a.e), a.b("utils.domData.clear", a.a.e.clear), a.a.w = new function() {
                function b(b, d) {
                    var g = a.a.e.get(b, c);
                    return g === n && d && (g = [], a.a.e.set(b, c, g)), g;
                }
                function d(c) {
                    var e = b(c, !1);
                    if (e) for (var e = e.slice(0), g = 0; g < e.length; g++) e[g](c);
                    if (a.a.e.clear(c), a.a.w.cleanExternalData(c), f[c.nodeType]) for (e = c.firstChild; c = e; ) e = c.nextSibling,
                    8 === c.nodeType && d(c);
                }
                var c = a.a.e.F(), e = {
                    1: !0,
                    8: !0,
                    9: !0
                }, f = {
                    1: !0,
                    9: !0
                };
                return {
                    da: function(a, c) {
                        if ("function" != typeof c) throw Error("Callback must be a function");
                        b(a, !0).push(c);
                    },
                    Kb: function(d, e) {
                        var g = b(d, !1);
                        g && (a.a.ua(g, e), 0 == g.length && a.a.e.set(d, c, n));
                    },
                    R: function(b) {
                        if (e[b.nodeType] && (d(b), f[b.nodeType])) {
                            var c = [];
                            a.a.ga(c, b.getElementsByTagName("*"));
                            for (var g = 0, m = c.length; g < m; g++) d(c[g]);
                        }
                        return b;
                    },
                    removeNode: function(b) {
                        a.R(b), b.parentNode && b.parentNode.removeChild(b);
                    },
                    cleanExternalData: function(a) {
                        r && "function" == typeof r.cleanData && r.cleanData([ a ]);
                    }
                };
            }(), a.R = a.a.w.R, a.removeNode = a.a.w.removeNode, a.b("cleanNode", a.R), a.b("removeNode", a.removeNode),
            a.b("utils.domNodeDisposal", a.a.w), a.b("utils.domNodeDisposal.addDisposeCallback", a.a.w.da),
            a.b("utils.domNodeDisposal.removeDisposeCallback", a.a.w.Kb), function() {
                a.a.ba = function(b) {
                    var d;
                    if (r) {
                        if (r.parseHTML) d = r.parseHTML(b) || []; else if ((d = r.clean([ b ])) && d[0]) {
                            for (b = d[0]; b.parentNode && 11 !== b.parentNode.nodeType; ) b = b.parentNode;
                            b.parentNode && b.parentNode.removeChild(b);
                        }
                    } else {
                        var c = a.a.cb(b).toLowerCase();
                        for (d = y.createElement("div"), c = c.match(/^<(thead|tbody|tfoot)/) && [ 1, "<table>", "</table>" ] || !c.indexOf("<tr") && [ 2, "<table><tbody>", "</tbody></table>" ] || (!c.indexOf("<td") || !c.indexOf("<th")) && [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ] || [ 0, "", "" ],
                        b = "ignored<div>" + c[1] + b + c[2] + "</div>", "function" == typeof v.innerShiv ? d.appendChild(v.innerShiv(b)) : d.innerHTML = b; c[0]--; ) d = d.lastChild;
                        d = a.a.S(d.lastChild.childNodes);
                    }
                    return d;
                }, a.a.$a = function(b, d) {
                    if (a.a.Ka(b), null !== (d = a.a.c(d)) && d !== n) if ("string" != typeof d && (d = d.toString()),
                    r) r(b).html(d); else for (var c = a.a.ba(d), e = 0; e < c.length; e++) b.appendChild(c[e]);
                };
            }(), a.b("utils.parseHtmlFragment", a.a.ba), a.b("utils.setHtml", a.a.$a), a.D = function() {
                function b(c, d) {
                    if (c) if (8 == c.nodeType) {
                        var f = a.D.Gb(c.nodeValue);
                        null != f && d.push({
                            bc: c,
                            mc: f
                        });
                    } else if (1 == c.nodeType) for (var f = 0, h = c.childNodes, k = h.length; f < k; f++) b(h[f], d);
                }
                var d = {};
                return {
                    Ua: function(a) {
                        if ("function" != typeof a) throw Error("You can only pass a function to ko.memoization.memoize()");
                        var b = (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1) + (4294967296 * (1 + Math.random()) | 0).toString(16).substring(1);
                        return d[b] = a, "\x3c!--[ko_memo:" + b + "]--\x3e";
                    },
                    Rb: function(a, b) {
                        var f = d[a];
                        if (f === n) throw Error("Couldn't find any memo with ID " + a + ". Perhaps it's already been unmemoized.");
                        try {
                            return f.apply(null, b || []), !0;
                        } finally {
                            delete d[a];
                        }
                    },
                    Sb: function(c, d) {
                        var f = [];
                        b(c, f);
                        for (var h = 0, k = f.length; h < k; h++) {
                            var g = f[h].bc, m = [ g ];
                            d && a.a.ga(m, d), a.D.Rb(f[h].mc, m), g.nodeValue = "", g.parentNode && g.parentNode.removeChild(g);
                        }
                    },
                    Gb: function(a) {
                        return (a = a.match(/^\[ko_memo\:(.*?)\]$/)) ? a[1] : null;
                    }
                };
            }(), a.b("memoization", a.D), a.b("memoization.memoize", a.D.Ua), a.b("memoization.unmemoize", a.D.Rb),
            a.b("memoization.parseMemoText", a.D.Gb), a.b("memoization.unmemoizeDomNodeAndDescendants", a.D.Sb),
            a.La = {
                throttle: function(b, d) {
                    b.throttleEvaluation = d;
                    var c = null;
                    return a.j({
                        read: b,
                        write: function(a) {
                            clearTimeout(c), c = setTimeout(function() {
                                b(a);
                            }, d);
                        }
                    });
                },
                rateLimit: function(a, d) {
                    var c, e, f;
                    "number" == typeof d ? c = d : (c = d.timeout, e = d.method), f = "notifyWhenChangesStop" == e ? S : R,
                    a.Ta(function(a) {
                        return f(a, c);
                    });
                },
                notify: function(a, d) {
                    a.equalityComparer = "always" == d ? null : H;
                }
            };
            var Q = {
                undefined: 1,
                boolean: 1,
                number: 1,
                string: 1
            };
            a.b("extenders", a.La), a.Pb = function(b, d, c) {
                this.target = b, this.wa = d, this.ac = c, this.Cb = !1, a.A(this, "dispose", this.K);
            }, a.Pb.prototype.K = function() {
                this.Cb = !0, this.ac();
            }, a.P = function() {
                a.a.Aa(this, a.P.fn), this.M = {};
            };
            var B = {
                U: function(b, d, c) {
                    var e = this;
                    c = c || "change";
                    var f = new a.Pb(e, d ? b.bind(d) : b, function() {
                        a.a.ua(e.M[c], f), e.nb && e.nb();
                    });
                    return e.va && e.va(c), e.M[c] || (e.M[c] = []), e.M[c].push(f), f;
                },
                notifySubscribers: function(b, d) {
                    if (d = d || "change", this.Ab(d)) try {
                        a.k.Ea();
                        for (var f, c = this.M[d].slice(0), e = 0; f = c[e]; ++e) f.Cb || f.wa(b);
                    } finally {
                        a.k.end();
                    }
                },
                Ta: function(b) {
                    var e, f, h, d = this, c = a.C(d);
                    d.qa || (d.qa = d.notifySubscribers, d.notifySubscribers = function(a, b) {
                        b && "change" !== b ? "beforeChange" === b ? d.kb(a) : d.qa(a, b) : d.lb(a);
                    });
                    var k = b(function() {
                        c && h === d && (h = d()), e = !1, d.Pa(f, h) && d.qa(f = h);
                    });
                    d.lb = function(a) {
                        e = !0, h = a, k();
                    }, d.kb = function(a) {
                        e || (f = a, d.qa(a, "beforeChange"));
                    };
                },
                Ab: function(a) {
                    return this.M[a] && this.M[a].length;
                },
                yb: function() {
                    var b = 0;
                    return a.a.G(this.M, function(a, c) {
                        b += c.length;
                    }), b;
                },
                Pa: function(a, d) {
                    return !this.equalityComparer || !this.equalityComparer(a, d);
                },
                extend: function(b) {
                    var d = this;
                    return b && a.a.G(b, function(b, e) {
                        var f = a.La[b];
                        "function" == typeof f && (d = f(d, e) || d);
                    }), d;
                }
            };
            a.A(B, "subscribe", B.U), a.A(B, "extend", B.extend), a.A(B, "getSubscriptionsCount", B.yb),
            a.a.xa && a.a.za(B, Function.prototype), a.P.fn = B, a.Db = function(a) {
                return null != a && "function" == typeof a.U && "function" == typeof a.notifySubscribers;
            }, a.b("subscribable", a.P), a.b("isSubscribable", a.Db), a.Y = a.k = function() {
                function b(a) {
                    c.push(e), e = a;
                }
                function d() {
                    e = c.pop();
                }
                var e, c = [], f = 0;
                return {
                    Ea: b,
                    end: d,
                    Jb: function(b) {
                        if (e) {
                            if (!a.Db(b)) throw Error("Only subscribable things can act as dependencies");
                            e.wa(b, b.Vb || (b.Vb = ++f));
                        }
                    },
                    B: function(a, c, g) {
                        try {
                            return b(), a.apply(c, g || []);
                        } finally {
                            d();
                        }
                    },
                    la: function() {
                        if (e) return e.s.la();
                    },
                    ma: function() {
                        if (e) return e.ma;
                    }
                };
            }(), a.b("computedContext", a.Y), a.b("computedContext.getDependenciesCount", a.Y.la),
            a.b("computedContext.isInitial", a.Y.ma), a.b("computedContext.isSleeping", a.Y.zc),
            a.p = function(b) {
                function d() {
                    return 0 < arguments.length ? (d.Pa(c, arguments[0]) && (d.X(), c = arguments[0],
                    d.W()), this) : (a.k.Jb(d), c);
                }
                var c = b;
                return a.P.call(d), a.a.Aa(d, a.p.fn), d.v = function() {
                    return c;
                }, d.W = function() {
                    d.notifySubscribers(c);
                }, d.X = function() {
                    d.notifySubscribers(c, "beforeChange");
                }, a.A(d, "peek", d.v), a.A(d, "valueHasMutated", d.W), a.A(d, "valueWillMutate", d.X),
                d;
            }, a.p.fn = {
                equalityComparer: H
            };
            var F = a.p.rc = "__ko_proto__";
            a.p.fn[F] = a.p, a.a.xa && a.a.za(a.p.fn, a.P.fn), a.Ma = function(b, d) {
                return null !== b && b !== n && b[F] !== n && (b[F] === d || a.Ma(b[F], d));
            }, a.C = function(b) {
                return a.Ma(b, a.p);
            }, a.Ra = function(b) {
                return !!("function" == typeof b && b[F] === a.p || "function" == typeof b && b[F] === a.j && b.hc);
            }, a.b("observable", a.p), a.b("isObservable", a.C), a.b("isWriteableObservable", a.Ra),
            a.b("isWritableObservable", a.Ra), a.aa = function(b) {
                if ("object" != typeof (b = b || []) || !("length" in b)) throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");
                return b = a.p(b), a.a.Aa(b, a.aa.fn), b.extend({
                    trackArrayChanges: !0
                });
            }, a.aa.fn = {
                remove: function(b) {
                    for (var d = this.v(), c = [], e = "function" != typeof b || a.C(b) ? function(a) {
                        return a === b;
                    } : b, f = 0; f < d.length; f++) {
                        var h = d[f];
                        e(h) && (0 === c.length && this.X(), c.push(h), d.splice(f, 1), f--);
                    }
                    return c.length && this.W(), c;
                },
                removeAll: function(b) {
                    if (b === n) {
                        var d = this.v(), c = d.slice(0);
                        return this.X(), d.splice(0, d.length), this.W(), c;
                    }
                    return b ? this.remove(function(c) {
                        return 0 <= a.a.m(b, c);
                    }) : [];
                },
                destroy: function(b) {
                    var d = this.v(), c = "function" != typeof b || a.C(b) ? function(a) {
                        return a === b;
                    } : b;
                    this.X();
                    for (var e = d.length - 1; 0 <= e; e--) c(d[e]) && (d[e]._destroy = !0);
                    this.W();
                },
                destroyAll: function(b) {
                    return b === n ? this.destroy(function() {
                        return !0;
                    }) : b ? this.destroy(function(d) {
                        return 0 <= a.a.m(b, d);
                    }) : [];
                },
                indexOf: function(b) {
                    var d = this();
                    return a.a.m(d, b);
                },
                replace: function(a, d) {
                    var c = this.indexOf(a);
                    0 <= c && (this.X(), this.v()[c] = d, this.W());
                }
            }, a.a.u("pop push reverse shift sort splice unshift".split(" "), function(b) {
                a.aa.fn[b] = function() {
                    var a = this.v();
                    return this.X(), this.sb(a, b, arguments), a = a[b].apply(a, arguments), this.W(),
                    a;
                };
            }), a.a.u([ "slice" ], function(b) {
                a.aa.fn[b] = function() {
                    var a = this();
                    return a[b].apply(a, arguments);
                };
            }), a.a.xa && a.a.za(a.aa.fn, a.p.fn), a.b("observableArray", a.aa), a.La.trackArrayChanges = function(b) {
                function d() {
                    if (!c) {
                        c = !0;
                        var d = b.notifySubscribers;
                        b.notifySubscribers = function(a, b) {
                            return b && "change" !== b || ++f, d.apply(this, arguments);
                        };
                        var g = [].concat(b.v() || []);
                        e = null, b.U(function(c) {
                            if (c = [].concat(c || []), b.Ab("arrayChange")) {
                                var d;
                                (!e || 1 < f) && (e = a.a.Fa(g, c, {
                                    sparse: !0
                                })), d = e, d.length && b.notifySubscribers(d, "arrayChange");
                            }
                            g = c, e = null, f = 0;
                        });
                    }
                }
                if (!b.sb) {
                    var c = !1, e = null, f = 0, h = b.U;
                    b.U = b.subscribe = function(a, b, c) {
                        return "arrayChange" === c && d(), h.apply(this, arguments);
                    }, b.sb = function(b, d, m) {
                        function l(a, b, c) {
                            return s[s.length] = {
                                status: a,
                                value: b,
                                index: c
                            };
                        }
                        if (c && !f) {
                            var s = [], h = b.length, p = m.length, z = 0;
                            switch (d) {
                              case "push":
                                z = h;

                              case "unshift":
                                for (d = 0; d < p; d++) l("added", m[d], z + d);
                                break;

                              case "pop":
                                z = h - 1;

                              case "shift":
                                h && l("deleted", b[z], z);
                                break;

                              case "splice":
                                d = Math.min(Math.max(0, 0 > m[0] ? h + m[0] : m[0]), h);
                                for (var h = 1 === p ? h : Math.min(d + (m[1] || 0), h), p = d + p - 2, z = Math.max(h, p), u = [], t = [], E = 2; d < z; ++d,
                                ++E) d < h && t.push(l("deleted", b[d], d)), d < p && u.push(l("added", m[E], d));
                                a.a.wb(t, u);
                                break;

                              default:
                                return;
                            }
                            e = s;
                        }
                    };
                }
            }, a.s = a.j = function(b, d, c) {
                function e() {
                    a.a.G(v, function(a, b) {
                        b.K();
                    }), v = {};
                }
                function f() {
                    e(), A = 0, u = !0, q = !1;
                }
                function h() {
                    var a = g.throttleEvaluation;
                    a && 0 <= a ? (clearTimeout(O), O = setTimeout(k, a)) : g.ib ? g.ib() : k();
                }
                function k(b) {
                    if (p) {
                        if (E) throw Error("A 'pure' computed must not be called recursively");
                    } else if (!u) {
                        if (J && J()) {
                            if (!z) return void r();
                        } else z = !1;
                        if (p = !0, x) try {
                            var c = {};
                            a.k.Ea({
                                wa: function(a, b) {
                                    c[b] || (c[b] = 1, ++A);
                                },
                                s: g,
                                ma: n
                            }), A = 0, s = t.call(d);
                        } finally {
                            a.k.end(), p = !1;
                        } else try {
                            var e = v, l = A;
                            a.k.Ea({
                                wa: function(a, b) {
                                    u || (l && e[b] ? (v[b] = e[b], ++A, delete e[b], --l) : v[b] || (v[b] = a.U(h),
                                    ++A));
                                },
                                s: g,
                                ma: E ? n : !A
                            }), v = {}, A = 0;
                            try {
                                var m = d ? t.call(d) : t();
                            } finally {
                                a.k.end(), l && a.a.G(e, function(a, b) {
                                    b.K();
                                }), q = !1;
                            }
                            g.Pa(s, m) && (g.notifySubscribers(s, "beforeChange"), s = m, !0 !== b && g.notifySubscribers(s));
                        } finally {
                            p = !1;
                        }
                        A || r();
                    }
                }
                function g() {
                    if (0 < arguments.length) {
                        if ("function" != typeof G) throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
                        return G.apply(d, arguments), this;
                    }
                    return a.k.Jb(g), q && k(!0), s;
                }
                function m() {
                    return q && !A && k(!0), s;
                }
                function l() {
                    return q || 0 < A;
                }
                var s, q = !0, p = !1, z = !1, u = !1, t = b, E = !1, x = !1;
                if (t && "object" == typeof t ? (c = t, t = c.read) : (c = c || {}, t || (t = c.read)),
                "function" != typeof t) throw Error("Pass a function that returns the value of the ko.computed");
                var G = c.write, w = c.disposeWhenNodeIsRemoved || c.o || null, C = c.disposeWhen || c.Ia, J = C, r = f, v = {}, A = 0, O = null;
                d || (d = c.owner), a.P.call(g), a.a.Aa(g, a.j.fn), g.v = m, g.la = function() {
                    return A;
                }, g.hc = "function" == typeof c.write, g.K = function() {
                    r();
                }, g.Z = l;
                var y = g.Ta;
                return g.Ta = function(a) {
                    y.call(g, a), g.ib = function() {
                        g.kb(s), q = !0, g.lb(g);
                    };
                }, c.pure ? (x = E = !0, g.va = function() {
                    x && (x = !1, k(!0));
                }, g.nb = function() {
                    g.yb() || (e(), x = q = !0);
                }) : c.deferEvaluation && (g.va = function() {
                    m(), delete g.va;
                }), a.A(g, "peek", g.v), a.A(g, "dispose", g.K), a.A(g, "isActive", g.Z), a.A(g, "getDependenciesCount", g.la),
                w && (z = !0, w.nodeType && (J = function() {
                    return !a.a.Ja(w) || C && C();
                })), x || c.deferEvaluation || k(), w && l() && w.nodeType && (r = function() {
                    a.a.w.Kb(w, r), f();
                }, a.a.w.da(w, r)), g;
            }, a.jc = function(b) {
                return a.Ma(b, a.j);
            }, B = a.p.rc, a.j[B] = a.p, a.j.fn = {
                equalityComparer: H
            }, a.j.fn[B] = a.j, a.a.xa && a.a.za(a.j.fn, a.P.fn), a.b("dependentObservable", a.j),
            a.b("computed", a.j), a.b("isComputed", a.jc), a.Ib = function(b, d) {
                return "function" == typeof b ? a.s(b, d, {
                    pure: !0
                }) : (b = a.a.extend({}, b), b.pure = !0, a.s(b, d));
            }, a.b("pureComputed", a.Ib), function() {
                function b(a, f, h) {
                    if (h = h || new c(), "object" != typeof (a = f(a)) || null === a || a === n || a instanceof Date || a instanceof String || a instanceof Number || a instanceof Boolean) return a;
                    var k = a instanceof Array ? [] : {};
                    return h.save(a, k), d(a, function(c) {
                        var d = f(a[c]);
                        switch (typeof d) {
                          case "boolean":
                          case "number":
                          case "string":
                          case "function":
                            k[c] = d;
                            break;

                          case "object":
                          case "undefined":
                            var l = h.get(d);
                            k[c] = l !== n ? l : b(d, f, h);
                        }
                    }), k;
                }
                function d(a, b) {
                    if (a instanceof Array) {
                        for (var c = 0; c < a.length; c++) b(c);
                        "function" == typeof a.toJSON && b("toJSON");
                    } else for (c in a) b(c);
                }
                function c() {
                    this.keys = [], this.hb = [];
                }
                a.Qb = function(c) {
                    if (0 == arguments.length) throw Error("When calling ko.toJS, pass the object you want to convert.");
                    return b(c, function(b) {
                        for (var c = 0; a.C(b) && 10 > c; c++) b = b();
                        return b;
                    });
                }, a.toJSON = function(b, c, d) {
                    return b = a.Qb(b), a.a.eb(b, c, d);
                }, c.prototype = {
                    save: function(b, c) {
                        var d = a.a.m(this.keys, b);
                        0 <= d ? this.hb[d] = c : (this.keys.push(b), this.hb.push(c));
                    },
                    get: function(b) {
                        return b = a.a.m(this.keys, b), 0 <= b ? this.hb[b] : n;
                    }
                };
            }(), a.b("toJS", a.Qb), a.b("toJSON", a.toJSON), function() {
                a.i = {
                    q: function(b) {
                        switch (a.a.t(b)) {
                          case "option":
                            return !0 === b.__ko__hasDomDataOptionValue__ ? a.a.e.get(b, a.d.options.Va) : 7 >= a.a.L ? b.getAttributeNode("value") && b.getAttributeNode("value").specified ? b.value : b.text : b.value;

                          case "select":
                            return 0 <= b.selectedIndex ? a.i.q(b.options[b.selectedIndex]) : n;

                          default:
                            return b.value;
                        }
                    },
                    ca: function(b, d, c) {
                        switch (a.a.t(b)) {
                          case "option":
                            switch (typeof d) {
                              case "string":
                                a.a.e.set(b, a.d.options.Va, n), "__ko__hasDomDataOptionValue__" in b && delete b.__ko__hasDomDataOptionValue__,
                                b.value = d;
                                break;

                              default:
                                a.a.e.set(b, a.d.options.Va, d), b.__ko__hasDomDataOptionValue__ = !0, b.value = "number" == typeof d ? d : "";
                            }
                            break;

                          case "select":
                            "" !== d && null !== d || (d = n);
                            for (var k, e = -1, f = 0, h = b.options.length; f < h; ++f) if ((k = a.i.q(b.options[f])) == d || "" == k && d === n) {
                                e = f;
                                break;
                            }
                            (c || 0 <= e || d === n && 1 < b.size) && (b.selectedIndex = e);
                            break;

                          default:
                            null !== d && d !== n || (d = ""), b.value = d;
                        }
                    }
                };
            }(), a.b("selectExtensions", a.i), a.b("selectExtensions.readValue", a.i.q), a.b("selectExtensions.writeValue", a.i.ca),
            a.h = function() {
                function b(b) {
                    b = a.a.cb(b), 123 === b.charCodeAt(0) && (b = b.slice(1, -1));
                    var s, k, c = [], d = b.match(e), p = 0;
                    if (d) {
                        d.push(",");
                        for (var u, z = 0; u = d[z]; ++z) {
                            var t = u.charCodeAt(0);
                            if (44 === t) {
                                if (0 >= p) {
                                    s && c.push(k ? {
                                        key: s,
                                        value: k.join("")
                                    } : {
                                        unknown: s
                                    }), s = k = p = 0;
                                    continue;
                                }
                            } else if (58 === t) {
                                if (!k) continue;
                            } else if (47 === t && z && 1 < u.length) (t = d[z - 1].match(f)) && !h[t[0]] && (b = b.substr(b.indexOf(u) + 1),
                            d = b.match(e), d.push(","), z = -1, u = "/"); else if (40 === t || 123 === t || 91 === t) ++p; else if (41 === t || 125 === t || 93 === t) --p; else if (!s && !k) {
                                s = 34 === t || 39 === t ? u.slice(1, -1) : u;
                                continue;
                            }
                            k ? k.push(u) : k = [ u ];
                        }
                    }
                    return c;
                }
                var d = [ "true", "false", "null", "undefined" ], c = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i, e = RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]", "g"), f = /[\])"'A-Za-z0-9_$]+$/, h = {
                    in: 1,
                    return: 1,
                    typeof: 1
                }, k = {};
                return {
                    ha: [],
                    V: k,
                    Wa: b,
                    ya: function(g, m) {
                        function l(b, g) {
                            var m;
                            if (!z) {
                                var u = a.getBindingHandler(b);
                                if (u && u.preprocess && !(g = u.preprocess(g, b, l))) return;
                                (u = k[b]) && (m = g, 0 <= a.a.m(d, m) ? m = !1 : (u = m.match(c), m = null !== u && (u[1] ? "Object(" + u[1] + ")" + u[2] : m)),
                                u = m), u && f.push("'" + b + "':function(_z){" + m + "=_z}");
                            }
                            h && (g = "function(){return " + g + " }"), e.push("'" + b + "':" + g);
                        }
                        m = m || {};
                        var e = [], f = [], h = m.valueAccessors, z = m.bindingParams, u = "string" == typeof g ? b(g) : g;
                        return a.a.u(u, function(a) {
                            l(a.key || a.unknown, a.value);
                        }), f.length && l("_ko_property_writers", "{" + f.join(",") + " }"), e.join(",");
                    },
                    lc: function(a, b) {
                        for (var c = 0; c < a.length; c++) if (a[c].key == b) return !0;
                        return !1;
                    },
                    pa: function(b, c, d, e, f) {
                        b && a.C(b) ? !a.Ra(b) || f && b.v() === e || b(e) : (b = c.get("_ko_property_writers")) && b[d] && b[d](e);
                    }
                };
            }(), a.b("expressionRewriting", a.h), a.b("expressionRewriting.bindingRewriteValidators", a.h.ha),
            a.b("expressionRewriting.parseObjectLiteral", a.h.Wa), a.b("expressionRewriting.preProcessBindings", a.h.ya),
            a.b("expressionRewriting._twoWayBindings", a.h.V), a.b("jsonExpressionRewriting", a.h),
            a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson", a.h.ya), function() {
                function b(a) {
                    return 8 == a.nodeType && h.test(f ? a.text : a.nodeValue);
                }
                function d(a) {
                    return 8 == a.nodeType && k.test(f ? a.text : a.nodeValue);
                }
                function c(a, c) {
                    for (var g = a, e = 1, f = []; g = g.nextSibling; ) {
                        if (d(g) && 0 === --e) return f;
                        f.push(g), b(g) && e++;
                    }
                    if (!c) throw Error("Cannot find closing comment tag to match: " + a.nodeValue);
                    return null;
                }
                function e(a, b) {
                    var d = c(a, b);
                    return d ? 0 < d.length ? d[d.length - 1].nextSibling : a.nextSibling : null;
                }
                var f = y && "\x3c!--test--\x3e" === y.createComment("test").text, h = f ? /^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/, k = f ? /^\x3c!--\s*\/ko\s*--\x3e$/ : /^\s*\/ko\s*$/, g = {
                    ul: !0,
                    ol: !0
                };
                a.f = {
                    Q: {},
                    childNodes: function(a) {
                        return b(a) ? c(a) : a.childNodes;
                    },
                    ja: function(c) {
                        if (b(c)) {
                            c = a.f.childNodes(c);
                            for (var d = 0, g = c.length; d < g; d++) a.removeNode(c[d]);
                        } else a.a.Ka(c);
                    },
                    T: function(c, d) {
                        if (b(c)) {
                            a.f.ja(c);
                            for (var g = c.nextSibling, e = 0, f = d.length; e < f; e++) g.parentNode.insertBefore(d[e], g);
                        } else a.a.T(c, d);
                    },
                    Hb: function(a, c) {
                        b(a) ? a.parentNode.insertBefore(c, a.nextSibling) : a.firstChild ? a.insertBefore(c, a.firstChild) : a.appendChild(c);
                    },
                    Bb: function(c, d, g) {
                        g ? b(c) ? c.parentNode.insertBefore(d, g.nextSibling) : g.nextSibling ? c.insertBefore(d, g.nextSibling) : c.appendChild(d) : a.f.Hb(c, d);
                    },
                    firstChild: function(a) {
                        return b(a) ? !a.nextSibling || d(a.nextSibling) ? null : a.nextSibling : a.firstChild;
                    },
                    nextSibling: function(a) {
                        return b(a) && (a = e(a)), a.nextSibling && d(a.nextSibling) ? null : a.nextSibling;
                    },
                    gc: b,
                    wc: function(a) {
                        return (a = (f ? a.text : a.nodeValue).match(h)) ? a[1] : null;
                    },
                    Fb: function(c) {
                        if (g[a.a.t(c)]) {
                            var l = c.firstChild;
                            if (l) do {
                                if (1 === l.nodeType) {
                                    var f;
                                    f = l.firstChild;
                                    var h = null;
                                    if (f) do {
                                        if (h) h.push(f); else if (b(f)) {
                                            var k = e(f, !0);
                                            k ? f = k : h = [ f ];
                                        } else d(f) && (h = [ f ]);
                                    } while (f = f.nextSibling);
                                    if (f = h) for (h = l.nextSibling, k = 0; k < f.length; k++) h ? c.insertBefore(f[k], h) : c.appendChild(f[k]);
                                }
                            } while (l = l.nextSibling);
                        }
                    }
                };
            }(), a.b("virtualElements", a.f), a.b("virtualElements.allowedBindings", a.f.Q),
            a.b("virtualElements.emptyNode", a.f.ja), a.b("virtualElements.insertAfter", a.f.Bb),
            a.b("virtualElements.prepend", a.f.Hb), a.b("virtualElements.setDomNodeChildren", a.f.T),
            function() {
                a.J = function() {
                    this.Yb = {};
                }, a.a.extend(a.J.prototype, {
                    nodeHasBindings: function(b) {
                        switch (b.nodeType) {
                          case 1:
                            return null != b.getAttribute("data-bind") || a.g.getComponentNameForNode(b);

                          case 8:
                            return a.f.gc(b);

                          default:
                            return !1;
                        }
                    },
                    getBindings: function(b, d) {
                        var c = this.getBindingsString(b, d), c = c ? this.parseBindingsString(c, d, b) : null;
                        return a.g.mb(c, b, d, !1);
                    },
                    getBindingAccessors: function(b, d) {
                        var c = this.getBindingsString(b, d), c = c ? this.parseBindingsString(c, d, b, {
                            valueAccessors: !0
                        }) : null;
                        return a.g.mb(c, b, d, !0);
                    },
                    getBindingsString: function(b) {
                        switch (b.nodeType) {
                          case 1:
                            return b.getAttribute("data-bind");

                          case 8:
                            return a.f.wc(b);

                          default:
                            return null;
                        }
                    },
                    parseBindingsString: function(b, d, c, e) {
                        try {
                            var k, f = this.Yb, h = b + (e && e.valueAccessors || "");
                            if (!(k = f[h])) {
                                var g, m = "with($context){with($data||{}){return{" + a.h.ya(b, e) + "}}}";
                                g = new Function("$context", "$element", m), k = f[h] = g;
                            }
                            return k(d, c);
                        } catch (l) {
                            throw l.message = "Unable to parse bindings.\nBindings value: " + b + "\nMessage: " + l.message,
                            l;
                        }
                    }
                }), a.J.instance = new a.J();
            }(), a.b("bindingProvider", a.J), function() {
                function b(a) {
                    return function() {
                        return a;
                    };
                }
                function d(a) {
                    return a();
                }
                function c(b) {
                    return a.a.na(a.k.B(b), function(a, c) {
                        return function() {
                            return b()[c];
                        };
                    });
                }
                function e(d, g, e) {
                    return "function" == typeof d ? c(d.bind(null, g, e)) : a.a.na(d, b);
                }
                function f(a, b) {
                    return c(this.getBindings.bind(this, a, b));
                }
                function h(b, c, d) {
                    var g, e = a.f.firstChild(c), l = a.J.instance, f = l.preprocessNode;
                    if (f) {
                        for (;g = e; ) e = a.f.nextSibling(g), f.call(l, g);
                        e = a.f.firstChild(c);
                    }
                    for (;g = e; ) e = a.f.nextSibling(g), k(b, g, d);
                }
                function k(b, c, d) {
                    var g = !0, e = 1 === c.nodeType;
                    e && a.f.Fb(c), (e && d || a.J.instance.nodeHasBindings(c)) && (g = m(c, null, b, d).shouldBindDescendants),
                    g && !s[a.a.t(c)] && h(b, c, !e);
                }
                function g(b) {
                    var c = [], d = {}, g = [];
                    return a.a.G(b, function G(e) {
                        if (!d[e]) {
                            var l = a.getBindingHandler(e);
                            l && (l.after && (g.push(e), a.a.u(l.after, function(c) {
                                if (b[c]) {
                                    if (-1 !== a.a.m(g, c)) throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + g.join(", "));
                                    G(c);
                                }
                            }), g.length--), c.push({
                                key: e,
                                zb: l
                            })), d[e] = !0;
                        }
                    }), c;
                }
                function m(b, c, e, l) {
                    var m = a.a.e.get(b, q);
                    if (!c) {
                        if (m) throw Error("You cannot apply bindings multiple times to the same element.");
                        a.a.e.set(b, q, !0);
                    }
                    !m && l && a.Ob(b, e);
                    var h;
                    if (c && "function" != typeof c) h = c; else {
                        var k = a.J.instance, s = k.getBindingAccessors || f, p = a.j(function() {
                            return (h = c ? c(e, b) : s.call(k, b, e)) && e.I && e.I(), h;
                        }, null, {
                            o: b
                        });
                        h && p.Z() || (p = null);
                    }
                    var r;
                    if (h) {
                        var v = p ? function(a) {
                            return function() {
                                return d(p()[a]);
                            };
                        } : function(a) {
                            return h[a];
                        }, A = function() {
                            return a.a.na(p ? p() : h, d);
                        };
                        A.get = function(a) {
                            return h[a] && d(v(a));
                        }, A.has = function(a) {
                            return a in h;
                        }, l = g(h), a.a.u(l, function(c) {
                            var d = c.zb.init, g = c.zb.update, l = c.key;
                            if (8 === b.nodeType && !a.f.Q[l]) throw Error("The binding '" + l + "' cannot be used with virtual elements");
                            try {
                                "function" == typeof d && a.k.B(function() {
                                    var a = d(b, v(l), A, e.$data, e);
                                    if (a && a.controlsDescendantBindings) {
                                        if (r !== n) throw Error("Multiple bindings (" + r + " and " + l + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                        r = l;
                                    }
                                }), "function" == typeof g && a.j(function() {
                                    g(b, v(l), A, e.$data, e);
                                }, null, {
                                    o: b
                                });
                            } catch (f) {
                                throw f.message = 'Unable to process binding "' + l + ": " + h[l] + '"\nMessage: ' + f.message,
                                f;
                            }
                        });
                    }
                    return {
                        shouldBindDescendants: r === n
                    };
                }
                function l(b) {
                    return b && b instanceof a.N ? b : new a.N(b);
                }
                a.d = {};
                var s = {
                    script: !0
                };
                a.getBindingHandler = function(b) {
                    return a.d[b];
                }, a.N = function(b, c, d, g) {
                    var f, e = this, l = "function" == typeof b && !a.C(b), m = a.j(function() {
                        var f = l ? b() : b, h = a.a.c(f);
                        return c ? (c.I && c.I(), a.a.extend(e, c), m && (e.I = m)) : (e.$parents = [],
                        e.$root = h, e.ko = a), e.$rawData = f, e.$data = h, d && (e[d] = h), g && g(e, c, h),
                        e.$data;
                    }, null, {
                        Ia: function() {
                            return f && !a.a.ob(f);
                        },
                        o: !0
                    });
                    m.Z() && (e.I = m, m.equalityComparer = null, f = [], m.Tb = function(b) {
                        f.push(b), a.a.w.da(b, function(b) {
                            a.a.ua(f, b), f.length || (m.K(), e.I = m = n);
                        });
                    });
                }, a.N.prototype.createChildContext = function(b, c, d) {
                    return new a.N(b, this, c, function(a, b) {
                        a.$parentContext = b, a.$parent = b.$data, a.$parents = (b.$parents || []).slice(0),
                        a.$parents.unshift(a.$parent), d && d(a);
                    });
                }, a.N.prototype.extend = function(b) {
                    return new a.N(this.I || this.$data, this, null, function(c, d) {
                        c.$rawData = d.$rawData, a.a.extend(c, "function" == typeof b ? b() : b);
                    });
                };
                var q = a.a.e.F(), p = a.a.e.F();
                a.Ob = function(b, c) {
                    if (2 != arguments.length) return a.a.e.get(b, p);
                    a.a.e.set(b, p, c), c.I && c.I.Tb(b);
                }, a.ra = function(b, c, d) {
                    return 1 === b.nodeType && a.f.Fb(b), m(b, c, l(d), !0);
                }, a.Wb = function(b, c, d) {
                    return d = l(d), a.ra(b, e(c, d, b), d);
                }, a.Ca = function(a, b) {
                    1 !== b.nodeType && 8 !== b.nodeType || h(l(a), b, !0);
                }, a.pb = function(a, b) {
                    if (!r && v.jQuery && (r = v.jQuery), b && 1 !== b.nodeType && 8 !== b.nodeType) throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
                    b = b || v.document.body, k(l(a), b, !0);
                }, a.Ha = function(b) {
                    switch (b.nodeType) {
                      case 1:
                      case 8:
                        var c = a.Ob(b);
                        if (c) return c;
                        if (b.parentNode) return a.Ha(b.parentNode);
                    }
                    return n;
                }, a.$b = function(b) {
                    return (b = a.Ha(b)) ? b.$data : n;
                }, a.b("bindingHandlers", a.d), a.b("applyBindings", a.pb), a.b("applyBindingsToDescendants", a.Ca),
                a.b("applyBindingAccessorsToNode", a.ra), a.b("applyBindingsToNode", a.Wb), a.b("contextFor", a.Ha),
                a.b("dataFor", a.$b);
            }(), function(b) {
                function d(d, g) {
                    var l, e = f.hasOwnProperty(d) ? f[d] : b;
                    e || (e = f[d] = new a.P(), c(d, function(a) {
                        h[d] = a, delete f[d], l ? e.notifySubscribers(a) : setTimeout(function() {
                            e.notifySubscribers(a);
                        }, 0);
                    }), l = !0), e.U(g);
                }
                function c(a, b) {
                    e("getConfig", [ a ], function(c) {
                        c ? e("loadComponent", [ a, c ], function(a) {
                            b(a);
                        }) : b(null);
                    });
                }
                function e(c, d, f, l) {
                    l || (l = a.g.loaders.slice(0));
                    var h = l.shift();
                    if (h) {
                        var q = h[c];
                        if (q) {
                            var p = !1;
                            if (q.apply(h, d.concat(function(a) {
                                p ? f(null) : null !== a ? f(a) : e(c, d, f, l);
                            })) !== b && (p = !0, !h.suppressLoaderExceptions)) throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");
                        } else e(c, d, f, l);
                    } else f(null);
                }
                var f = {}, h = {};
                a.g = {
                    get: function(a, c) {
                        var e = h.hasOwnProperty(a) ? h[a] : b;
                        e ? setTimeout(function() {
                            c(e);
                        }, 0) : d(a, c);
                    },
                    tb: function(a) {
                        delete h[a];
                    },
                    jb: e
                }, a.g.loaders = [], a.b("components", a.g), a.b("components.get", a.g.get), a.b("components.clearCachedDefinition", a.g.tb);
            }(), function() {
                function b(b, c, d, e) {
                    function h() {
                        0 == --u && e(k);
                    }
                    var k = {}, u = 2, t = d.template;
                    d = d.viewModel, t ? f(c, t, function(c) {
                        a.g.jb("loadTemplate", [ b, c ], function(a) {
                            k.template = a, h();
                        });
                    }) : h(), d ? f(c, d, function(c) {
                        a.g.jb("loadViewModel", [ b, c ], function(a) {
                            k[g] = a, h();
                        });
                    }) : h();
                }
                function d(a, b, c) {
                    if ("function" == typeof b) c(function(a) {
                        return new b(a);
                    }); else if ("function" == typeof b[g]) c(b[g]); else if ("instance" in b) {
                        var e = b.instance;
                        c(function() {
                            return e;
                        });
                    } else "viewModel" in b ? d(a, b.viewModel, c) : a("Unknown viewModel value: " + b);
                }
                function c(b) {
                    switch (a.a.t(b)) {
                      case "script":
                        return a.a.ba(b.text);

                      case "textarea":
                        return a.a.ba(b.value);

                      case "template":
                        if (e(b.content)) return a.a.ia(b.content.childNodes);
                    }
                    return a.a.ia(b.childNodes);
                }
                function e(a) {
                    return v.DocumentFragment ? a instanceof DocumentFragment : a && 11 === a.nodeType;
                }
                function f(a, b, c) {
                    "string" == typeof b.require ? N || v.require ? (N || v.require)([ b.require ], c) : a("Uses require, but no AMD loader is present") : c(b);
                }
                function h(a) {
                    return function(b) {
                        throw Error("Component '" + a + "': " + b);
                    };
                }
                var k = {};
                a.g.register = function(b, c) {
                    if (!c) throw Error("Invalid configuration for " + b);
                    if (a.g.Qa(b)) throw Error("Component " + b + " is already registered");
                    k[b] = c;
                }, a.g.Qa = function(a) {
                    return a in k;
                }, a.g.vc = function(b) {
                    delete k[b], a.g.tb(b);
                }, a.g.ub = {
                    getConfig: function(a, b) {
                        b(k.hasOwnProperty(a) ? k[a] : null);
                    },
                    loadComponent: function(a, c, d) {
                        var e = h(a);
                        f(e, c, function(c) {
                            b(a, e, c, d);
                        });
                    },
                    loadTemplate: function(b, d, g) {
                        if (b = h(b), "string" == typeof d) g(a.a.ba(d)); else if (d instanceof Array) g(d); else if (e(d)) g(a.a.S(d.childNodes)); else if (d.element) if (d = d.element,
                        v.HTMLElement ? d instanceof HTMLElement : d && d.tagName && 1 === d.nodeType) g(c(d)); else if ("string" == typeof d) {
                            var f = y.getElementById(d);
                            f ? g(c(f)) : b("Cannot find element with ID " + d);
                        } else b("Unknown element type: " + d); else b("Unknown template value: " + d);
                    },
                    loadViewModel: function(a, b, c) {
                        d(h(a), b, c);
                    }
                };
                var g = "createViewModel";
                a.b("components.register", a.g.register), a.b("components.isRegistered", a.g.Qa),
                a.b("components.unregister", a.g.vc), a.b("components.defaultLoader", a.g.ub), a.g.loaders.push(a.g.ub),
                a.g.Ub = k;
            }(), function() {
                function b(b, e) {
                    var f = b.getAttribute("params");
                    if (f) {
                        var f = d.parseBindingsString(f, e, b, {
                            valueAccessors: !0,
                            bindingParams: !0
                        }), f = a.a.na(f, function(d) {
                            return a.s(d, null, {
                                o: b
                            });
                        }), h = a.a.na(f, function(d) {
                            return d.Z() ? a.s(function() {
                                return a.a.c(d());
                            }, null, {
                                o: b
                            }) : d.v();
                        });
                        return h.hasOwnProperty("$raw") || (h.$raw = f), h;
                    }
                    return {
                        $raw: {}
                    };
                }
                a.g.getComponentNameForNode = function(b) {
                    return b = a.a.t(b), a.g.Qa(b) && b;
                }, a.g.mb = function(c, d, f, h) {
                    if (1 === d.nodeType) {
                        var k = a.g.getComponentNameForNode(d);
                        if (k) {
                            if (c = c || {}, c.component) throw Error('Cannot use the "component" binding on a custom element matching a component');
                            var g = {
                                name: k,
                                params: b(d, f)
                            };
                            c.component = h ? function() {
                                return g;
                            } : g;
                        }
                    }
                    return c;
                };
                var d = new a.J();
                9 > a.a.L && (a.g.register = function(a) {
                    return function(b) {
                        return y.createElement(b), a.apply(this, arguments);
                    };
                }(a.g.register), y.createDocumentFragment = function(b) {
                    return function() {
                        var h, d = b(), f = a.g.Ub;
                        for (h in f) f.hasOwnProperty(h) && d.createElement(h);
                        return d;
                    };
                }(y.createDocumentFragment));
            }(), function() {
                var b = 0;
                a.d.component = {
                    init: function(d, c, e, f, h) {
                        function k() {
                            var a = g && g.dispose;
                            "function" == typeof a && a.call(g), m = null;
                        }
                        var g, m;
                        return a.a.w.da(d, k), a.s(function() {
                            var f, q, e = a.a.c(c());
                            if ("string" == typeof e ? f = e : (f = a.a.c(e.name), q = a.a.c(e.params)), !f) throw Error("No component name specified");
                            var p = m = ++b;
                            a.g.get(f, function(b) {
                                if (m === p) {
                                    if (k(), !b) throw Error("Unknown component '" + f + "'");
                                    var c = b.template;
                                    if (!c) throw Error("Component '" + f + "' has no template");
                                    c = a.a.ia(c), a.f.T(d, c);
                                    var c = q, e = b.createViewModel;
                                    b = e ? e.call(b, c, {
                                        element: d
                                    }) : c, c = h.createChildContext(b), g = b, a.Ca(c, d);
                                }
                            });
                        }, null, {
                            o: d
                        }), {
                            controlsDescendantBindings: !0
                        };
                    }
                }, a.f.Q.component = !0;
            }();
            var P = {
                class: "className",
                for: "htmlFor"
            };
            a.d.attr = {
                update: function(b, d) {
                    var c = a.a.c(d()) || {};
                    a.a.G(c, function(c, d) {
                        d = a.a.c(d);
                        var h = !1 === d || null === d || d === n;
                        h && b.removeAttribute(c), 8 >= a.a.L && c in P ? (c = P[c], h ? b.removeAttribute(c) : b[c] = d) : h || b.setAttribute(c, d.toString()),
                        "name" === c && a.a.Mb(b, h ? "" : d.toString());
                    });
                }
            }, function() {
                a.d.checked = {
                    after: [ "value", "attr" ],
                    init: function(b, d, c) {
                        function e() {
                            var e = b.checked, f = s ? h() : e;
                            if (!a.Y.ma() && (!g || e)) {
                                var k = a.k.B(d);
                                m ? l !== f ? (e && (a.a.ea(k, f, !0), a.a.ea(k, l, !1)), l = f) : a.a.ea(k, f, e) : a.h.pa(k, c, "checked", f, !0);
                            }
                        }
                        function f() {
                            var c = a.a.c(d());
                            b.checked = m ? 0 <= a.a.m(c, h()) : k ? c : h() === c;
                        }
                        var h = a.Ib(function() {
                            return c.has("checkedValue") ? a.a.c(c.get("checkedValue")) : c.has("value") ? a.a.c(c.get("value")) : b.value;
                        }), k = "checkbox" == b.type, g = "radio" == b.type;
                        if (k || g) {
                            var m = k && a.a.c(d()) instanceof Array, l = m ? h() : n, s = g || m;
                            g && !b.name && a.d.uniqueName.init(b, function() {
                                return !0;
                            }), a.s(e, null, {
                                o: b
                            }), a.a.n(b, "click", e), a.s(f, null, {
                                o: b
                            });
                        }
                    }
                }, a.h.V.checked = !0, a.d.checkedValue = {
                    update: function(b, d) {
                        b.value = a.a.c(d());
                    }
                };
            }(), a.d.css = {
                update: function(b, d) {
                    var c = a.a.c(d());
                    "object" == typeof c ? a.a.G(c, function(c, d) {
                        d = a.a.c(d), a.a.Ba(b, c, d);
                    }) : (c = String(c || ""), a.a.Ba(b, b.__ko__cssValue, !1), b.__ko__cssValue = c,
                    a.a.Ba(b, c, !0));
                }
            }, a.d.enable = {
                update: function(b, d) {
                    var c = a.a.c(d());
                    c && b.disabled ? b.removeAttribute("disabled") : c || b.disabled || (b.disabled = !0);
                }
            }, a.d.disable = {
                update: function(b, d) {
                    a.d.enable.update(b, function() {
                        return !a.a.c(d());
                    });
                }
            }, a.d.event = {
                init: function(b, d, c, e, f) {
                    var h = d() || {};
                    a.a.G(h, function(h) {
                        "string" == typeof h && a.a.n(b, h, function(b) {
                            var m, l = d()[h];
                            if (l) {
                                try {
                                    var s = a.a.S(arguments);
                                    e = f.$data, s.unshift(e), m = l.apply(e, s);
                                } finally {
                                    !0 !== m && (b.preventDefault ? b.preventDefault() : b.returnValue = !1);
                                }
                                !1 === c.get(h + "Bubble") && (b.cancelBubble = !0, b.stopPropagation && b.stopPropagation());
                            }
                        });
                    });
                }
            }, a.d.foreach = {
                Eb: function(b) {
                    return function() {
                        var d = b(), c = a.a.Xa(d);
                        return c && "number" != typeof c.length ? (a.a.c(d), {
                            foreach: c.data,
                            as: c.as,
                            includeDestroyed: c.includeDestroyed,
                            afterAdd: c.afterAdd,
                            beforeRemove: c.beforeRemove,
                            afterRender: c.afterRender,
                            beforeMove: c.beforeMove,
                            afterMove: c.afterMove,
                            templateEngine: a.O.Oa
                        }) : {
                            foreach: d,
                            templateEngine: a.O.Oa
                        };
                    };
                },
                init: function(b, d) {
                    return a.d.template.init(b, a.d.foreach.Eb(d));
                },
                update: function(b, d, c, e, f) {
                    return a.d.template.update(b, a.d.foreach.Eb(d), c, e, f);
                }
            }, a.h.ha.foreach = !1, a.f.Q.foreach = !0, a.d.hasfocus = {
                init: function(b, d, c) {
                    function e(e) {
                        b.__ko_hasfocusUpdating = !0;
                        var g = b.ownerDocument;
                        if ("activeElement" in g) {
                            var f;
                            try {
                                f = g.activeElement;
                            } catch (h) {
                                f = g.body;
                            }
                            e = f === b;
                        }
                        g = d(), a.h.pa(g, c, "hasfocus", e, !0), b.__ko_hasfocusLastValue = e, b.__ko_hasfocusUpdating = !1;
                    }
                    var f = e.bind(null, !0), h = e.bind(null, !1);
                    a.a.n(b, "focus", f), a.a.n(b, "focusin", f), a.a.n(b, "blur", h), a.a.n(b, "focusout", h);
                },
                update: function(b, d) {
                    var c = !!a.a.c(d());
                    b.__ko_hasfocusUpdating || b.__ko_hasfocusLastValue === c || (c ? b.focus() : b.blur(),
                    a.k.B(a.a.oa, null, [ b, c ? "focusin" : "focusout" ]));
                }
            }, a.h.V.hasfocus = !0, a.d.hasFocus = a.d.hasfocus, a.h.V.hasFocus = !0, a.d.html = {
                init: function() {
                    return {
                        controlsDescendantBindings: !0
                    };
                },
                update: function(b, d) {
                    a.a.$a(b, d());
                }
            }, I("if"), I("ifnot", !1, !0), I("with", !0, !1, function(a, d) {
                return a.createChildContext(d);
            });
            var K = {};
            a.d.options = {
                init: function(b) {
                    if ("select" !== a.a.t(b)) throw Error("options binding applies only to SELECT elements");
                    for (;0 < b.length; ) b.remove(0);
                    return {
                        controlsDescendantBindings: !0
                    };
                },
                update: function(b, d, c) {
                    function e() {
                        return a.a.ta(b.options, function(a) {
                            return a.selected;
                        });
                    }
                    function f(a, b, c) {
                        var d = typeof b;
                        return "function" == d ? b(a) : "string" == d ? a[b] : c;
                    }
                    function h(c, d) {
                        if (s.length) {
                            var e = 0 <= a.a.m(s, a.i.q(d[0]));
                            a.a.Nb(d[0], e), q && !e && a.k.B(a.a.oa, null, [ b, "change" ]);
                        }
                    }
                    var k = 0 != b.length && b.multiple ? b.scrollTop : null, g = a.a.c(d()), m = c.get("optionsIncludeDestroyed");
                    d = {};
                    var l, s;
                    s = b.multiple ? a.a.Da(e(), a.i.q) : 0 <= b.selectedIndex ? [ a.i.q(b.options[b.selectedIndex]) ] : [],
                    g && (void 0 === g.length && (g = [ g ]), l = a.a.ta(g, function(b) {
                        return m || b === n || null === b || !a.a.c(b._destroy);
                    }), c.has("optionsCaption") && null !== (g = a.a.c(c.get("optionsCaption"))) && g !== n && l.unshift(K));
                    var q = !1;
                    d.beforeRemove = function(a) {
                        b.removeChild(a);
                    }, g = h, c.has("optionsAfterRender") && (g = function(b, d) {
                        h(0, d), a.k.B(c.get("optionsAfterRender"), null, [ d[0], b !== K ? b : n ]);
                    }), a.a.Za(b, l, function(d, e, g) {
                        return g.length && (s = g[0].selected ? [ a.i.q(g[0]) ] : [], q = !0), e = b.ownerDocument.createElement("option"),
                        d === K ? (a.a.bb(e, c.get("optionsCaption")), a.i.ca(e, n)) : (g = f(d, c.get("optionsValue"), d),
                        a.i.ca(e, a.a.c(g)), d = f(d, c.get("optionsText"), g), a.a.bb(e, d)), [ e ];
                    }, d, g), a.k.B(function() {
                        c.get("valueAllowUnset") && c.has("value") ? a.i.ca(b, a.a.c(c.get("value")), !0) : (b.multiple ? s.length && e().length < s.length : s.length && 0 <= b.selectedIndex ? a.i.q(b.options[b.selectedIndex]) !== s[0] : s.length || 0 <= b.selectedIndex) && a.a.oa(b, "change");
                    }), a.a.dc(b), k && 20 < Math.abs(k - b.scrollTop) && (b.scrollTop = k);
                }
            }, a.d.options.Va = a.a.e.F(), a.d.selectedOptions = {
                after: [ "options", "foreach" ],
                init: function(b, d, c) {
                    a.a.n(b, "change", function() {
                        var e = d(), f = [];
                        a.a.u(b.getElementsByTagName("option"), function(b) {
                            b.selected && f.push(a.i.q(b));
                        }), a.h.pa(e, c, "selectedOptions", f);
                    });
                },
                update: function(b, d) {
                    if ("select" != a.a.t(b)) throw Error("values binding applies only to SELECT elements");
                    var c = a.a.c(d());
                    c && "number" == typeof c.length && a.a.u(b.getElementsByTagName("option"), function(b) {
                        var d = 0 <= a.a.m(c, a.i.q(b));
                        a.a.Nb(b, d);
                    });
                }
            }, a.h.V.selectedOptions = !0, a.d.style = {
                update: function(b, d) {
                    var c = a.a.c(d() || {});
                    a.a.G(c, function(c, d) {
                        d = a.a.c(d), null !== d && d !== n && !1 !== d || (d = ""), b.style[c] = d;
                    });
                }
            }, a.d.submit = {
                init: function(b, d, c, e, f) {
                    if ("function" != typeof d()) throw Error("The value for a submit binding must be a function");
                    a.a.n(b, "submit", function(a) {
                        var c, e = d();
                        try {
                            c = e.call(f.$data, b);
                        } finally {
                            !0 !== c && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
                        }
                    });
                }
            }, a.d.text = {
                init: function() {
                    return {
                        controlsDescendantBindings: !0
                    };
                },
                update: function(b, d) {
                    a.a.bb(b, d());
                }
            }, a.f.Q.text = !0, function() {
                if (v && v.navigator) var b = function(a) {
                    if (a) return parseFloat(a[1]);
                }, d = v.opera && v.opera.version && parseInt(v.opera.version()), c = v.navigator.userAgent, e = b(c.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)), f = b(c.match(/Firefox\/([^ ]*)/));
                if (10 > a.a.L) var h = a.a.e.F(), k = a.a.e.F(), g = function(b) {
                    var c = this.activeElement;
                    (c = c && a.a.e.get(c, k)) && c(b);
                }, m = function(b, c) {
                    var d = b.ownerDocument;
                    a.a.e.get(d, h) || (a.a.e.set(d, h, !0), a.a.n(d, "selectionchange", g)), a.a.e.set(b, k, c);
                };
                a.d.textInput = {
                    init: function(b, c, g) {
                        function h(c, d) {
                            a.a.n(b, c, d);
                        }
                        function k() {
                            var d = a.a.c(c());
                            null !== d && d !== n || (d = ""), v !== n && d === v ? setTimeout(k, 4) : b.value !== d && (r = d,
                            b.value = d);
                        }
                        function u() {
                            x || (v = b.value, x = setTimeout(t, 4));
                        }
                        function t() {
                            clearTimeout(x), v = x = n;
                            var d = b.value;
                            r !== d && (r = d, a.h.pa(c(), g, "textInput", d));
                        }
                        var x, v, r = b.value;
                        10 > a.a.L ? (h("propertychange", function(a) {
                            "value" === a.propertyName && t();
                        }), 8 == a.a.L && (h("keyup", t), h("keydown", t)), 8 <= a.a.L && (m(b, t), h("dragend", u))) : (h("input", t),
                        5 > e && "textarea" === a.a.t(b) ? (h("keydown", u), h("paste", u), h("cut", u)) : 11 > d ? h("keydown", u) : 4 > f && (h("DOMAutoComplete", t),
                        h("dragdrop", t), h("drop", t))), h("change", t), a.s(k, null, {
                            o: b
                        });
                    }
                }, a.h.V.textInput = !0, a.d.textinput = {
                    preprocess: function(a, b, c) {
                        c("textInput", a);
                    }
                };
            }(), a.d.uniqueName = {
                init: function(b, d) {
                    if (d()) {
                        var c = "ko_unique_" + ++a.d.uniqueName.Zb;
                        a.a.Mb(b, c);
                    }
                }
            }, a.d.uniqueName.Zb = 0, a.d.value = {
                after: [ "options", "foreach" ],
                init: function(b, d, c) {
                    if ("input" != b.tagName.toLowerCase() || "checkbox" != b.type && "radio" != b.type) {
                        var e = [ "change" ], f = c.get("valueUpdate"), h = !1, k = null;
                        f && ("string" == typeof f && (f = [ f ]), a.a.ga(e, f), e = a.a.rb(e));
                        var g = function() {
                            k = null, h = !1;
                            var e = d(), g = a.i.q(b);
                            a.h.pa(e, c, "value", g);
                        };
                        !a.a.L || "input" != b.tagName.toLowerCase() || "text" != b.type || "off" == b.autocomplete || b.form && "off" == b.form.autocomplete || -1 != a.a.m(e, "propertychange") || (a.a.n(b, "propertychange", function() {
                            h = !0;
                        }), a.a.n(b, "focus", function() {
                            h = !1;
                        }), a.a.n(b, "blur", function() {
                            h && g();
                        })), a.a.u(e, function(c) {
                            var d = g;
                            a.a.uc(c, "after") && (d = function() {
                                k = a.i.q(b), setTimeout(g, 0);
                            }, c = c.substring(5)), a.a.n(b, c, d);
                        });
                        var m = function() {
                            var e = a.a.c(d()), g = a.i.q(b);
                            if (null !== k && e === k) setTimeout(m, 0); else if (e !== g) if ("select" === a.a.t(b)) {
                                var f = c.get("valueAllowUnset"), g = function() {
                                    a.i.ca(b, e, f);
                                };
                                g(), f || e === a.i.q(b) ? setTimeout(g, 0) : a.k.B(a.a.oa, null, [ b, "change" ]);
                            } else a.i.ca(b, e);
                        };
                        a.s(m, null, {
                            o: b
                        });
                    } else a.ra(b, {
                        checkedValue: d
                    });
                },
                update: function() {}
            }, a.h.V.value = !0, a.d.visible = {
                update: function(b, d) {
                    var c = a.a.c(d()), e = "none" != b.style.display;
                    c && !e ? b.style.display = "" : !c && e && (b.style.display = "none");
                }
            }, function(b) {
                a.d[b] = {
                    init: function(d, c, e, f, h) {
                        return a.d.event.init.call(this, d, function() {
                            var a = {};
                            return a[b] = c(), a;
                        }, e, f, h);
                    }
                };
            }("click"), a.H = function() {}, a.H.prototype.renderTemplateSource = function() {
                throw Error("Override renderTemplateSource");
            }, a.H.prototype.createJavaScriptEvaluatorBlock = function() {
                throw Error("Override createJavaScriptEvaluatorBlock");
            }, a.H.prototype.makeTemplateSource = function(b, d) {
                if ("string" == typeof b) {
                    d = d || y;
                    var c = d.getElementById(b);
                    if (!c) throw Error("Cannot find template with ID " + b);
                    return new a.r.l(c);
                }
                if (1 == b.nodeType || 8 == b.nodeType) return new a.r.fa(b);
                throw Error("Unknown template type: " + b);
            }, a.H.prototype.renderTemplate = function(a, d, c, e) {
                return a = this.makeTemplateSource(a, e), this.renderTemplateSource(a, d, c);
            }, a.H.prototype.isTemplateRewritten = function(a, d) {
                return !1 === this.allowTemplateRewriting || this.makeTemplateSource(a, d).data("isRewritten");
            }, a.H.prototype.rewriteTemplate = function(a, d, c) {
                a = this.makeTemplateSource(a, c), d = d(a.text()), a.text(d), a.data("isRewritten", !0);
            }, a.b("templateEngine", a.H), a.fb = function() {
                function b(b, c, d, k) {
                    b = a.h.Wa(b);
                    for (var g = a.h.ha, m = 0; m < b.length; m++) {
                        var l = b[m].key;
                        if (g.hasOwnProperty(l)) {
                            var s = g[l];
                            if ("function" == typeof s) {
                                if (l = s(b[m].value)) throw Error(l);
                            } else if (!s) throw Error("This template engine does not support the '" + l + "' binding within its templates");
                        }
                    }
                    return d = "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + a.h.ya(b, {
                        valueAccessors: !0
                    }) + " } })()},'" + d.toLowerCase() + "')", k.createJavaScriptEvaluatorBlock(d) + c;
                }
                var d = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi, c = /\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;
                return {
                    ec: function(b, c, d) {
                        c.isTemplateRewritten(b, d) || c.rewriteTemplate(b, function(b) {
                            return a.fb.nc(b, c);
                        }, d);
                    },
                    nc: function(a, f) {
                        return a.replace(d, function(a, c, d, e, l) {
                            return b(l, c, d, f);
                        }).replace(c, function(a, c) {
                            return b(c, "\x3c!-- ko --\x3e", "#comment", f);
                        });
                    },
                    Xb: function(b, c) {
                        return a.D.Ua(function(d, k) {
                            var g = d.nextSibling;
                            g && g.nodeName.toLowerCase() === c && a.ra(g, b, k);
                        });
                    }
                };
            }(), a.b("__tr_ambtns", a.fb.Xb), function() {
                a.r = {}, a.r.l = function(a) {
                    this.l = a;
                }, a.r.l.prototype.text = function() {
                    var b = a.a.t(this.l), b = "script" === b ? "text" : "textarea" === b ? "value" : "innerHTML";
                    if (0 == arguments.length) return this.l[b];
                    var d = arguments[0];
                    "innerHTML" === b ? a.a.$a(this.l, d) : this.l[b] = d;
                };
                var b = a.a.e.F() + "_";
                a.r.l.prototype.data = function(c) {
                    if (1 === arguments.length) return a.a.e.get(this.l, b + c);
                    a.a.e.set(this.l, b + c, arguments[1]);
                };
                var d = a.a.e.F();
                a.r.fa = function(a) {
                    this.l = a;
                }, a.r.fa.prototype = new a.r.l(), a.r.fa.prototype.text = function() {
                    if (0 == arguments.length) {
                        var b = a.a.e.get(this.l, d) || {};
                        return b.gb === n && b.Ga && (b.gb = b.Ga.innerHTML), b.gb;
                    }
                    a.a.e.set(this.l, d, {
                        gb: arguments[0]
                    });
                }, a.r.l.prototype.nodes = function() {
                    if (0 == arguments.length) return (a.a.e.get(this.l, d) || {}).Ga;
                    a.a.e.set(this.l, d, {
                        Ga: arguments[0]
                    });
                }, a.b("templateSources", a.r), a.b("templateSources.domElement", a.r.l), a.b("templateSources.anonymousTemplate", a.r.fa);
            }(), function() {
                function b(b, c, d) {
                    var e;
                    for (c = a.f.nextSibling(c); b && (e = b) !== c; ) b = a.f.nextSibling(e), d(e, b);
                }
                function d(c, d) {
                    if (c.length) {
                        var e = c[0], f = c[c.length - 1], h = e.parentNode, k = a.J.instance, n = k.preprocessNode;
                        if (n) {
                            if (b(e, f, function(a, b) {
                                var c = a.previousSibling, d = n.call(k, a);
                                d && (a === e && (e = d[0] || b), a === f && (f = d[d.length - 1] || c));
                            }), c.length = 0, !e) return;
                            e === f ? c.push(e) : (c.push(e, f), a.a.ka(c, h));
                        }
                        b(e, f, function(b) {
                            1 !== b.nodeType && 8 !== b.nodeType || a.pb(d, b);
                        }), b(e, f, function(b) {
                            1 !== b.nodeType && 8 !== b.nodeType || a.D.Sb(b, [ d ]);
                        }), a.a.ka(c, h);
                    }
                }
                function c(a) {
                    return a.nodeType ? a : 0 < a.length ? a[0] : null;
                }
                function e(b, e, f, k, q) {
                    q = q || {};
                    var p = b && c(b), p = p && p.ownerDocument, n = q.templateEngine || h;
                    if (a.fb.ec(f, n, p), f = n.renderTemplate(f, k, q, p), "number" != typeof f.length || 0 < f.length && "number" != typeof f[0].nodeType) throw Error("Template engine must return an array of DOM nodes");
                    switch (p = !1, e) {
                      case "replaceChildren":
                        a.f.T(b, f), p = !0;
                        break;

                      case "replaceNode":
                        a.a.Lb(b, f), p = !0;
                        break;

                      case "ignoreTargetNode":
                        break;

                      default:
                        throw Error("Unknown renderMode: " + e);
                    }
                    return p && (d(f, k), q.afterRender && a.k.B(q.afterRender, null, [ f, k.$data ])),
                    f;
                }
                function f(b, c, d) {
                    return a.C(b) ? b() : "function" == typeof b ? b(c, d) : b;
                }
                var h;
                a.ab = function(b) {
                    if (b != n && !(b instanceof a.H)) throw Error("templateEngine must inherit from ko.templateEngine");
                    h = b;
                }, a.Ya = function(b, d, k, s, q) {
                    if (k = k || {}, (k.templateEngine || h) == n) throw Error("Set a template engine before calling renderTemplate");
                    if (q = q || "replaceChildren", s) {
                        var p = c(s);
                        return a.j(function() {
                            var h = d && d instanceof a.N ? d : new a.N(a.a.c(d)), n = f(b, h.$data, h), h = e(s, q, n, h, k);
                            "replaceNode" == q && (s = h, p = c(s));
                        }, null, {
                            Ia: function() {
                                return !p || !a.a.Ja(p);
                            },
                            o: p && "replaceNode" == q ? p.parentNode : p
                        });
                    }
                    return a.D.Ua(function(c) {
                        a.Ya(b, d, k, c, "replaceNode");
                    });
                }, a.tc = function(b, c, h, k, q) {
                    function p(a, b) {
                        d(b, u), h.afterRender && h.afterRender(b, a);
                    }
                    function r(a, c) {
                        return u = q.createChildContext(a, h.as, function(a) {
                            a.$index = c;
                        }), e(null, "ignoreTargetNode", f(b, a, u), u, h);
                    }
                    var u;
                    return a.j(function() {
                        var b = a.a.c(c) || [];
                        void 0 === b.length && (b = [ b ]), b = a.a.ta(b, function(b) {
                            return h.includeDestroyed || b === n || null === b || !a.a.c(b._destroy);
                        }), a.k.B(a.a.Za, null, [ k, b, r, h, p ]);
                    }, null, {
                        o: k
                    });
                };
                var k = a.a.e.F();
                a.d.template = {
                    init: function(b, c) {
                        var d = a.a.c(c());
                        return "string" == typeof d || d.name ? a.f.ja(b) : (d = a.f.childNodes(b), d = a.a.oc(d),
                        new a.r.fa(b).nodes(d)), {
                            controlsDescendantBindings: !0
                        };
                    },
                    update: function(b, c, d, e, f) {
                        var r, h = c();
                        c = a.a.c(h), d = !0, e = null, "string" == typeof c ? c = {} : (h = c.name, "if" in c && (d = a.a.c(c.if)),
                        d && "ifnot" in c && (d = !a.a.c(c.ifnot)), r = a.a.c(c.data)), "foreach" in c ? e = a.tc(h || b, d && c.foreach || [], c, b, f) : d ? (f = "data" in c ? f.createChildContext(r, c.as) : f,
                        e = a.Ya(h || b, f, c, b)) : a.f.ja(b), f = e, (r = a.a.e.get(b, k)) && "function" == typeof r.K && r.K(),
                        a.a.e.set(b, k, f && f.Z() ? f : n);
                    }
                }, a.h.ha.template = function(b) {
                    return b = a.h.Wa(b), 1 == b.length && b[0].unknown || a.h.lc(b, "name") ? null : "This template engine does not support anonymous templates nested within its templates";
                }, a.f.Q.template = !0;
            }(), a.b("setTemplateEngine", a.ab), a.b("renderTemplate", a.Ya), a.a.wb = function(a, d, c) {
                if (a.length && d.length) {
                    var e, f, h, k, g;
                    for (e = f = 0; (!c || e < c) && (k = a[f]); ++f) {
                        for (h = 0; g = d[h]; ++h) if (k.value === g.value) {
                            k.moved = g.index, g.moved = k.index, d.splice(h, 1), e = h = 0;
                            break;
                        }
                        e += h;
                    }
                }
            }, a.a.Fa = function() {
                function b(b, c, e, f, h) {
                    var l, q, t, v, x, k = Math.min, g = Math.max, m = [], n = b.length, p = c.length, r = p - n || 1, u = n + p + 1;
                    for (l = 0; l <= n; l++) for (v = t, m.push(t = []), x = k(p, l + r), q = g(0, l - 1); q <= x; q++) t[q] = q ? l ? b[l - 1] === c[q - 1] ? v[q - 1] : k(v[q] || u, t[q - 1] || u) + 1 : q + 1 : l + 1;
                    for (k = [], g = [], r = [], l = n, q = p; l || q; ) p = m[l][q] - 1, q && p === m[l][q - 1] ? g.push(k[k.length] = {
                        status: e,
                        value: c[--q],
                        index: q
                    }) : l && p === m[l - 1][q] ? r.push(k[k.length] = {
                        status: f,
                        value: b[--l],
                        index: l
                    }) : (--q, --l, h.sparse || k.push({
                        status: "retained",
                        value: c[q]
                    }));
                    return a.a.wb(g, r, 10 * n), k.reverse();
                }
                return function(a, c, e) {
                    return e = "boolean" == typeof e ? {
                        dontLimitMoves: e
                    } : e || {}, a = a || [], c = c || [], a.length <= c.length ? b(a, c, "added", "deleted", e) : b(c, a, "deleted", "added", e);
                };
            }(), a.b("utils.compareArrays", a.a.Fa), function() {
                function b(b, d, f, h, k) {
                    var g = [], m = a.j(function() {
                        var l = d(f, k, a.a.ka(g, b)) || [];
                        0 < g.length && (a.a.Lb(g, l), h && a.k.B(h, null, [ f, l, k ])), g.length = 0,
                        a.a.ga(g, l);
                    }, null, {
                        o: b,
                        Ia: function() {
                            return !a.a.ob(g);
                        }
                    });
                    return {
                        $: g,
                        j: m.Z() ? m : n
                    };
                }
                var d = a.a.e.F();
                a.a.Za = function(c, e, f, h, k) {
                    function g(b, d) {
                        w = s[d], t !== d && (y[b] = w), w.Na(t++), a.a.ka(w.$, c), r.push(w), x.push(w);
                    }
                    function m(b, c) {
                        if (b) for (var d = 0, e = c.length; d < e; d++) c[d] && a.a.u(c[d].$, function(a) {
                            b(a, d, c[d].sa);
                        });
                    }
                    e = e || [], h = h || {};
                    var l = a.a.e.get(c, d) === n, s = a.a.e.get(c, d) || [], q = a.a.Da(s, function(a) {
                        return a.sa;
                    }), p = a.a.Fa(q, e, h.dontLimitMoves), r = [], u = 0, t = 0, v = [], x = [];
                    e = [];
                    for (var w, B, D, y = [], q = [], C = 0; B = p[C]; C++) switch (D = B.moved, B.status) {
                      case "deleted":
                        D === n && (w = s[u], w.j && w.j.K(), v.push.apply(v, a.a.ka(w.$, c)), h.beforeRemove && (e[C] = w,
                        x.push(w))), u++;
                        break;

                      case "retained":
                        g(C, u++);
                        break;

                      case "added":
                        D !== n ? g(C, D) : (w = {
                            sa: B.value,
                            Na: a.p(t++)
                        }, r.push(w), x.push(w), l || (q[C] = w));
                    }
                    m(h.beforeMove, y), a.a.u(v, h.beforeRemove ? a.R : a.removeNode);
                    for (var F, C = 0, l = a.f.firstChild(c); w = x[C]; C++) {
                        for (w.$ || a.a.extend(w, b(c, f, w.sa, k, w.Na)), u = 0; p = w.$[u]; l = p.nextSibling,
                        F = p, u++) p !== l && a.f.Bb(c, p, F);
                        !w.ic && k && (k(w.sa, w.$, w.Na), w.ic = !0);
                    }
                    m(h.beforeRemove, e), m(h.afterMove, y), m(h.afterAdd, q), a.a.e.set(c, d, r);
                };
            }(), a.b("utils.setDomNodeChildrenFromArrayMapping", a.a.Za), a.O = function() {
                this.allowTemplateRewriting = !1;
            }, a.O.prototype = new a.H(), a.O.prototype.renderTemplateSource = function(b) {
                var d = (9 > a.a.L ? 0 : b.nodes) ? b.nodes() : null;
                return d ? a.a.S(d.cloneNode(!0).childNodes) : (b = b.text(), a.a.ba(b));
            }, a.O.Oa = new a.O(), a.ab(a.O.Oa), a.b("nativeTemplateEngine", a.O), function() {
                a.Sa = function() {
                    var a = this.kc = function() {
                        if (!r || !r.tmpl) return 0;
                        try {
                            if (0 <= r.tmpl.tag.tmpl.open.toString().indexOf("__")) return 2;
                        } catch (a) {}
                        return 1;
                    }();
                    this.renderTemplateSource = function(b, e, f) {
                        if (f = f || {}, 2 > a) throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
                        var h = b.data("precompiled");
                        return h || (h = b.text() || "", h = r.template(null, "{{ko_with $item.koBindingContext}}" + h + "{{/ko_with}}"),
                        b.data("precompiled", h)), b = [ e.$data ], e = r.extend({
                            koBindingContext: e
                        }, f.templateOptions), e = r.tmpl(h, b, e), e.appendTo(y.createElement("div")),
                        r.fragments = {}, e;
                    }, this.createJavaScriptEvaluatorBlock = function(a) {
                        return "{{ko_code ((function() { return " + a + " })()) }}";
                    }, this.addTemplate = function(a, b) {
                        y.write("<script type='text/html' id='" + a + "'>" + b + "<\/script>");
                    }, 0 < a && (r.tmpl.tag.ko_code = {
                        open: "__.push($1 || '');"
                    }, r.tmpl.tag.ko_with = {
                        open: "with($1) {",
                        close: "} "
                    });
                }, a.Sa.prototype = new a.H();
                var b = new a.Sa();
                0 < b.kc && a.ab(b), a.b("jqueryTmplTemplateEngine", a.Sa);
            }();
        });
    }();
}(), function(a, b) {
    "use strict";
    "object" == typeof exports ? b(exports, require("jquery"), require("knockout"), require("jquery-ui")) : "function" == typeof define && define.amd ? define([ "exports", "jquery", "knockout", "jquery-ui" ], b) : b(a.kojqui = {}, a.jQuery, a.ko);
}(this, function(a, b, c) {
    "use strict";
    var d, e;
    d = function() {
        var a, d, e, f;
        return a = function(a) {
            var b = (a || "").match(/^(\d)\.(\d+)\..*$/);
            return b ? {
                major: parseInt(b[1], 10),
                minor: parseInt(b[2], 10)
            } : null;
        }, d = b && b.fn ? a(b.fn.jquery) : null, e = b && b.ui ? a(b.ui.version) : null,
        f = c ? a(c.version) : null, {
            jQuery: d,
            jQueryUI: e,
            knockout: f
        };
    }(), function() {
        if (!d.jQuery) throw new Error("jQuery must be loaded before knockout-jquery.");
        if (!d.jQueryUI) throw new Error("jQuery UI must be loaded before knockout-jquery.");
        if (!d.knockout) throw new Error("knockout must be loaded before knockout-jquery.");
        if (d.jQueryUI.major < 1 || 1 === d.jQueryUI.major && d.jQueryUI.minor < 8) throw new Error("This version of the jQuery UI library is not supported.");
        if (d.knockout.major < 2 || 2 === d.knockout.major && d.knockout.minor < 2) throw new Error("This version of the knockout library is not supported.");
    }(), e = function() {
        var a, d, e, f;
        return a = "__kojqui_options", d = function(a, b) {
            var d = {};
            return c.utils.arrayForEach(b, function(b) {
                void 0 !== a[b] && (d[b] = c.utils.unwrapObservable(a[b]));
            }), d;
        }, e = function(a, d, e) {
            c.isObservable(e.refreshOn) && c.computed({
                read: function() {
                    e.refreshOn(), b(d)[a]("refresh");
                },
                disposeWhenNodeIsRemoved: d
            });
        }, f = function(f) {
            var g, h, i;
            g = f.name, b.fn[g] && (h = function(h, i, j, k, l) {
                var m, n, o, p;
                return m = i(), o = d(m, f.options), p = d(m, f.events), n = arguments, c.utils.arrayForEach(c.bindingHandlers[g].preInitHandlers, function(a) {
                    a.apply(this, n);
                }), c.applyBindingsToDescendants(l, h), c.utils.domData.set(h, a, o), b.each(p, function(a, b) {
                    p[a] = b.bind(k);
                }), b(h)[g](c.utils.extend(o, p)), f.hasRefresh && e(g, h, m), c.isWriteableObservable(m.widget) && m.widget(b(h)),
                c.utils.domNodeDisposal.addDisposeCallback(h, function() {
                    b(h)[g]("destroy");
                }), c.utils.arrayForEach(c.bindingHandlers[g].postInitHandlers, function(a) {
                    a.apply(this, n);
                }), {
                    controlsDescendantBindings: !0
                };
            }, i = function(e, h) {
                var i, j, k;
                i = h(), j = c.utils.domData.get(e, a), k = d(i, f.options), b.each(k, function(a, c) {
                    c !== j[a] && b(e)[g]("option", a, k[a]);
                }), c.utils.domData.set(e, a, k);
            }, c.bindingHandlers[g] = {
                init: h,
                update: i,
                config: f,
                preInitHandlers: [],
                postInitHandlers: []
            }, f.preInit && c.bindingHandlers[g].preInitHandlers.push(f.preInit), f.postInit && c.bindingHandlers[g].postInitHandlers.push(f.postInit));
        }, {
            create: f
        };
    }(), function() {
        var a, f, g, h, i;
        f = function(d, e) {
            var f = e();
            c.isWriteableObservable(f.active) && b(d).on(a, function() {
                f.active(b(d).accordion("option", "active"));
            }), c.utils.domNodeDisposal.addDisposeCallback(d, function() {
                b(d).off(".accordion");
            });
        }, 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? (g = [ "active", "animated", "autoHeight", "clearStyle", "collapsible", "disabled", "event", "fillSpace", "header", "icons", "navigation", "navigationFilter" ],
        h = [ "change", "changestart", "create" ], i = !1, a = "accordionchange.accordion") : (g = [ "active", "animate", "collapsible", "disabled", "event", "header", "heightStyle", "icons" ],
        h = [ "activate", "beforeActivate", "create" ], i = !0, a = "accordionactivate.accordion"),
        e.create({
            name: "accordion",
            options: g,
            events: h,
            postInit: f,
            hasRefresh: i
        });
    }(), function() {
        var a;
        a = 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? [ "change", "close", "create", "focus", "open", "search", "select" ] : [ "change", "close", "create", "focus", "open", "response", "search", "select" ],
        e.create({
            name: "autocomplete",
            options: [ "appendTo", "autoFocus", "delay", "disabled", "minLength", "position", "source" ],
            events: a
        });
    }(), function() {
        e.create({
            name: "button",
            options: [ "disabled", "icons", "label", "text" ],
            events: [ "create" ],
            hasRefresh: !0
        });
    }(), function() {
        e.create({
            name: "buttonset",
            options: [ "items", "disabled" ],
            events: [ "create" ],
            hasRefresh: !0
        });
    }(), function() {
        var a;
        a = function(a, d) {
            var e, f, g, h;
            e = d(), f = c.utils.unwrapObservable(e.value), f && b(a).datepicker("setDate", f),
            c.isObservable(e.value) && (g = e.value.subscribe(function(c) {
                b(a).datepicker("setDate", c);
            }), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                g.dispose();
            })), c.isWriteableObservable(e.value) && (h = b(a).datepicker("option", "onSelect"),
            b(a).datepicker("option", "onSelect", function(c) {
                var d, f;
                d = b(a).datepicker("option", "dateFormat"), f = b.datepicker.parseDate(d, c), e.value(f),
                "function" == typeof h && h.apply(this, Array.prototype.slice.call(arguments));
            }));
        }, e.create({
            name: "datepicker",
            options: [ "altField", "altFormat", "appendText", "autoSize", "buttonImage", "buttonImageOnly", "buttonText", "calculateWeek", "changeMonth", "changeYear", "closeText", "constrainInput", "currentText", "dateFormat", "dayNames", "dayNamesMin", "dayNamesShort", "defaultDate", "duration", "firstDay", "gotoCurrent", "hideIfNoPrevNext", "isRTL", "maxDate", "minDate", "monthNames", "monthNamesShort", "navigationAsDateFormat", "nextText", "numberOfMonths", "prevText", "selectOtherMonths", "shortYearCutoff", "showAnim", "showButtonPanel", "showCurrentAtPos", "showMonthAfterYear", "showOn", "showOptions", "showOtherMonths", "showWeek", "stepMonths", "weekHeader", "yearRange", "yearSuffix", "beforeShow", "beforeShowDay", "onChangeMonthYear", "onClose", "onSelect" ],
            events: [],
            postInit: a
        });
    }(), function() {
        var a, f, g, h;
        a = function(a) {
            var b;
            b = document.createElement("DIV"), b.style.display = "none", a.parentNode.insertBefore(b, a),
            c.utils.domNodeDisposal.addDisposeCallback(b, function() {
                c.removeNode(a);
            });
        }, f = function(a, d) {
            var e = d();
            e.isOpen && c.computed({
                read: function() {
                    c.utils.unwrapObservable(e.isOpen) ? b(a).dialog("open") : b(a).dialog("close");
                },
                disposeWhenNodeIsRemoved: a
            }), c.isWriteableObservable(e.isOpen) && (b(a).on("dialogopen.dialog", function() {
                e.isOpen(!0);
            }), b(a).on("dialogclose.dialog", function() {
                e.isOpen(!1);
            })), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".dialog");
            });
        }, 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? (g = [ "autoOpen", "buttons", "closeOnEscape", "closeText", "dialogClass", "disabled", "draggable", "height", "maxHeight", "maxWidth", "minHeight", "minWidth", "modal", "position", "resizable", "show", "stack", "title", "width", "zIndex" ],
        h = [ "beforeClose", "create", "open", "focus", "dragStart", "drag", "dragStop", "resizeStart", "resize", "resizeStop", "close" ]) : 1 === d.jQueryUI.major && 9 === d.jQueryUI.minor ? (g = [ "autoOpen", "buttons", "closeOnEscape", "closeText", "dialogClass", "draggable", "height", "hide", "maxHeight", "maxWidth", "minHeight", "minWidth", "modal", "position", "resizable", "show", "stack", "title", "width", "zIndex" ],
        h = [ "beforeClose", "create", "open", "focus", "dragStart", "drag", "dragStop", "resizeStart", "resize", "resizeStop", "close" ]) : (g = [ "appendTo", "autoOpen", "buttons", "closeOnEscape", "closeText", "dialogClass", "draggable", "height", "hide", "maxHeight", "maxWidth", "minHeight", "minWidth", "modal", "position", "resizable", "show", "title", "width" ],
        h = [ "beforeClose", "create", "open", "focus", "dragStart", "drag", "dragStop", "resizeStart", "resize", "resizeStop", "close" ]),
        e.create({
            name: "dialog",
            options: g,
            events: h,
            preInit: a,
            postInit: f
        });
    }(), function() {
        e.create({
            name: "menu",
            options: [ "disabled", "icons", "menus", "position", "role" ],
            events: [ "blur", "create", "focus", "select" ],
            hasRefresh: !0
        });
    }(), function() {
        var a;
        a = 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? [ "disabled", "value" ] : [ "disabled", "max", "value" ],
        e.create({
            name: "progressbar",
            options: a,
            events: [ "change", "create", "complete" ]
        });
    }(), function() {
        var a;
        a = function(a, d) {
            var e = d();
            c.isWriteableObservable(e.value) && b(a).on("slidechange.slider", function(c, d) {
                b(a).find(".ui-slider-handle")[0] === d.handle && e.value(d.value);
            }), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".slider");
            });
        }, e.create({
            name: "slider",
            options: [ "animate", "disabled", "max", "min", "orientation", "range", "step", "value", "values" ],
            events: [ "create", "start", "slide", "change", "stop" ],
            postInit: a
        });
    }(), function() {
        var a;
        a = function(a, d, e) {
            var f = d();
            f.value && c.computed({
                read: function() {
                    b(a).spinner("value", c.utils.unwrapObservable(f.value));
                },
                disposeWhenNodeIsRemoved: a
            }), c.isWriteableObservable(f.value) && (e().valueUpdate ? b(a).on("spin.spinner", function(a, b) {
                f.value(b.value);
            }) : b(a).on("spinchange.spinner", function() {
                f.value(b(a).spinner("value"));
            })), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".spinner");
            });
        }, e.create({
            name: "spinner",
            options: [ "culture", "disabled", "icons", "incremental", "max", "min", "numberFormat", "page", "step" ],
            events: [ "create", "start", "spin", "stop", "change" ],
            postInit: a
        });
    }(), function() {
        var a, f, g, h, i, j;
        a = function(a, d) {
            var e = d();
            c.isWriteableObservable(e.selected) && b(a).on("tabsshow.tabs", function(c, d) {
                b(a)[0] === c.target && e.selected(d.index);
            }), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".tabs");
            });
        }, f = function(a, d) {
            var e = d();
            c.isWriteableObservable(e.active) && b(a).on("tabsactivate.tabs", function(c, d) {
                b(a)[0] === c.target && e.active(d.newTab.index());
            }), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".tabs");
            });
        }, 1 === d.jQueryUI.major && 8 === d.jQueryUI.minor ? (g = [ "ajaxOptions", "cache", "collapsible", "cookie", "disabled", "event", "fx", "idPrefix", "panelTemplate", "selected", "spinner", "tabTemplate" ],
        h = [ "add", "create", "disable", "enable", "load", "remove", "select", "show" ],
        j = a, i = !1) : (g = [ "active", "collapsible", "disabled", "event", "heightStyle", "hide", "show" ],
        h = [ "activate", "beforeActivate", "beforeLoad", "create", "load" ], j = f, i = !0),
        e.create({
            name: "tabs",
            options: g,
            events: h,
            postInit: j,
            hasRefresh: i
        });
    }(), function() {
        var a;
        a = function(a, d) {
            var e = d();
            e.isOpen && c.computed({
                read: function() {
                    c.utils.unwrapObservable(e.isOpen) ? b(a).tooltip("open") : b(a).tooltip("close");
                },
                disposeWhenNodeIsRemoved: a
            }), c.isWriteableObservable(e.isOpen) && (b(a).on("tooltipopen.tooltip", function() {
                e.isOpen(!0);
            }), b(a).on("tooltipclose.tooltip", function() {
                e.isOpen(!1);
            })), c.utils.domNodeDisposal.addDisposeCallback(a, function() {
                b(a).off(".tooltip");
            });
        }, e.create({
            name: "tooltip",
            options: [ "content", "disabled", "hide", "items", "position", "show", "tooltipClass", "track" ],
            events: [ "create", "open", "close" ],
            postInit: a
        });
    }(), a.bindingFactory = e, a.version = "1.0.0";
}), function(a) {
    if ("function" == typeof define && define.amd) define([ "knockout", "jquery", "jquery-ui/ui/widgets/sortable", "jquery-ui/ui/widgets/draggable", "jquery-ui/ui/widgets/droppable" ], a); else if ("function" == typeof require && "object" == typeof exports && "object" == typeof module) {
        var b = require("knockout"), c = require("jquery");
        require("jquery-ui/ui/widgets/sortable"), require("jquery-ui/ui/widgets/draggable"),
        require("jquery-ui/ui/widgets/droppable"), a(b, c);
    } else a(window.ko, window.jQuery);
}(function(a, b) {
    var c = "ko_sortItem", d = "ko_sourceIndex", e = "ko_sortList", f = "ko_parentList", g = "ko_dragItem", h = a.utils.unwrapObservable, i = a.utils.domData.get, j = a.utils.domData.set, k = b.ui && b.ui.version, l = k && k.indexOf("1.6.") && k.indexOf("1.7.") && (k.indexOf("1.8.") || "1.8.24" === k), m = function(b, d) {
        a.utils.arrayForEach(b, function(a) {
            1 === a.nodeType && (j(a, c, d), j(a, f, i(a.parentNode, e)));
        });
    }, n = function(b, c) {
        var d, e = {}, f = h(b()) || {};
        return f.data ? (e[c] = f.data, e.name = f.template) : e[c] = b(), a.utils.arrayForEach([ "afterAdd", "afterRender", "as", "beforeRemove", "includeDestroyed", "templateEngine", "templateOptions", "nodes" ], function(b) {
            f.hasOwnProperty(b) ? e[b] = f[b] : a.bindingHandlers.sortable.hasOwnProperty(b) && (e[b] = a.bindingHandlers.sortable[b]);
        }), "foreach" === c && (e.afterRender ? (d = e.afterRender, e.afterRender = function(a, b) {
            m.call(b, a, b), d.call(b, a, b);
        }) : e.afterRender = m), e;
    }, o = function(a, b) {
        var c = h(b);
        if (c) for (var d = 0; d < a; d++) c[d] && h(c[d]._destroy) && a++;
        return a;
    }, p = function(c, d) {
        var e, f;
        d ? (f = document.getElementById(d)) && (e = new a.templateSources.domElement(f),
        e.text(b.trim(e.text()))) : b(c).contents().each(function() {
            this && 1 !== this.nodeType && c.removeChild(this);
        });
    };
    a.bindingHandlers.sortable = {
        init: function(k, m, q, r, s) {
            var t, u, v = b(k), w = h(m()) || {}, x = n(m, "foreach"), y = {};
            p(k, x.name), b.extend(!0, y, a.bindingHandlers.sortable), w.options && y.options && (a.utils.extend(y.options, w.options),
            delete w.options), a.utils.extend(y, w), y.connectClass && (a.isObservable(y.allowDrop) || "function" == typeof y.allowDrop) ? a.computed({
                read: function() {
                    var b = h(y.allowDrop), c = "function" == typeof b ? b.call(this, x.foreach) : b;
                    a.utils.toggleDomNodeCssClass(k, y.connectClass, c);
                },
                disposeWhenNodeIsRemoved: k
            }, this) : a.utils.toggleDomNodeCssClass(k, y.connectClass, y.allowDrop), a.bindingHandlers.template.init(k, function() {
                return x;
            }, q, r, s), t = y.options.start, u = y.options.update, y.options.helper || (y.options.helper = function(a, c) {
                return c.is("tr") && c.children().each(function() {
                    b(this).width(b(this).width());
                }), c;
            });
            var z = setTimeout(function() {
                var m, n = y.options.receive;
                v.sortable(a.utils.extend(y.options, {
                    start: function(b, c) {
                        var e = c.item[0];
                        j(e, d, a.utils.arrayIndexOf(c.item.parent().children(), e)), c.item.find("input:focus").change(),
                        t && t.apply(this, arguments);
                    },
                    receive: function(a, b) {
                        "function" == typeof n && n.call(this, a, b), (m = i(b.item[0], g)) && (m.clone && (m = m.clone()),
                        y.dragged && (m = y.dragged.call(this, m, a, b) || m));
                    },
                    update: function(g, k) {
                        var n, p, q, r, s, t = k.item[0], v = k.item.parent()[0], w = i(t, c) || m;
                        if (w || b(t).remove(), m = null, w && this === v || !l && b.contains(this, v)) {
                            if (n = i(t, f), q = i(t, d), p = i(t.parentNode, e), r = a.utils.arrayIndexOf(k.item.parent().children(), t),
                            x.includeDestroyed || (q = o(q, n), r = o(r, p)), (y.beforeMove || y.afterMove) && (s = {
                                item: w,
                                sourceParent: n,
                                sourceParentNode: n && k.sender || t.parentNode,
                                sourceIndex: q,
                                targetParent: p,
                                targetIndex: r,
                                cancelDrop: !1
                            }, y.beforeMove && y.beforeMove.call(this, s, g, k)), n ? b(n === p ? this : k.sender || this).sortable("cancel") : b(t).remove(),
                            s && s.cancelDrop) return;
                            if (y.hasOwnProperty("strategyMove") && !1 !== y.strategyMove) {
                                if (r >= 0) if (n) if (n !== p) n.splice(q, 1), p.splice(r, 0, w), j(t, c, null),
                                k.item.remove(); else {
                                    var z = h(n);
                                    n.valueWillMutate && n.valueWillMutate(), z.splice(q, 1), z.splice(r, 0, w), n.valueHasMutated && n.valueHasMutated();
                                } else p.splice(r, 0, w), j(t, c, null), k.item.remove();
                            } else r >= 0 && (n && (n.splice(q, 1), a.processAllDeferredBindingUpdates && a.processAllDeferredBindingUpdates(),
                            a.options && a.options.deferUpdates && a.tasks.runEarly()), p.splice(r, 0, w)),
                            j(t, c, null);
                            a.processAllDeferredBindingUpdates && a.processAllDeferredBindingUpdates(), y.afterMove && y.afterMove.call(this, s, g, k);
                        }
                        u && u.apply(this, arguments);
                    },
                    connectWith: !!y.connectClass && "." + y.connectClass
                })), void 0 !== y.isEnabled && a.computed({
                    read: function() {
                        v.sortable(h(y.isEnabled) ? "enable" : "disable");
                    },
                    disposeWhenNodeIsRemoved: k
                });
            }, 0);
            return a.utils.domNodeDisposal.addDisposeCallback(k, function() {
                (v.data("ui-sortable") || v.data("sortable")) && v.sortable("destroy"), a.utils.toggleDomNodeCssClass(k, y.connectClass, !1),
                clearTimeout(z);
            }), {
                controlsDescendantBindings: !0
            };
        },
        update: function(b, c, d, f, g) {
            var h = n(c, "foreach");
            j(b, e, h.foreach), a.bindingHandlers.template.update(b, function() {
                return h;
            }, d, f, g);
        },
        connectClass: "ko_container",
        allowDrop: !0,
        afterMove: null,
        beforeMove: null,
        options: {}
    }, a.bindingHandlers.draggable = {
        init: function(c, d, e, f, i) {
            var k = h(d()) || {}, l = k.options || {}, m = a.utils.extend({}, a.bindingHandlers.draggable.options), o = n(d, "data"), p = k.connectClass || a.bindingHandlers.draggable.connectClass, q = void 0 !== k.isEnabled ? k.isEnabled : a.bindingHandlers.draggable.isEnabled;
            return k = "data" in k ? k.data : k, j(c, g, k), a.utils.extend(m, l), m.connectToSortable = !!p && "." + p,
            b(c).draggable(m), void 0 !== q && a.computed({
                read: function() {
                    b(c).draggable(h(q) ? "enable" : "disable");
                },
                disposeWhenNodeIsRemoved: c
            }), a.utils.domNodeDisposal.addDisposeCallback(c, function() {
                b(c).draggable("destroy");
            }), a.bindingHandlers.template.init(c, function() {
                return o;
            }, e, f, i);
        },
        update: function(b, c, d, e, f) {
            var g = n(c, "data");
            return a.bindingHandlers.template.update(b, function() {
                return g;
            }, d, e, f);
        },
        connectClass: a.bindingHandlers.sortable.connectClass,
        options: {
            helper: "clone"
        }
    }, a.bindingHandlers.droppable = {
        init: function(d, e, f, j, k) {
            var l = h(e()) || {}, m = l.options || {}, n = a.utils.extend({}, a.bindingHandlers.droppable.options), o = void 0 !== l.isEnabled ? l.isEnabled : a.bindingHandlers.droppable.isEnabled;
            a.utils.extend(n, m), l = "data" in l ? l.data : e(), n.drop = function(a, b) {
                var d = i(b.draggable[0], g) || i(b.draggable[0], c);
                l(d);
            }, b(d).droppable(n), void 0 !== o && a.computed({
                read: function() {
                    b(d).droppable(h(o) ? "enable" : "disable");
                },
                disposeWhenNodeIsRemoved: d
            }), a.utils.domNodeDisposal.addDisposeCallback(d, function() {
                b(d).droppable("destroy");
            });
        },
        options: {
            accept: "*"
        }
    };
}), "object" == typeof nw) {
    window.usingNode = !0;
    var fs = require("fs"), mkdirp = require("mkdirp"), trash = require("trash"), getDirName = require("path").dirname, gui = require("nw.gui"), updater = require("cside-updater"), win = gui.Window.get();
    win.show(), process.on("uncaughtException", function(err) {
        if (bootbox.alert(err.message), console.log(err), "mac_os" === cside.getPlatform()) var usefulDirIndex = process.execPath.lastIndexOf("Choicescript IDE.app"), installFolderPath = process.execPath.substring(0, usefulDirIndex); else var installFolderPath = process.execPath.slice(0, process.execPath.lastIndexOf("\\")) + "\\";
        fs.writeFile(installFolderPath + "error-log.txt", err.message() + "\n", function(err) {
            if (err) throw err;
        });
    });
} else window.usingNode = !1, window.onbeforeunload = function(evt) {
    if (cside.session.isDirty() && 0 !== cside.getProjects().length) {
        var msg = "Warning: You have unsaved changes.";
        return evt = evt || window.event, evt && (evt.returnValue = msg), msg;
    }
    return null;
};

if (window.cside = new IDEViewModel(), ko.applyBindings(cside, $(".main-wrap")[0]),
cside.init(), "undefined" != typeof module && module.exports && (this["encoding-indexes"] = require("./encoding-indexes.js")["encoding-indexes"]),
function(global) {
    "use strict";
    function inRange(a, min, max) {
        return min <= a && a <= max;
    }
    function includes(array, item) {
        return -1 !== array.indexOf(item);
    }
    function ToDictionary(o) {
        if (void 0 === o) return {};
        if (o === Object(o)) return o;
        throw TypeError("Could not convert argument to dictionary");
    }
    function stringToCodePoints(string) {
        for (var s = String(string), n = s.length, i = 0, u = []; i < n; ) {
            var c = s.charCodeAt(i);
            if (c < 55296 || c > 57343) u.push(c); else if (56320 <= c && c <= 57343) u.push(65533); else if (55296 <= c && c <= 56319) if (i === n - 1) u.push(65533); else {
                var d = s.charCodeAt(i + 1);
                if (56320 <= d && d <= 57343) {
                    var a = 1023 & c, b = 1023 & d;
                    u.push(65536 + (a << 10) + b), i += 1;
                } else u.push(65533);
            }
            i += 1;
        }
        return u;
    }
    function codePointsToString(code_points) {
        for (var s = "", i = 0; i < code_points.length; ++i) {
            var cp = code_points[i];
            cp <= 65535 ? s += String.fromCharCode(cp) : (cp -= 65536, s += String.fromCharCode(55296 + (cp >> 10), 56320 + (1023 & cp)));
        }
        return s;
    }
    function isASCIIByte(a) {
        return 0 <= a && a <= 127;
    }
    function Stream(tokens) {
        this.tokens = [].slice.call(tokens), this.tokens.reverse();
    }
    function decoderError(fatal, opt_code_point) {
        if (fatal) throw TypeError("Decoder error");
        return opt_code_point || 65533;
    }
    function encoderError(code_point) {
        throw TypeError("The code point " + code_point + " could not be encoded.");
    }
    function Decoder() {}
    function Encoder() {}
    function getEncoding(label) {
        return label = String(label).trim().toLowerCase(), Object.prototype.hasOwnProperty.call(label_to_encoding, label) ? label_to_encoding[label] : null;
    }
    function indexCodePointFor(pointer, index) {
        return index ? index[pointer] || null : null;
    }
    function indexPointerFor(code_point, index) {
        var pointer = index.indexOf(code_point);
        return -1 === pointer ? null : pointer;
    }
    function index(name) {
        if (!("encoding-indexes" in global)) throw Error("Indexes missing. Did you forget to include encoding-indexes.js?");
        return global["encoding-indexes"][name];
    }
    function indexGB18030RangesCodePointFor(pointer) {
        if (pointer > 39419 && pointer < 189e3 || pointer > 1237575) return null;
        if (7457 === pointer) return 59335;
        var i, offset = 0, code_point_offset = 0, idx = index("gb18030-ranges");
        for (i = 0; i < idx.length; ++i) {
            var entry = idx[i];
            if (!(entry[0] <= pointer)) break;
            offset = entry[0], code_point_offset = entry[1];
        }
        return code_point_offset + pointer - offset;
    }
    function indexGB18030RangesPointerFor(code_point) {
        if (59335 === code_point) return 7457;
        var i, offset = 0, pointer_offset = 0, idx = index("gb18030-ranges");
        for (i = 0; i < idx.length; ++i) {
            var entry = idx[i];
            if (!(entry[1] <= code_point)) break;
            offset = entry[1], pointer_offset = entry[0];
        }
        return pointer_offset + code_point - offset;
    }
    function indexShiftJISPointerFor(code_point) {
        return shift_jis_index = shift_jis_index || index("jis0208").map(function(code_point, pointer) {
            return inRange(pointer, 8272, 8835) ? null : code_point;
        }), shift_jis_index.indexOf(code_point);
    }
    function indexBig5PointerFor(code_point) {
        big5_index_no_hkscs = big5_index_no_hkscs || index("big5").map(function(code_point, pointer) {
            return pointer < 5024 ? null : code_point;
        });
        var index_ = big5_index_no_hkscs;
        return 9552 === code_point || 9566 === code_point || 9569 === code_point || 9578 === code_point || 21313 === code_point || 21317 === code_point ? index_.lastIndexOf(code_point) : indexPointerFor(code_point, index_);
    }
    function TextDecoder(label, options) {
        if (!(this instanceof TextDecoder)) throw TypeError("Called as a function. Did you forget 'new'?");
        label = void 0 !== label ? String(label) : DEFAULT_ENCODING, options = ToDictionary(options),
        this._encoding = null, this._decoder = null, this._ignoreBOM = !1, this._BOMseen = !1,
        this._error_mode = "replacement", this._do_not_flush = !1;
        var encoding = getEncoding(label);
        if (null === encoding || "replacement" === encoding.name) throw RangeError("Unknown encoding: " + label);
        if (!decoders[encoding.name]) throw Error("Decoder not present. Did you forget to include encoding-indexes.js?");
        var dec = this;
        return dec._encoding = encoding, Boolean(options.fatal) && (dec._error_mode = "fatal"),
        Boolean(options.ignoreBOM) && (dec._ignoreBOM = !0), Object.defineProperty || (this.encoding = dec._encoding.name.toLowerCase(),
        this.fatal = "fatal" === dec._error_mode, this.ignoreBOM = dec._ignoreBOM), dec;
    }
    function TextEncoder(label, options) {
        if (!(this instanceof TextEncoder)) throw TypeError("Called as a function. Did you forget 'new'?");
        options = ToDictionary(options), this._encoding = null, this._encoder = null, this._do_not_flush = !1,
        this._fatal = Boolean(options.fatal) ? "fatal" : "replacement";
        var enc = this;
        if (Boolean(options.NONSTANDARD_allowLegacyEncoding)) {
            label = void 0 !== label ? String(label) : DEFAULT_ENCODING;
            var encoding = getEncoding(label);
            if (null === encoding || "replacement" === encoding.name) throw RangeError("Unknown encoding: " + label);
            if (!encoders[encoding.name]) throw Error("Encoder not present. Did you forget to include encoding-indexes.js?");
            enc._encoding = encoding;
        } else enc._encoding = getEncoding("utf-8"), void 0 !== label && "console" in global && console.warn("TextEncoder constructor called with encoding label, which is ignored.");
        return Object.defineProperty || (this.encoding = enc._encoding.name.toLowerCase()),
        enc;
    }
    function UTF8Decoder(options) {
        var fatal = options.fatal, utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
            if (bite === end_of_stream && 0 !== utf8_bytes_needed) return utf8_bytes_needed = 0,
            decoderError(fatal);
            if (bite === end_of_stream) return finished;
            if (0 === utf8_bytes_needed) {
                if (inRange(bite, 0, 127)) return bite;
                if (inRange(bite, 194, 223)) utf8_bytes_needed = 1, utf8_code_point = 31 & bite; else if (inRange(bite, 224, 239)) 224 === bite && (utf8_lower_boundary = 160),
                237 === bite && (utf8_upper_boundary = 159), utf8_bytes_needed = 2, utf8_code_point = 15 & bite; else {
                    if (!inRange(bite, 240, 244)) return decoderError(fatal);
                    240 === bite && (utf8_lower_boundary = 144), 244 === bite && (utf8_upper_boundary = 143),
                    utf8_bytes_needed = 3, utf8_code_point = 7 & bite;
                }
                return null;
            }
            if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) return utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0,
            utf8_lower_boundary = 128, utf8_upper_boundary = 191, stream.prepend(bite), decoderError(fatal);
            if (utf8_lower_boundary = 128, utf8_upper_boundary = 191, utf8_code_point = utf8_code_point << 6 | 63 & bite,
            (utf8_bytes_seen += 1) !== utf8_bytes_needed) return null;
            var code_point = utf8_code_point;
            return utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0, code_point;
        };
    }
    function UTF8Encoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream) return finished;
            if (isASCIICodePoint(code_point)) return code_point;
            var count, offset;
            inRange(code_point, 128, 2047) ? (count = 1, offset = 192) : inRange(code_point, 2048, 65535) ? (count = 2,
            offset = 224) : inRange(code_point, 65536, 1114111) && (count = 3, offset = 240);
            for (var bytes = [ (code_point >> 6 * count) + offset ]; count > 0; ) {
                var temp = code_point >> 6 * (count - 1);
                bytes.push(128 | 63 & temp), count -= 1;
            }
            return bytes;
        };
    }
    function SingleByteDecoder(index, options) {
        var fatal = options.fatal;
        this.handler = function(stream, bite) {
            if (bite === end_of_stream) return finished;
            if (isASCIIByte(bite)) return bite;
            var code_point = index[bite - 128];
            return null === code_point ? decoderError(fatal) : code_point;
        };
    }
    function SingleByteEncoder(index, options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream) return finished;
            if (isASCIICodePoint(code_point)) return code_point;
            var pointer = indexPointerFor(code_point, index);
            return null === pointer && encoderError(code_point), pointer + 128;
        };
    }
    function GB18030Decoder(options) {
        var fatal = options.fatal, gb18030_first = 0, gb18030_second = 0, gb18030_third = 0;
        this.handler = function(stream, bite) {
            if (bite === end_of_stream && 0 === gb18030_first && 0 === gb18030_second && 0 === gb18030_third) return finished;
            bite !== end_of_stream || 0 === gb18030_first && 0 === gb18030_second && 0 === gb18030_third || (gb18030_first = 0,
            gb18030_second = 0, gb18030_third = 0, decoderError(fatal));
            var code_point;
            if (0 !== gb18030_third) {
                code_point = null, inRange(bite, 48, 57) && (code_point = indexGB18030RangesCodePointFor(10 * (126 * (10 * (gb18030_first - 129) + gb18030_second - 48) + gb18030_third - 129) + bite - 48));
                var buffer = [ gb18030_second, gb18030_third, bite ];
                return gb18030_first = 0, gb18030_second = 0, gb18030_third = 0, null === code_point ? (stream.prepend(buffer),
                decoderError(fatal)) : code_point;
            }
            if (0 !== gb18030_second) return inRange(bite, 129, 254) ? (gb18030_third = bite,
            null) : (stream.prepend([ gb18030_second, bite ]), gb18030_first = 0, gb18030_second = 0,
            decoderError(fatal));
            if (0 !== gb18030_first) {
                if (inRange(bite, 48, 57)) return gb18030_second = bite, null;
                var lead = gb18030_first, pointer = null;
                gb18030_first = 0;
                var offset = bite < 127 ? 64 : 65;
                return (inRange(bite, 64, 126) || inRange(bite, 128, 254)) && (pointer = 190 * (lead - 129) + (bite - offset)),
                code_point = null === pointer ? null : indexCodePointFor(pointer, index("gb18030")),
                null === code_point && isASCIIByte(bite) && stream.prepend(bite), null === code_point ? decoderError(fatal) : code_point;
            }
            return isASCIIByte(bite) ? bite : 128 === bite ? 8364 : inRange(bite, 129, 254) ? (gb18030_first = bite,
            null) : decoderError(fatal);
        };
    }
    function GB18030Encoder(options, gbk_flag) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream) return finished;
            if (isASCIICodePoint(code_point)) return code_point;
            if (58853 === code_point) return encoderError(code_point);
            if (gbk_flag && 8364 === code_point) return 128;
            var pointer = indexPointerFor(code_point, index("gb18030"));
            if (null !== pointer) {
                var lead = floor(pointer / 190) + 129, trail = pointer % 190;
                return [ lead, trail + (trail < 63 ? 64 : 65) ];
            }
            if (gbk_flag) return encoderError(code_point);
            pointer = indexGB18030RangesPointerFor(code_point);
            var byte1 = floor(pointer / 10 / 126 / 10);
            pointer -= 10 * byte1 * 126 * 10;
            var byte2 = floor(pointer / 10 / 126);
            pointer -= 10 * byte2 * 126;
            var byte3 = floor(pointer / 10);
            return [ byte1 + 129, byte2 + 48, byte3 + 129, pointer - 10 * byte3 + 48 ];
        };
    }
    function Big5Decoder(options) {
        var fatal = options.fatal, Big5_lead = 0;
        this.handler = function(stream, bite) {
            if (bite === end_of_stream && 0 !== Big5_lead) return Big5_lead = 0, decoderError(fatal);
            if (bite === end_of_stream && 0 === Big5_lead) return finished;
            if (0 !== Big5_lead) {
                var lead = Big5_lead, pointer = null;
                Big5_lead = 0;
                var offset = bite < 127 ? 64 : 98;
                switch ((inRange(bite, 64, 126) || inRange(bite, 161, 254)) && (pointer = 157 * (lead - 129) + (bite - offset)),
                pointer) {
                  case 1133:
                    return [ 202, 772 ];

                  case 1135:
                    return [ 202, 780 ];

                  case 1164:
                    return [ 234, 772 ];

                  case 1166:
                    return [ 234, 780 ];
                }
                var code_point = null === pointer ? null : indexCodePointFor(pointer, index("big5"));
                return null === code_point && isASCIIByte(bite) && stream.prepend(bite), null === code_point ? decoderError(fatal) : code_point;
            }
            return isASCIIByte(bite) ? bite : inRange(bite, 129, 254) ? (Big5_lead = bite, null) : decoderError(fatal);
        };
    }
    function Big5Encoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream) return finished;
            if (isASCIICodePoint(code_point)) return code_point;
            var pointer = indexBig5PointerFor(code_point);
            if (null === pointer) return encoderError(code_point);
            var lead = floor(pointer / 157) + 129;
            if (lead < 161) return encoderError(code_point);
            var trail = pointer % 157;
            return [ lead, trail + (trail < 63 ? 64 : 98) ];
        };
    }
    function EUCJPDecoder(options) {
        var fatal = options.fatal, eucjp_jis0212_flag = !1, eucjp_lead = 0;
        this.handler = function(stream, bite) {
            if (bite === end_of_stream && 0 !== eucjp_lead) return eucjp_lead = 0, decoderError(fatal);
            if (bite === end_of_stream && 0 === eucjp_lead) return finished;
            if (142 === eucjp_lead && inRange(bite, 161, 223)) return eucjp_lead = 0, 65216 + bite;
            if (143 === eucjp_lead && inRange(bite, 161, 254)) return eucjp_jis0212_flag = !0,
            eucjp_lead = bite, null;
            if (0 !== eucjp_lead) {
                var lead = eucjp_lead;
                eucjp_lead = 0;
                var code_point = null;
                return inRange(lead, 161, 254) && inRange(bite, 161, 254) && (code_point = indexCodePointFor(94 * (lead - 161) + (bite - 161), index(eucjp_jis0212_flag ? "jis0212" : "jis0208"))),
                eucjp_jis0212_flag = !1, inRange(bite, 161, 254) || stream.prepend(bite), null === code_point ? decoderError(fatal) : code_point;
            }
            return isASCIIByte(bite) ? bite : 142 === bite || 143 === bite || inRange(bite, 161, 254) ? (eucjp_lead = bite,
            null) : decoderError(fatal);
        };
    }
    function EUCJPEncoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream) return finished;
            if (isASCIICodePoint(code_point)) return code_point;
            if (165 === code_point) return 92;
            if (8254 === code_point) return 126;
            if (inRange(code_point, 65377, 65439)) return [ 142, code_point - 65377 + 161 ];
            8722 === code_point && (code_point = 65293);
            var pointer = indexPointerFor(code_point, index("jis0208"));
            return null === pointer ? encoderError(code_point) : [ floor(pointer / 94) + 161, pointer % 94 + 161 ];
        };
    }
    function ISO2022JPDecoder(options) {
        var fatal = options.fatal, states = {
            ASCII: 0,
            Roman: 1,
            Katakana: 2,
            LeadByte: 3,
            TrailByte: 4,
            EscapeStart: 5,
            Escape: 6
        }, iso2022jp_decoder_state = states.ASCII, iso2022jp_decoder_output_state = states.ASCII, iso2022jp_lead = 0, iso2022jp_output_flag = !1;
        this.handler = function(stream, bite) {
            switch (iso2022jp_decoder_state) {
              default:
              case states.ASCII:
                return 27 === bite ? (iso2022jp_decoder_state = states.EscapeStart, null) : inRange(bite, 0, 127) && 14 !== bite && 15 !== bite && 27 !== bite ? (iso2022jp_output_flag = !1,
                bite) : bite === end_of_stream ? finished : (iso2022jp_output_flag = !1, decoderError(fatal));

              case states.Roman:
                return 27 === bite ? (iso2022jp_decoder_state = states.EscapeStart, null) : 92 === bite ? (iso2022jp_output_flag = !1,
                165) : 126 === bite ? (iso2022jp_output_flag = !1, 8254) : inRange(bite, 0, 127) && 14 !== bite && 15 !== bite && 27 !== bite && 92 !== bite && 126 !== bite ? (iso2022jp_output_flag = !1,
                bite) : bite === end_of_stream ? finished : (iso2022jp_output_flag = !1, decoderError(fatal));

              case states.Katakana:
                return 27 === bite ? (iso2022jp_decoder_state = states.EscapeStart, null) : inRange(bite, 33, 95) ? (iso2022jp_output_flag = !1,
                65344 + bite) : bite === end_of_stream ? finished : (iso2022jp_output_flag = !1,
                decoderError(fatal));

              case states.LeadByte:
                return 27 === bite ? (iso2022jp_decoder_state = states.EscapeStart, null) : inRange(bite, 33, 126) ? (iso2022jp_output_flag = !1,
                iso2022jp_lead = bite, iso2022jp_decoder_state = states.TrailByte, null) : bite === end_of_stream ? finished : (iso2022jp_output_flag = !1,
                decoderError(fatal));

              case states.TrailByte:
                if (27 === bite) return iso2022jp_decoder_state = states.EscapeStart, decoderError(fatal);
                if (inRange(bite, 33, 126)) {
                    iso2022jp_decoder_state = states.LeadByte;
                    var pointer = 94 * (iso2022jp_lead - 33) + bite - 33, code_point = indexCodePointFor(pointer, index("jis0208"));
                    return null === code_point ? decoderError(fatal) : code_point;
                }
                return bite === end_of_stream ? (iso2022jp_decoder_state = states.LeadByte, stream.prepend(bite),
                decoderError(fatal)) : (iso2022jp_decoder_state = states.LeadByte, decoderError(fatal));

              case states.EscapeStart:
                return 36 === bite || 40 === bite ? (iso2022jp_lead = bite, iso2022jp_decoder_state = states.Escape,
                null) : (stream.prepend(bite), iso2022jp_output_flag = !1, iso2022jp_decoder_state = iso2022jp_decoder_output_state,
                decoderError(fatal));

              case states.Escape:
                var lead = iso2022jp_lead;
                iso2022jp_lead = 0;
                var state = null;
                if (40 === lead && 66 === bite && (state = states.ASCII), 40 === lead && 74 === bite && (state = states.Roman),
                40 === lead && 73 === bite && (state = states.Katakana), 36 !== lead || 64 !== bite && 66 !== bite || (state = states.LeadByte),
                null !== state) {
                    iso2022jp_decoder_state = iso2022jp_decoder_state = state;
                    var output_flag = iso2022jp_output_flag;
                    return iso2022jp_output_flag = !0, output_flag ? decoderError(fatal) : null;
                }
                return stream.prepend([ lead, bite ]), iso2022jp_output_flag = !1, iso2022jp_decoder_state = iso2022jp_decoder_output_state,
                decoderError(fatal);
            }
        };
    }
    function ISO2022JPEncoder(options) {
        var states = (options.fatal, {
            ASCII: 0,
            Roman: 1,
            jis0208: 2
        }), iso2022jp_state = states.ASCII;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) return stream.prepend(code_point),
            iso2022jp_state = states.ASCII, [ 27, 40, 66 ];
            if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished;
            if (!(iso2022jp_state !== states.ASCII && iso2022jp_state !== states.Roman || 14 !== code_point && 15 !== code_point && 27 !== code_point)) return encoderError(65533);
            if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point;
            if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && 92 !== code_point && 126 !== code_point || 165 == code_point || 8254 == code_point)) {
                if (isASCIICodePoint(code_point)) return code_point;
                if (165 === code_point) return 92;
                if (8254 === code_point) return 126;
            }
            if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) return stream.prepend(code_point),
            iso2022jp_state = states.ASCII, [ 27, 40, 66 ];
            if ((165 === code_point || 8254 === code_point) && iso2022jp_state !== states.Roman) return stream.prepend(code_point),
            iso2022jp_state = states.Roman, [ 27, 40, 74 ];
            8722 === code_point && (code_point = 65293);
            var pointer = indexPointerFor(code_point, index("jis0208"));
            return null === pointer ? encoderError(code_point) : iso2022jp_state !== states.jis0208 ? (stream.prepend(code_point),
            iso2022jp_state = states.jis0208, [ 27, 36, 66 ]) : [ floor(pointer / 94) + 33, pointer % 94 + 33 ];
        };
    }
    function ShiftJISDecoder(options) {
        var fatal = options.fatal, Shift_JIS_lead = 0;
        this.handler = function(stream, bite) {
            if (bite === end_of_stream && 0 !== Shift_JIS_lead) return Shift_JIS_lead = 0, decoderError(fatal);
            if (bite === end_of_stream && 0 === Shift_JIS_lead) return finished;
            if (0 !== Shift_JIS_lead) {
                var lead = Shift_JIS_lead, pointer = null;
                Shift_JIS_lead = 0;
                var offset = bite < 127 ? 64 : 65, lead_offset = lead < 160 ? 129 : 193;
                if ((inRange(bite, 64, 126) || inRange(bite, 128, 252)) && (pointer = 188 * (lead - lead_offset) + bite - offset),
                inRange(pointer, 8836, 10715)) return 48508 + pointer;
                var code_point = null === pointer ? null : indexCodePointFor(pointer, index("jis0208"));
                return null === code_point && isASCIIByte(bite) && stream.prepend(bite), null === code_point ? decoderError(fatal) : code_point;
            }
            return isASCIIByte(bite) || 128 === bite ? bite : inRange(bite, 161, 223) ? 65216 + bite : inRange(bite, 129, 159) || inRange(bite, 224, 252) ? (Shift_JIS_lead = bite,
            null) : decoderError(fatal);
        };
    }
    function ShiftJISEncoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream) return finished;
            if (isASCIICodePoint(code_point) || 128 === code_point) return code_point;
            if (165 === code_point) return 92;
            if (8254 === code_point) return 126;
            if (inRange(code_point, 65377, 65439)) return code_point - 65377 + 161;
            8722 === code_point && (code_point = 65293);
            var pointer = indexShiftJISPointerFor(code_point);
            if (null === pointer) return encoderError(code_point);
            var lead = floor(pointer / 188), lead_offset = lead < 31 ? 129 : 193, trail = pointer % 188;
            return [ lead + lead_offset, trail + (trail < 63 ? 64 : 65) ];
        };
    }
    function EUCKRDecoder(options) {
        var fatal = options.fatal, euckr_lead = 0;
        this.handler = function(stream, bite) {
            if (bite === end_of_stream && 0 !== euckr_lead) return euckr_lead = 0, decoderError(fatal);
            if (bite === end_of_stream && 0 === euckr_lead) return finished;
            if (0 !== euckr_lead) {
                var lead = euckr_lead, pointer = null;
                euckr_lead = 0, inRange(bite, 65, 254) && (pointer = 190 * (lead - 129) + (bite - 65));
                var code_point = null === pointer ? null : indexCodePointFor(pointer, index("euc-kr"));
                return null === pointer && isASCIIByte(bite) && stream.prepend(bite), null === code_point ? decoderError(fatal) : code_point;
            }
            return isASCIIByte(bite) ? bite : inRange(bite, 129, 254) ? (euckr_lead = bite,
            null) : decoderError(fatal);
        };
    }
    function EUCKREncoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream) return finished;
            if (isASCIICodePoint(code_point)) return code_point;
            var pointer = indexPointerFor(code_point, index("euc-kr"));
            return null === pointer ? encoderError(code_point) : [ floor(pointer / 190) + 129, pointer % 190 + 65 ];
        };
    }
    function convertCodeUnitToBytes(code_unit, utf16be) {
        var byte1 = code_unit >> 8, byte2 = 255 & code_unit;
        return utf16be ? [ byte1, byte2 ] : [ byte2, byte1 ];
    }
    function UTF16Decoder(utf16_be, options) {
        var fatal = options.fatal, utf16_lead_byte = null, utf16_lead_surrogate = null;
        this.handler = function(stream, bite) {
            if (bite === end_of_stream && (null !== utf16_lead_byte || null !== utf16_lead_surrogate)) return decoderError(fatal);
            if (bite === end_of_stream && null === utf16_lead_byte && null === utf16_lead_surrogate) return finished;
            if (null === utf16_lead_byte) return utf16_lead_byte = bite, null;
            var code_unit;
            if (code_unit = utf16_be ? (utf16_lead_byte << 8) + bite : (bite << 8) + utf16_lead_byte,
            utf16_lead_byte = null, null !== utf16_lead_surrogate) {
                var lead_surrogate = utf16_lead_surrogate;
                return utf16_lead_surrogate = null, inRange(code_unit, 56320, 57343) ? 65536 + 1024 * (lead_surrogate - 55296) + (code_unit - 56320) : (stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be)),
                decoderError(fatal));
            }
            return inRange(code_unit, 55296, 56319) ? (utf16_lead_surrogate = code_unit, null) : inRange(code_unit, 56320, 57343) ? decoderError(fatal) : code_unit;
        };
    }
    function UTF16Encoder(utf16_be, options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            if (code_point === end_of_stream) return finished;
            if (inRange(code_point, 0, 65535)) return convertCodeUnitToBytes(code_point, utf16_be);
            var lead = convertCodeUnitToBytes(55296 + (code_point - 65536 >> 10), utf16_be), trail = convertCodeUnitToBytes(56320 + (code_point - 65536 & 1023), utf16_be);
            return lead.concat(trail);
        };
    }
    function XUserDefinedDecoder(options) {
        options.fatal;
        this.handler = function(stream, bite) {
            return bite === end_of_stream ? finished : isASCIIByte(bite) ? bite : 63360 + bite - 128;
        };
    }
    function XUserDefinedEncoder(options) {
        options.fatal;
        this.handler = function(stream, code_point) {
            return code_point === end_of_stream ? finished : isASCIICodePoint(code_point) ? code_point : inRange(code_point, 63360, 63487) ? code_point - 63360 + 128 : encoderError(code_point);
        };
    }
    var floor = Math.floor, isASCIICodePoint = isASCIIByte, end_of_stream = -1;
    Stream.prototype = {
        endOfStream: function() {
            return !this.tokens.length;
        },
        read: function() {
            return this.tokens.length ? this.tokens.pop() : end_of_stream;
        },
        prepend: function(token) {
            if (Array.isArray(token)) for (var tokens = token; tokens.length; ) this.tokens.push(tokens.pop()); else this.tokens.push(token);
        },
        push: function(token) {
            if (Array.isArray(token)) for (var tokens = token; tokens.length; ) this.tokens.unshift(tokens.shift()); else this.tokens.unshift(token);
        }
    };
    var finished = -1;
    Decoder.prototype = {
        handler: function(stream, bite) {}
    }, Encoder.prototype = {
        handler: function(stream, code_point) {}
    };
    var encodings = [ {
        encodings: [ {
            labels: [ "unicode-1-1-utf-8", "utf-8", "utf8" ],
            name: "UTF-8"
        } ],
        heading: "The Encoding"
    }, {
        encodings: [ {
            labels: [ "866", "cp866", "csibm866", "ibm866" ],
            name: "IBM866"
        }, {
            labels: [ "csisolatin2", "iso-8859-2", "iso-ir-101", "iso8859-2", "iso88592", "iso_8859-2", "iso_8859-2:1987", "l2", "latin2" ],
            name: "ISO-8859-2"
        }, {
            labels: [ "csisolatin3", "iso-8859-3", "iso-ir-109", "iso8859-3", "iso88593", "iso_8859-3", "iso_8859-3:1988", "l3", "latin3" ],
            name: "ISO-8859-3"
        }, {
            labels: [ "csisolatin4", "iso-8859-4", "iso-ir-110", "iso8859-4", "iso88594", "iso_8859-4", "iso_8859-4:1988", "l4", "latin4" ],
            name: "ISO-8859-4"
        }, {
            labels: [ "csisolatincyrillic", "cyrillic", "iso-8859-5", "iso-ir-144", "iso8859-5", "iso88595", "iso_8859-5", "iso_8859-5:1988" ],
            name: "ISO-8859-5"
        }, {
            labels: [ "arabic", "asmo-708", "csiso88596e", "csiso88596i", "csisolatinarabic", "ecma-114", "iso-8859-6", "iso-8859-6-e", "iso-8859-6-i", "iso-ir-127", "iso8859-6", "iso88596", "iso_8859-6", "iso_8859-6:1987" ],
            name: "ISO-8859-6"
        }, {
            labels: [ "csisolatingreek", "ecma-118", "elot_928", "greek", "greek8", "iso-8859-7", "iso-ir-126", "iso8859-7", "iso88597", "iso_8859-7", "iso_8859-7:1987", "sun_eu_greek" ],
            name: "ISO-8859-7"
        }, {
            labels: [ "csiso88598e", "csisolatinhebrew", "hebrew", "iso-8859-8", "iso-8859-8-e", "iso-ir-138", "iso8859-8", "iso88598", "iso_8859-8", "iso_8859-8:1988", "visual" ],
            name: "ISO-8859-8"
        }, {
            labels: [ "csiso88598i", "iso-8859-8-i", "logical" ],
            name: "ISO-8859-8-I"
        }, {
            labels: [ "csisolatin6", "iso-8859-10", "iso-ir-157", "iso8859-10", "iso885910", "l6", "latin6" ],
            name: "ISO-8859-10"
        }, {
            labels: [ "iso-8859-13", "iso8859-13", "iso885913" ],
            name: "ISO-8859-13"
        }, {
            labels: [ "iso-8859-14", "iso8859-14", "iso885914" ],
            name: "ISO-8859-14"
        }, {
            labels: [ "csisolatin9", "iso-8859-15", "iso8859-15", "iso885915", "iso_8859-15", "l9" ],
            name: "ISO-8859-15"
        }, {
            labels: [ "iso-8859-16" ],
            name: "ISO-8859-16"
        }, {
            labels: [ "cskoi8r", "koi", "koi8", "koi8-r", "koi8_r" ],
            name: "KOI8-R"
        }, {
            labels: [ "koi8-ru", "koi8-u" ],
            name: "KOI8-U"
        }, {
            labels: [ "csmacintosh", "mac", "macintosh", "x-mac-roman" ],
            name: "macintosh"
        }, {
            labels: [ "dos-874", "iso-8859-11", "iso8859-11", "iso885911", "tis-620", "windows-874" ],
            name: "windows-874"
        }, {
            labels: [ "cp1250", "windows-1250", "x-cp1250" ],
            name: "windows-1250"
        }, {
            labels: [ "cp1251", "windows-1251", "x-cp1251" ],
            name: "windows-1251"
        }, {
            labels: [ "ansi_x3.4-1968", "ascii", "cp1252", "cp819", "csisolatin1", "ibm819", "iso-8859-1", "iso-ir-100", "iso8859-1", "iso88591", "iso_8859-1", "iso_8859-1:1987", "l1", "latin1", "us-ascii", "windows-1252", "x-cp1252" ],
            name: "windows-1252"
        }, {
            labels: [ "cp1253", "windows-1253", "x-cp1253" ],
            name: "windows-1253"
        }, {
            labels: [ "cp1254", "csisolatin5", "iso-8859-9", "iso-ir-148", "iso8859-9", "iso88599", "iso_8859-9", "iso_8859-9:1989", "l5", "latin5", "windows-1254", "x-cp1254" ],
            name: "windows-1254"
        }, {
            labels: [ "cp1255", "windows-1255", "x-cp1255" ],
            name: "windows-1255"
        }, {
            labels: [ "cp1256", "windows-1256", "x-cp1256" ],
            name: "windows-1256"
        }, {
            labels: [ "cp1257", "windows-1257", "x-cp1257" ],
            name: "windows-1257"
        }, {
            labels: [ "cp1258", "windows-1258", "x-cp1258" ],
            name: "windows-1258"
        }, {
            labels: [ "x-mac-cyrillic", "x-mac-ukrainian" ],
            name: "x-mac-cyrillic"
        } ],
        heading: "Legacy single-byte encodings"
    }, {
        encodings: [ {
            labels: [ "chinese", "csgb2312", "csiso58gb231280", "gb2312", "gb_2312", "gb_2312-80", "gbk", "iso-ir-58", "x-gbk" ],
            name: "GBK"
        }, {
            labels: [ "gb18030" ],
            name: "gb18030"
        } ],
        heading: "Legacy multi-byte Chinese (simplified) encodings"
    }, {
        encodings: [ {
            labels: [ "big5", "big5-hkscs", "cn-big5", "csbig5", "x-x-big5" ],
            name: "Big5"
        } ],
        heading: "Legacy multi-byte Chinese (traditional) encodings"
    }, {
        encodings: [ {
            labels: [ "cseucpkdfmtjapanese", "euc-jp", "x-euc-jp" ],
            name: "EUC-JP"
        }, {
            labels: [ "csiso2022jp", "iso-2022-jp" ],
            name: "ISO-2022-JP"
        }, {
            labels: [ "csshiftjis", "ms932", "ms_kanji", "shift-jis", "shift_jis", "sjis", "windows-31j", "x-sjis" ],
            name: "Shift_JIS"
        } ],
        heading: "Legacy multi-byte Japanese encodings"
    }, {
        encodings: [ {
            labels: [ "cseuckr", "csksc56011987", "euc-kr", "iso-ir-149", "korean", "ks_c_5601-1987", "ks_c_5601-1989", "ksc5601", "ksc_5601", "windows-949" ],
            name: "EUC-KR"
        } ],
        heading: "Legacy multi-byte Korean encodings"
    }, {
        encodings: [ {
            labels: [ "csiso2022kr", "hz-gb-2312", "iso-2022-cn", "iso-2022-cn-ext", "iso-2022-kr" ],
            name: "replacement"
        }, {
            labels: [ "utf-16be" ],
            name: "UTF-16BE"
        }, {
            labels: [ "utf-16", "utf-16le" ],
            name: "UTF-16LE"
        }, {
            labels: [ "x-user-defined" ],
            name: "x-user-defined"
        } ],
        heading: "Legacy miscellaneous encodings"
    } ], label_to_encoding = {};
    encodings.forEach(function(category) {
        category.encodings.forEach(function(encoding) {
            encoding.labels.forEach(function(label) {
                label_to_encoding[label] = encoding;
            });
        });
    });
    var shift_jis_index, big5_index_no_hkscs, encoders = {}, decoders = {}, DEFAULT_ENCODING = "utf-8";
    Object.defineProperty && (Object.defineProperty(TextDecoder.prototype, "encoding", {
        get: function() {
            return this._encoding.name.toLowerCase();
        }
    }), Object.defineProperty(TextDecoder.prototype, "fatal", {
        get: function() {
            return "fatal" === this._error_mode;
        }
    }), Object.defineProperty(TextDecoder.prototype, "ignoreBOM", {
        get: function() {
            return this._ignoreBOM;
        }
    })), TextDecoder.prototype.decode = function(input, options) {
        function serializeStream(stream) {
            return !includes([ "UTF-8", "UTF-16LE", "UTF-16BE" ], this._encoding.name) || this._ignoreBOM || this._BOMseen || (stream.length > 0 && 65279 === stream[0] ? (this._BOMseen = !0,
            stream.shift()) : stream.length > 0 && (this._BOMseen = !0)), codePointsToString(stream);
        }
        var bytes;
        bytes = "object" == typeof input && input instanceof ArrayBuffer ? new Uint8Array(input) : "object" == typeof input && "buffer" in input && input.buffer instanceof ArrayBuffer ? new Uint8Array(input.buffer, input.byteOffset, input.byteLength) : new Uint8Array(0),
        options = ToDictionary(options), this._do_not_flush || (this._decoder = decoders[this._encoding.name]({
            fatal: "fatal" === this._error_mode
        }), this._BOMseen = !1), this._do_not_flush = Boolean(options.stream);
        for (var result, input_stream = new Stream(bytes), output = []; ;) {
            var token = input_stream.read();
            if (token === end_of_stream) break;
            if ((result = this._decoder.handler(input_stream, token)) === finished) break;
            null !== result && (Array.isArray(result) ? output.push.apply(output, result) : output.push(result));
        }
        if (!this._do_not_flush) {
            do {
                if ((result = this._decoder.handler(input_stream, input_stream.read())) === finished) break;
                null !== result && (Array.isArray(result) ? output.push.apply(output, result) : output.push(result));
            } while (!input_stream.endOfStream());
            this._decoder = null;
        }
        return serializeStream.call(this, output);
    }, Object.defineProperty && Object.defineProperty(TextEncoder.prototype, "encoding", {
        get: function() {
            return this._encoding.name.toLowerCase();
        }
    }), TextEncoder.prototype.encode = function(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "", options = ToDictionary(options),
        this._do_not_flush || (this._encoder = encoders[this._encoding.name]({
            fatal: "fatal" === this._fatal
        })), this._do_not_flush = Boolean(options.stream);
        for (var result, input = new Stream(stringToCodePoints(opt_string)), output = []; ;) {
            var token = input.read();
            if (token === end_of_stream) break;
            if ((result = this._encoder.handler(input, token)) === finished) break;
            Array.isArray(result) ? output.push.apply(output, result) : output.push(result);
        }
        if (!this._do_not_flush) {
            for (;;) {
                if ((result = this._encoder.handler(input, input.read())) === finished) break;
                Array.isArray(result) ? output.push.apply(output, result) : output.push(result);
            }
            this._encoder = null;
        }
        return new Uint8Array(output);
    }, encoders["UTF-8"] = function(options) {
        return new UTF8Encoder(options);
    }, decoders["UTF-8"] = function(options) {
        return new UTF8Decoder(options);
    }, function() {
        "encoding-indexes" in global && encodings.forEach(function(category) {
            "Legacy single-byte encodings" === category.heading && category.encodings.forEach(function(encoding) {
                var name = encoding.name, idx = index(name.toLowerCase());
                decoders[name] = function(options) {
                    return new SingleByteDecoder(idx, options);
                }, encoders[name] = function(options) {
                    return new SingleByteEncoder(idx, options);
                };
            });
        });
    }(), decoders.GBK = function(options) {
        return new GB18030Decoder(options);
    }, encoders.GBK = function(options) {
        return new GB18030Encoder(options, !0);
    }, encoders.gb18030 = function(options) {
        return new GB18030Encoder(options);
    }, decoders.gb18030 = function(options) {
        return new GB18030Decoder(options);
    }, encoders.Big5 = function(options) {
        return new Big5Encoder(options);
    }, decoders.Big5 = function(options) {
        return new Big5Decoder(options);
    }, encoders["EUC-JP"] = function(options) {
        return new EUCJPEncoder(options);
    }, decoders["EUC-JP"] = function(options) {
        return new EUCJPDecoder(options);
    }, encoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPEncoder(options);
    }, decoders["ISO-2022-JP"] = function(options) {
        return new ISO2022JPDecoder(options);
    }, encoders.Shift_JIS = function(options) {
        return new ShiftJISEncoder(options);
    }, decoders.Shift_JIS = function(options) {
        return new ShiftJISDecoder(options);
    }, encoders["EUC-KR"] = function(options) {
        return new EUCKREncoder(options);
    }, decoders["EUC-KR"] = function(options) {
        return new EUCKRDecoder(options);
    }, encoders["UTF-16BE"] = function(options) {
        return new UTF16Encoder(!0, options);
    }, decoders["UTF-16BE"] = function(options) {
        return new UTF16Decoder(!0, options);
    }, encoders["UTF-16LE"] = function(options) {
        return new UTF16Encoder(!1, options);
    }, decoders["UTF-16LE"] = function(options) {
        return new UTF16Decoder(!1, options);
    }, encoders["x-user-defined"] = function(options) {
        return new XUserDefinedEncoder(options);
    }, decoders["x-user-defined"] = function(options) {
        return new XUserDefinedDecoder(options);
    }, global.TextEncoder || (global.TextEncoder = TextEncoder), global.TextDecoder || (global.TextDecoder = TextDecoder),
    "undefined" != typeof module && module.exports && (module.exports = {
        TextEncoder: global.TextEncoder,
        TextDecoder: global.TextDecoder,
        EncodingIndexes: global["encoding-indexes"]
    });
}(this), function(a, b) {
    "use strict";
    "function" == typeof define && define.amd ? define([ "jquery" ], b) : "object" == typeof exports ? module.exports = b(require("jquery")) : a.bootbox = b(a.jQuery);
}(this, function a(b, c) {
    "use strict";
    function d(a) {
        var b = q[o.locale];
        return b ? b[a] : q.en[a];
    }
    function e(a, c, d) {
        a.stopPropagation(), a.preventDefault(), b.isFunction(d) && !1 === d(a) || c.modal("hide");
    }
    function f(a) {
        var b, c = 0;
        for (b in a) c++;
        return c;
    }
    function g(a, c) {
        var d = 0;
        b.each(a, function(a, b) {
            c(a, b, d++);
        });
    }
    function h(a) {
        var c, d;
        if ("object" != typeof a) throw new Error("Please supply an object of options");
        if (!a.message) throw new Error("Please specify a message");
        return a = b.extend({}, o, a), a.buttons || (a.buttons = {}), a.backdrop = !!a.backdrop && "static",
        c = a.buttons, d = f(c), g(c, function(a, e, f) {
            if (b.isFunction(e) && (e = c[a] = {
                callback: e
            }), "object" !== b.type(e)) throw new Error("button with key " + a + " must be an object");
            e.label || (e.label = a), e.className || (e.className = 2 >= d && f === d - 1 ? "btn-primary" : "btn-default");
        }), a;
    }
    function i(a, b) {
        var c = a.length, d = {};
        if (1 > c || c > 2) throw new Error("Invalid argument length");
        return 2 === c || "string" == typeof a[0] ? (d[b[0]] = a[0], d[b[1]] = a[1]) : d = a[0],
        d;
    }
    function j(a, c, d) {
        return b.extend(!0, {}, a, i(c, d));
    }
    function k(a, b, c, d) {
        return m(j({
            className: "bootbox-" + a,
            buttons: l.apply(null, b)
        }, d, c), b);
    }
    function l() {
        for (var a = {}, b = 0, c = arguments.length; c > b; b++) {
            var e = arguments[b], f = e.toLowerCase(), g = e.toUpperCase();
            a[f] = {
                label: d(g)
            };
        }
        return a;
    }
    function m(a, b) {
        var d = {};
        return g(b, function(a, b) {
            d[b] = !0;
        }), g(a.buttons, function(a) {
            if (d[a] === c) throw new Error("button key " + a + " is not allowed (options are " + b.join("\n") + ")");
        }), a;
    }
    var n = {
        dialog: "<div class='bootbox modal' tabindex='-1' role='dialog'><div class='modal-dialog'><div class='modal-content'><div class='modal-body'><div class='bootbox-body'></div></div></div></div></div>",
        header: "<div class='modal-header'><h4 class='modal-title'></h4></div>",
        footer: "<div class='modal-footer'></div>",
        closeButton: "<button type='button' class='bootbox-close-button close' data-dismiss='modal' aria-hidden='true'>&times;</button>",
        form: "<form class='bootbox-form'></form>",
        inputs: {
            text: "<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text />",
            textarea: "<textarea class='bootbox-input bootbox-input-textarea form-control'></textarea>",
            email: "<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' />",
            select: "<select class='bootbox-input bootbox-input-select form-control'></select>",
            checkbox: "<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' /></label></div>",
            date: "<input class='bootbox-input bootbox-input-date form-control' autocomplete=off type='date' />",
            time: "<input class='bootbox-input bootbox-input-time form-control' autocomplete=off type='time' />",
            number: "<input class='bootbox-input bootbox-input-number form-control' autocomplete=off type='number' />",
            password: "<input class='bootbox-input bootbox-input-password form-control' autocomplete='off' type='password' />"
        }
    }, o = {
        locale: "en",
        backdrop: !0,
        animate: !0,
        className: null,
        closeButton: !0,
        show: !0,
        container: "body"
    }, p = {};
    p.alert = function() {
        var a;
        if (a = k("alert", [ "ok" ], [ "message", "callback" ], arguments), a.callback && !b.isFunction(a.callback)) throw new Error("alert requires callback property to be a function when provided");
        return a.buttons.ok.callback = a.onEscape = function() {
            return !b.isFunction(a.callback) || a.callback();
        }, p.dialog(a);
    }, p.confirm = function() {
        var a;
        if (a = k("confirm", [ "cancel", "confirm" ], [ "message", "callback" ], arguments),
        a.buttons.cancel.callback = a.onEscape = function() {
            return a.callback(!1);
        }, a.buttons.confirm.callback = function() {
            return a.callback(!0);
        }, !b.isFunction(a.callback)) throw new Error("confirm requires a callback");
        return p.dialog(a);
    }, p.prompt = function() {
        var a, d, e, f, h, i, k;
        f = b(n.form), d = {
            className: "bootbox-prompt",
            buttons: l("cancel", "confirm"),
            value: "",
            inputType: "text"
        }, a = m(j(d, arguments, [ "title", "callback" ]), [ "cancel", "confirm" ]), i = a.show === c || a.show;
        var o = [ "date", "time", "number" ], q = document.createElement("input");
        if (q.setAttribute("type", a.inputType), o[a.inputType] && (a.inputType = q.type),
        a.message = f, a.buttons.cancel.callback = a.onEscape = function() {
            return a.callback(null);
        }, a.buttons.confirm.callback = function() {
            var c;
            switch (a.inputType) {
              case "text":
              case "textarea":
              case "email":
              case "select":
              case "date":
              case "time":
              case "number":
              case "password":
                c = h.val();
                break;

              case "checkbox":
                var d = h.find("input:checked");
                c = [], g(d, function(a, d) {
                    c.push(b(d).val());
                });
            }
            return a.callback(c);
        }, a.show = !1, !a.title) throw new Error("prompt requires a title");
        if (!b.isFunction(a.callback)) throw new Error("prompt requires a callback");
        if (!n.inputs[a.inputType]) throw new Error("invalid prompt type");
        switch (h = b(n.inputs[a.inputType]), a.inputType) {
          case "text":
          case "textarea":
          case "email":
          case "date":
          case "time":
          case "number":
          case "password":
            h.val(a.value);
            break;

          case "select":
            var r = {};
            if (k = a.inputOptions || [], !k.length) throw new Error("prompt with select requires options");
            g(k, function(a, d) {
                var e = h;
                if (d.value === c || d.text === c) throw new Error("given options in wrong format");
                d.group && (r[d.group] || (r[d.group] = b("<optgroup/>").attr("label", d.group)),
                e = r[d.group]), e.append("<option value='" + d.value + "'>" + d.text + "</option>");
            }), g(r, function(a, b) {
                h.append(b);
            }), h.val(a.value);
            break;

          case "checkbox":
            var s = b.isArray(a.value) ? a.value : [ a.value ];
            if (k = a.inputOptions || [], !k.length) throw new Error("prompt with checkbox requires options");
            if (!k[0].value || !k[0].text) throw new Error("given options in wrong format");
            h = b("<div/>"), g(k, function(c, d) {
                var e = b(n.inputs[a.inputType]);
                e.find("input").attr("value", d.value), e.find("label").append(d.text), g(s, function(a, b) {
                    b === d.value && e.find("input").prop("checked", !0);
                }), h.append(e);
            });
        }
        return a.placeholder && h.attr("placeholder", a.placeholder), a.pattern && h.attr("pattern", a.pattern),
        f.append(h), f.on("submit", function(a) {
            a.preventDefault(), e.find(".btn-primary").click();
        }), e = p.dialog(a), e.off("shown.bs.modal"), e.on("shown.bs.modal", function() {
            h.focus();
        }), !0 === i && e.modal("show"), e;
    }, p.dialog = function(a) {
        a = h(a);
        var c = b(n.dialog), d = c.find(".modal-body"), f = a.buttons, i = "", j = {
            onEscape: a.onEscape
        };
        if (g(f, function(a, b) {
            i += "<button data-bb-handler='" + a + "' type='button' class='btn " + b.className + "'>" + b.label + "</button>",
            j[a] = b.callback;
        }), d.find(".bootbox-body").html(a.message), !0 === a.animate && c.addClass("fade"),
        a.className && c.addClass(a.className), a.title && d.before(n.header), a.closeButton) {
            var k = b(n.closeButton);
            a.title ? c.find(".modal-header").prepend(k) : k.css("margin-top", "-10px").prependTo(d);
        }
        return a.title && c.find(".modal-title").html(a.title), i.length && (d.after(n.footer),
        c.find(".modal-footer").html(i)), c.on("hidden.bs.modal", function(a) {
            a.target === this && c.remove();
        }), c.on("shown.bs.modal", function() {
            c.find(".btn-primary:first").focus();
        }), c.on("escape.close.bb", function(a) {
            j.onEscape && e(a, c, j.onEscape);
        }), c.on("click", ".modal-footer button", function(a) {
            var d = b(this).data("bb-handler");
            e(a, c, j[d]);
        }), c.on("click", ".bootbox-close-button", function(a) {
            e(a, c, j.onEscape);
        }), c.on("keyup", function(a) {
            27 === a.which && c.trigger("escape.close.bb");
        }), b(a.container).append(c), c.modal({
            backdrop: a.backdrop,
            keyboard: !1,
            show: !1
        }), a.show && c.modal("show"), c;
    }, p.setDefaults = function() {
        var a = {};
        2 === arguments.length ? a[arguments[0]] = arguments[1] : a = arguments[0], b.extend(o, a);
    }, p.hideAll = function() {
        b(".bootbox").modal("hide");
    };
    var q = {
        br: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Sim"
        },
        da: {
            OK: "OK",
            CANCEL: "Annuller",
            CONFIRM: "Accepter"
        },
        de: {
            OK: "OK",
            CANCEL: "Abbrechen",
            CONFIRM: "Akzeptieren"
        },
        en: {
            OK: "OK",
            CANCEL: "Cancel",
            CONFIRM: "OK"
        },
        es: {
            OK: "OK",
            CANCEL: "Cancelar",
            CONFIRM: "Aceptar"
        },
        fi: {
            OK: "OK",
            CANCEL: "Peruuta",
            CONFIRM: "OK"
        },
        fr: {
            OK: "OK",
            CANCEL: "Annuler",
            CONFIRM: "D'accord"
        },
        he: {
            OK: "אישור",
            CANCEL: "ביטול",
            CONFIRM: "אישור"
        },
        it: {
            OK: "OK",
            CANCEL: "Annulla",
            CONFIRM: "Conferma"
        },
        lt: {
            OK: "Gerai",
            CANCEL: "Atšaukti",
            CONFIRM: "Patvirtinti"
        },
        lv: {
            OK: "Labi",
            CANCEL: "Atcelt",
            CONFIRM: "Apstiprināt"
        },
        nl: {
            OK: "OK",
            CANCEL: "Annuleren",
            CONFIRM: "Accepteren"
        },
        no: {
            OK: "OK",
            CANCEL: "Avbryt",
            CONFIRM: "OK"
        },
        pl: {
            OK: "OK",
            CANCEL: "Anuluj",
            CONFIRM: "Potwierdź"
        },
        ru: {
            OK: "OK",
            CANCEL: "Отмена",
            CONFIRM: "Применить"
        },
        sv: {
            OK: "OK",
            CANCEL: "Avbryt",
            CONFIRM: "OK"
        },
        tr: {
            OK: "Tamam",
            CANCEL: "İptal",
            CONFIRM: "Onayla"
        },
        zh_CN: {
            OK: "OK",
            CANCEL: "取消",
            CONFIRM: "确认"
        },
        zh_TW: {
            OK: "OK",
            CANCEL: "取消",
            CONFIRM: "確認"
        }
    };
    return p.init = function(c) {
        return a(c || b);
    }, p;
}), "undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");

+function(a) {
    "use strict";
    function b() {
        var a = document.createElement("bootstrap"), b = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var c in b) if (void 0 !== a.style[c]) return {
            end: b[c]
        };
        return !1;
    }
    a.fn.emulateTransitionEnd = function(b) {
        var c = !1, d = this;
        a(this).one(a.support.transition.end, function() {
            c = !0;
        });
        var e = function() {
            c || a(d).trigger(a.support.transition.end);
        };
        return setTimeout(e, b), this;
    }, a(function() {
        a.support.transition = b();
    });
}(jQuery), function(a) {
    "use strict";
    var b = '[data-dismiss="alert"]', c = function(c) {
        a(c).on("click", b, this.close);
    };
    c.prototype.close = function(b) {
        function c() {
            f.trigger("closed.bs.alert").remove();
        }
        var d = a(this), e = d.attr("data-target");
        e || (e = d.attr("href"), e = e && e.replace(/.*(?=#[^\s]*$)/, ""));
        var f = a(e);
        b && b.preventDefault(), f.length || (f = d.hasClass("alert") ? d : d.parent()),
        f.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (f.removeClass("in"),
        a.support.transition && f.hasClass("fade") ? f.one(a.support.transition.end, c).emulateTransitionEnd(150) : c());
    };
    var d = a.fn.alert;
    a.fn.alert = function(b) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.alert");
            e || d.data("bs.alert", e = new c(this)), "string" == typeof b && e[b].call(d);
        });
    }, a.fn.alert.Constructor = c, a.fn.alert.noConflict = function() {
        return a.fn.alert = d, this;
    }, a(document).on("click.bs.alert.data-api", b, c.prototype.close);
}(jQuery), function(a) {
    "use strict";
    var b = function(c, d) {
        this.$element = a(c), this.options = a.extend({}, b.DEFAULTS, d), this.isLoading = !1;
    };
    b.DEFAULTS = {
        loadingText: "loading..."
    }, b.prototype.setState = function(b) {
        var c = "disabled", d = this.$element, e = d.is("input") ? "val" : "html", f = d.data();
        b += "Text", f.resetText || d.data("resetText", d[e]()), d[e](f[b] || this.options[b]),
        setTimeout(a.proxy(function() {
            "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1,
            d.removeClass(c).removeAttr(c));
        }, this), 0);
    }, b.prototype.toggle = function() {
        var a = !0, b = this.$element.closest('[data-toggle="buttons"]');
        if (b.length) {
            var c = this.$element.find("input");
            "radio" == c.prop("type") && (c.prop("checked") && this.$element.hasClass("active") ? a = !1 : b.find(".active").removeClass("active")),
            a && c.prop("checked", !this.$element.hasClass("active")).trigger("change");
        }
        a && this.$element.toggleClass("active");
    };
    var c = a.fn.button;
    a.fn.button = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.button"), f = "object" == typeof c && c;
            e || d.data("bs.button", e = new b(this, f)), "toggle" == c ? e.toggle() : c && e.setState(c);
        });
    }, a.fn.button.Constructor = b, a.fn.button.noConflict = function() {
        return a.fn.button = c, this;
    }, a(document).on("click.bs.button.data-api", "[data-toggle^=button]", function(b) {
        var c = a(b.target);
        c.hasClass("btn") || (c = c.closest(".btn")), c.button("toggle"), b.preventDefault();
    });
}(jQuery), function(a) {
    "use strict";
    var b = function(b, c) {
        this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"),
        this.options = c, this.paused = this.sliding = this.interval = this.$active = this.$items = null,
        "hover" == this.options.pause && this.$element.on("mouseenter", a.proxy(this.pause, this)).on("mouseleave", a.proxy(this.cycle, this));
    };
    b.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0
    }, b.prototype.cycle = function(b) {
        return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)),
        this;
    }, b.prototype.getActiveIndex = function() {
        return this.$active = this.$element.find(".item.active"), this.$items = this.$active.parent().children(),
        this.$items.index(this.$active);
    }, b.prototype.to = function(b) {
        var c = this, d = this.getActiveIndex();
        return b > this.$items.length - 1 || 0 > b ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function() {
            c.to(b);
        }) : d == b ? this.pause().cycle() : this.slide(b > d ? "next" : "prev", a(this.$items[b]));
    }, b.prototype.pause = function(b) {
        return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end),
        this.cycle(!0)), this.interval = clearInterval(this.interval), this;
    }, b.prototype.next = function() {
        return this.sliding ? void 0 : this.slide("next");
    }, b.prototype.prev = function() {
        return this.sliding ? void 0 : this.slide("prev");
    }, b.prototype.slide = function(b, c) {
        var d = this.$element.find(".item.active"), e = c || d[b](), f = this.interval, g = "next" == b ? "left" : "right", h = "next" == b ? "first" : "last", i = this;
        if (!e.length) {
            if (!this.options.wrap) return;
            e = this.$element.find(".item")[h]();
        }
        if (e.hasClass("active")) return this.sliding = !1;
        var j = a.Event("slide.bs.carousel", {
            relatedTarget: e[0],
            direction: g
        });
        return this.$element.trigger(j), j.isDefaultPrevented() ? void 0 : (this.sliding = !0,
        f && this.pause(), this.$indicators.length && (this.$indicators.find(".active").removeClass("active"),
        this.$element.one("slid.bs.carousel", function() {
            var b = a(i.$indicators.children()[i.getActiveIndex()]);
            b && b.addClass("active");
        })), a.support.transition && this.$element.hasClass("slide") ? (e.addClass(b), e[0].offsetWidth,
        d.addClass(g), e.addClass(g), d.one(a.support.transition.end, function() {
            e.removeClass([ b, g ].join(" ")).addClass("active"), d.removeClass([ "active", g ].join(" ")),
            i.sliding = !1, setTimeout(function() {
                i.$element.trigger("slid.bs.carousel");
            }, 0);
        }).emulateTransitionEnd(1e3 * d.css("transition-duration").slice(0, -1))) : (d.removeClass("active"),
        e.addClass("active"), this.sliding = !1, this.$element.trigger("slid.bs.carousel")),
        f && this.cycle(), this);
    };
    var c = a.fn.carousel;
    a.fn.carousel = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.carousel"), f = a.extend({}, b.DEFAULTS, d.data(), "object" == typeof c && c), g = "string" == typeof c ? c : f.slide;
            e || d.data("bs.carousel", e = new b(this, f)), "number" == typeof c ? e.to(c) : g ? e[g]() : f.interval && e.pause().cycle();
        });
    }, a.fn.carousel.Constructor = b, a.fn.carousel.noConflict = function() {
        return a.fn.carousel = c, this;
    }, a(document).on("click.bs.carousel.data-api", "[data-slide], [data-slide-to]", function(b) {
        var c, d = a(this), e = a(d.attr("data-target") || (c = d.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, "")), f = a.extend({}, e.data(), d.data()), g = d.attr("data-slide-to");
        g && (f.interval = !1), e.carousel(f), (g = d.attr("data-slide-to")) && e.data("bs.carousel").to(g),
        b.preventDefault();
    }), a(window).on("load", function() {
        a('[data-ride="carousel"]').each(function() {
            var b = a(this);
            b.carousel(b.data());
        });
    });
}(jQuery), function(a) {
    "use strict";
    var b = function(c, d) {
        this.$element = a(c), this.options = a.extend({}, b.DEFAULTS, d), this.transitioning = null,
        this.options.parent && (this.$parent = a(this.options.parent)), this.options.toggle && this.toggle();
    };
    b.DEFAULTS = {
        toggle: !0
    }, b.prototype.dimension = function() {
        return this.$element.hasClass("width") ? "width" : "height";
    }, b.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var b = a.Event("show.bs.collapse");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                var c = this.$parent && this.$parent.find("> .panel > .in");
                if (c && c.length) {
                    var d = c.data("bs.collapse");
                    if (d && d.transitioning) return;
                    c.collapse("hide"), d || c.data("bs.collapse", null);
                }
                var e = this.dimension();
                this.$element.removeClass("collapse").addClass("collapsing")[e](0), this.transitioning = 1;
                var f = function() {
                    this.$element.removeClass("collapsing").addClass("collapse in")[e]("auto"), this.transitioning = 0,
                    this.$element.trigger("shown.bs.collapse");
                };
                if (!a.support.transition) return f.call(this);
                var g = a.camelCase([ "scroll", e ].join("-"));
                this.$element.one(a.support.transition.end, a.proxy(f, this)).emulateTransitionEnd(350)[e](this.$element[0][g]);
            }
        }
    }, b.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var b = a.Event("hide.bs.collapse");
            if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                var c = this.dimension();
                this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse").removeClass("in"),
                this.transitioning = 1;
                var d = function() {
                    this.transitioning = 0, this.$element.trigger("hidden.bs.collapse").removeClass("collapsing").addClass("collapse");
                };
                return a.support.transition ? void this.$element[c](0).one(a.support.transition.end, a.proxy(d, this)).emulateTransitionEnd(350) : d.call(this);
            }
        }
    }, b.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    };
    var c = a.fn.collapse;
    a.fn.collapse = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.collapse"), f = a.extend({}, b.DEFAULTS, d.data(), "object" == typeof c && c);
            !e && f.toggle && "show" == c && (c = !c), e || d.data("bs.collapse", e = new b(this, f)),
            "string" == typeof c && e[c]();
        });
    }, a.fn.collapse.Constructor = b, a.fn.collapse.noConflict = function() {
        return a.fn.collapse = c, this;
    }, a(document).on("click.bs.collapse.data-api", "[data-toggle=collapse]", function(b) {
        var c, d = a(this), e = d.attr("data-target") || b.preventDefault() || (c = d.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, ""), f = a(e), g = f.data("bs.collapse"), h = g ? "toggle" : d.data(), i = d.attr("data-parent"), j = i && a(i);
        g && g.transitioning || (j && j.find('[data-toggle=collapse][data-parent="' + i + '"]').not(d).addClass("collapsed"),
        d[f.hasClass("in") ? "addClass" : "removeClass"]("collapsed")), f.collapse(h);
    });
}(jQuery), function(a) {
    "use strict";
    function b(b) {
        a(d).remove(), a(e).each(function() {
            var d = c(a(this)), e = {
                relatedTarget: this
            };
            d.hasClass("open") && (d.trigger(b = a.Event("hide.bs.dropdown", e)), b.isDefaultPrevented() || d.removeClass("open").trigger("hidden.bs.dropdown", e));
        });
    }
    function c(b) {
        var c = b.attr("data-target");
        c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));
        var d = c && a(c);
        return d && d.length ? d : b.parent();
    }
    var d = ".dropdown-backdrop", e = "[data-toggle=dropdown]", f = function(b) {
        a(b).on("click.bs.dropdown", this.toggle);
    };
    f.prototype.toggle = function(d) {
        var e = a(this);
        if (!e.is(".disabled, :disabled")) {
            var f = c(e), g = f.hasClass("open");
            if (b(), !g) {
                "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click", b);
                var h = {
                    relatedTarget: this
                };
                if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;
                f.toggleClass("open").trigger("shown.bs.dropdown", h), e.focus();
            }
            return !1;
        }
    }, f.prototype.keydown = function(b) {
        if (/(38|40|27)/.test(b.keyCode)) {
            var d = a(this);
            if (b.preventDefault(), b.stopPropagation(), !d.is(".disabled, :disabled")) {
                var f = c(d), g = f.hasClass("open");
                if (!g || g && 27 == b.keyCode) return 27 == b.which && f.find(e).focus(), d.click();
                var h = " li:not(.divider):visible a", i = f.find("[role=menu]" + h + ", [role=listbox]" + h);
                if (i.length) {
                    var j = i.index(i.filter(":focus"));
                    38 == b.keyCode && j > 0 && j--, 40 == b.keyCode && j < i.length - 1 && j++, ~j || (j = 0),
                    i.eq(j).focus();
                }
            }
        }
    };
    var g = a.fn.dropdown;
    a.fn.dropdown = function(b) {
        return this.each(function() {
            var c = a(this), d = c.data("bs.dropdown");
            d || c.data("bs.dropdown", d = new f(this)), "string" == typeof b && d[b].call(c);
        });
    }, a.fn.dropdown.Constructor = f, a.fn.dropdown.noConflict = function() {
        return a.fn.dropdown = g, this;
    }, a(document).on("click.bs.dropdown.data-api", b).on("click.bs.dropdown.data-api", ".dropdown form", function(a) {
        a.stopPropagation();
    }).on("click.bs.dropdown.data-api", e, f.prototype.toggle).on("keydown.bs.dropdown.data-api", e + ", [role=menu], [role=listbox]", f.prototype.keydown);
}(jQuery), function(a) {
    "use strict";
    var b = function(b, c) {
        this.options = c, this.$element = a(b), this.$backdrop = this.isShown = null, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function() {
            this.$element.trigger("loaded.bs.modal");
        }, this));
    };
    b.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, b.prototype.toggle = function(a) {
        return this[this.isShown ? "hide" : "show"](a);
    }, b.prototype.show = function(b) {
        var c = this, d = a.Event("show.bs.modal", {
            relatedTarget: b
        });
        this.$element.trigger(d), this.isShown || d.isDefaultPrevented() || (this.isShown = !0,
        this.escape(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)),
        this.backdrop(function() {
            var d = a.support.transition && c.$element.hasClass("fade");
            c.$element.parent().length || c.$element.appendTo(document.body), c.$element.show().scrollTop(0),
            d && c.$element[0].offsetWidth, c.$element.addClass("in").attr("aria-hidden", !1),
            c.enforceFocus();
            var e = a.Event("shown.bs.modal", {
                relatedTarget: b
            });
            d ? c.$element.find(".modal-dialog").one(a.support.transition.end, function() {
                c.$element.focus().trigger(e);
            }).emulateTransitionEnd(300) : c.$element.focus().trigger(e);
        }));
    }, b.prototype.hide = function(b) {
        b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b),
        this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), a(document).off("focusin.bs.modal"),
        this.$element.removeClass("in").attr("aria-hidden", !0).off("click.dismiss.bs.modal"),
        a.support.transition && this.$element.hasClass("fade") ? this.$element.one(a.support.transition.end, a.proxy(this.hideModal, this)).emulateTransitionEnd(300) : this.hideModal());
    }, b.prototype.enforceFocus = function() {
        a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function(a) {
            this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.focus();
        }, this));
    }, b.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keyup.dismiss.bs.modal", a.proxy(function(a) {
            27 == a.which && this.hide();
        }, this)) : this.isShown || this.$element.off("keyup.dismiss.bs.modal");
    }, b.prototype.hideModal = function() {
        var a = this;
        this.$element.hide(), this.backdrop(function() {
            a.removeBackdrop(), a.$element.trigger("hidden.bs.modal");
        });
    }, b.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
    }, b.prototype.backdrop = function(b) {
        var c = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var d = a.support.transition && c;
            if (this.$backdrop = a('<div class="modal-backdrop ' + c + '" />').appendTo(document.body),
            this.$element.on("click.dismiss.bs.modal", a.proxy(function(a) {
                a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this));
            }, this)), d && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;
            d ? this.$backdrop.one(a.support.transition.end, b).emulateTransitionEnd(150) : b();
        } else !this.isShown && this.$backdrop ? (this.$backdrop.removeClass("in"), a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one(a.support.transition.end, b).emulateTransitionEnd(150) : b()) : b && b();
    };
    var c = a.fn.modal;
    a.fn.modal = function(c, d) {
        return this.each(function() {
            var e = a(this), f = e.data("bs.modal"), g = a.extend({}, b.DEFAULTS, e.data(), "object" == typeof c && c);
            f || e.data("bs.modal", f = new b(this, g)), "string" == typeof c ? f[c](d) : g.show && f.show(d);
        });
    }, a.fn.modal.Constructor = b, a.fn.modal.noConflict = function() {
        return a.fn.modal = c, this;
    }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(b) {
        var c = a(this), d = c.attr("href"), e = a(c.attr("data-target") || d && d.replace(/.*(?=#[^\s]+$)/, "")), f = e.data("bs.modal") ? "toggle" : a.extend({
            remote: !/#/.test(d) && d
        }, e.data(), c.data());
        c.is("a") && b.preventDefault(), e.modal(f, this).one("hide", function() {
            c.is(":visible") && c.focus();
        });
    }), a(document).on("show.bs.modal", ".modal", function() {
        a(document.body).addClass("modal-open");
    }).on("hidden.bs.modal", ".modal", function() {
        a(document.body).removeClass("modal-open");
    });
}(jQuery), function(a) {
    "use strict";
    var b = function(a, b) {
        this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null,
        this.init("tooltip", a, b);
    };
    b.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1
    }, b.prototype.init = function(b, c, d) {
        this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d);
        for (var e = this.options.trigger.split(" "), f = e.length; f--; ) {
            var g = e[f];
            if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this)); else if ("manual" != g) {
                var h = "hover" == g ? "mouseenter" : "focusin", i = "hover" == g ? "mouseleave" : "focusout";
                this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)),
                this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = a.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    }, b.prototype.getDefaults = function() {
        return b.DEFAULTS;
    }, b.prototype.getOptions = function(b) {
        return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = {
            show: b.delay,
            hide: b.delay
        }), b;
    }, b.prototype.getDelegateOptions = function() {
        var b = {}, c = this.getDefaults();
        return this._options && a.each(this._options, function(a, d) {
            c[a] != d && (b[a] = d);
        }), b;
    }, b.prototype.enter = function(b) {
        var c = b instanceof this.constructor ? b : a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type);
        return clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function() {
            "in" == c.hoverState && c.show();
        }, c.options.delay.show)) : c.show();
    }, b.prototype.leave = function(b) {
        var c = b instanceof this.constructor ? b : a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type);
        return clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function() {
            "out" == c.hoverState && c.hide();
        }, c.options.delay.hide)) : c.hide();
    }, b.prototype.show = function() {
        var b = a.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            if (this.$element.trigger(b), b.isDefaultPrevented()) return;
            var c = this, d = this.tip();
            this.setContent(), this.options.animation && d.addClass("fade");
            var e = "function" == typeof this.options.placement ? this.options.placement.call(this, d[0], this.$element[0]) : this.options.placement, f = /\s?auto?\s?/i, g = f.test(e);
            g && (e = e.replace(f, "") || "top"), d.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(e), this.options.container ? d.appendTo(this.options.container) : d.insertAfter(this.$element);
            var h = this.getPosition(), i = d[0].offsetWidth, j = d[0].offsetHeight;
            if (g) {
                var k = this.$element.parent(), l = e, m = document.documentElement.scrollTop || document.body.scrollTop, n = "body" == this.options.container ? window.innerWidth : k.outerWidth(), o = "body" == this.options.container ? window.innerHeight : k.outerHeight(), p = "body" == this.options.container ? 0 : k.offset().left;
                e = "bottom" == e && h.top + h.height + j - m > o ? "top" : "top" == e && h.top - m - j < 0 ? "bottom" : "right" == e && h.right + i > n ? "left" : "left" == e && h.left - i < p ? "right" : e,
                d.removeClass(l).addClass(e);
            }
            var q = this.getCalculatedOffset(e, h, i, j);
            this.applyPlacement(q, e), this.hoverState = null;
            var r = function() {
                c.$element.trigger("shown.bs." + c.type);
            };
            a.support.transition && this.$tip.hasClass("fade") ? d.one(a.support.transition.end, r).emulateTransitionEnd(150) : r();
        }
    }, b.prototype.applyPlacement = function(b, c) {
        var d, e = this.tip(), f = e[0].offsetWidth, g = e[0].offsetHeight, h = parseInt(e.css("margin-top"), 10), i = parseInt(e.css("margin-left"), 10);
        isNaN(h) && (h = 0), isNaN(i) && (i = 0), b.top = b.top + h, b.left = b.left + i,
        a.offset.setOffset(e[0], a.extend({
            using: function(a) {
                e.css({
                    top: Math.round(a.top),
                    left: Math.round(a.left)
                });
            }
        }, b), 0), e.addClass("in");
        var j = e[0].offsetWidth, k = e[0].offsetHeight;
        if ("top" == c && k != g && (d = !0, b.top = b.top + g - k), /bottom|top/.test(c)) {
            var l = 0;
            b.left < 0 && (l = -2 * b.left, b.left = 0, e.offset(b), j = e[0].offsetWidth, k = e[0].offsetHeight),
            this.replaceArrow(l - f + j, j, "left");
        } else this.replaceArrow(k - g, k, "top");
        d && e.offset(b);
    }, b.prototype.replaceArrow = function(a, b, c) {
        this.arrow().css(c, a ? 50 * (1 - a / b) + "%" : "");
    }, b.prototype.setContent = function() {
        var a = this.tip(), b = this.getTitle();
        a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right");
    }, b.prototype.hide = function() {
        function b() {
            "in" != c.hoverState && d.detach(), c.$element.trigger("hidden.bs." + c.type);
        }
        var c = this, d = this.tip(), e = a.Event("hide.bs." + this.type);
        return this.$element.trigger(e), e.isDefaultPrevented() ? void 0 : (d.removeClass("in"),
        a.support.transition && this.$tip.hasClass("fade") ? d.one(a.support.transition.end, b).emulateTransitionEnd(150) : b(),
        this.hoverState = null, this);
    }, b.prototype.fixTitle = function() {
        var a = this.$element;
        (a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "");
    }, b.prototype.hasContent = function() {
        return this.getTitle();
    }, b.prototype.getPosition = function() {
        var b = this.$element[0];
        return a.extend({}, "function" == typeof b.getBoundingClientRect ? b.getBoundingClientRect() : {
            width: b.offsetWidth,
            height: b.offsetHeight
        }, this.$element.offset());
    }, b.prototype.getCalculatedOffset = function(a, b, c, d) {
        return "bottom" == a ? {
            top: b.top + b.height,
            left: b.left + b.width / 2 - c / 2
        } : "top" == a ? {
            top: b.top - d,
            left: b.left + b.width / 2 - c / 2
        } : "left" == a ? {
            top: b.top + b.height / 2 - d / 2,
            left: b.left - c
        } : {
            top: b.top + b.height / 2 - d / 2,
            left: b.left + b.width
        };
    }, b.prototype.getTitle = function() {
        var b = this.$element, c = this.options;
        return b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title);
    }, b.prototype.tip = function() {
        return this.$tip = this.$tip || a(this.options.template);
    }, b.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    }, b.prototype.validate = function() {
        this.$element[0].parentNode || (this.hide(), this.$element = null, this.options = null);
    }, b.prototype.enable = function() {
        this.enabled = !0;
    }, b.prototype.disable = function() {
        this.enabled = !1;
    }, b.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    }, b.prototype.toggle = function(b) {
        var c = b ? a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type) : this;
        c.tip().hasClass("in") ? c.leave(c) : c.enter(c);
    }, b.prototype.destroy = function() {
        clearTimeout(this.timeout), this.hide().$element.off("." + this.type).removeData("bs." + this.type);
    };
    var c = a.fn.tooltip;
    a.fn.tooltip = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.tooltip"), f = "object" == typeof c && c;
            (e || "destroy" != c) && (e || d.data("bs.tooltip", e = new b(this, f)), "string" == typeof c && e[c]());
        });
    }, a.fn.tooltip.Constructor = b, a.fn.tooltip.noConflict = function() {
        return a.fn.tooltip = c, this;
    };
}(jQuery), function(a) {
    "use strict";
    var b = function(a, b) {
        this.init("popover", a, b);
    };
    if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");
    b.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), b.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), b.prototype.constructor = b,
    b.prototype.getDefaults = function() {
        return b.DEFAULTS;
    }, b.prototype.setContent = function() {
        var a = this.tip(), b = this.getTitle(), c = this.getContent();
        a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content")[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c),
        a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide();
    }, b.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    }, b.prototype.getContent = function() {
        var a = this.$element, b = this.options;
        return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content);
    }, b.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    }, b.prototype.tip = function() {
        return this.$tip || (this.$tip = a(this.options.template)), this.$tip;
    };
    var c = a.fn.popover;
    a.fn.popover = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.popover"), f = "object" == typeof c && c;
            (e || "destroy" != c) && (e || d.data("bs.popover", e = new b(this, f)), "string" == typeof c && e[c]());
        });
    }, a.fn.popover.Constructor = b, a.fn.popover.noConflict = function() {
        return a.fn.popover = c, this;
    };
}(jQuery), function(a) {
    "use strict";
    function b(c, d) {
        var e, f = a.proxy(this.process, this);
        this.$element = a(a(c).is("body") ? window : c), this.$body = a("body"), this.$scrollElement = this.$element.on("scroll.bs.scroll-spy.data-api", f),
        this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || (e = a(c).attr("href")) && e.replace(/.*(?=#[^\s]+$)/, "") || "") + " .nav li > a",
        this.offsets = a([]), this.targets = a([]), this.activeTarget = null, this.refresh(),
        this.process();
    }
    b.DEFAULTS = {
        offset: 10
    }, b.prototype.refresh = function() {
        var b = this.$element[0] == window ? "offset" : "position";
        this.offsets = a([]), this.targets = a([]);
        var c = this;
        this.$body.find(this.selector).map(function() {
            var d = a(this), e = d.data("target") || d.attr("href"), f = /^#./.test(e) && a(e);
            return f && f.length && f.is(":visible") && [ [ f[b]().top + (!a.isWindow(c.$scrollElement.get(0)) && c.$scrollElement.scrollTop()), e ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            c.offsets.push(this[0]), c.targets.push(this[1]);
        });
    }, b.prototype.process = function() {
        var a, b = this.$scrollElement.scrollTop() + this.options.offset, c = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight, d = c - this.$scrollElement.height(), e = this.offsets, f = this.targets, g = this.activeTarget;
        if (b >= d) return g != (a = f.last()[0]) && this.activate(a);
        if (g && b <= e[0]) return g != (a = f[0]) && this.activate(a);
        for (a = e.length; a--; ) g != f[a] && b >= e[a] && (!e[a + 1] || b <= e[a + 1]) && this.activate(f[a]);
    }, b.prototype.activate = function(b) {
        this.activeTarget = b, a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
        var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]', d = a(c).parents("li").addClass("active");
        d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")),
        d.trigger("activate.bs.scrollspy");
    };
    var c = a.fn.scrollspy;
    a.fn.scrollspy = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.scrollspy"), f = "object" == typeof c && c;
            e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]();
        });
    }, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function() {
        return a.fn.scrollspy = c, this;
    }, a(window).on("load", function() {
        a('[data-spy="scroll"]').each(function() {
            var b = a(this);
            b.scrollspy(b.data());
        });
    });
}(jQuery), function(a) {
    "use strict";
    var b = function(b) {
        this.element = a(b);
    };
    b.prototype.show = function() {
        var b = this.element, c = b.closest("ul:not(.dropdown-menu)"), d = b.data("target");
        if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
            var e = c.find(".active:last a")[0], f = a.Event("show.bs.tab", {
                relatedTarget: e
            });
            if (b.trigger(f), !f.isDefaultPrevented()) {
                var g = a(d);
                this.activate(b.parent("li"), c), this.activate(g, g.parent(), function() {
                    b.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: e
                    });
                });
            }
        }
    }, b.prototype.activate = function(b, c, d) {
        function e() {
            f.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),
            b.addClass("active"), g ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"),
            b.parent(".dropdown-menu") && b.closest("li.dropdown").addClass("active"), d && d();
        }
        var f = c.find("> .active"), g = d && a.support.transition && f.hasClass("fade");
        g ? f.one(a.support.transition.end, e).emulateTransitionEnd(150) : e(), f.removeClass("in");
    };
    var c = a.fn.tab;
    a.fn.tab = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.tab");
            e || d.data("bs.tab", e = new b(this)), "string" == typeof c && e[c]();
        });
    }, a.fn.tab.Constructor = b, a.fn.tab.noConflict = function() {
        return a.fn.tab = c, this;
    }, a(document).on("click.bs.tab.data-api", '[data-toggle="tab"], [data-toggle="pill"]', function(b) {
        b.preventDefault(), a(this).tab("show");
    });
}(jQuery), function(a) {
    "use strict";
    var b = function(c, d) {
        this.options = a.extend({}, b.DEFAULTS, d), this.$window = a(window).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)),
        this.$element = a(c), this.affixed = this.unpin = this.pinnedOffset = null, this.checkPosition();
    };
    b.RESET = "affix affix-top affix-bottom", b.DEFAULTS = {
        offset: 0
    }, b.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(b.RESET).addClass("affix");
        var a = this.$window.scrollTop(), c = this.$element.offset();
        return this.pinnedOffset = c.top - a;
    }, b.prototype.checkPositionWithEventLoop = function() {
        setTimeout(a.proxy(this.checkPosition, this), 1);
    }, b.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var c = a(document).height(), d = this.$window.scrollTop(), e = this.$element.offset(), f = this.options.offset, g = f.top, h = f.bottom;
            "top" == this.affixed && (e.top += d), "object" != typeof f && (h = g = f), "function" == typeof g && (g = f.top(this.$element)),
            "function" == typeof h && (h = f.bottom(this.$element));
            var i = !(null != this.unpin && d + this.unpin <= e.top) && (null != h && e.top + this.$element.height() >= c - h ? "bottom" : null != g && g >= d && "top");
            if (this.affixed !== i) {
                this.unpin && this.$element.css("top", "");
                var j = "affix" + (i ? "-" + i : ""), k = a.Event(j + ".bs.affix");
                this.$element.trigger(k), k.isDefaultPrevented() || (this.affixed = i, this.unpin = "bottom" == i ? this.getPinnedOffset() : null,
                this.$element.removeClass(b.RESET).addClass(j).trigger(a.Event(j.replace("affix", "affixed"))),
                "bottom" == i && this.$element.offset({
                    top: c - h - this.$element.height()
                }));
            }
        }
    };
    var c = a.fn.affix;
    a.fn.affix = function(c) {
        return this.each(function() {
            var d = a(this), e = d.data("bs.affix"), f = "object" == typeof c && c;
            e || d.data("bs.affix", e = new b(this, f)), "string" == typeof c && e[c]();
        });
    }, a.fn.affix.Constructor = b, a.fn.affix.noConflict = function() {
        return a.fn.affix = c, this;
    }, a(window).on("load", function() {
        a('[data-spy="affix"]').each(function() {
            var b = a(this), c = b.data();
            c.offset = c.offset || {}, c.offsetBottom && (c.offset.bottom = c.offsetBottom),
            c.offsetTop && (c.offset.top = c.offsetTop), b.affix(c);
        });
    });
}(jQuery), function($) {
    "use strict";
    var ContextMenu = function(element, options) {
        this.$element = $(element), this.before = options.before || this.before, this.onItem = options.onItem || this.onItem,
        this.scopes = options.scopes || null, options.target && this.$element.data("target", options.target),
        this.listen();
    };
    ContextMenu.prototype = {
        constructor: ContextMenu,
        show: function(e) {
            var $menu, tp, items, relatedTarget = {
                relatedTarget: this
            };
            if (!this.isDisabled() && (this.closemenu(), this.before.call(this, e, $(e.currentTarget)))) return $menu = this.getMenu(),
            $menu.trigger($.Event("show.bs.context", relatedTarget)), tp = this.getPosition(e, $menu),
            items = "li:not(.divider)", $menu.attr("style", "").css(tp).addClass("open").on("click.context.data-api", items, $.proxy(this.onItem, this, $(e.currentTarget))).trigger("shown.bs.context", relatedTarget),
            $("html").on("click.context.data-api", $menu.selector, $.proxy(this.closemenu, this)),
            !1;
        },
        closemenu: function(e) {
            var $menu, items, relatedTarget;
            if ($menu = this.getMenu(), $menu.hasClass("open")) return relatedTarget = {
                relatedTarget: this
            }, $menu.trigger($.Event("hide.bs.context", relatedTarget)), items = "li:not(.divider)",
            $menu.removeClass("open").off("click.context.data-api", items).trigger("hidden.bs.context", relatedTarget),
            $("html").off("click.context.data-api", $menu.selector), !1;
        },
        before: function(e) {
            return !0;
        },
        onItem: function(e) {
            return !0;
        },
        listen: function() {
            this.$element.on("contextmenu.context.data-api", this.scopes, $.proxy(this.show, this)),
            $("html").on("click.context.data-api", $.proxy(this.closemenu, this));
        },
        destroy: function() {
            this.$element.off(".context.data-api").removeData("context"), $("html").off(".context.data-api");
        },
        isDisabled: function() {
            return this.$element.hasClass(".disabled") || this.$element.attr("disabled");
        },
        getMenu: function() {
            var $menu, selector = this.$element.data("target");
            return selector || (selector = this.$element.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")),
            $menu = $(selector), $menu && $menu.length ? $menu : this.$element.find(selector);
        },
        getPosition: function(e, $menu) {
            var Y, X, parentOffset, mouseX = e.clientX, mouseY = e.clientY, boundsX = $(window).width(), boundsY = $(window).height(), menuWidth = $menu.find(".dropdown-menu").outerWidth(), menuHeight = $menu.find(".dropdown-menu").outerHeight(), tp = {
                position: "absolute",
                "z-index": 9999
            };
            return Y = mouseY + menuHeight > boundsY ? {
                top: mouseY - menuHeight + $(window).scrollTop()
            } : {
                top: mouseY + $(window).scrollTop()
            }, X = mouseX + menuWidth > boundsX && mouseX - menuWidth > 0 ? {
                left: mouseX - menuWidth + $(window).scrollLeft()
            } : {
                left: mouseX + $(window).scrollLeft()
            }, parentOffset = $menu.offsetParent().offset(), X.left = X.left - parentOffset.left,
            Y.top = Y.top - parentOffset.top, $.extend(tp, Y, X);
        }
    }, $.fn.contextmenu = function(option, e) {
        return this.each(function() {
            var $this = $(this), data = $this.data("context"), options = "object" == typeof option && option;
            data || $this.data("context", data = new ContextMenu($this, options)), "string" == typeof option && data[option].call(data, e);
        });
    }, $.fn.contextmenu.Constructor = ContextMenu, $(document).on("contextmenu.context.data-api", '[data-toggle="context"]', function(e) {
        $(this).contextmenu("show", e), e.preventDefault();
    });
}(jQuery), Scene.prototype.reexecute = function() {
    this.lineNum = this.stats.testEntryPoint || 0, this.finished = 0, this.indent = this.getIndent(this.lines[this.lineNum]),
    this.prevLine = "empty", this.screenEmpty = !0, this.execute();
}, Scene.prototype.printLoop = function() {
    for (var line; !this.finished && this.lineNum < this.lines.length; this.lineNum++) if (line = this.lines[this.lineNum],
    trim(line)) {
        var indent = this.getIndent(line);
        if (indent > this.indent) {
            if (/\s*\*comment\b/.test(line)) continue;
            throw new Error(this.lineMsg() + "increasing indent not allowed, expected " + this.indent + " was " + indent);
        }
        if (indent < this.indent && this.dedent(indent), this.temps._choiceEnds[this.lineNum] && (this.stats.implicit_control_flow || this.temps._fakeChoiceDepth > 0)) this.rollbackLineCoverage(),
        this.lineNum = this.temps._choiceEnds[this.lineNum], this.rollbackLineCoverage(),
        this.temps._fakeChoiceDepth > 0 && this.temps._fakeChoiceDepth--; else {
            if (this.indent = indent, /^\s*#/.test(line)) throw new Error(this.lineMsg() + "It is illegal to fall out of a *choice statement; you must *goto or *finish before the end of the indented block.");
            this.runCommand(line) || (this.prevLine = "text", this.screenEmpty = !1, this.printLine(line));
        }
    } else this.paragraph();
    this.rollbackLineCoverage(), this.finished || this.autofinish(), this.save("temp"),
    this.skipFooter ? this.skipFooter = !1 : printFooter();
}, Scene.prototype.dedent = function(newDent) {}, Scene.prototype.printLine = function(line) {
    if (!line) return null;
    line = this.replaceVariables(line.replace(/^ */, "")), this.accumulatedParagraph.push(line),
    /([-\u2011-\u2014]|\[c\/\])$/.test(line) || this.accumulatedParagraph.push(" ");
}, Scene.prototype.replaceVariables = function(line) {
    line = String(line);
    for (var replacer = /([$@](\!?\!?)\{)/, index = 0, output = [], result = replacer.exec(line); result; result = replacer.exec(line.substring(index))) {
        output.push(line.substring(index, index + result.index));
        for (var curlies = 0, closingCurly = -1, exprStart = index + result.index + result[1].length, i = exprStart; i < line.length; i++) {
            var c = line.charAt(i);
            if ("{" === c) curlies++; else if ("}" === c) {
                if (!curlies) {
                    closingCurly = i;
                    break;
                }
                curlies--;
            }
        }
        if (-1 == closingCurly) throw new Error(this.lineMsg() + "invalid " + result[0] + "} variable substitution at letter " + (index + result.index + 1));
        var stack, value, body = line.substring(exprStart, closingCurly);
        if ("$" === result[0].charAt(0)) stack = this.tokenizeExpr(body), value = this.evaluateExpr(stack); else {
            var expr, options;
            if (/^\s*\(/.test(body)) {
                for (var parens = 0, closingParen = -1, i = 1; i < body.length; i++) {
                    var c = body.charAt(i);
                    if ("(" === c) parens++; else if (")" === c) {
                        if (!parens) {
                            closingParen = i;
                            break;
                        }
                        parens--;
                    }
                }
                if (-1 == closingParen) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; missing closing parenthesis )");
                if (" " != body.charAt(closingParen + 1)) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; there should be a space after the closing parenthesis )");
                expr = body.substring(1, closingParen), options = body.substring(closingParen + 2).split("|");
            } else {
                if (!/^\S+ /.test(body)) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; there should be a space after the first word");
                var spaceIndex = body.indexOf(" ");
                expr = body.substring(0, spaceIndex), options = body.substring(spaceIndex + 1).split("|");
            }
            if (options.length < 2) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; there should be at least one pipe | to separate options");
            if (stack = this.tokenizeExpr(expr), value = this.evaluateExpr(stack), ("boolean" == typeof value || /^(true|false)$/i.test(value)) && (value = bool(value) ? 1 : 2),
            (0 | (value = num(value, this.lineNum + 1))) !== value) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; '" + expr + "' is equal to " + value + " which is not a whole integer number");
            if (value < 1) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; '" + expr + "' is equal to " + value + " which is not a positive number");
            if (value > options.length) throw new Error(this.lineMsg() + "invalid " + result[0] + "} at letter " + (index + result.index + 1) + "; '" + expr + "' is equal to " + value + " but there are only " + options.length + " options");
            value = options[value - 1], value = this.replaceVariables(value);
        }
        var capitalize = result[2];
        capitalize && (value = String(value)), "!" == capitalize ? value = value.charAt(0).toUpperCase() + value.slice(1) : "!!" == capitalize && (value = value.toUpperCase()),
        "undefined" != typeof highlightGenderPronouns && highlightGenderPronouns && /\b(he|him|his|she|her|hers)\b/gi.test(value) && output.push("​"),
        output.push(value), index = closingCurly + 1;
    }
    return 0 === index ? line : (output.push(line.substring(index)), output.join(""));
}, Scene.prototype.paragraph = function() {
    printParagraph(this.accumulatedParagraph.join("")), this.accumulatedParagraph = [],
    this.prevLine = "empty";
}, Scene.prototype.loadSceneFast = function(url) {
    function retryScenes(command) {
        command || (command = "retryscenes"), clearScreen(function() {
            startLoading(), "retryscenes" == command && curl(), window.downloadState = null,
            callIos(command), startedWaiting = new Date().getTime(), awaitAllScenes();
        });
    }
    function awaitAllScenes() {
        if ("undefined" != typeof allScenes) {
            if (!(result = allScenes[self.name])) throw new Error("Couldn't load scene '" + self.name + "'\nThe file doesn't exist.");
            self.loadLinesFast(result.crc, result.lines, result.labels);
        } else if ("failed" == window.downloadState || new Date().getTime() - startedWaiting > 5e3) if (doneLoading(),
        window.downloadRequired) println("We weren't able to download the latest version of the game."),
        println(""), printButton("Try Again", main, !1, retryScenes); else {
            println("We weren't able to download the latest version of the game. Please try downloading again. The latest version may contain important fixes."),
            println("");
            var retry = {
                name: "Try downloading again."
            }, ignore = {
                name: "Continue playing without the latest version."
            };
            printOptions([ "" ], [ retry, ignore ], function(option) {
                option == retry ? retryScenes() : retryScenes("requestscenesforce");
            });
        } else setTimeout(awaitAllScenes, 0);
    }
    if (!this.loading) {
        this.loading = !0;
        var result;
        if (window.cachedResults && window.cachedResults[this.name]) return result = window.cachedResults[this.name],
        this.loadLinesFast(result.crc, result.lines, result.labels);
        if ("undefined" != typeof allScenes) {
            if (!(result = allScenes[this.name])) throw new Error("Couldn't load scene '" + this.name + "'\nThe file doesn't exist.");
            return this.loadLinesFast(result.crc, result.lines, result.labels);
        }
        if ("undefined" != typeof isIosApp) {
            startLoading();
            var self = this, startedWaiting = new Date().getTime();
            return awaitAllScenes();
        }
        startLoading(), url || (url = Scene.baseUrl + "/" + this.name.replace(/ /g, "_") + ".txt.json");
        var xhr = findXhr();
        xhr.open("GET", url, !0);
        var self = this, done = !1;
        if (xhr.onreadystatechange = function() {
            if (!done && 4 == xhr.readyState) {
                if (403 == xhr.status) try {
                    if ("not registered" == JSON.parse(xhr.responseText).error) return isRegistered(function(registered) {
                        return registered && (logout(), loginDiv()), clearScreen(function() {
                            loginForm(main, 0, "Please sign in to access this part of the game.", function() {
                                clearScreen(loadAndRestoreGame);
                            });
                        });
                    });
                } catch (e) {}
                done = !0;
                var result;
                try {
                    result = jsonParse(xhr.responseText);
                } catch (e) {
                    window.console && console.error(e, e.stack);
                }
                if (window.isWeb && (200 != xhr.status || !result)) {
                    var status = xhr.status;
                    return 200 != status && status || (status = "network"), void (main.innerHTML = "<p>Our apologies; there was a " + status + " error while loading game data.  Please refresh your browser now; if that doesn't work, please click the Restart button and email " + getSupportEmail() + " with details.</p> <p><button onclick='window.location.reload();'>Refresh Now</button></p>");
                }
                if ("" === xhr.responseText) throw new Error("Couldn't load " + url + "\nThe file is probably missing or empty.");
                window.cachedResults || (window.cachedResults = {}), cachedResults[self.name] = result,
                self.loadLinesFast(result.crc, result.lines, result.labels);
            }
        }, isIE) xhr.send(null); else try {
            xhr.send(null);
        } catch (e) {
            if ("file:" == window.location.protocol && !window.isMobile && /Chrome/.test(navigator.userAgent)) return void window.onerror('We\'re sorry, Google Chrome has blocked ChoiceScript from functioning.  ("file:" URLs cannot load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.');
            window.onerror("Couldn't load URL: " + url + "\n" + e);
        }
    }
}, Scene.prototype.loadLinesFast = function(crc, lines, labels) {
    this.checkSum(crc), this.lines = lines, this.labels = labels, this.loading = !1,
    this.loaded = !0;
    var self = this;
    this.executing && safeCall(this, function() {
        doneLoading(), self.execute();
    });
}, Scene.prototype.loadScene = function(url) {
    if (!this.loading) {
        this.loading = !0, startLoading(), url || (url = Scene.baseUrl + "/" + this.name + ".txt");
        var xhr = findXhr();
        xhr.open("GET", url, !0);
        var self = this, done = !1;
        if (xhr.onreadystatechange = function() {
            if (!done && 4 == xhr.readyState) {
                if (done = !0, 403 == xhr.status) try {
                    if ("not registered" == JSON.parse(xhr.responseText).error) return isRegistered(function(registered) {
                        return registered && (logout(), loginDiv()), clearScreen(function() {
                            loginForm(main, 0, "Please sign in to access this part of the game.", function() {
                                clearScreen(loadAndRestoreGame);
                            });
                        });
                    });
                } catch (e) {}
                if (window.isWeb && 200 != xhr.status) {
                    var status = xhr.status || "network";
                    return void (main.innerHTML = "<p>Our apologies; there was a " + status + " error while loading game data.  Please refresh your browser now; if that doesn't work, please email " + getSupportEmail() + " with details.</p> <p><button onclick='window.location.reload();'>Refresh Now</button></p>");
                }
                if ("" === xhr.responseText) return "file:" == window.location.protocol && !window.isMobile && /Chrome/.test(navigator.userAgent) ? void window.onerror('We\'re sorry, Google Chrome has blocked ChoiceScript from functioning.  ("file:" URLs cannot load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.') : void window.onerror("Couldn't load " + url + "\nThe file is probably missing or empty.");
                var result = xhr.responseText;
                scene = result, scene = scene.replace(/\r/g, ""), this.loading = !1, self.loadLines(scene),
                self.executing && safeCall(self, function() {
                    doneLoading(), self.execute();
                });
            }
        }, isIE) xhr.send(null); else try {
            xhr.send(null);
        } catch (e) {
            if ("file:" == window.location.protocol && !window.isMobile) {
                if (/Chrome/.test(navigator.userAgent)) return void window.onerror('We\'re sorry, Google Chrome has blocked ChoiceScript from functioning.  ("file:" URLs cannot load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.');
                if (1012 === e.code) return void window.onerror("Couldn't load scene file: " + url + "\nThe file is probably missing.");
            }
            window.onerror("Couldn't load URL: " + url + "\n" + e);
        }
    }
}, Scene.prototype.checkSum = function(crc) {
    if (this.temps.choice_crc) {
        if (this.temps.choice_crc != crc) {
            var userRestored = this.temps.choice_user_restored || !1;
            this.temps = {
                choice_reuse: "allow",
                choice_user_restored: userRestored,
                choice_crc: crc,
                _choiceEnds: {}
            }, this.lineNum = 0, this.indent = 0;
        }
    } else this.temps.choice_crc = crc;
}, Scene.prototype.loadLines = function(str) {
    var crc = crc32(str);
    this.checkSum(crc), this.lines = str.split(/\r?\n/), this.parseLabels(), this.loaded = !0;
}, Scene.prototype.execute = function() {
    if (!this.loaded) return this.executing = !0, void (Scene.generatedFast || "undefined" != typeof generatedFast && generatedFast || "undefined" != typeof allScenes ? this.loadSceneFast() : this.loadScene());
    if (this.nav && this.nav.repairStats(stats), this.temps._choiceEnds || (this.temps._choiceEnds = {}),
    doneLoading(), void 0 !== this.targetLabel) {
        var label = this.targetLabel.label.toLowerCase();
        if (void 0 === this.labels[label]) throw new Error(this.targetLabel.origin + " line " + (this.targetLabel.originLine + 1) + ": " + this.name + " doesn't contain label " + label);
        this.lineNum = this.labels[label], this.indent = this.getIndent(this.lines[this.lineNum]),
        delete this.targetLabel;
    }
    this.printLoop();
}, Scene.prototype.parseLabels = function() {
    var lineLength = this.lines.length, oldLineNum = this.lineNum, screenshots = "choicescript_screenshots" == this.name, seenChoiceWithoutSet = 0;
    for (this.lineNum = 0; this.lineNum < lineLength; this.lineNum++) {
        this.rollbackLineCoverage();
        var line = this.lines[this.lineNum];
        0 == this.lineNum && 65279 == line.charCodeAt(0) && (lines[0] = line.substring(1));
        var invalidCharacter = line.match(/^(.*)\ufffd/);
        if (invalidCharacter) throw new Error(this.lineMsg() + "invalid character. (ChoiceScript text should be saved in the UTF-8 encoding.) " + invalidCharacter[0]);
        var result = /^(\s*)\*(\w+)(.*)/.exec(line);
        if (result) {
            var indentation = result[1], command = (indentation.length, result[2].toLowerCase()), data = trim(result[3]);
            if ("label" == command) {
                if (data = data.toLowerCase(), /\s/.test(data)) throw new Error(this.lineMsg() + "label '" + data + "' is not allowed to contain spaces");
                if (this.labels.hasOwnProperty(data)) throw new Error(this.lineMsg() + "label '" + data + "' already defined on line " + (1 * this.labels[data] + 1));
                this.labels[data] = this.lineNum;
            } else if (screenshots) if ("fake_choice" == command) {
                if (seenChoiceWithoutSet) throw new Error(this.lineMsg() + "In choicescript_screenshots, you need to *set at least one variable between *fake_choice commands, so the stat screen looks interesting. There was no *set since the last *fake_choice on line " + seenChoiceWithoutSet + ".");
                seenChoiceWithoutSet = this.lineNum + 1;
            } else "set" == command && (seenChoiceWithoutSet = 0);
        }
    }
    this.rollbackLineCoverage(), this.lineNum = oldLineNum;
}, Scene.prototype.runCommand = function(line) {
    var result = /^\s*\*(\w+)(.*)/.exec(line);
    if (!result) return !("startup" != this.secondaryMode || !this.startupCallback) && (this.finished = !0,
    this.skipFooter = !0, this.startupCallback(), !0);
    var command = result[1].toLowerCase(), data = trim(result[2]);
    if (!Scene.validCommands[command]) throw new Error(this.lineMsg() + "Non-existent command '" + command + "'");
    if ("comment" == command) return !0;
    if (Scene.initialCommands[command]) {
        if ("startup" != String(this.name).toLowerCase() || !this.initialCommands) throw new Error(this.lineMsg() + "Invalid " + command + " instruction, only allowed at the top of startup.txt");
    } else {
        if ("startup" == this.secondaryMode && this.startupCallback) return this.finished = !0,
        this.skipFooter = !0, this.startupCallback(), !0;
        this.initialCommands = !1;
    }
    if ("choice" == command && "choicescript_screenshots" == String(this.name).toLowerCase()) throw new Error(this.lineMsg() + "choicescript_screenshots files should only contain *fake_choice commands, not real *choice commands");
    return this[command](data), !0;
}, Scene.prototype.choice = function(data) {
    for (var startLineNum = this.lineNum, groups = data.split(/ /), i = 0; i < groups.length; i++) if (!/^\w*$/.test(groups[i])) throw new Error(this.lineMsg() + "invalid choice group name: " + groups[i]);
    var options = this.parseOptions(this.indent, groups), self = this;
    if (this.renderOptions(groups, options, function(option) {
        self.standardResolution(option);
    }), this.finished = !0, this.temps._fakeChoiceDepth > 0 || this.stats.implicit_control_flow) for (this.temps._choiceEnds || (this.temps._choiceEnds = {}),
    i = 0; i < options.length; i++) this.temps._choiceEnds[options[i].line - 1] = this.lineNum;
    this.lineNum = startLineNum;
}, Scene.prototype.fake_choice = function(data) {
    void 0 === this.temps._fakeChoiceDepth && (this.temps._fakeChoiceDepth = 0), this.temps._fakeChoiceDepth++,
    this.choice(data);
}, Scene.prototype.standardResolution = function(option) {
    var self = this;
    self.lineNum = option.line, self.indent = self.getIndent(self.nextNonBlankLine(!0)),
    option.reuse && "allow" != option.reuse && (self.temps.choice_used[option.line - 1] = 1),
    this.nav && this.nav.bugLog.push("#" + (option.line + 1) + " " + option.name), self.finished = !1,
    self.resetPage();
}, Scene.prototype.nextNonBlankLine = function(includingThisOne) {
    var line, i = this.lineNum;
    for (includingThisOne || i++; isDefined(line = this.lines[i]) && !trim(line); ) i++;
    return line;
}, Scene.prototype.previousNonBlankLineNum = function() {
    for (var line, i = this.lineNum - 1; isDefined(line = this.lines[i]) && !trim(line); ) i--;
    return i;
}, Scene.prototype.resetCheckedPurchases = function() {
    for (var temp in this.temps) /^choice_purchased/.test(temp) && delete this.temps[temp];
}, Scene.prototype.resetPage = function() {
    var self = this;
    this.resetCheckedPurchases(), clearScreen(function() {
        self.save(""), self.prevLine = "empty", self.screenEmpty = !0, self.execute();
    });
}, Scene.prototype.save = function(slot) {
    if (this.saveSlot) transferTempStatWrites(); else {
        if (!slot) {
            slot = "";
            for (var key in tempStatWrites) tempStatWrites.hasOwnProperty(key) && (this.stats[key] = tempStatWrites[key]);
            tempStatWrites = {};
        }
        saveCookie(function() {}, slot, this.stats, this.temps, this.lineNum, this.indent, this.debugMode, this.nav);
    }
}, Scene.prototype.goto = function(line) {
    var label;
    if (label = /[\[\{]/.test(line) ? this.evaluateReference(this.tokenizeExpr(line)) : String(line).toLowerCase(),
    void 0 === this.labels[label]) throw new Error(this.lineMsg() + "bad label " + label);
    this.lineNum = this.labels[label], this.indent = this.getIndent(this.lines[this.lineNum]);
}, Scene.prototype.gosub = function(data) {
    for (var label = /\S+/.exec(data)[0], rest = data.substring(label.length + 1), args = [], stack = this.tokenizeExpr(rest); stack.length; ) args.push(this.evaluateValueToken(stack.shift(), stack));
    this.temps.choice_substack || (this.temps.choice_substack = []), this.temps.choice_substack.push({
        lineNum: this.lineNum,
        indent: this.indent
    }), this.temps.param = args, this.goto(label);
}, Scene.prototype.gosub_scene = function(data) {
    this.stats.choice_subscene_stack || (this.stats.choice_subscene_stack = []), this.stats.choice_subscene_stack.push({
        name: this.name,
        lineNum: this.lineNum + 1,
        indent: this.indent,
        temps: this.temps
    }), this.goto_scene(data);
}, Scene.prototype.params = function(data) {
    var words = /\w+/.exec(data), nextParamNum = 1;
    for (this.temps.param_count = this.temps.param.length; words; ) {
        var varName = words[0];
        if (this.validateVariable(varName), this.temps.param.length < 1) throw new Error(this.lineMsg() + "No parameter passed for " + varName);
        var paramVal = this.temps.param.shift();
        this.temps[varName] = paramVal, this.temps["param_" + nextParamNum] = paramVal,
        nextParamNum++, data = data.substring(varName.length + 1), words = /\w+/.exec(data);
    }
    for (;this.temps.param.length > 0; ) {
        var paramVal = this.temps.param.shift();
        this.temps["param_" + nextParamNum] = paramVal, nextParamNum++;
    }
}, Scene.prototype.return = function() {
    var stackFrame;
    if (this.temps.choice_substack && this.temps.choice_substack.length) stackFrame = this.temps.choice_substack.pop(),
    this.lineNum = stackFrame.lineNum, this.indent = stackFrame.indent; else {
        if (!this.stats.choice_subscene_stack || !this.stats.choice_subscene_stack.length) throw this.temps.choice_substack || this.stats.choice_subscene_stack ? new Error(this.lineMsg() + "invalid return; we've already returned from the last gosub") : new Error(this.lineMsg() + "invalid return; gosub has not yet been called");
        if (stackFrame = this.stats.choice_subscene_stack.pop(), stackFrame.name == this.name) return this.temps = stackFrame.temps,
        this.lineNum = stackFrame.lineNum - 1, void (this.indent = stackFrame.indent);
        this.finished = !0, this.skipFooter = !0;
        var scene = new Scene(stackFrame.name, this.stats, this.nav, {
            debugMode: this.debugMode,
            secondaryMode: this.secondaryMode,
            saveSlot: this.saveSlot
        });
        scene.temps = stackFrame.temps, scene.screenEmpty = this.screenEmpty, scene.prevLine = this.prevLine,
        scene.lineNum = stackFrame.lineNum, scene.indent = stackFrame.indent, scene.accumulatedParagraph = this.accumulatedParagraph,
        scene.execute();
    }
}, Scene.prototype.gotoref = function(expression) {
    var stack = this.tokenizeExpr(expression), value = this.evaluateExpr(stack);
    this.goto(value);
}, Scene.prototype.finish = function(buttonName) {
    this.paragraph(), this.finished = !0;
    var self = this;
    if ("stats" == this.secondaryMode) {
        if ("undefined" == typeof window) return;
        if ("choicescript_stats" == window.forcedScene) return;
        if (window.isAndroidApp && window.statsMode.get()) return;
        return void printButton(buttonName || "Next", main, !1, function() {
            clearScreen(loadAndRestoreGame);
        });
    }
    var nextSceneName = this.nav && nav.nextSceneName(this.name);
    return nextSceneName ? this.screenEmpty ? void this.goto_scene(nextSceneName) : (buttonName || (buttonName = "Next Chapter"),
    buttonName = this.replaceVariables(buttonName), printButton(buttonName, main, !1, function() {
        safeCall(self, function() {
            new Scene(nextSceneName, self.stats, self.nav, {
                debugMode: self.debugMode,
                secondaryMode: self.secondaryMode
            }).resetPage();
        });
    }), void (this.debugMode && println(toJson(this.stats)))) : void (this.secondaryMode || this.ending());
}, Scene.prototype.autofinish = function(buttonName) {
    this.finish(buttonName);
}, Scene.prototype.reset = function() {
    this.nav.resetStats(this.stats), this.stats.scene = this;
}, Scene.prototype.parseGotoScene = function(data) {
    var sceneName, label, stack, param = [];
    if (/[\[\{]/.test(data)) for (stack = this.tokenizeExpr(data), sceneName = this.evaluateReference(stack, {
        toLowerCase: !1
    }), stack.length && (label = this.evaluateReference(stack)); stack.length; ) param.push(this.evaluateValueToken(stack.shift(), stack)); else {
        var match = /(\S+)\s+(\S+)\s*(.*)/.exec(data);
        if (match) for (sceneName = match[1], label = match[2], stack = this.tokenizeExpr(match[3]); stack.length; ) param.push(this.evaluateValueToken(stack.shift(), stack)); else {
            if ("" === data) throw new Error(this.lineMsg() + "missing scene name");
            sceneName = data;
        }
    }
    return {
        sceneName: sceneName,
        label: label,
        param: param
    };
}, Scene.prototype.goto_scene = function(data) {
    var result = this.parseGotoScene(data);
    if (result.sceneName == this.name) return void 0 === result.label ? this.lineNum = 0 : this.goto(result.label),
    this.temps = {
        choice_reuse: "allow",
        choice_user_restored: !1,
        _choiceEnds: {}
    }, this.temps.param = result.param, void (this.initialCommands = !0);
    this.finished = !0, this.skipFooter = !0;
    var scene = new Scene(result.sceneName, this.stats, this.nav, {
        debugMode: this.debugMode,
        secondaryMode: this.secondaryMode,
        saveSlot: this.saveSlot
    });
    scene.screenEmpty = this.screenEmpty, scene.prevLine = this.prevLine, scene.accumulatedParagraph = this.accumulatedParagraph,
    void 0 !== result.label && (scene.targetLabel = {
        label: result.label,
        origin: this.name,
        originLine: this.lineNum
    }), void 0 !== result.param && (scene.temps.param = result.param), scene.execute();
}, Scene.prototype.redirect_scene = function(data) {
    if ("stats" != this.secondaryMode) throw new Error(this.lineMsg() + "The *redirect_scene command can only be used from the stats screen.");
    var sceneName, label, args = trim(data).split(/ /);
    1 == args.length ? sceneName = data : (sceneName = args[0], label = args[1]), this.finished = !0,
    this.skipFooter = !0;
    var self = this;
    redirectFromStats(sceneName, label, this.lineNum, function() {
        delete self.secondaryMode, self.goto_scene(data);
    });
}, Scene.prototype.product = function(productId) {
    if (!/^[a-z]+$/.test(productId)) throw new Error(this.lineMsg() + "Invalid product id: " + productId);
    this.nav && (this.nav.products[productId] = {});
}, Scene.prototype.restore_purchases = function(data) {
    var self = this, target = this.target;
    target || (target = document.getElementById("text"));
    var button = printButton("Restore Purchases", target, !1, function() {
        safeCall(self, function() {
            restorePurchases(null, function() {
                self.goto(data), self.finished = !1, self.resetPage();
            });
        });
    });
    setClass(button, ""), this.prevLine = "block";
}, Scene.prototype.check_purchase = function(data) {
    this.finished = !0, this.skipFooter = !0;
    for (var self = this, productList = data.split(/ /), i = 0; i < productList.length; i++) {
        var product = productList[i];
        if (!this.nav.products[product] && "adfree" != product) throw new Error(this.lineMsg() + "The product " + product + " wasn't declared in a *product command");
    }
    checkPurchase(data, function(ok, result) {
        self.finished = !1, self.skipFooter = !1, ok || (result = {
            billingSupported: !0
        }, self.temps.choice_purchase_error = !0), result = result || {};
        for (var products = data.split(/ /), everything = !0, i = 0; i < products.length; i++) {
            var purchasedProduct = result[products[i]] || !1;
            self.temps["choice_purchased_" + products[i]] = purchasedProduct, purchasedProduct || (everything = !1);
        }
        self.temps.choice_purchased_everything = everything, self.temps.choice_purchase_supported = !!result.billingSupported,
        self.execute();
    });
}, Scene.prototype.purchase = function(data) {
    var result = /^(\w+)\s+(\S+)\s+(.*)/.exec(data);
    if (!result) throw new Error(this.lineMsg() + "invalid line; can't parse purchaseable product: " + data);
    var product = result[1], priceGuess = trim(result[2]), label = trim(result[3]);
    if (!this.nav.products[product] && "adfree" != product) throw new Error(this.lineMsg() + "The product " + product + " wasn't declared in a *product command");
    if (void 0 === this.temps["choice_purchased_" + product]) throw new Error(this.lineMsg() + "Didn't check_purchases on this page");
    this.finished = !0, this.skipFooter = !0;
    var self = this;
    getPrice(product, function(price) {
        if (price && "free" != price) {
            "guess" == price && (price = priceGuess);
            var buttonText, prerelease = "undefined" != typeof window && window.releaseDate && window.isWeb && window.releaseDate > new Date();
            buttonText = prerelease ? "Pre-Order It" : "Buy It Now", "hide" != price && (buttonText += " for " + price);
            var target = self.target;
            target || (target = document.getElementById("text")), self.paragraph();
            printButton(buttonText, target, !1, function() {
                safeCall(self, function() {
                    purchase(product, function() {
                        safeCall(self, function() {
                            self.goto(label), self.finished = !1, self.resetPage();
                        });
                    });
                });
            });
            self.prevLine = "block", isRestorePurchasesSupported() && (self.prevLine = "text",
            printLink(printParagraph("If you've already purchased, click here to "), "#", "restore purchases", function(e) {
                preventDefault(e), safeCall(self, function() {
                    restorePurchases(product, function(purchased) {
                        purchased ? (self.goto(label), self.finished = !1, self.resetPage()) : self.secondaryMode || clearScreen(loadAndRestoreGame);
                    });
                });
            })), self.skipFooter = !1, self.finished = !1, self.execute();
        } else self.goto(label), self.finished = !1, self.resetPage();
    });
}, Scene.prototype.purchase_discount = function(line) {
    this.paragraph();
    var args = trim(String(line)).split(" ");
    if (5 != args.length) throw new Error(this.lineMsg() + "expected five arguments, saw " + args.length + ": " + line);
    var product = args[0], expectedEndDateString = args[1], expectedEndDate = parseDateStringInCurrentTimezone(expectedEndDateString, this.lineNum + 1), fullPriceGuess = this.replaceVariables(args[2]), discountedPriceGuess = this.replaceVariables(args[3]), label = args[4], startsWithDollar = /^\$/;
    if (!startsWithDollar.test(fullPriceGuess)) throw new Error(this.lineMsg() + "full price guess " + fullPriceGuess + "doesn't start with dollar: " + line);
    if (!startsWithDollar.test(discountedPriceGuess)) throw new Error(this.lineMsg() + "discounted price guess " + discountedPriceGuess + "doesn't start with dollar: " + line);
    var discountText, prerelease = "undefined" != typeof window && window.releaseDate && window.isWeb && window.releaseDate > new Date();
    discountText = prerelease ? "[b]Buy now before the price increases![/b]" : "[b]On sale until " + shortMonthStrings[expectedEndDate.getMonth() + 1] + " " + expectedEndDate.getDate() + "! Buy now before the price increases![/b]",
    "undefined" != typeof printDiscount && printDiscount(product, expectedEndDate.getYear() + 1900, expectedEndDate.getMonth() + 1, expectedEndDate.getDate(), discountText);
    var priceGuess;
    priceGuess = new Date().getTime() < expectedEndDate.getTime() ? discountedPriceGuess : fullPriceGuess,
    this.purchase([ product, priceGuess, label ].join(" "));
}, Scene.prototype.print_discount = function(line) {
    var result = /(\w+) (\d{4})-(\d{2})-(\d{2}) (.*$)/.exec(line);
    if (!result) throw new Error("invalid discount: " + line);
    var product = result[1], fullYear = result[2], oneBasedMonthNumber = parseInt(result[3], 10), dayOfMonth = parseInt(result[4], 10), discountText = result[5];
    this.temps.choice_discount_ends = "POISONTOKEN", discountText = this.replaceVariables(discountText).replace("POISONTOKEN", "${choice_discount_ends}"),
    delete this.temps.choice_discount_ends, "undefined" != typeof printDiscount && printDiscount(product, fullYear, oneBasedMonthNumber, dayOfMonth, discountText);
}, Scene.prototype.abort = function() {
    this.paragraph(), this.finished = !0;
}, Scene.prototype.create = function(line) {
    function complexError() {
        throw new Error(self.lineMsg() + "Invalid create instruction, value must be a a number, true/false, or a quoted string: " + line);
    }
    var result = /^(\w*)(.*)/.exec(line);
    if (!result) throw new Error(this.lineMsg() + "Invalid create instruction, no variable specified: " + line);
    var variable = result[1];
    this.validateVariable(variable), variable = variable.toLowerCase();
    var expr = result[2], stack = this.tokenizeExpr(expr);
    if (0 === stack.length) throw new Error(this.lineMsg() + "Invalid create instruction, no value specified: " + line);
    var self = this;
    stack.length > 1 && complexError();
    var token = stack[0];
    if (/STRING|NUMBER|VAR/.test(token.name) || complexError(), "VAR" != token.name || /^true|false$/i.test(token.value) || complexError(),
    "STRING" == token.name && /(\$|@)!?!?{/.test(token.value)) throw new Error(this.lineMsg() + "Invalid create instruction, value must be a simple string without ${} or @{}: " + line);
    var value = this.evaluateExpr(stack);
    this.stats[variable] = value, this.nav && (this.nav.startingStats[variable] = value);
}, Scene.prototype.temp = function(line) {
    var result = /^(\w*)(.*)/.exec(line);
    if (!result) throw new Error(this.lineMsg() + "Invalid temp instruction, no variable specified: " + line);
    var variable = result[1];
    this.validateVariable(variable);
    var expr = result[2], stack = this.tokenizeExpr(expr);
    if (0 === stack.length) return void (this.temps[variable.toLowerCase()] = null);
    var value = this.evaluateExpr(stack);
    this.temps[variable.toLowerCase()] = value;
}, Scene.prototype.getVar = function(variable) {
    var value;
    if ((variable = String(variable).toLowerCase()) && !isNaN(1 * variable) && String(1 * variable) === variable) return 1 * variable;
    if ("true" == variable) return !0;
    if ("false" == variable) return !1;
    if ("choice_subscribe_allowed" == variable) return !0;
    if ("choice_register_allowed" == variable) return isRegisterAllowed();
    if ("choice_registered" == variable) return "undefined" != typeof window && !!window.registered;
    if ("choice_is_web" == variable) return "undefined" != typeof window && !!window.isWeb;
    if ("choice_is_steam" == variable) return "undefined" != typeof window && !!window.isSteamApp;
    if ("choice_is_ios_app" == variable) return "undefined" != typeof window && !!window.isIosApp;
    if ("choice_is_advertising_supported" == variable) return "undefined" != typeof isAdvertisingSupported && !!isAdvertisingSupported();
    if ("choice_is_trial" == variable) return !("undefined" == typeof isTrial || !isTrial);
    if ("choice_release_date" == variable) return "undefined" != typeof window && window.releaseDate ? simpleDateTimeFormat(window.releaseDate) : "release day";
    if ("choice_prerelease" == variable) return !("undefined" == typeof window || !window.releaseDate) && new Date() < window.releaseDate.getTime();
    if ("choice_kindle" == variable) return !1;
    if ("choice_randomtest" == variable) return !!this.randomtest;
    if ("choice_quicktest" == variable) return !1;
    if ("choice_restore_purchases_allowed" == variable) return isRestorePurchasesSupported();
    if ("choice_save_allowed" == variable) return areSaveSlotsSupported();
    if ("choice_time_stamp" == variable) return Math.floor(new Date() / 1e3);
    if ("choice_nightmode" == variable) return "undefined" != typeof isNightMode && isNightMode();
    if (!this.temps.hasOwnProperty(variable)) {
        if (!this.stats.hasOwnProperty(variable)) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
        if (null === (value = this.stats[variable]) || void 0 === value) throw new Error(this.lineMsg() + "Variable '" + variable + "' exists but has no value");
        return this.debugMode && println("stats[" + variable + "]==" + value), value;
    }
    if (null === (value = this.temps[variable]) || void 0 === value) throw new Error(this.lineMsg() + "Variable '" + variable + "' exists but has no value");
    return this.debugMode && println("temps[" + variable + "]==" + value), value;
}, Scene.prototype.setVar = function(variable, value) {
    if (variable = variable.toLowerCase(), this.debugMode && println(variable + "=" + value),
    void 0 === this.temps[variable]) {
        if (void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
        this.stats[variable] = value, "temp" == this.saveSlot && (tempStatWrites[variable] = value),
        "implicit_control_flow" == variable && this.nav && (this.nav.startingStats.implicit_control_flow = value);
    } else this.temps[variable] = value;
}, Scene.prototype.delete = function(variable) {
    if (variable = variable.toLowerCase(), void 0 === this.temps[variable]) {
        if (void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
        delete this.stats[variable];
    } else delete this.temps[variable];
}, Scene.prototype.parseOptions = function(startIndent, choicesRemaining, expectedSubOptions) {
    function removeModifierCommand(stripParethentical) {
        if (stripParethentical) {
            var openParen = line.indexOf("(") + 1, closingParen = matchBracket(line, "()", openParen);
            if (-1 == closingParen) throw new Error(self.lineMsg() + "missing closing parenthesis");
            line = trim(line.substr(closingParen + 1));
        } else line = trim(line.replace(/^\s*\*(\w+)(.*)/, "$2"));
        parsed = /^\s*\*(\w+)(.*)/.exec(line), parsed ? (command = parsed[1].toLowerCase(),
        data = trim(parsed[2])) : command = "";
    }
    var line, nextIndent = null, options = [], choiceEnds = [], currentChoice = choicesRemaining[0];
    currentChoice || (currentChoice = "choice");
    for (var previousSubOptions, prevOption, ifResult, suboptionsEncountered = !1, bodyExpected = !1, namesEncountered = {}, atLeastOneSelectableOption = !1, startingLine = this.lineNum, self = this; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null === nextIndent || void 0 === nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one '" + currentChoice + "'");
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) {
            if (choicesRemaining.length > 1 && !suboptionsEncountered) throw new Error(this.lineMsg() + "invalid indent, there were subchoices remaining: [" + choicesRemaining.join(",") + "]");
            if (bodyExpected && (void 0 === this.temps._fakeChoiceDepth || this.temps._fakeChoiceDepth < 1)) throw new Error(this.lineMsg() + "Expected choice body");
            for (atLeastOneSelectableOption || this.conflictingOptions("line " + (startingLine + 1) + ": No selectable options"),
            expectedSubOptions && this.verifyOptionsMatch(expectedSubOptions, options), this.rollbackLineCoverage(),
            prevOption = options[options.length - 1], this.lineNum = this.previousNonBlankLineNum(),
            prevOption.endLine || (prevOption.endLine = this.lineNum + 1), i = 0; i < choiceEnds.length; i++) this.temps._choiceEnds[choiceEnds[i]] = this.lineNum;
            return this.rollbackLineCoverage(), options;
        }
        if (indent < this.indent && (this.dedent(indent), this.indent = indent), indent > this.indent) {
            if (choicesRemaining.length > 1) throw new Error(this.lineMsg() + "invalid indent, there were subchoices remaining: [" + choicesRemaining.join(",") + "]");
            this.rollbackLineCoverage(), bodyExpected = !1;
        } else {
            options.length && (prevOption = options[options.length - 1], prevOption.endLine || (prevOption.endLine = this.lineNum));
            var parsed = /^\s*\*(\w+)(.*)/.exec(line), unselectable = !1, inlineIf = null, selectableIf = null, self = this, reuse = this.temps.choice_reuse;
            if (parsed) {
                var command = parsed[1].toLowerCase(), data = trim(parsed[2]);
                if ("hide_reuse" == command && (reuse = "hide", !0, removeModifierCommand()), "disable_reuse" == command && (reuse = "disable",
                !0, removeModifierCommand()), "allow_reuse" == command && (reuse = "allow", !0,
                removeModifierCommand()), "print" == command) line = this.evaluateExpr(this.tokenizeExpr(data)); else if ("if" == command) {
                    if (!(ifResult = this.parseOptionIf(data, command))) {
                        this.if(data, !0);
                        continue;
                    }
                    if (choiceEnds.push(this.lineNum), inlineIf = ifResult.condition, !ifResult.result) continue;
                    line = ifResult.line;
                } else {
                    if (/^(else|elseif|elsif)$/.test(command)) {
                        this[command](data, !0);
                        continue;
                    }
                    if ("selectable_if" == command) {
                        if (!(ifResult = this.parseOptionIf(data, command))) throw new Error(this.lineMsg() + "Couldn't parse the line after *selectable_if: " + data);
                        line = ifResult.line, selectableIf = ifResult.condition, unselectable = unselectable || !ifResult.result;
                    } else {
                        if ("comment" == command) continue;
                        if (command) throw Scene.validCommands[command] ? new Error(this.lineMsg() + "Invalid indent? Expected an #option here, not *" + command) : new Error(this.lineMsg() + "Non-existent command '" + command + "'");
                    }
                }
            }
            if ("allow" != reuse && (this.temps.choice_used || (this.temps.choice_used = {}),
            this.temps.choice_used[this.lineNum])) {
                if ("hide" == reuse) continue;
                unselectable = !0;
            }
            if (!/^\s*\#\s*\S/.test(line)) throw new Error(this.lineMsg() + "Expected option starting with #");
            this.replaceVariables(line), line = trim(trim(line).substring(1));
            var option = {
                name: line,
                group: currentChoice
            };
            if ("allow" != reuse && (option.reuse = reuse), this.displayOptionConditions) {
                option.displayIf = [];
                for (var i = 0; i < this.displayOptionConditions.length; i++) option.displayIf[i] = this.displayOptionConditions[i];
                inlineIf && option.displayIf.push(inlineIf);
            } else inlineIf && (option.displayIf = [ inlineIf ]);
            selectableIf && (option.selectableIf = selectableIf), option.line = this.lineNum + 1,
            unselectable && (option.unselectable = !0), namesEncountered[line] ? this.conflictingOptions(this.lineMsg() + "Invalid option; conflicts with option '" + option.name + "' on line " + namesEncountered[line]) : namesEncountered[line] = option.line,
            options.push(option), choicesRemaining.length > 1 ? (option.suboptions = this.parseOptions(this.indent, choicesRemaining.slice(1), previousSubOptions),
            this.indent = nextIndent, previousSubOptions || (previousSubOptions = option.suboptions),
            suboptionsEncountered = !0) : bodyExpected = !0, unselectable || (atLeastOneSelectableOption = !0);
        }
    } else this.rollbackLineCoverage();
    if (bodyExpected && (void 0 === this.temps._fakeChoiceDepth || this.temps._fakeChoiceDepth < 1)) throw new Error(this.lineMsg() + "Expected choice body");
    return prevOption = options[options.length - 1], prevOption.endLine || (prevOption.endLine = this.lineNum),
    atLeastOneSelectableOption || this.conflictingOptions("line " + (startingLine + 1) + ": No selectable options"),
    options;
}, Scene.prototype.parseOptionIf = function(data) {
    var parsed = /^\s*\((.*)\)\s+(#.*)/.exec(data);
    if (parsed) {
        var condition = parsed[1], stack = this.tokenizeExpr(condition), result = this.evaluateExpr(stack);
        return this.debugMode && println(condition + " :: " + result), result = bool(result, this.lineNum + 1),
        result = result || this.testPath, {
            result: result,
            line: parsed[2],
            condition: null
        };
    }
}, Scene.prototype.conflictingOptions = function(str) {
    throw new Error(str);
}, Scene.prototype.verifyOptionsMatch = function(prev, current) {
    function findMatch(name, options) {
        for (var i = 0; i < options.length; i++) {
            var option = options[i];
            if (option && name == option.name) return option;
        }
        return null;
    }
    for (var prevOpt, curOpt, i = 0; i < prev.length; i++) if (prevOpt = prev[i], !(curOpt = findMatch(prevOpt.name, current))) throw new Error(this.lineMsg() + "Missing expected suboption '" + prevOpt.name + "'; all suboptions must have same option list");
    if (prev.length != current.length) {
        for (i = 0; i < current.length; i++) if (curOpt = current[i], !(prevOpt = findMatch(curOpt.name, prev))) throw new Error(this.lineMsg() + "Added unexpected suboption '" + curOpt.name + "'; all suboptions must have same option list");
        throw new Error(this.lineMsg() + "Bug? previous options and current options mismatch, but no particular missing element");
    }
}, Scene.prototype.renderOptions = function(groups, options, callback) {
    for (var i = 0; i < options.length; i++) {
        var option = options[i];
        option.name = this.replaceVariables(option.name);
    }
    this.paragraph(), printOptions(groups, options, callback), this.debugMode && println(toJson(this.stats)),
    this.finished && printFooter();
}, Scene.prototype.page_break = function(buttonName) {
    if (!this.screenEmpty) {
        buttonName || (buttonName = "Next"), buttonName = this.replaceVariables(buttonName),
        this.paragraph(), this.finished = !0;
        var self = this;
        printButton(buttonName, main, !1, function() {
            self.finished = !1, self.resetPage();
        }), this.debugMode && println(toJson(this.stats));
    }
}, Scene.prototype.line_break = function() {
    this.accumulatedParagraph.length ? this.accumulatedParagraph.push("[n/]") : println();
}, Scene.prototype.image = function(data, invert) {
    this.paragraph(), data = data || "", data = this.replaceVariables(data);
    var source, alignment, args = data.split(" "), alt = null;
    if (args.length > 2) var source = args[0], alignment = args[1], alt = trim(args[2]); else if (args.length > 1) var source = args[0], alignment = args[1]; else var source = data;
    if ("" === source) throw new Error(this.lineMsg() + "*image requires the file name of an image");
    if (alignment = alignment || "center", !/(right|left|center|none)/.test(alignment)) throw new Error(this.lineMsg() + "Invalid alignment, expected right, left, center, or none: " + data);
    printImage(source, alignment, alt, invert), this.verifyImage && this.verifyImage(source),
    "none" == alignment && (this.prevLine = "text"), this.screenEmpty = !1;
}, Scene.prototype.text_image = function(data) {
    this.image(data, "invert");
}, Scene.prototype.sound = function(source) {
    "function" == typeof playSound && playSound(source), this.verifyImage && this.verifyImage(source);
}, Scene.prototype.youtube = function(slug) {
    "undefined" != typeof printYoutubeFrame && (printYoutubeFrame(slug), this.prevLine = "block",
    this.screenEmpty = !1);
}, Scene.prototype.link = function(data) {
    var result = /^(\S+)\s*(.*)/.exec(data);
    if (!result) throw new Error(this.lineMsg() + "invalid line; this line should have an URL: " + data);
    var href = result[1].replace(/\]/g, "%5D"), anchorText = trim(result[2]) || href;
    this.printLine("[url=" + href + "]" + anchorText + "[/url]"), this.prevLine = "text",
    this.screenEmpty = !1;
}, Scene.prototype.link_button = function(data) {
    if ("undefined" != typeof window) {
        var result = /^(\S+)\s*(.*)/.exec(data);
        if (!result) throw new Error(this.lineMsg() + "invalid line; this line should have an URL: " + data);
        var href = result[1], anchorText = trim(result[2]) || href, target = this.target;
        target || (target = document.getElementById("text")), printButton(anchorText, target, !1, function() {
            window.location.href = href;
        }), this.prevLine = "empty", this.screenEmpty = !1;
    }
}, Scene.prototype.getIndent = function(line) {
    if (null === line || void 0 === line) return 0;
    var spaces = line.match(/^([ \t]*)/);
    if (null === spaces || void 0 === spaces) return 0;
    var whitespace = spaces[0], len = whitespace.length;
    if (0 === len) return 0;
    var tab = /\t/.test(whitespace), space = / /.test(whitespace);
    if (tab && space) throw new Error(this.lineMsg() + "Tabs and spaces appear on the same line");
    if (tab) {
        if (this.firstTab = this.lineNum + 1, this.firstSpace) throw new Error(this.lineMsg() + "Illegal mixing of spaces and tabs; this line has a tab, but there were spaces on line " + this.firstSpace);
    } else if (this.firstSpace = this.lineNum + 1, this.firstTab) throw new Error(this.lineMsg() + "Illegal mixing of spaces and tabs; this line has a space, but there were tabs on line " + this.firstTab);
    return len;
}, Scene.prototype.comment = function(line) {
    this.debugMode && println("*comment " + line);
}, Scene.prototype.advertisement = function() {
    if ("undefined" != typeof isFullScreenAdvertisingSupported && isFullScreenAdvertisingSupported()) {
        this.finished = !0, this.skipFooter = !0;
        var self = this;
        showFullScreenAdvertisement(function() {
            self.finished = !1, self.skipFooter = !1, self.resetPage();
        });
    }
}, Scene.prototype.looplimit = function() {}, Scene.prototype.hide_reuse = function() {
    this.temps.choice_reuse = "hide";
}, Scene.prototype.disable_reuse = function() {
    this.temps.choice_reuse = "disable";
}, Scene.prototype.allow_reuse = function() {
    this.temps.choice_reuse = "allow";
}, Scene.prototype.label = function() {}, Scene.prototype.print = function(expr) {
    var value = this.evaluateExpr(this.tokenizeExpr(expr));
    this.prevLine = "text", this.screenEmpty = !1, this.printLine(value);
}, Scene.prototype.input_text = function(line) {
    var stack = this.tokenizeExpr(line), variable = this.evaluateReference(stack);
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    var inputType = "text";
    if (1 == stack.length && "VAR" == stack[0].name && "long" == stack[0].value && (inputType = "textarea"),
    void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    this.finished = !0, this.paragraph();
    var self = this;
    printInput(this.target, inputType, function(value) {
        safeCall(self, function() {
            value = trim(String(value)), value = value.replace(/\n/g, "[n/]"), self.nav && self.nav.bugLog.push("*input_text " + variable + " " + value),
            self.finished = !1, self.setVar(variable, value), self.resetPage();
        });
    }), this.debugMode && println(toJson(this.stats));
}, Scene.prototype.input_number = function(data) {
    function isInt(x) {
        var y = parseInt(x, 10);
        return !isNaN(y) && (x == y && x.toString() == y.toString());
    }
    var stack = this.tokenizeExpr(data);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    var variable = this.evaluateReference(stack);
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    var simpleConstants;
    if (simpleConstants = 2 == stack.length && "NUMBER" == stack[0].name && "NUMBER" == stack[1].name,
    !stack.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    var minimum = this.evaluateValueToken(stack.shift(), stack);
    if (isNaN(1 * minimum)) throw new Error(this.lineMsg() + "Invalid minimum, not numeric: " + minimum);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    var maximum = this.evaluateValueToken(stack.shift(), stack);
    if (stack.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    if (isNaN(1 * maximum)) throw new Error(this.lineMsg() + "Invalid maximum, not numeric: " + maximum);
    if ((!this.quicktest || simpleConstants) && parseFloat(minimum) > parseFloat(maximum)) throw new Error(this.lineMsg() + "Minimum " + minimum + " should not be greater than maximum " + maximum);
    var intRequired;
    isInt(minimum) && isInt(maximum) && (intRequired = 1), this.finished = !0, this.paragraph();
    var self = this;
    printInput(this.target, "number", function(value) {
        safeCall(self, function() {
            var numValue = parseFloat("" + value);
            return isNaN(numValue) ? void asyncAlert("Please type in a number.") : intRequired && !isInt(value) ? void asyncAlert("Please type in an integer number.") : numValue < 1 * minimum ? void asyncAlert("Please use a number greater than or equal to " + minimum) : numValue > 1 * maximum && !this.quicktest ? void asyncAlert("Please use a number less than or equal to " + maximum) : (self.nav && self.nav.bugLog.push("*input_number " + variable + " " + value),
            self.finished = !1, self.setVar(variable, numValue), void self.resetPage());
        });
    }, minimum, maximum, intRequired), this.debugMode && println(toJson(this.stats));
}, Scene.prototype.script = function script(code) {
    var stats = this.stats, temps = this.temps;
    try {
        "undefined" == typeof window ? function() {
            var window = _global;
            eval(code);
        }.call(this) : eval(code);
    } catch (e) {
        throw new Error(this.lineMsg() + "error executing *script: " + e + (e.stack ? "\n" + e.stack : ""));
    }
}, Scene.prototype.validateVariable = function(variable) {
    if (!variable || !/^[a-zA-Z]/.test(variable)) throw new Error(this.lineMsg() + "Invalid variable name, must start with a letter: " + variable);
    if (!/^\w+$/.test(variable)) throw new Error(this.lineMsg() + "Invalid variable name: '" + variable + "'");
    if (/^(and|or|true|false)$/.test(variable)) throw new Error(this.lineMsg() + "Invalid variable name, '" + variable + "' is a reserved word");
    if (/^choice_/.test(variable)) throw new Error(this.lineMsg() + "Invalid variable name, variables may not start with 'choice_'; this is a reserved prefix");
}, Scene.prototype.rand = function(data) {
    function isInt(x) {
        var y = parseInt(x, 10);
        return !isNaN(y) && (x == y && x.toString() == y.toString());
    }
    var stack = this.tokenizeExpr(data);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var variable = this.evaluateReference(stack);
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var minimum = this.evaluateValueToken(stack.shift(), stack);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var maximum = this.evaluateValueToken(stack.shift(), stack);
    if (stack.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var diff;
    if (diff = maximum - minimum, isNaN(diff)) throw new Error(this.lineMsg() + "Invalid rand statement, min and max must be numbers");
    if (diff < 0) throw new Error(this.lineMsg() + "Invalid rand statement, min must be less than max: " + minimum + " > " + maximum);
    if (0 === diff) return void this.setVar(variable, minimum);
    var result, random = Math.random();
    result = isInt(minimum) && isInt(maximum) ? 1 * minimum + Math.floor(random * (diff + 1)) : 1 * minimum + random * diff,
    this.setVar(variable, result), this.randomLog && this.randomLog("*rand " + variable + " " + result),
    this.nav && this.nav.bugLog.push("*rand " + variable + " " + result);
}, Scene.prototype.set = function(line) {
    var stack = this.tokenizeExpr(line), variable = this.evaluateReference(stack);
    if (void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    if (0 === stack.length) throw new Error(this.lineMsg() + "Invalid set instruction, no expression specified: " + line);
    /OPERATOR|FAIRMATH/.test(stack[0].name) && stack.unshift({
        name: "VAR",
        value: variable,
        pos: "(implicit)"
    });
    var value = this.evaluateExpr(stack);
    this.setVar(variable, value);
}, Scene.prototype.setref = function(line) {
    var stack = this.tokenizeExpr(line), variable = this.evaluateValueToken(stack.shift(), stack);
    if (variable = String(variable).toLowerCase(), void 0 === this.temps[variable] && void 0 === this.stats[variable]) throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
    /OPERATOR|FAIRMATH/.test(stack[0].name) && stack.unshift({
        name: "VAR",
        value: variable,
        pos: "(implicit)"
    });
    var value = this.evaluateExpr(stack);
    this.setVar(variable, value);
}, Scene.prototype.share_this_game = function(now) {
    now = !!trim(now), this.paragraph(), printShareLinks(this.target, now), this.prevLine = "empty";
}, Scene.prototype.more_games = function(now) {
    if ("undefined" != typeof window && "undefined" != typeof moreGames) {
        if (trim(now)) return void moreGames();
        var self = this, target = this.target;
        target || (target = document.getElementById("text"));
        var button = printButton("Play More Games Like This", target, !1, function() {
            safeCall(self, moreGames);
        });
        setClass(button, ""), this.prevLine = "block";
    }
}, Scene.prototype.ending = function() {
    function endingMenu() {
        printFollowButtons(), self.renderOptions([ "" ], options, function(option) {
            if (option.restart) return void clearScreen(function() {
                self.restart(), "startup" === self.name && (self.finished = !1, self.resetPage());
            });
            option.moreGames ? (self.more_games("now"), "undefined" != typeof curl && curl()) : option.share ? clearScreen(function() {
                self.share_this_game("now"), endingMenu();
            }) : option.subscribe && subscribeLink();
        });
    }
    if ("undefined" != typeof window) {
        this.paragraph();
        options = [], options.push({
            name: "Play again.",
            group: "choice",
            restart: !0
        }), options.push({
            name: "Play more games like this.",
            group: "choice",
            moreGames: !0
        }), options.push({
            name: "Share this game with friends.",
            group: "choice",
            share: !0
        }), options.push({
            name: "Email me when new games are available.",
            group: "choice",
            subscribe: !0
        });
        var self = this;
        endingMenu(), this.finished = !0;
    }
}, Scene.prototype.restart = function() {
    if (this.secondaryMode && "stats" != this.secondaryMode) throw new Error(this.lineMsg() + "Cannot *restart in " + this.secondaryMode + " mode");
    delayBreakEnd(), this.reset();
    var startupScene = this.nav.getStartupScene();
    "stats" == this.secondaryMode ? this.redirect_scene(startupScene) : this.goto_scene(startupScene);
}, Scene.prototype.subscribe = function(data) {
    this.paragraph();
    var options = {};
    if (data) try {
        options = JSON.parse(data);
    } catch (e) {
        throw new Error(this.lineMsg() + "Couldn't parse subscribe arguments: " + data);
    }
    this.prevLine = "block", this.finished = !0, this.skipFooter = !0;
    var self = this;
    subscribe(this.target, options, function(now) {
        self.finished = !1, now ? (self.skipFooter = !1, self.execute()) : self.resetPage();
    });
}, Scene.prototype.restore_game = function(data) {
    function renderRestoreMenu(saveList, dirtySaveList) {
        self.paragraph();
        for (var options = [], i = 0; i < saveList.length; i++) {
            var save = saveList[i], date = new Date(1 * save.timestamp);
            if (save) {
                var name = "";
                save.temps && save.temps.choice_restore_name && (name = save.temps.choice_restore_name),
                options.push({
                    name: name + " (" + simpleDateTimeFormat(date) + ")",
                    group: "choice",
                    state: save
                });
            }
        }
        options.push({
            name: "Retrieve saved games online from choiceofgames.com.",
            group: "choice",
            fetch: !0
        }), dirtySaveList.length && options.push({
            name: "Upload saved games to choiceofgames.com.",
            group: "choice",
            upload: !0
        }), options.push({
            name: "Cancel.",
            group: "choice",
            cancel: !0
        });
        var groups = [ "" ];
        self.renderOptions(groups, options, function(option) {
            if (option.upload) clearScreen(function() {
                fetchEmail(function(defaultEmail) {
                    self.printLine("Please type your email address to identify yourself."), self.paragraph(),
                    promptEmailAddress(this.target, defaultEmail, "allowContinue", function(cancel, email) {
                        if (cancel) return self.finished = !1, void 0 !== cancelLabel && self.goto(cancelLabel),
                        void self.resetPage();
                        clearScreen(function() {
                            startLoading(), submitDirtySaves(dirtySaveList, email, function(ok) {
                                if (doneLoading(), self.prevLine = "text", ok) {
                                    var count = dirtySaveList.length + (1 == dirtySaveList.length ? " save" : " saves");
                                    self.printLine("Uploaded " + count + "."), renderRestoreMenu(saveList, []);
                                } else self.printLine("Error uploading saves. Please try again later."), renderRestoreMenu(saveList, dirtySaveList);
                            });
                        });
                    });
                });
            }); else if (option.fetch) clearScreen(function() {
                fetchEmail(function(defaultEmail) {
                    self.printLine("Please type your email address to identify yourself."), self.paragraph(),
                    promptEmailAddress(this.target, defaultEmail, "allowContinue", function(cancel, email) {
                        if (cancel) return self.finished = !1, void 0 !== cancelLabel && self.goto(cancelLabel),
                        void self.resetPage();
                        clearScreen(function() {
                            startLoading(), getRemoteSaves(email, function(remoteSaveList) {
                                doneLoading(), self.prevLine = "text", remoteSaveList ? mergeRemoteSaves(remoteSaveList, "recordDirty", function(saveList, newRemoteSaves, dirtySaveList) {
                                    if (remoteSaveList.length) {
                                        var downloadCount = remoteSaveList.length + " saved " + (1 == remoteSaveList.length ? "game" : "games"), newCount = newRemoteSaves + " new saved " + (1 == newRemoteSaves ? "game" : "games");
                                        self.printLine("Synchronized " + downloadCount + ". Downloaded " + newCount + "."),
                                        renderRestoreMenu(saveList, dirtySaveList);
                                    } else self.printLine('No saves downloaded for email address "' + email + "\". (Is that the correct email address?) If you're having trouble, please contact support at " + getSupportEmail() + "."),
                                    renderRestoreMenu(saveList, dirtySaveList);
                                }) : (self.printLine("Error downloading saves. Please try again later."), renderRestoreMenu(saveList, dirtySaveList));
                            });
                        });
                    });
                });
            }); else if (option.password) clearScreen(function() {
                self.restore_password();
            }); else if (option.cancel) self.finished = !1, void 0 !== cancelLabel && self.goto(cancelLabel),
            self.resetPage(); else {
                var state = option.state, sceneName = null;
                state.stats && state.stats.sceneName && (sceneName = ("" + state.stats.sceneName).toLowerCase());
                var unrestorable = unrestorableScenes[sceneName];
                if (unrestorable) return asyncAlert(unrestorable), self.finished = !1, void self.resetPage();
                saveCookie(function() {
                    clearScreen(function() {
                        restoreGame(state, null, !0);
                    });
                }, "", state.stats, state.temps, state.lineNum, state.indent, this.debugMode, this.nav);
            }
        });
    }
    var cancelLabel;
    if (data) {
        var result = /^cancel=(\S+)$/.exec(data);
        if (!result) throw new Error(this.lineMsg() + "invalid restore_game line: " + data);
        cancelLabel = result[1];
    }
    this.finished = !0, this.skipFooter = !0;
    var self = this, unrestorableScenes = this.parseRestoreGame(!1);
    getDirtySaveList(function(dirtySaveList) {
        getSaves(function(saveList) {
            renderRestoreMenu(saveList, dirtySaveList);
        });
    });
}, Scene.prototype.restore_password = function() {
    var alreadyFinished = this.finished;
    this.finished = !0, this.paragraph(), this.printLine('Please paste your password here, then press "Next" below to continue.'),
    this.prevLine = "text", this.paragraph();
    var self = this, unrestorableScenes = this.parseRestoreGame(alreadyFinished);
    getPassword(this.target, function(cancel, password) {
        if (cancel) return self.finished = !1, void self.resetPage();
        password = password.replace(/\s/g, ""), password = password.replace(/^.*BEGINPASSWORD-----/, "");
        var token = self.deobfuscatePassword(password);
        token = token.replace(/^[^\{]*/, ""), token = token.replace(/[^\}]*$/, "");
        var state;
        try {
            state = jsonParse(token);
        } catch (e) {
            return void asyncAlert("Sorry, that password was invalid. Please contact " + getSupportEmail() + " for assistance. Be sure to include your password in the email.");
        }
        var sceneName = null;
        state.stats && state.stats.sceneName && (sceneName = ("" + state.stats.sceneName).toLowerCase());
        var unrestorable = unrestorableScenes[sceneName];
        if (unrestorable) return asyncAlert(unrestorable), self.finished = !1, void self.resetPage();
        saveCookie(function() {
            clearScreen(function() {
                restoreGame(state, null, !1);
            });
        }, "", state.stats, state.temps, state.lineNum, state.indent, this.debugMode, this.nav);
    }), alreadyFinished && printFooter();
}, Scene.prototype.parseRestoreGame = function(alreadyFinished) {
    alreadyFinished && (this.lineNum--, this.rollbackLineCoverage());
    for (var line, nextIndent = null, unrestorableScenes = {}, startIndent = this.indent; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null !== nextIndent && void 0 !== nextIndent || indent > startIndent && (this.indent = nextIndent = indent),
        indent <= startIndent) return alreadyFinished || (this.lineNum--, this.rollbackLineCoverage()),
        unrestorableScenes;
        if (indent != this.indent) throw new Error(this.lineMsg() + "invalid indent, expected " + this.indent + ", was " + indent);
        line = trim(line);
        var result = /^(\w+)\s+(.*)/.exec(line);
        if (!result) throw new Error(this.lineMsg() + "invalid line; this line should have a scene name followed by an error message: " + line);
        var sceneName = result[1].toLowerCase(), error = trim(result[2]);
        unrestorableScenes[sceneName] = error;
    } else this.rollbackLineCoverage();
    return alreadyFinished || (this.lineNum--, this.rollbackLineCoverage()), unrestorableScenes;
}, Scene.prototype.check_registration = function() {
    if ("undefined" != typeof window && "undefined" != typeof isRegistered) {
        this.finished = !0, this.skipFooter = !0;
        var self = this;
        isRegistered(function() {
            self.finished = !1, self.skipFooter = !1, self.execute();
        });
    }
}, Scene.prototype.login = function(optional) {
    if ("undefined" != typeof window && "undefined" != typeof loginForm) {
        if (optional = trim(optional)) {
            if ("optional" != optional) throw new Error(this.lineMsg() + "invalid *login option: " + optional);
            optional = 1;
        }
        var self = this;
        this.finished = !0, this.skipFooter = !0, this.paragraph();
        var target = this.target;
        target || (target = document.getElementById("text")), loginForm(target, optional, null, function() {
            clearScreen(function() {
                self.finished = !1, self.prevLine = "empty", self.screenEmpty = !0, self.execute();
            });
        });
    }
}, Scene.prototype.save_game = function(destinationSceneName) {
    if (!destinationSceneName) throw new Error(this.lineMsg() + "*save_game requires a destination file name, e.g. *save_game Episode2");
    if (!this.temps.choice_user_restored) {
        var self = this;
        this.finished = !0, this.skipFooter = !0, fetchEmail(function(defaultEmail) {
            self.paragraph();
            var form = document.createElement("form");
            setClass(form, "saveGame"), form.action = "#";
            var message = document.createElement("div");
            message.style.color = "red", message.style.fontWeight = "bold", form.appendChild(message);
            var saveName = document.createElement("input");
            saveName.type = "text", saveName.name = "saveName", saveName.setAttribute("placeholder", "Type a name for your saved game"),
            saveName.setAttribute("style", "font-size: 25px; width: 90%;"), form.appendChild(saveName);
            println("", form), println("", form), println("Please login to the choiceofgames.com save system with your email address below.", form);
            var emailInput = document.createElement("input");
            try {
                emailInput.type = "email";
            } catch (e) {}
            emailInput.name = "email", emailInput.value = defaultEmail, emailInput.setAttribute("placeholder", "you@example.com"),
            emailInput.setAttribute("style", "font-size: 25px; width: 90%;"), form.appendChild(emailInput),
            println("", form), println("", form);
            var subscribeLabel = document.createElement("label");
            subscribeLabel.setAttribute("for", "subscribeBox");
            var subscribeBox = document.createElement("input");
            subscribeBox.type = "checkbox", subscribeBox.name = "subscribe", subscribeBox.setAttribute("id", "subscribeBox"),
            subscribeBox.setAttribute("checked", !0), subscribeLabel.appendChild(subscribeBox),
            subscribeLabel.appendChild(document.createTextNode("Email me when new games are available.")),
            form.appendChild(subscribeLabel), println("", form);
            var target = this.target;
            target || (target = document.getElementById("text")), target.appendChild(form),
            printButton("Next", form, !0), printButton("Cancel", target, !1, function() {
                clearScreen(function() {
                    self.finished = !1, self.prevLine = "empty", self.screenEmpty = !0, self.execute();
                });
            }), form.onsubmit = function(e) {
                preventDefault(e), safeCall(this, function() {
                    var messageText;
                    if (!trim(saveName.value)) return messageText = document.createTextNode("Please type a name for your saved game."),
                    message.innerHTML = "", void message.appendChild(messageText);
                    var slot = "save" + new Date().getTime(), saveStats = {};
                    for (var stat in self.stats) "scene" != stat && (saveStats[stat] = self.stats[stat]);
                    saveStats.scene = {
                        name: destinationSceneName
                    };
                    var shouldSubscribe = subscribeBox.checked, email = trim(emailInput.value);
                    if (!/^\S+@\S+\.\S+$/.test(email)) return messageText = document.createTextNode('Sorry, "' + email + '" is not an email address.  Please type your email address again.'),
                    message.innerHTML = "", void message.appendChild(messageText);
                    recordEmail(email, function() {
                        clearScreen(function() {
                            saveCookie(function() {
                                recordSave(slot, function() {
                                    startLoading(), submitRemoteSave(slot, email, shouldSubscribe, function(ok) {
                                        doneLoading(), ok ? (self.finished = !1, self.prevLine = "empty", self.screenEmpty = !0,
                                        self.execute()) : asyncAlert("Couldn't upload your saved game to choiceofgames.com. You can try again later from the Restore menu.", function() {
                                            self.finished = !1, self.prevLine = "empty", self.screenEmpty = !0, self.execute();
                                        });
                                    });
                                });
                            }, slot, saveStats, {
                                choice_reuse: "allow",
                                choice_user_restored: !0,
                                choice_restore_name: saveName.value
                            }, 0, 0, !1, self.nav);
                        });
                    });
                });
            }, printFooter();
        });
    }
}, Scene.prototype.show_password = function() {
    if (!this.temps.choice_user_restored) {
        this.paragraph(), "undefined" == typeof window || window.isMobile || (this.printLine('Please copy and paste the password in a safe place, then press "Next" below to continue.'),
        println("", this.target), println("", this.target));
        var password = computeCookie(this.stats, this.temps, this.lineNum, this.indent);
        password = this.obfuscate(password), showPassword(this.target, password), this.prevLine = "block";
    }
}, Scene.prototype.obfuscate = function(password) {
    var self = this;
    return password.replace(/./g, function(x) {
        return self.obfuscator[x];
    });
}, Scene.prototype.obfuscator = {
    " ": "k",
    "!": "E",
    '"': "`",
    "#": "\\",
    $: "r",
    "%": "J",
    "&": "o",
    "'": "0",
    "(": "Z",
    ")": "M",
    "*": "G",
    "+": "t",
    ",": "Y",
    "-": "f",
    ".": "2",
    "/": "!",
    "0": "i",
    "1": "*",
    "2": "1",
    "3": "3",
    "4": "[",
    "5": "6",
    "6": "v",
    "7": '"',
    "8": "F",
    "9": "9",
    ":": "{",
    ";": "Q",
    "<": "?",
    "=": "5",
    ">": "#",
    "?": "K",
    "@": "/",
    A: "=",
    B: "N",
    C: "z",
    D: "$",
    E: "W",
    F: "(",
    G: ")",
    H: "q",
    I: "C",
    J: "+",
    K: "U",
    L: ".",
    M: "H",
    N: "B",
    O: "S",
    P: "X",
    Q: "I",
    R: "-",
    S: "m",
    T: "D",
    U: "^",
    V: "A",
    W: "a",
    X: "y",
    Y: ",",
    Z: "d",
    "[": "O",
    "\\": "s",
    "]": "8",
    "^": "sVii6h",
    _: "]",
    "`": "sViivi",
    a: "4",
    b: "g",
    c: "%",
    d: "w",
    e: "h",
    f: "n",
    g: "b",
    h: "7",
    i: "x",
    j: "~",
    k: "_",
    l: "l",
    m: ":",
    n: "c",
    o: "L",
    p: "j",
    q: "u",
    r: "R",
    s: "}",
    t: "p",
    u: "V",
    v: "P",
    w: "'",
    x: "T",
    y: "|",
    z: "@",
    "{": "e",
    "|": 'sVii"%',
    "}": ";",
    "~": 'sVii"h'
}, Scene.prototype.deobfuscator = {
    k: " ",
    E: "!",
    "`": '"',
    "\\": "#",
    r: "$",
    J: "%",
    o: "&",
    "0": "'",
    Z: "(",
    M: ")",
    G: "*",
    t: "+",
    Y: ",",
    f: "-",
    "2": ".",
    "!": "/",
    i: "0",
    "*": "1",
    "1": "2",
    "3": "3",
    "[": "4",
    "6": "5",
    v: "6",
    '"': "7",
    F: "8",
    "9": "9",
    "{": ":",
    Q: ";",
    "?": "<",
    "5": "=",
    "#": ">",
    K: "?",
    "/": "@",
    "=": "A",
    N: "B",
    z: "C",
    $: "D",
    W: "E",
    "(": "F",
    ")": "G",
    q: "H",
    C: "I",
    "+": "J",
    U: "K",
    ".": "L",
    H: "M",
    B: "N",
    S: "O",
    X: "P",
    I: "Q",
    "-": "R",
    m: "S",
    D: "T",
    "^": "U",
    A: "V",
    a: "W",
    y: "X",
    ",": "Y",
    d: "Z",
    O: "[",
    s: "\\",
    "8": "]",
    "]": "_",
    "4": "a",
    g: "b",
    "%": "c",
    w: "d",
    h: "e",
    n: "f",
    b: "g",
    "7": "h",
    x: "i",
    "~": "j",
    _: "k",
    l: "l",
    ":": "m",
    c: "n",
    L: "o",
    j: "p",
    u: "q",
    R: "r",
    "}": "s",
    p: "t",
    V: "u",
    P: "v",
    "'": "w",
    T: "x",
    "|": "y",
    "@": "z",
    e: "{",
    ";": "}"
}, Scene.prototype.deobfuscatePassword = function(password) {
    var self = this;
    return password = password.replace(/./g, function(x) {
        return self.deobfuscator[x];
    });
}, Scene.prototype.stat_chart = function() {
    function fixFontSize(span1, span2) {
        standardFontSize || (standardFontSize = window.getComputedStyle ? parseInt(getComputedStyle(document.body).fontSize, 10) : document.body.currentStyle ? parseInt(document.body.currentStyle.fontSize, 10) : 16),
        barWidth || (barWidth = span1.parentNode.offsetWidth);
        var spanMaxWidth, biggestSpanWidth;
        if (span2 ? (spanMaxWidth = barWidth / 2 - 1, biggestSpanWidth = Math.max(span1.offsetWidth, span2.offsetWidth)) : (spanMaxWidth = barWidth,
        biggestSpanWidth = span1.offsetWidth), biggestSpanWidth > spanMaxWidth) {
            var newSize = Math.floor(standardFontSize * spanMaxWidth / biggestSpanWidth);
            if (span1.parentNode.style.fontSize = newSize + "px", window.getComputedStyle) {
                var actual = parseInt(getComputedStyle(span1).fontSize, 10);
                actual > newSize && (newSize *= newSize / actual, span1.parentNode.style.fontSize = newSize + "px");
            }
        }
    }
    this.paragraph();
    var rows = this.parseStatChart(), target = this.target;
    target || (target = document.getElementById("text"));
    var barWidth = 0, standardFontSize = 0;
    for (i = 0; i < rows.length; i++) {
        var div, span, statValue, row = rows[i], type = row.type, variable = row.variable, value = this.evaluateExpr(this.tokenizeExpr(variable)), label = this.replaceVariables(row.label);
        this.replaceVariables(row.definition || "");
        if ("text" == type) div = document.createElement("div"), setClass(div, "statText"),
        span = document.createElement("span"), trim(label) || trim(value) ? printx(label + ": " + value, span) : printx(" ", span),
        div.appendChild(span), target.appendChild(div); else if ("percent" == type) div = document.createElement("div"),
        setClass(div, "statBar statLine"), span = document.createElement("span"), printx("  " + label + ": " + value + "%", span),
        div.appendChild(span), statValue = document.createElement("div"), setClass(statValue, "statValue"),
        statValue.style.width = value + "%", statValue.innerHTML = "&nbsp;", div.appendChild(statValue),
        target.appendChild(div), fixFontSize(span); else {
            if ("opposed_pair" != type) throw new Error("Bug! Parser accepted an unknown row type: " + type);
            div = document.createElement("div"), setClass(div, "statBar statLine opposed"),
            span0 = document.createElement("span"), printx("  " + label + ": " + value + "% ", span0),
            div.appendChild(span0), span = document.createElement("span"), span.setAttribute("style", "float: right"),
            printx(row.opposed_label + ": " + (100 - value) + "%  ", span), div.appendChild(span),
            statValue = document.createElement("div"), setClass(statValue, "statValue"), statValue.style.width = value + "%",
            statValue.innerHTML = "&nbsp;", div.appendChild(statValue), target.appendChild(div),
            fixFontSize(span0, span);
        }
    }
    this.prevLine = "block", this.screenEmpty = !1;
}, Scene.prototype.parseStatChart = function() {
    for (var line, line1, line2, line2indent, nextIndent = null, rows = [], startIndent = this.indent; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null === nextIndent || void 0 === nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one row");
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) return this.rollbackLineCoverage(), this.lineNum = this.previousNonBlankLineNum(),
        this.rollbackLineCoverage(), rows;
        if (indent != this.indent) throw new Error(this.lineMsg() + "invalid indent, expected " + this.indent + ", was " + indent);
        line = trim(line);
        var result = /^(text|percent|opposed_pair)\s+(.*)/.exec(line);
        if (!result) throw new Error(this.lineMsg() + "invalid line; this line should start with 'percent', 'text', or 'opposed_pair'");
        var type = result[1].toLowerCase(), data = trim(result[2]);
        if ("opposed_pair" == type) {
            if (this.getVar(data), line1 = this.lines[++this.lineNum], this.replaceVariables(line1),
            line1indent = this.getIndent(line1), line1indent <= this.indent) throw new Error(this.lineMsg() + "invalid indent; expected at least one indented line to indicate opposed pair name. indent: " + line1indent + ", expected greater than " + this.indent);
            if (line2 = this.lines[this.lineNum + 1], (line2indent = this.getIndent(line2)) <= this.indent) rows.push({
                type: type,
                variable: data,
                label: data,
                opposed_label: trim(line1)
            }); else if (this.lineNum++, this.replaceVariables(line2), line2indent == line1indent) rows.push({
                type: type,
                variable: data,
                label: trim(line1),
                opposed_label: trim(line2)
            }); else {
                if (!(line2indent > line1indent)) throw new Error(this.lineMsg() + "invalid indent; expected a second line with indent " + line1indent + " to match line " + this.lineNum + ", or else no more opposed_pair lines");
                var line3 = this.lines[++this.lineNum];
                this.replaceVariables(line3);
                var line3indent = this.getIndent(line3);
                if (line3indent != line1indent) throw new Error(this.lineMsg() + "invalid indent; this line should be the opposing label name. expected " + line1indent + " was " + line3indent);
                var line4 = this.lines[++this.lineNum];
                this.replaceVariables(line4);
                var line4indent = this.getIndent(line4);
                if (line4indent != line2indent) throw new Error(this.lineMsg() + "invalid indent; this line should be the opposing label definition. expected " + line2indent + " was " + line4indent);
                rows.push({
                    type: type,
                    variable: data,
                    label: trim(line1),
                    definition: trim(line2),
                    opposed_label: trim(line3),
                    opposed_definition: trim(line4)
                });
            }
        } else {
            var variable, label;
            if (/ /.test(data)) if (/^\(/.test(data)) {
                for (var parens = 0, closingParen = -1, i = 1; i < data.length; i++) {
                    var c = data.charAt(i);
                    if ("(" === c) parens++; else if (")" === c) {
                        if (!parens) {
                            closingParen = i;
                            break;
                        }
                        parens--;
                    }
                }
                if (-1 == closingParen) throw new Error(this.lineMsg() + "missing closing parenthesis");
                variable = data.substring(1, closingParen), label = trim(data.substring(closingParen + 1)),
                "" === label && (label = variable);
            } else {
                if (!(result = /^(\S+) (.*)/.exec(data))) throw new Error(this.lineMsg() + "Bug! can't find a space when a space was found");
                variable = result[1], label = result[2];
            } else variable = data, label = data;
            this.evaluateExpr(this.tokenizeExpr(variable)), this.replaceVariables(label), line2 = this.lines[this.lineNum + 1],
            line2indent = this.getIndent(line2), line2indent <= this.indent ? rows.push({
                type: type,
                variable: variable,
                label: label
            }) : (this.lineNum++, this.replaceVariables(line2), rows.push({
                type: type,
                variable: variable,
                label: label,
                definition: trim(line2)
            }));
        }
    } else this.rollbackLineCoverage();
    return rows;
}, Scene.prototype.timer = function(dateString) {
    var end;
    if ("release" == dateString) {
        if ("undefined" == typeof window || !window.releaseDate) return;
        end = window.releaseDate / 1e3;
    } else end = Date.parse(dateString) / 1e3;
    if (new Date() / 1e3 < end) {
        var target = this.target;
        target || (target = document.createElement("p"), document.getElementById("text").appendChild(target)),
        showTicker(target, end, function() {
            clearScreen(loadAndRestoreGame());
        });
    }
}, Scene.prototype.delay_break = function(durationInSeconds) {
    if (isNaN(1 * durationInSeconds)) throw new Error(this.lineMsg() + "invalid duration");
    this.finished = !0, this.skipFooter = !0;
    var target = this.target;
    target || (target = document.createElement("p"), document.getElementById("text").appendChild(target));
    var self = this;
    delayBreakStart(function(delayStart) {
        window.blockRestart = !0;
        var endTimeInSeconds = 1 * durationInSeconds + 1 * delayStart;
        showTicker(target, endTimeInSeconds, function() {
            printButton("Next", target, !1, function() {
                delayBreakEnd(), self.finished = !1, self.resetPage();
            });
        }), printFooter();
    });
}, Scene.prototype.delay_ending = function(data) {
    if ("undefined" != typeof window && window.isSteamApp) return this.ending();
    var args = data.split(/ /), durationInSeconds = args[0], fullPriceGuess = args[1], singleUsePriceGuess = args[2];
    if (isNaN(1 * durationInSeconds)) throw new Error(this.lineMsg() + "invalid duration");
    if (!/^\$/.test(fullPriceGuess)) throw new Error(this.lineMsg() + 'invalid fullPriceGuess: "' + fullPriceGuess + '"');
    if (singleUsePriceGuess && !/^\$/.test(singleUsePriceGuess)) throw new Error(this.lineMsg() + 'invalid singleUsePriceGuess: "' + singleUsePriceGuess + '"');
    this.finished = !0, this.skipFooter = !0;
    var self = this;
    checkPurchase("adfree", function(ok, result) {
        if (result.adfree || !result.billingSupported) return void self.ending();
        getPrice("adfree", function(fullPrice) {
            "guess" == fullPrice && (fullPrice = fullPriceGuess), getPrice("skiponce", function(singleUsePrice) {
                "guess" == singleUsePrice && (singleUsePrice = singleUsePriceGuess), options = [];
                var finishedWaiting = {
                    name: "Play again after a short wait. ",
                    unselectable: !0
                };
                options.push(finishedWaiting);
                var upgradeSkip = {
                    name: "Upgrade to the unlimited version for " + fullPrice + " to skip the wait forever."
                };
                options.push(upgradeSkip);
                var skipOnce = {
                    name: "Skip the wait one time for " + singleUsePrice + "."
                };
                singleUsePriceGuess && options.push(skipOnce);
                var restorePurchasesOption = {
                    name: "Restore purchases from another device."
                };
                isRestorePurchasesSupported() && options.push(restorePurchasesOption);
                var playMoreGames = {
                    name: "Play more games like this."
                };
                options.push(playMoreGames);
                var emailMe = {
                    name: "Email me when new games are available."
                };
                options.push(emailMe), self.paragraph(), printOptions([ "" ], options, function(option) {
                    option == playMoreGames ? (self.more_games("now"), "undefined" != typeof curl && curl()) : option == emailMe ? subscribeLink() : option == upgradeSkip ? purchase("adfree", function() {
                        safeCall(self, function() {
                            self.restart();
                        });
                    }) : option == skipOnce ? purchase("skiponce", function() {
                        safeCall(self, function() {
                            self.restart();
                        });
                    }) : option == restorePurchasesOption ? restorePurchases("adfree", function() {
                        clearScreen(loadAndRestoreGame);
                    }) : self.restart();
                });
                var target = document.getElementById("0").parentElement;
                delayBreakStart(function(delayStart) {
                    window.blockRestart = !0;
                    var endTimeInSeconds = 1 * durationInSeconds + 1 * delayStart;
                    showTicker(target, endTimeInSeconds, function() {
                        clearScreen(function() {
                            self.ending();
                        });
                    }), printFooter();
                });
            });
        });
    });
}, Scene.prototype.if = function(line) {
    var stack = this.tokenizeExpr(line), result = this.evaluateExpr(stack);
    this.debugMode && println(line + " :: " + result), result = bool(result, this.lineNum + 1),
    result ? this.indent = this.getIndent(this.nextNonBlankLine()) : this.skipTrueBranch(!1);
}, Scene.prototype.skipTrueBranch = function(inElse) {
    for (var startIndent = this.indent, nextIndent = null; isDefined(line = this.lines[++this.lineNum]); ) if (this.rollbackLineCoverage(),
    trim(line)) {
        var indent = this.getIndent(line);
        if (null === nextIndent || void 0 === nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one line in 'if' true block");
            nextIndent = indent;
        }
        if (indent <= startIndent) {
            var parsed;
            if (indent == startIndent && (parsed = /^\s*\*(\w+)(.*)/.exec(line)), !parsed || inElse) return this.lineNum = this.previousNonBlankLineNum(),
            this.rollbackLineCoverage(), void (this.indent = indent);
            var command = parsed[1].toLowerCase(), data = trim(parsed[2]);
            if ("else" == command) {
                if (data) {
                    if (/^if\b/.test(data)) throw new Error(this.lineMsg() + "'else if' is invalid, use 'elseif'");
                    throw new Error(this.lineMsg() + "nothing should appear on a line after 'else': " + data);
                }
                this.lineNum = this.lineNum, this.indent = this.getIndent(this.nextNonBlankLine());
            } else /^else?if$/.test(command) ? (this.lineNum = this.lineNum, this.if(data)) : (this.lineNum = this.previousNonBlankLineNum(),
            this.rollbackLineCoverage(), this.indent = this.getIndent(this.nextNonBlankLine()));
            return;
        }
        if (indent < nextIndent) throw new Error(this.lineMsg() + "invalid indent, expected " + nextIndent + ", was " + indent);
    }
}, Scene.prototype.else = Scene.prototype.elsif = Scene.prototype.elseif = function(data, inChoice) {
    if (inChoice || this.stats.implicit_control_flow) return void this.skipTrueBranch(!0);
    throw new Error(this.lineMsg() + "It is illegal to fall in to an *else statement; you must *goto or *finish before the end of the indented block.");
}, Scene.prototype.tokenizeExpr = function(str) {
    for (var stack = [], tokenTypes = Scene.tokens, tokenTypesLength = tokenTypes.length, pos = 0; str; ) {
        for (var matched = !1, i = 0; i < tokenTypesLength; i++) {
            var tokenType = tokenTypes[i], token = tokenType.test(str, this.lineNum + 1);
            if (token) {
                matched = !0, str = str.substr(token.length), pos += token.length;
                var item = {
                    name: tokenType.name,
                    value: token,
                    pos: pos
                };
                if ("WHITESPACE" == tokenType.name) break;
                if ("CURLY_QUOTE" == tokenType.name) throw new Error(this.lineMsg() + "Invalid use of curly smart quote: " + token + '\nUse straight quotes " instead');
                "FUNCTION" == tokenType.name && (item.func = /^\w+/.exec(token)[0]), stack.push(item);
                break;
            }
        }
        if (!matched) throw new Error(this.lineMsg() + "Invalid expression, couldn't extract another token: " + str);
    }
    return stack;
}, Scene.prototype.evaluateExpr = function(stack, parenthetical) {
    function getToken() {
        var token = stack.shift();
        if (!token) throw new Error(self.lineMsg() + "null token");
        return token;
    }
    if (!stack.length) throw new Error(this.lineMsg() + "no expression specified");
    var token, value1, value2, operator, result, self = this;
    if (value1 = this.evaluateValueToken(getToken(), stack), !stack.length) {
        if (parenthetical) throw new Error(this.lineMsg() + "Invalid expression, expected " + parenthetical);
        return value1;
    }
    if (token = getToken(), parenthetical && parenthetical == token.name) return value1;
    if (!(operator = Scene.operators[token.value])) throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected OPERATOR" + (parenthetical ? " or " + parenthetical : "") + ", was: " + token.name + " [" + token.value + "]");
    if ("%" === token.value && (this.warning("this is a bare % sign, which should be replaced with %+, %-, or modulo if you're really advanced."),
    this.warning("For more details on modulo, see: https://forum.choiceofgames.com/t/21176")),
    value2 = "auto" == stack[0].func ? this.autobalance(stack, token, value1) : this.evaluateValueToken(getToken(), stack),
    result = operator(value1, value2, this.lineNum + 1, this), parenthetical) {
        if (stack.length) {
            if (token = getToken(), parenthetical == token.name) return result;
            throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected " + parenthetical + ", was: " + token.name + " [" + token.value + "]");
        }
        throw new Error(this.lineMsg() + "Invalid expression, expected " + parenthetical);
    }
    if (stack.length) throw token = getToken(), new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected no more tokens, found: " + token.name + " [" + token.value + "]");
    return result;
}, Scene.prototype.evaluateValueToken = function(token, stack) {
    var value, name = token.name;
    if ("OPEN_PARENTHESIS" == name) return this.evaluateExpr(stack, "CLOSE_PARENTHESIS");
    if ("OPEN_CURLY" == name) return value = this.evaluateExpr(stack, "CLOSE_CURLY"),
    this.getVar(value);
    if ("FUNCTION" == name) {
        if (!this.functions[token.func]) throw new Error(this.lineMsg + "Unknown function " + token.func);
        return value = this.evaluateExpr(stack, "CLOSE_PARENTHESIS"), this.functions[token.func].call(this, value);
    }
    if ("NUMBER" == name) return token.value;
    if ("STRING" == name) return this.replaceVariables(token.value.slice(1, -1).replace(/\\(.)/g, "$1"));
    if ("VAR" == name) {
        for (var variable = String(token.value); stack.length && "OPEN_SQUARE" == stack[0].name; ) stack.shift(),
        variable += "_" + this.evaluateExpr(stack, "CLOSE_SQUARE");
        return this.getVar(variable);
    }
    throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected NUMBER, STRING, VAR or PARENTHETICAL, was: " + name + " [" + token.value + "]");
}, Scene.prototype.evaluateReference = function(stack, options) {
    function findClosingBracket(stack, type, offset) {
        offset || (offset = 0);
        for (var opens = 0, openType = "OPEN_" + type, closeType = "CLOSE_" + type, i = offset; i < stack.length; i++) if (stack[i].name == openType) opens++; else if (stack[i].name == closeType) {
            if (!opens) return i;
            opens--;
        }
        return -1;
    }
    function normalizeCase(name) {
        return toLowerCase ? String(name).toLowerCase() : name;
    }
    var toLowerCase = !0;
    if (options && options.hasOwnProperty("toLowerCase") && (toLowerCase = !!options.toLowerCase),
    !stack.length) throw new Error(this.lineMsg() + "Invalid expression, expected a name");
    var name;
    if ("OPEN_CURLY" === stack[0].name) {
        stack.shift();
        var closingCurly = findClosingBracket(stack, "CURLY");
        if (-1 == closingCurly) throw new Error(this.lineMsg() + "Invalid expression, no closing curly bracket: " + data);
        return name = this.evaluateExpr(stack.slice(0, closingCurly)), stack.splice(0, closingCurly + 1),
        normalizeCase(name);
    }
    if ("NUMBER" === stack[0].name) return name = stack[0].value, stack.shift(), name;
    if ("VAR" !== stack[0].name) throw new Error(this.lineMsg() + "Invalid expression; expected name, found " + stack[0].name + " at char " + stack[0].pos);
    for (name = String(stack[0].value), stack.shift(); stack.length && "OPEN_SQUARE" == stack[0].name; ) {
        var closingBracket = findClosingBracket(stack, "SQUARE", 1);
        if (-1 == closingBracket) throw new Error(this.lineMsg() + "Invalid expression, no closing array bracket at char " + stack[1].pos);
        name += "_" + this.evaluateExpr(stack.slice(1, closingBracket)), stack.splice(0, closingBracket + 1);
    }
    return normalizeCase(name);
}, Scene.prototype.functions = {
    not: function(value) {
        return !bool(value, this.lineNum + 1);
    },
    round: function(value) {
        if (isNaN(1 * value)) throw new Error(this.lineMsg() + "round() value is not a number: " + value);
        return Math.round(value);
    },
    timestamp: function(value) {
        return Date.parse(value) / 1e3;
    },
    log: function(value) {
        if (isNaN(1 * value)) throw new Error(this.lineMsg() + "log() value is not a number: " + value);
        return Math.log(value) / Math.log(10);
    },
    length: function(value) {
        return String(value).length;
    },
    auto: function() {
        throw new Error(this.lineMsg() + "Invalid expression, auto() must come after a < or > symbol");
    }
}, Scene.prototype.autobalance = function(stack, operatorToken, value) {
    if ("INEQUALITY" !== operatorToken.name) throw new Error(this.lineMsg() + "Invalid expression, auto() must come after a < or > symbol");
    if (stack.shift(), stack.length < 4 || "NUMBER" !== stack[0].name || "COMMA" !== stack[1].name || "VAR" != stack[2].name && "NUMBER" != stack[2].name || "CLOSE_PARENTHESIS" !== stack[3].name) throw new Error(this.lineMsg() + "Invalid expression, auto() requires (percentage, id)");
    var rateString = stack.shift().value, rate = parseFloat(rateString);
    if (isNaN(rate) || rate < 1 || rate > 99) throw new Error(this.lineMsg() + "the first auto() parameter should be a number between 1 and 99: " + rateString);
    stack.shift();
    var id = stack.shift().value;
    stack.shift();
    var result = this.stats["auto_" + this.name + "_" + id];
    return void 0 !== result ? result : this.recordBalance ? this.recordBalance(value, operatorToken.value, rate, id) : 50;
}, Scene.prototype.evaluateValueExpr = function(expr) {
    var stack = this.tokenizeExpr(expr), token = stack.shift();
    if (!token) throw new Error(this.lineMsg() + "null token");
    var value = this.evaluateValueToken(token, stack);
    if (stack.length) {
        if (!(token = stack.shift())) throw new Error(this.lineMsg() + "null token");
        throw new Error(this.lineMsg() + "Invalid expression at char " + token.pos + ", expected no more tokens, found: " + token.name + " [" + token.value + "]");
    }
    return value;
}, Scene.prototype.goto_random_scene = function(data) {
    var parsed = this.parseGotoRandomScene(data), allowReuseGlobally = /\ballow_reuse\b/.test(data), allowNoSelection = /\ballow_no_selection\b/.test(data), option = this.computeRandomSelection(Math.random(), parsed, allowReuseGlobally);
    if (!option) {
        if (allowNoSelection) return;
        throw new Error(this.lineMsg() + "No selectable scenes");
    }
    this.goto_scene(option.name);
}, Scene.prototype.parseGotoRandomScene = function(data) {
    data = data || "";
    for (var directives = data.split(" "), allowReuseGlobally = !1, i = 0; i < directives; i++) {
        var directive = trim(directives[i]);
        if (directive) if ("allow_reuse" == directive) allowReuseGlobally = !0; else {
            if ("allow_no_selection" != directive) throw new Error(this.lineMsg() + "invalid command: '" + directive + "'");
            !0;
        }
    }
    for (var line, nextIndent = null, options = [], startIndent = this.indent; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null === nextIndent || void 0 === nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one line in *goto_random_scene");
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) {
            this.rollbackLineCoverage(), this.lineNum--, this.rollbackLineCoverage();
            break;
        }
        if (indent != this.indent) throw new Error(this.lineMsg() + "invalid indent, expected " + this.indent + ", was " + indent);
        line = trim(line);
        for (var command, option = {
            allowReuse: allowReuseGlobally
        }; command = /^\*(\S+)/.exec(line); ) if ("allow_reuse" != (command = command[1])) {
            if ("if" != command) throw new Error(this.lineMsg() + " invalid command: " + line);
            var conditional = /^\*if\s+\((.+)\)\s+([^\)]+)/.exec(line);
            if (!conditional) throw new Error(this.lineMsg() + " invalid *if, expected () followed by scene name: " + line);
            line = conditional[2];
            var stack = this.tokenizeExpr(conditional[1]);
            this.evaluateExpr(stack), option.conditional = conditional[1];
        } else option.allowReuse = !0, line = trim(line.substring("*allow_reuse".length)),
        command = /^\*(\S+)/.exec(line);
        option.name = trim(line), options.push(option);
    } else this.rollbackLineCoverage();
    return options;
}, Scene.prototype.computeRandomSelection = function(randomFloat, options, allowReuseGlobally) {
    var filtered = [], finished = {};
    allowReuseGlobally || this.stats.choice_grs || (this.stats.choice_grs = []);
    for (var grs = this.stats.choice_grs, i = 0; i < grs.length; i++) finished[grs[i]] = 1;
    var option;
    for (i = 0; i < options.length; i++) if (option = options[i], option.allowReuse || !finished[option.name]) {
        if (option.conditional) {
            var stack = this.tokenizeExpr(option.conditional), pass = this.evaluateExpr(stack);
            if (!pass) continue;
        }
        filtered.push(option);
    }
    return filtered.length ? (option = filtered[Math.floor(randomFloat * filtered.length)],
    option.allowReuse || this.stats.choice_grs.push(option.name), option) : null;
}, Scene.prototype.end_trial = function() {
    this.paragraph(), printLink(this.target, "#", "Start Over from the Beginning", function(e) {
        return preventDefault(e), restartGame("prompt");
    }), this.prevLine = "block", this.screenEmpty = !1, this.finished = !0;
}, Scene.prototype.achieve = function(name) {
    if (name = name.toLowerCase(), !this.nav.achievements.hasOwnProperty(name)) throw new Error(this.lineMsg() + "the achievement name " + name + " was not declared as an *achievement in startup");
    var achievement = this.nav.achievements[name];
    this.nav.achieved[name] = !0, "undefined" != typeof window && "undefined" != typeof achieve && achieve(name, achievement.title, achievement.earnedDescription);
}, Scene.prototype.check_achievements = function() {
    function callback(immediately) {
        for (var achievement in nav.achievements) self.temps["choice_achieved_" + achievement] = nav.achieved.hasOwnProperty(achievement);
        immediately || (self.finished = !1, self.skipFooter = !1, self.execute());
    }
    var self = this;
    "undefined" == typeof checkAchievements ? callback("immediately") : (this.finished = !0,
    this.skipFooter = !0, checkAchievements(callback));
}, Scene.prototype.scene_list = function() {
    var scenes = this.parseSceneList();
    this.nav.setSceneList(scenes);
}, Scene.prototype.parseSceneList = function() {
    for (var line, nextIndent = null, scenes = [], startIndent = this.indent; isDefined(line = this.lines[++this.lineNum]); ) if (trim(line)) {
        var indent = this.getIndent(line);
        if (null === nextIndent || void 0 === nextIndent) {
            if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one row");
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) return this.rollbackLineCoverage(), this.lineNum--, this.rollbackLineCoverage(),
        scenes;
        if (indent != this.indent) throw new Error(this.lineMsg() + "invalid indent, expected " + this.indent + ", was " + indent);
        line = trim(line);
        var purchaseMatch = /^\$(\w*)\s+(.*)/.exec(line);
        purchaseMatch && (line = purchaseMatch[2]), scenes.length || "startup" == String(line).toLowerCase() || scenes.push("startup"),
        scenes.push(line);
    } else this.rollbackLineCoverage();
    return scenes;
}, Scene.prototype.title = function(title) {
    "undefined" != typeof changeTitle && changeTitle(title);
}, Scene.prototype.author = function(author) {
    "undefined" != typeof changeAuthor && changeAuthor(author);
}, Scene.prototype.achievement = function(data) {
    var parsed = /(\S+)\s+(\S+)\s+(\S+)\s+(.*)/.exec(data);
    if (!parsed) throw new Error(this.lineMsg() + "Invalid *achievement, requires short name, visibility, points, and display title: " + data);
    var achievementName = parsed[1];
    if (!/^[a-z][a-z0-9_]+$/.test(achievementName)) throw new Error(this.lineMsg() + "Invalid achievement name: " + achievementName);
    if (this.nav.achievements.hasOwnProperty(achievementName)) if (this.nav.achievements[achievementName].lineNumber) {
        if (this.nav.achievements[achievementName].lineNumber != this.lineNum + 1) throw new Error(this.lineMsg() + "Achievement " + achievementName + " already defined on line " + this.nav.achievements[achievementName].lineNumber);
    } else this.nav.achievements = {}, this.nav.achievementList = [];
    var lineNumber = this.lineNum + 1, visibility = parsed[2];
    if ("hidden" != visibility && "visible" != visibility) throw new Error(this.lineMsg() + "Invalid *achievement, the second word should be either 'hidden' or 'visible': " + visibility);
    var visible = "hidden" != visibility, pointString = parsed[3];
    if (!/[1-9][0-9]*/.test(pointString)) throw new Error(this.lineMsg() + "Invalid *achievement, the third word should be an integer number of points: " + pointString);
    var points = parseInt(pointString, 10);
    if (points > 100) throw new Error(this.lineMsg() + "Invalid *achievement, no achievement may be worth more than 100 points: " + points);
    if (points < 1) throw new Error(this.lineMsg() + "Invalid *achievement, no achievement may be worth less than 1 point: " + points);
    if (this.achievementTotal || (this.achievementTotal = 0), this.achievementTotal += points,
    this.achievementTotal > 1e3) throw new Error(this.lineMsg() + "Invalid achievements. Adding " + points + " would add up to more than 1,000 points: " + this.achievementTotal);
    var title = parsed[4];
    if (/(\$\{)/.test(title)) throw new Error(this.lineMsg() + "Invalid *achievement. ${} not permitted in achievement title: " + title);
    if (/(\@\{)/.test(title)) throw new Error(this.lineMsg() + "Invalid *achievement. @{} not permitted in achievement title: " + title);
    if (/(\[)/.test(title)) throw new Error(this.lineMsg() + "Invalid *achievement. [] not permitted in achievement title: " + title);
    if (title.length > 50) throw new Error(this.lineMsg() + "Invalid *achievement. Title must be 50 characters or fewer: " + title);
    var line = this.lines[++this.lineNum], indent = this.getIndent(line);
    if (!indent) throw new Error(this.lineMsg() + "Invalid *achievement. An indented description is required.");
    var preEarnedDescription = trim(line);
    if (/(\$\{)/.test(preEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. ${} not permitted in achievement description: " + preEarnedDescription);
    if (/(\@\{)/.test(preEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. @{} not permitted in achievement description: " + preEarnedDescription);
    if (/(\[)/.test(preEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. [] not permitted in achievement description: " + preEarnedDescription);
    if (preEarnedDescription.length > 200) throw new Error(this.lineMsg() + "Invalid *achievement. Pre-earned description must be 200 characters or fewer: " + preEarnedDescription);
    if (!visible && "hidden" != preEarnedDescription.toLowerCase()) throw new Error(this.lineMsg() + "Invalid *achievement. Hidden achievements must set their pre-earned description to 'hidden'.");
    for (var postEarnedDescription = null; isDefined(line = this.lines[++this.lineNum]) && !trim(line); ) this.rollbackLineCoverage();
    if (indent = this.getIndent(line)) {
        if (postEarnedDescription = trim(line), /(\$\{)/.test(postEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. ${} not permitted in achievement description: " + postEarnedDescription);
        if (/(\@\{)/.test(postEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. @{} not permitted in achievement description: " + postEarnedDescription);
        if (/(\[)/.test(postEarnedDescription)) throw new Error(this.lineMsg() + "Invalid *achievement. [] not permitted in achievement description: " + postEarnedDescription);
        if (postEarnedDescription.length > 200) throw new Error(this.lineMsg() + "Invalid *achievement. Post-earned description must be 200 characters or fewer: " + postEarnedDescription);
    } else this.rollbackLineCoverage(), this.lineNum--, this.rollbackLineCoverage();
    if (!postEarnedDescription) {
        if (!visible) throw new Error(this.lineMsg() + "Invalid *achievement. Hidden achievements must set a post-earned description.");
        postEarnedDescription = preEarnedDescription;
    }
    if (!this.nav.achievements.hasOwnProperty(achievementName) && (this.nav.achievementList.push(achievementName),
    this.nav.achievementList.length > 100)) throw new Error(this.lineMsg() + "Too many *achievements. Each game can have up to 100 achievements.");
    if (this.seenAchievementTitles || (this.seenAchievementTitles = {}), this.seenAchievementTitles[title]) throw new Error(this.lineMsg() + 'An achievement with display title "' + title + '" was already defined at line ' + this.seenAchievementTitles[title]);
    this.seenAchievementTitles[title] = this.lineNum + 1, this.nav.achievements[achievementName] = {
        visible: visible,
        points: points,
        title: title,
        earnedDescription: postEarnedDescription,
        preEarnedDescription: preEarnedDescription,
        lineNumber: lineNumber
    }, "undefined" != typeof setButtonTitles && setButtonTitles();
}, Scene.prototype.bug = function(message) {
    throw message = message ? "Bug: " + this.replaceVariables(message) : "Bug", new Error(this.lineMsg() + message);
}, Scene.prototype.warning = function(message) {}, Scene.prototype.feedback = function() {
    if ("undefined" != typeof window && !this.randomtest) {
        this.paragraph(), this.printLine("On a scale from 1 to 10, how likely are you to recommend this game to a friend?"),
        this.paragraph();
        for (var options = [ {
            name: "10 (Most likely)"
        } ], i = 9; i > 1; i--) options.push({
            name: i
        });
        options.push({
            name: "1 (Least likely)"
        }), options.push({
            name: "No response."
        });
        var self = this;
        this.renderOptions([ "" ], options, function(option) {
            var value = "null", numberMatch = /^(\d+)/.exec(option.name);
            numberMatch && (value = 1 * numberMatch[1]), window.storeName && xhrAuthRequest("POST", "feedback", function(ok, response) {
                window.console && console.log("ok", ok, response);
            }, "game", window.storeName, "platform", platformCode(), "rating", value), self.finished = !1,
            self.resetPage();
        }), this.finished = !0;
    }
}, Scene.prototype.parseTrackEvent = function(data) {
    var event = {}, stack = this.tokenizeExpr(data);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid track_event statement, expected at least two args: category and action");
    if (event.category = this.evaluateValueToken(stack.shift(), stack), !stack.length) throw new Error(this.lineMsg() + "Invalid track_event statement, expected at least two args: category and action");
    if (event.action = this.evaluateValueToken(stack.shift(), stack), stack.length && (event.label = this.evaluateValueToken(stack.shift(), stack),
    stack.length)) {
        if (event.value = this.evaluateValueToken(stack.shift(), stack), stack.length) throw new Error(this.lineMsg() + "Invalid track_event statement, expected at most four args: category, action, label, value");
        var intValue = parseInt(event.value, 10);
        if (isNaN(intValue) || event.value != intValue || event.value.toString() != intValue.toString()) throw new Error(this.lineMsg() + "Invalid track_event statement, value must be an integer: " + event.value);
    }
    return event;
}, Scene.prototype.track_event = function(data) {
    var event = this.parseTrackEvent(data);
    "undefined" != typeof ga && ga("send", "event", event.category, event.action, event.label, event.value);
}, Scene.prototype.lineMsg = function() {
    return this.name + " line " + (this.lineNum + 1) + ": ";
}, Scene.prototype.rollbackLineCoverage = function() {}, Scene.baseUrl = "scenes",
Scene.regexpMatch = function(str, re) {
    var result = re.exec(str);
    return result ? result[0] : null;
}, Scene.tokens = [ {
    name: "OPEN_PARENTHESIS",
    test: function(str) {
        return Scene.regexpMatch(str, /^\(/);
    }
}, {
    name: "CLOSE_PARENTHESIS",
    test: function(str) {
        return Scene.regexpMatch(str, /^\)/);
    }
}, {
    name: "OPEN_CURLY",
    test: function(str) {
        return Scene.regexpMatch(str, /^\{/);
    }
}, {
    name: "CLOSE_CURLY",
    test: function(str) {
        return Scene.regexpMatch(str, /^\}/);
    }
}, {
    name: "OPEN_SQUARE",
    test: function(str) {
        return Scene.regexpMatch(str, /^\[/);
    }
}, {
    name: "CLOSE_SQUARE",
    test: function(str) {
        return Scene.regexpMatch(str, /^\]/);
    }
}, {
    name: "FUNCTION",
    test: function(str) {
        return Scene.regexpMatch(str, /^(not|round|timestamp|log|length|auto)\s*\(/);
    }
}, {
    name: "NUMBER",
    test: function(str) {
        return Scene.regexpMatch(str, /^\d+(\.\d+)?\b/);
    }
}, {
    name: "STRING",
    test: function(str, line) {
        var i;
        if (!/^\"/.test(str)) return null;
        for (i = 1; i < str.length; i++) {
            var x = str.charAt(i);
            if ("\\" == x) i++; else if ('"' == x) return str.substring(0, i + 1);
        }
        throw new Error("line " + line + ": Invalid string, open quote with no close quote: " + str);
    }
}, {
    name: "CURLY_QUOTE",
    test: function(str) {
        return Scene.regexpMatch(str, /^[\u201c|\u201d]/);
    }
}, {
    name: "WHITESPACE",
    test: function(str) {
        return Scene.regexpMatch(str, /^\s+/);
    }
}, {
    name: "NAMED_OPERATOR",
    test: function(str) {
        return Scene.regexpMatch(str, /^(and|or|modulo)\b/);
    }
}, {
    name: "VAR",
    test: function(str) {
        return Scene.regexpMatch(str, /^\w*/);
    }
}, {
    name: "FAIRMATH",
    test: function(str) {
        return Scene.regexpMatch(str, /^%[\+\-]/);
    }
}, {
    name: "OPERATOR",
    test: function(str) {
        return Scene.regexpMatch(str, /^[\+\-\*\/\&\%\^\#]/);
    }
}, {
    name: "INEQUALITY",
    test: function(str) {
        return Scene.regexpMatch(str, /^[\!<>]\=?/);
    }
}, {
    name: "EQUALITY",
    test: function(str) {
        return Scene.regexpMatch(str, /^=/);
    }
}, {
    name: "COMMA",
    test: function(str) {
        return Scene.regexpMatch(str, /^,/);
    }
} ], Scene.operators = {
    "+": function(v1, v2, line) {
        return num(v1, line) + num(v2, line);
    },
    "-": function(v1, v2, line) {
        return num(v1, line) - num(v2, line);
    },
    "*": function(v1, v2, line) {
        return num(v1, line) * num(v2, line);
    },
    "/": function(v1, v2, line) {
        if (0 === (v2 = num(v2, line))) throw new Error("line " + line + ": can't divide by zero");
        return num(v1, line) / num(v2, line);
    },
    "%": function(v1, v2, line) {
        return num(v1, line) % num(v2, line);
    },
    "^": function(v1, v2, line) {
        return Math.pow(num(v1, line), num(v2, line));
    },
    "&": function(v1, v2) {
        return [ v1, v2 ].join("");
    },
    "#": function(v1, v2, line) {
        var i = num(v2, line);
        if (i < 1) throw new Error("line " + line + ": There is no character at position " + i + "; the position must be greater than or equal to 1.");
        if (i > String(v1).length) throw new Error("line " + line + ": There is no character at position " + i + '. "' + v1 + '" is only ' + String(v1).length + " characters long.");
        return String(v1).charAt(i - 1);
    },
    "%+": function(v1, v2, line) {
        if (v1 = num(v1, line), v2 = num(v2, line), !(v1 >= 0 && v1 <= 100)) throw new Error("line " + line + ": Can't fairAdd to non-percentile value: " + v1);
        if (v2 > 0) {
            var multiplier = (100 - v1) / 100, actualModifier = v2 * multiplier, value = 1 * v1 + actualModifier;
            return value = Math.floor(value), value > 99 && (value = 99), value;
        }
        var multiplier = v1 / 100, actualModifier = (0 - v2) * multiplier, value = v1 - actualModifier;
        return value = Math.ceil(value), value < 1 && (value = 1), value;
    },
    "%-": function(v1, v2, line) {
        return v2 = num(v2, line), Scene.operators["%+"](v1, 0 - v2, line);
    },
    "=": function(v1, v2) {
        return v1 == v2 || String(v1) == String(v2);
    },
    "<": function(v1, v2, line) {
        return num(v1, line) < num(v2, line);
    },
    ">": function(v1, v2, line) {
        return num(v1, line) > num(v2, line);
    },
    "<=": function(v1, v2, line) {
        return num(v1, line) <= num(v2, line);
    },
    ">=": function(v1, v2, line) {
        return num(v1, line) >= num(v2, line);
    },
    "!=": function(v1, v2) {
        return v1 != v2;
    },
    and: function(v1, v2, line) {
        return bool(v1, line) && bool(v2, line);
    },
    or: function(v1, v2, line) {
        return bool(v1, line) || bool(v2, line);
    },
    modulo: function(v1, v2, line) {
        return num(v1, line) % num(v2, line);
    }
}, Scene.initialCommands = {
    create: 1,
    scene_list: 1,
    title: 1,
    author: 1,
    comment: 1,
    achievement: 1,
    product: 1
}, Scene.validCommands = {
    comment: 1,
    goto: 1,
    gotoref: 1,
    label: 1,
    looplimit: 1,
    finish: 1,
    abort: 1,
    choice: 1,
    create: 1,
    temp: 1,
    delete: 1,
    set: 1,
    setref: 1,
    print: 1,
    if: 1,
    rand: 1,
    page_break: 1,
    line_break: 1,
    script: 1,
    else: 1,
    elseif: 1,
    elsif: 1,
    reset: 1,
    goto_scene: 1,
    fake_choice: 1,
    input_text: 1,
    ending: 1,
    share_this_game: 1,
    stat_chart: 1,
    subscribe: 1,
    show_password: 1,
    gosub: 1,
    return: 1,
    hide_reuse: 1,
    disable_reuse: 1,
    allow_reuse: 1,
    check_purchase: 1,
    restore_purchases: 1,
    purchase: 1,
    restore_game: 1,
    advertisement: 1,
    feedback: 1,
    save_game: 1,
    delay_break: 1,
    image: 1,
    link: 1,
    input_number: 1,
    goto_random_scene: 1,
    restart: 1,
    more_games: 1,
    delay_ending: 1,
    end_trial: 1,
    login: 1,
    achieve: 1,
    scene_list: 1,
    title: 1,
    bug: 1,
    link_button: 1,
    check_registration: 1,
    sound: 1,
    author: 1,
    gosub_scene: 1,
    achievement: 1,
    check_achievements: 1,
    redirect_scene: 1,
    print_discount: 1,
    purchase_discount: 1,
    track_event: 1,
    timer: 1,
    youtube: 1,
    product: 1,
    text_image: 1,
    params: 1
}, SceneNavigator.prototype.setSceneList = function(sceneList) {
    this._sceneList = sceneList, this._sceneMap = {};
    for (var i = 0; i < sceneList.length - 1; i++) {
        var scene1 = sceneList[i], scene2 = sceneList[i + 1];
        this._sceneMap[scene1] = scene2;
    }
    this._startupScene = sceneList[0];
}, SceneNavigator.prototype.nextSceneName = function(currentSceneName) {
    return this._sceneMap[currentSceneName];
}, SceneNavigator.prototype.getStartupScene = function() {
    return this._startupScene;
}, SceneNavigator.prototype.setStartingStatsClone = function(stats) {
    this.startingStats = {};
    for (var i in stats) this.startingStats[i] = stats[i];
}, SceneNavigator.prototype.resetStats = function(stats) {
    for (var i in stats) delete stats[i];
    for (i in this.startingStats) stats[i] = this.startingStats[i];
    this.bugLog = [];
}, SceneNavigator.prototype.repairStats = function(stats) {
    for (var i in this.startingStats) {
        var startingStat = this.startingStats[i];
        null !== startingStat && void 0 !== startingStat && (void 0 !== stats[i] && null !== stats[i] || (stats[i] = this.startingStats[i]));
    }
}, SceneNavigator.prototype.bugLog = [], SceneNavigator.prototype.achievements = {},
SceneNavigator.prototype.achievementList = [], SceneNavigator.prototype.achieved = {},
SceneNavigator.prototype.products = {}, SceneNavigator.prototype.loadAchievements = function(achievementArray) {
    if (achievementArray) {
        this.achievements = {}, this.achievementList = [];
        for (var i = 0; i < achievementArray.length; i++) {
            var achievement = achievementArray[i], achievementName = achievement[0], visible = achievement[1], points = achievement[2], title = achievement[3], earnedDescription = achievement[4], preEarnedDescription = achievement[5];
            this.achievements[achievementName] = {
                visible: visible,
                points: points,
                title: title,
                earnedDescription: earnedDescription,
                preEarnedDescription: preEarnedDescription
            }, this.achievementList.push(achievementName);
        }
    }
}, SceneNavigator.prototype.loadProducts = function(productArray, purchaseMap) {
    if (productArray || purchaseMap) {
        this.products = {};
        for (var i = 0; i < productArray; i++) this.products[productArray[i]] = {};
        for (var scene in purchaseMap) {
            var product = purchaseMap[scene];
            this.products[product] = {};
        }
    }
}, _global = this, function() {
    var userAgent, url, protocol;
    "undefined" != typeof window && (userAgent = navigator.userAgent, url = window.location.href,
    protocol = window.location.protocol), _global.isWebOS = /webOS/.test(userAgent),
    _global.isMobile = _global.isWebOS || /Mobile/.test(userAgent), _global.isFile = /^file:/.test(url),
    _global.isXul = /^chrome:/.test(url);
    try {
        _global.greenworks = require("greenworks"), _global.isGreenworks = !0;
    } catch (ignored) {}
    _global.isWinOldApp = !1;
    try {
        isWinOldApp = window.external.IsWinOldApp();
    } catch (ignored) {}
    _global.isWeb = !_global.isWinOldApp && /^https?:/.test(url), _global.isAndroid = /Android/.test(userAgent),
    _global.isSecureWeb = /^https:?$/.test(protocol), _global.isSafari = /Safari/.test(userAgent),
    _global.isIE = /(MSIE|Trident)/.test(userAgent), _global.isIPad = /iPad/.test(userAgent),
    _global.isIPhone = /iPhone/.test(userAgent), _global.isKindleFire = /Kindle Fire/.test(userAgent),
    _global.isWinStoreApp = "ms-appx:" == protocol, _global.isCef = !!_global.cefQuery,
    _global.isNode = "undefined" != typeof process;
}(), _global.loadTime = new Date().getTime();

var loginUrlBase = "https://www.choiceofgames.com/api/";

webSaveDomain = "www.choiceofgames.com", webSaveUrl = "https://" + webSaveDomain + "/ajax_proxy.php/websave",
tempStatWrites = {}, crcTable = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D",
shortMonthStrings = [ null, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
nav = new SceneNavigator([ "startup" ]), stats = {};
